// Copyright 2016-2020, Pulumi Corporation
// *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.Json;
using GlobExpressions;

using TransformationAction = System.Func<System.Collections.Immutable.ImmutableDictionary<string, object>, Pulumi.CustomResourceOptions, System.Collections.Immutable.ImmutableDictionary<string, object>>;

namespace Pulumi.Kubernetes.Yaml
{
    /// <summary>
    /// Base component for containers of Kubernetes resources.
    /// </summary>
    public abstract class CollectionComponentResource : ComponentResource
    {
        internal Output<ImmutableDictionary<string, KubernetesResource>> Resources { get; private set; } = null!;

        protected CollectionComponentResource(string type, string name, ResourceOptions? options = null)
            : base(type, name, options)
        {
        }

        protected void RegisterResources(Output<ImmutableDictionary<string, KubernetesResource>> resources)
        {
            Resources = resources;
            RegisterOutputs(new Dictionary<string, object?> { { "resources", resources } });
        }

        /// <summary>
        /// Returns a resource defined by the given name.
        /// </summary>
        /// <param name="name">Resource name.</param>
        /// <param name="namespaceName">Optional namespace, e.g. "kube-prometheus-exporter-kubernetes".</param>
        /// <typeparam name="T">The type of the resource.</typeparam>
        public Output<T> GetResource<T>(string name, string? namespaceName = null)
            where T : KubernetesResource
        {
            var type = typeof(T);
            var groupVersionKind =
                {{#Groups}}
                {{#Versions}}
                {{#TopLevelKindsAndAliases}}
                type == typeof({{Group}}.{{Version}}.{{Kind}}) ? "{{DefaultAPIVersion}}/{{Kind}}" :
                {{/TopLevelKindsAndAliases}}
                {{/Versions}}
                {{/Groups}}
                throw new ArgumentException($"Unknown resource type {typeof(T).FullName}");
            var id = namespaceName != null ? $"{namespaceName}/{name}" : name;
            return Resources.Apply(r =>
            {
                if (!r.TryGetValue($"{groupVersionKind}::{id}", out var value))
                {
                    var existingKeys = string.Join(", ", r.Keys);
                    throw new ArgumentException($"Resource {groupVersionKind}::{id} of type {type.FullName} and id {id} is not found, existing resources are {existingKeys}");
                }

                return (T) value;
            });
        }

        /// <summary>
        /// Returns a custom resource defined by the given group/version/kind and name.
        /// </summary>
        /// <param name="groupVersionKind">Group/version/kind, e.g. "monitoring.coreos.com/v1/ServiceMonitor".
        /// </param>
        /// <param name="name">Resource name.</param>
        /// <param name="namespaceName">Optional namespace, e.g. "kube-prometheus-exporter-kubernetes".</param>
        public Output<CustomResource> GetCustomResource(string groupVersionKind, string name, string? namespaceName = null)
        {
            var id = namespaceName != null ? $"{namespaceName}/{name}" : name;
            return Resources.Apply(r => (CustomResource)r[$"{groupVersionKind}::{id}"]);
        }
    }

    internal static class Parser
    {
        public static Output<ImmutableDictionary<string, KubernetesResource>> Parse(ConfigGroupArgs config, ComponentResourceOptions? options)
        {
            var resources = Output.Create(ImmutableDictionary.Create<string, KubernetesResource>());

            if (config.Files != null)
            {
                var files = new List<string>();
                foreach (var file in config.Files)
                {
                    if (IsUrl(file))
                        files.Add(file);
                    else
                        files.AddRange(Glob.Files(Directory.GetCurrentDirectory(), file));
                }

                foreach (var file in files)
                {
                    var cf = new ConfigFile(
                        file,
                        new ConfigFileArgs
                        {
                            File = file,
                            Transformations = config.Transformations,
                            ResourcePrefix = config.ResourcePrefix
                        },
                        options);
                    resources = Output.Tuple(resources, cf.Resources).Apply(vs => vs.Item1.AddRange(vs.Item2));
                }
            }

            if (config.Yaml != null)
            {
                var yamlResources = config.Yaml.ToOutput().Apply(texts =>
                {
                    var yamls = texts
                        .Select(text =>
                            ParseYamlDocument(new ParseArgs
                            {
                                Objs = Invokes.YamlDecode(new YamlDecodeArgs { Text = text }),
                                Transformations = config.Transformations,
                                ResourcePrefix = config.ResourcePrefix
                            }, options))
                        .Select(output => (Input<ImmutableDictionary<string, KubernetesResource>>)output)
                        .ToImmutableArray();
                    return Output.All(yamls);
                });

                resources = Output.Tuple(resources, yamlResources).Apply(vs =>
                {
                    var builder = ImmutableDictionary.CreateBuilder<string, KubernetesResource>();
                    builder.AddRange(vs.Item1);
                    foreach (var bs in vs.Item2)
                        builder.AddRange(bs);
                    return builder.ToImmutable();
                });
            }

            if (config.Objs != null)
            {
                var docResources = ParseYamlDocument(new ParseArgs
                {
                    Objs = config.Objs,
                    Transformations = config.Transformations,
                    ResourcePrefix = config.ResourcePrefix
                }, options);
                resources = Output.Tuple(resources, docResources).Apply(vs => vs.Item1.AddRange(vs.Item2));
            }

            return resources;

        }

        internal static bool IsUrl(string s) => s.StartsWith("http://") || s.StartsWith("https://");

        internal static Output<ImmutableDictionary<string, KubernetesResource>> ParseYamlDocument(ParseArgs config,
            ComponentResourceOptions? options = null)
        {
            return config.Objs.ToOutput().Apply(objs =>
            {

                var inputs = objs
                    .SelectMany(obj => ParseYamlObject(obj, config.Transformations, config.ResourcePrefix, options))
                    .Select(output => (Input<(string, KubernetesResource)>) output)
                    .ToImmutableArray();

                return Output.All(inputs)
                    .Apply(items =>
                        items.Select(obj => new KeyValuePair<string, KubernetesResource>(obj.Item1, obj.Item2))
                             .ToImmutableDictionary());
            });
        }

        private static Output<(string, KubernetesResource)>[] ParseYamlObject(ImmutableDictionary<string, object> obj,
            TransformationAction[]? transformations, string? resourcePrefix, ComponentResourceOptions? options = null)
        {
            if (obj == null || obj.Count == 0)
                return new Output<(string, KubernetesResource)>[0];

            // Create custom resource options based on component resource options.
            var opts = new CustomResourceOptions
            {
                Parent = options?.Parent,
                DependsOn = options?.DependsOn ?? new InputList<Resource>(),
                IgnoreChanges = options?.IgnoreChanges ?? new List<string>(),
                Version = options?.Version,
                Provider = options?.Provider,
                CustomTimeouts = options?.CustomTimeouts
            };

            // Allow users to change API objects before any validation.
            if (transformations != null)
            {
                foreach (var transform in transformations)
                    obj = transform(obj, opts);
            }

            if (!(obj.ContainsKey("kind") && obj.ContainsKey("apiVersion")))
            {
                var serialized = JsonSerializer.Serialize(obj);
                throw new FormatException($"Kubernetes resources require a kind and apiVersion: {serialized}");
            }

            var kind = (string)obj["kind"];
            var apiVersion = (string)obj["apiVersion"];

            // Recursively traverse built-in Kubernetes list types into a single set of "naked" resource
            // definitions that we can register with the Pulumi engine.
            //
            // Kubernetes does not instantiate list types like `v1.List`. When the API server receives
            // a list, it will recursively traverse it and perform the necessary operations on the
            // each "instantiable" resource it finds. For example, `kubectl apply` on a
            // `v1.ConfigMapList` will cause the API server to traverse the list, and `apply` each
            // `v1.ConfigMap` it finds.
            //
            // Since Kubernetes does not instantiate list types directly, Pulumi also traverses lists
            // for resource definitions that can be managed by Kubernetes, and registers those with the
            // engine instead.
            if (
                apiVersion == "v1" && kind == "List"
                {{#Groups}}
                {{#Versions}}
                {{#ListTopLevelKindsAndAliases}}
                || apiVersion == "{{DefaultAPIVersion}}" && kind == "{{Kind}}"
                {{/ListTopLevelKindsAndAliases}}
                {{/Versions}}
                {{/Groups}}
               )
            {
                var objs = new List<Output<(string, KubernetesResource)>>();
                if (obj["items"] is IEnumerable<ImmutableDictionary<string, object>> items)
                {
                    foreach (var item in items)
                        objs.AddRange(Parser.ParseYamlObject(item, transformations, resourcePrefix));
                }
                return objs.ToArray();
            }

            if (!obj.ContainsKey("metadata") || !(obj["metadata"] is ImmutableDictionary<string, object> metadata)
                || !metadata.ContainsKey("name"))
            {
                var serialized = obj.TryGetValue("metadata", out var m) ? JsonSerializer.Serialize(m) : "<null>";
                throw new FormatException($"YAML object does not have a .metadata.name: {apiVersion}/{kind} {serialized}");
            }

            var meta = (ImmutableDictionary<string, object>)obj["metadata"];
            var id = Output.Create((string)meta["name"]);
            if (meta.TryGetValue("namespace", out object ns))
                id = Output.Format($"{ns}/{id}");
            if (resourcePrefix != null)
                id = Output.Format($"{resourcePrefix}-{id}");

            switch ($"{apiVersion}/{kind}")
            {
                {{#Groups}}
                {{#Versions}}
                {{#TopLevelKindsAndAliases}}
                    case "{{DefaultAPIVersion}}/{{Kind}}":
                        return new[]
                        {
                            id.Apply(id => ($"{{DefaultAPIVersion}}/{{Kind}}::{id}",
                                new {{Group}}.{{Version}}.{{Kind}}(id, obj!, opts) as KubernetesResource))
                        };
                {{/TopLevelKindsAndAliases}}
                {{/Versions}}
                {{/Groups}}
                default:
                    return new[]
                    {
                        id.Apply(id => ($"{apiVersion}/{kind}::{id}",
                            new ApiExtensions.V1.CustomResourceDefinition(id, obj!, opts) as KubernetesResource))
                    };
            }
        }
    }

    internal class ParseArgs
    {
        /// <summary>
        /// Objects representing Kubernetes resources.
        /// </summary>
        public InputList<ImmutableDictionary<string, object>> Objs { get; set; } = null!;

        /// <summary>
        /// A set of transformations to apply to Kubernetes resource definitions before registering
        /// with engine.
        /// </summary>
        public TransformationAction[]? Transformations { get; set; }

        /// <summary>
        /// An optional prefix for the auto-generated resource names.
        /// Example: A resource created with resourcePrefix="foo" would produce a resource named "foo-resourceName".
        /// </summary>
        public string? ResourcePrefix { get; set; }
    }
}
