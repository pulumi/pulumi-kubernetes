# *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import json
from copy import deepcopy
from typing import Optional

import pulumi
import pulumi.runtime
import requests
import yaml
{{#Groups}}
{{#Versions}}
from pulumi_kubernetes.{{Group}}.{{Version}} import *
{{/Versions}}
{{/Groups}}

from . import tables


class ConfigFile(pulumi.ComponentResource):
    """
    ConfigFile creates a set of Kubernetes resources from a Kubernetes YAML file. If `config.name`
    is not specified, `ConfigFile` assumes the argument `name` is the filename.
    """

    def __init__(self, __name__: str, file_id: str, __opts__: Optional[pulumi.ResourceOptions] = None):
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, str):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        super(ConfigFile, self).__init__(
            "kubernetes:yaml:ConfigFile",
            __name__,
            __props__,
            __opts__)

        text: str = ""
        if file_id.startswith('http://') or file_id.startswith('https://'):
            text = read_url(file_id)
        else:
            text = read_file(file_id)

        # TODO: transformation support
        opts = None
        if __opts__ is not None:
            opts = deepcopy(__opts__)
            opts.parent = self
        else:
            opts = pulumi.ResourceOptions(parent=self)

        self.register_outputs(parse_yaml_document(yaml.safe_load_all(text), opts))

    def translate_output_property(self, prop: str) -> str:
        return tables._CASING_FORWARD_TABLE.get(prop) or prop

    def translate_input_property(self, prop: str) -> str:
        return tables._CASING_BACKWARD_TABLE.get(prop) or prop


def read_url(url: str) -> str:
    response = requests.get(url)
    response.raise_for_status()

    return response.text


def read_file(path: str) -> str:
    with open(path, 'r') as file:
        data = file.read()

    return data


def parse_yaml_document(objects, __opts__: Optional[pulumi.ResourceOptions] = None):
    resources = {}
    for obj in objects:
        # TODO: transformation support
        file_objects = parse_yaml_object(obj, __opts__)
        for file_object in file_objects:
            resources[file_object[0]] = file_object[1]

    return resources


def parse_yaml_object(obj, __opts__: Optional[pulumi.ResourceOptions] = None):
    if not obj:
        return []

    # TODO: transformation support

    if "kind" not in obj or "apiVersion" not in obj:
        raise Exception("Kubernetes resources require a kind and apiVersion: {}".format(json.dumps(obj)))

    api_version = obj["apiVersion"]
    kind = obj["kind"]

    if kind.endswith("List"):
        objs = []
        if "items" in obj:
            for item in obj["items"]:
                objs = objs + parse_yaml_object(item, __opts__)
        return objs

    if ("metadata" not in obj) or ("name" not in obj["metadata"]):
        raise Exception("YAML object does not have a .metadata.name: {}/{} {}".format(
            api_version, kind, json.dumps(obj)))

    metadata = obj["metadata"]
    spec = None
    if "spec" in obj:
        spec = obj["spec"]
    identifier = metadata["name"]
    if "namespace" in metadata:
        identifier = "{}/{}".format(metadata["namespace"], metadata["name"])

    gvk = f"{api_version}/{kind}"
{{#Groups}}
{{#Versions}}
{{#Kinds}}
    if gvk == "{{RawAPIVersion}}/{{Kind}}":
        return [(f"{{RawAPIVersion}}/{{Kind}}:{identifier}",
                 {{Kind}}(identifier, __opts__, metadata, spec))]
{{/Kinds}}
{{/Versions}}
{{/Groups}}
    raise Exception(f"Unsupported gvk: {gvk}")
