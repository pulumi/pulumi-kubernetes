// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.kubernetes.apiextensions;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.pulumi.core.Either;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.annotations.ImportMetadata;
import com.pulumi.resources.ResourceArgs;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.description.annotation.AnnotationDescription;
import net.bytebuddy.implementation.FieldAccessor;
import net.bytebuddy.implementation.Implementation;
import net.bytebuddy.implementation.MethodCall;

class Util {
    private Util() {
    }

    /**
     * Generates a ResourceArgs containing the union of inputs in 'args' and 'others'.
     * 
     * @param args a ResourceArgs containing fields with @Import annotations.
     * @param others a map of additional inputs to include in the generated ResourceArgs.
     * @return
     */
    public static ResourceArgs generateResourceArgs(ResourceArgs args, Map<String,Output<?>> others) {
        // define a field for each Java field that has an @Import annotation, and copy the annotation.
        var importFields = 
            ImportMetadata.of(args.getClass()).values().stream()
            .map(info -> new ImportField(info.getFieldOutput(args), Either.ofLeft(info.getAnnotation())));
        // define a field for each input in 'others' map, with a simple @Import annotation.
        var otherFields = 
            others.entrySet().stream()
            .map(entry -> new ImportField(Optional.ofNullable(entry.getValue()), Either.ofRight(
                AnnotationDescription.Builder.ofType(Import.class).define("name", entry.getKey()).build())));
        List<ImportField> fields = 
            Stream.concat(importFields, otherFields)
            .collect(Collectors.toList());

        try {
            // define a dynamic subclass of ResourceArgs with a field for each input property
            // and a constructor that takes the property values and assigns them to the fields.
            var t = new ByteBuddy().subclass(ResourceArgs.class); 
            Implementation.Composable c = MethodCall.invoke(ResourceArgs.class.getConstructor());

            var paramTypes = new ArrayList<Class<?>>();
            var paramValues = new ArrayList<Object>();

            for (var arg : fields) {
                // define a field of type Output with @Import(name="foo")
                var fieldName = String.format("f%d", paramTypes.size());
                var f = t.defineField(fieldName, Output.class, Modifier.PUBLIC);
                t = arg.importAnnotation.either(a -> f.annotateField(a), ad -> f.annotateField(ad));

                // bind the field to the corresponding constructor parameter
                c = c.andThen(FieldAccessor.ofField(fieldName).setsArgumentAt(paramTypes.size()));

                paramTypes.add(Output.class);
                paramValues.add(arg.value.map(v -> v instanceof Output ? v : Output.ofNullable(v)).orElse(null));
            }

            return (ResourceArgs) t
                    .defineConstructor(Modifier.PUBLIC).withParameters(paramTypes).intercept(c)
                    .make()
                    .load(Util.class.getClassLoader())
                    .getLoaded().getConstructors()[0]
                    .newInstance(paramValues.toArray());

        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException
                | InvocationTargetException e) {
            throw new RuntimeException("Unable to generate ResourceArgs", e);
        }
    }

    private static class ImportField {
        public Optional<?> value;
        public Either<Annotation,AnnotationDescription> importAnnotation;

        public ImportField(Optional<?> value, Either<Annotation,AnnotationDescription> importAnnotation) {
            this.value = value;
            this.importAnnotation = importAnnotation;
        }
    }
}
