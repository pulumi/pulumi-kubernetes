// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.kubernetes.certificates.v1alpha1.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * PodCertificateRequestSpec describes the certificate request.  All fields are immutable after creation.
 * 
 */
public final class PodCertificateRequestSpecArgs extends com.pulumi.resources.ResourceArgs {

    public static final PodCertificateRequestSpecArgs Empty = new PodCertificateRequestSpecArgs();

    /**
     * maxExpirationSeconds is the maximum lifetime permitted for the certificate.
     * 
     * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
     * 
     * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
     * 
     */
    @Import(name="maxExpirationSeconds")
    private @Nullable Output<Integer> maxExpirationSeconds;

    /**
     * @return maxExpirationSeconds is the maximum lifetime permitted for the certificate.
     * 
     * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
     * 
     * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
     * 
     */
    public Optional<Output<Integer>> maxExpirationSeconds() {
        return Optional.ofNullable(this.maxExpirationSeconds);
    }

    /**
     * nodeName is the name of the node the pod is assigned to.
     * 
     */
    @Import(name="nodeName", required=true)
    private Output<String> nodeName;

    /**
     * @return nodeName is the name of the node the pod is assigned to.
     * 
     */
    public Output<String> nodeName() {
        return this.nodeName;
    }

    /**
     * nodeUID is the UID of the node the pod is assigned to.
     * 
     */
    @Import(name="nodeUID", required=true)
    private Output<String> nodeUID;

    /**
     * @return nodeUID is the UID of the node the pod is assigned to.
     * 
     */
    public Output<String> nodeUID() {
        return this.nodeUID;
    }

    /**
     * pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
     * 
     * The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
     * 
     * Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of &#34;Denied&#34; and a reason of &#34;UnsupportedKeyType&#34;. It may also suggest a key type that it does support in the message field.
     * 
     */
    @Import(name="pkixPublicKey", required=true)
    private Output<String> pkixPublicKey;

    /**
     * @return pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
     * 
     * The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
     * 
     * Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of &#34;Denied&#34; and a reason of &#34;UnsupportedKeyType&#34;. It may also suggest a key type that it does support in the message field.
     * 
     */
    public Output<String> pkixPublicKey() {
        return this.pkixPublicKey;
    }

    /**
     * podName is the name of the pod into which the certificate will be mounted.
     * 
     */
    @Import(name="podName", required=true)
    private Output<String> podName;

    /**
     * @return podName is the name of the pod into which the certificate will be mounted.
     * 
     */
    public Output<String> podName() {
        return this.podName;
    }

    /**
     * podUID is the UID of the pod into which the certificate will be mounted.
     * 
     */
    @Import(name="podUID", required=true)
    private Output<String> podUID;

    /**
     * @return podUID is the UID of the pod into which the certificate will be mounted.
     * 
     */
    public Output<String> podUID() {
        return this.podUID;
    }

    /**
     * proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
     * 
     * It is contructed by signing the ASCII bytes of the pod&#39;s UID using `pkixPublicKey`.
     * 
     * kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
     * 
     * If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
     * 
     * If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
     * 
     * If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
     * 
     */
    @Import(name="proofOfPossession", required=true)
    private Output<String> proofOfPossession;

    /**
     * @return proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
     * 
     * It is contructed by signing the ASCII bytes of the pod&#39;s UID using `pkixPublicKey`.
     * 
     * kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
     * 
     * If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
     * 
     * If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
     * 
     * If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
     * 
     */
    public Output<String> proofOfPossession() {
        return this.proofOfPossession;
    }

    /**
     * serviceAccountName is the name of the service account the pod is running as.
     * 
     */
    @Import(name="serviceAccountName", required=true)
    private Output<String> serviceAccountName;

    /**
     * @return serviceAccountName is the name of the service account the pod is running as.
     * 
     */
    public Output<String> serviceAccountName() {
        return this.serviceAccountName;
    }

    /**
     * serviceAccountUID is the UID of the service account the pod is running as.
     * 
     */
    @Import(name="serviceAccountUID", required=true)
    private Output<String> serviceAccountUID;

    /**
     * @return serviceAccountUID is the UID of the service account the pod is running as.
     * 
     */
    public Output<String> serviceAccountUID() {
        return this.serviceAccountUID;
    }

    /**
     * signerName indicates the requested signer.
     * 
     * All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
     * 
     */
    @Import(name="signerName", required=true)
    private Output<String> signerName;

    /**
     * @return signerName indicates the requested signer.
     * 
     * All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
     * 
     */
    public Output<String> signerName() {
        return this.signerName;
    }

    private PodCertificateRequestSpecArgs() {}

    private PodCertificateRequestSpecArgs(PodCertificateRequestSpecArgs $) {
        this.maxExpirationSeconds = $.maxExpirationSeconds;
        this.nodeName = $.nodeName;
        this.nodeUID = $.nodeUID;
        this.pkixPublicKey = $.pkixPublicKey;
        this.podName = $.podName;
        this.podUID = $.podUID;
        this.proofOfPossession = $.proofOfPossession;
        this.serviceAccountName = $.serviceAccountName;
        this.serviceAccountUID = $.serviceAccountUID;
        this.signerName = $.signerName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(PodCertificateRequestSpecArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private PodCertificateRequestSpecArgs $;

        public Builder() {
            $ = new PodCertificateRequestSpecArgs();
        }

        public Builder(PodCertificateRequestSpecArgs defaults) {
            $ = new PodCertificateRequestSpecArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param maxExpirationSeconds maxExpirationSeconds is the maximum lifetime permitted for the certificate.
         * 
         * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
         * 
         * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
         * 
         * @return builder
         * 
         */
        public Builder maxExpirationSeconds(@Nullable Output<Integer> maxExpirationSeconds) {
            $.maxExpirationSeconds = maxExpirationSeconds;
            return this;
        }

        /**
         * @param maxExpirationSeconds maxExpirationSeconds is the maximum lifetime permitted for the certificate.
         * 
         * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
         * 
         * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
         * 
         * @return builder
         * 
         */
        public Builder maxExpirationSeconds(Integer maxExpirationSeconds) {
            return maxExpirationSeconds(Output.of(maxExpirationSeconds));
        }

        /**
         * @param nodeName nodeName is the name of the node the pod is assigned to.
         * 
         * @return builder
         * 
         */
        public Builder nodeName(Output<String> nodeName) {
            $.nodeName = nodeName;
            return this;
        }

        /**
         * @param nodeName nodeName is the name of the node the pod is assigned to.
         * 
         * @return builder
         * 
         */
        public Builder nodeName(String nodeName) {
            return nodeName(Output.of(nodeName));
        }

        /**
         * @param nodeUID nodeUID is the UID of the node the pod is assigned to.
         * 
         * @return builder
         * 
         */
        public Builder nodeUID(Output<String> nodeUID) {
            $.nodeUID = nodeUID;
            return this;
        }

        /**
         * @param nodeUID nodeUID is the UID of the node the pod is assigned to.
         * 
         * @return builder
         * 
         */
        public Builder nodeUID(String nodeUID) {
            return nodeUID(Output.of(nodeUID));
        }

        /**
         * @param pkixPublicKey pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
         * 
         * The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
         * 
         * Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of &#34;Denied&#34; and a reason of &#34;UnsupportedKeyType&#34;. It may also suggest a key type that it does support in the message field.
         * 
         * @return builder
         * 
         */
        public Builder pkixPublicKey(Output<String> pkixPublicKey) {
            $.pkixPublicKey = pkixPublicKey;
            return this;
        }

        /**
         * @param pkixPublicKey pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
         * 
         * The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
         * 
         * Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of &#34;Denied&#34; and a reason of &#34;UnsupportedKeyType&#34;. It may also suggest a key type that it does support in the message field.
         * 
         * @return builder
         * 
         */
        public Builder pkixPublicKey(String pkixPublicKey) {
            return pkixPublicKey(Output.of(pkixPublicKey));
        }

        /**
         * @param podName podName is the name of the pod into which the certificate will be mounted.
         * 
         * @return builder
         * 
         */
        public Builder podName(Output<String> podName) {
            $.podName = podName;
            return this;
        }

        /**
         * @param podName podName is the name of the pod into which the certificate will be mounted.
         * 
         * @return builder
         * 
         */
        public Builder podName(String podName) {
            return podName(Output.of(podName));
        }

        /**
         * @param podUID podUID is the UID of the pod into which the certificate will be mounted.
         * 
         * @return builder
         * 
         */
        public Builder podUID(Output<String> podUID) {
            $.podUID = podUID;
            return this;
        }

        /**
         * @param podUID podUID is the UID of the pod into which the certificate will be mounted.
         * 
         * @return builder
         * 
         */
        public Builder podUID(String podUID) {
            return podUID(Output.of(podUID));
        }

        /**
         * @param proofOfPossession proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
         * 
         * It is contructed by signing the ASCII bytes of the pod&#39;s UID using `pkixPublicKey`.
         * 
         * kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
         * 
         * If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
         * 
         * If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
         * 
         * If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
         * 
         * @return builder
         * 
         */
        public Builder proofOfPossession(Output<String> proofOfPossession) {
            $.proofOfPossession = proofOfPossession;
            return this;
        }

        /**
         * @param proofOfPossession proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
         * 
         * It is contructed by signing the ASCII bytes of the pod&#39;s UID using `pkixPublicKey`.
         * 
         * kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
         * 
         * If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
         * 
         * If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
         * 
         * If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
         * 
         * @return builder
         * 
         */
        public Builder proofOfPossession(String proofOfPossession) {
            return proofOfPossession(Output.of(proofOfPossession));
        }

        /**
         * @param serviceAccountName serviceAccountName is the name of the service account the pod is running as.
         * 
         * @return builder
         * 
         */
        public Builder serviceAccountName(Output<String> serviceAccountName) {
            $.serviceAccountName = serviceAccountName;
            return this;
        }

        /**
         * @param serviceAccountName serviceAccountName is the name of the service account the pod is running as.
         * 
         * @return builder
         * 
         */
        public Builder serviceAccountName(String serviceAccountName) {
            return serviceAccountName(Output.of(serviceAccountName));
        }

        /**
         * @param serviceAccountUID serviceAccountUID is the UID of the service account the pod is running as.
         * 
         * @return builder
         * 
         */
        public Builder serviceAccountUID(Output<String> serviceAccountUID) {
            $.serviceAccountUID = serviceAccountUID;
            return this;
        }

        /**
         * @param serviceAccountUID serviceAccountUID is the UID of the service account the pod is running as.
         * 
         * @return builder
         * 
         */
        public Builder serviceAccountUID(String serviceAccountUID) {
            return serviceAccountUID(Output.of(serviceAccountUID));
        }

        /**
         * @param signerName signerName indicates the requested signer.
         * 
         * All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
         * 
         * @return builder
         * 
         */
        public Builder signerName(Output<String> signerName) {
            $.signerName = signerName;
            return this;
        }

        /**
         * @param signerName signerName indicates the requested signer.
         * 
         * All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
         * 
         * @return builder
         * 
         */
        public Builder signerName(String signerName) {
            return signerName(Output.of(signerName));
        }

        public PodCertificateRequestSpecArgs build() {
            if ($.nodeName == null) {
                throw new MissingRequiredPropertyException("PodCertificateRequestSpecArgs", "nodeName");
            }
            if ($.nodeUID == null) {
                throw new MissingRequiredPropertyException("PodCertificateRequestSpecArgs", "nodeUID");
            }
            if ($.pkixPublicKey == null) {
                throw new MissingRequiredPropertyException("PodCertificateRequestSpecArgs", "pkixPublicKey");
            }
            if ($.podName == null) {
                throw new MissingRequiredPropertyException("PodCertificateRequestSpecArgs", "podName");
            }
            if ($.podUID == null) {
                throw new MissingRequiredPropertyException("PodCertificateRequestSpecArgs", "podUID");
            }
            if ($.proofOfPossession == null) {
                throw new MissingRequiredPropertyException("PodCertificateRequestSpecArgs", "proofOfPossession");
            }
            if ($.serviceAccountName == null) {
                throw new MissingRequiredPropertyException("PodCertificateRequestSpecArgs", "serviceAccountName");
            }
            if ($.serviceAccountUID == null) {
                throw new MissingRequiredPropertyException("PodCertificateRequestSpecArgs", "serviceAccountUID");
            }
            if ($.signerName == null) {
                throw new MissingRequiredPropertyException("PodCertificateRequestSpecArgs", "signerName");
            }
            return $;
        }
    }

}
