// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.kubernetes.core.v1.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.kubernetes.core.v1.outputs.AttachedVolumePatch;
import com.pulumi.kubernetes.core.v1.outputs.ContainerImagePatch;
import com.pulumi.kubernetes.core.v1.outputs.NodeAddressPatch;
import com.pulumi.kubernetes.core.v1.outputs.NodeConditionPatch;
import com.pulumi.kubernetes.core.v1.outputs.NodeConfigStatusPatch;
import com.pulumi.kubernetes.core.v1.outputs.NodeDaemonEndpointsPatch;
import com.pulumi.kubernetes.core.v1.outputs.NodeRuntimeHandlerPatch;
import com.pulumi.kubernetes.core.v1.outputs.NodeSystemInfoPatch;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class NodeStatusPatch {
    /**
     * @return List of addresses reachable to the node. Queried from cloud provider, if available. More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses Note: This field is declared as mergeable, but the merge key is not sufficiently unique, which can cause data corruption when it is merged. Callers should instead use a full-replacement patch. See https://pr.k8s.io/79391 for an example. Consumers should assume that addresses can change during the lifetime of a Node. However, there are some exceptions where this may not be possible, such as Pods that inherit a Node&#39;s address in its own status or consumers of the downward API (status.hostIP).
     * 
     */
    private @Nullable List<NodeAddressPatch> addresses;
    /**
     * @return Allocatable represents the resources of a node that are available for scheduling. Defaults to Capacity.
     * 
     */
    private @Nullable Map<String,String> allocatable;
    /**
     * @return Capacity represents the total resources of a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
     * 
     */
    private @Nullable Map<String,String> capacity;
    /**
     * @return Conditions is an array of current observed node conditions. More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
     * 
     */
    private @Nullable List<NodeConditionPatch> conditions;
    /**
     * @return Status of the config assigned to the node via the dynamic Kubelet config feature.
     * 
     */
    private @Nullable NodeConfigStatusPatch config;
    /**
     * @return Endpoints of daemons running on the Node.
     * 
     */
    private @Nullable NodeDaemonEndpointsPatch daemonEndpoints;
    /**
     * @return List of container images on this node
     * 
     */
    private @Nullable List<ContainerImagePatch> images;
    /**
     * @return Set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
     * 
     */
    private @Nullable NodeSystemInfoPatch nodeInfo;
    /**
     * @return NodePhase is the recently observed lifecycle phase of the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and now is deprecated.
     * 
     */
    private @Nullable String phase;
    /**
     * @return The available runtime handlers.
     * 
     */
    private @Nullable List<NodeRuntimeHandlerPatch> runtimeHandlers;
    /**
     * @return List of volumes that are attached to the node.
     * 
     */
    private @Nullable List<AttachedVolumePatch> volumesAttached;
    /**
     * @return List of attachable volumes in use (mounted) by the node.
     * 
     */
    private @Nullable List<String> volumesInUse;

    private NodeStatusPatch() {}
    /**
     * @return List of addresses reachable to the node. Queried from cloud provider, if available. More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses Note: This field is declared as mergeable, but the merge key is not sufficiently unique, which can cause data corruption when it is merged. Callers should instead use a full-replacement patch. See https://pr.k8s.io/79391 for an example. Consumers should assume that addresses can change during the lifetime of a Node. However, there are some exceptions where this may not be possible, such as Pods that inherit a Node&#39;s address in its own status or consumers of the downward API (status.hostIP).
     * 
     */
    public List<NodeAddressPatch> addresses() {
        return this.addresses == null ? List.of() : this.addresses;
    }
    /**
     * @return Allocatable represents the resources of a node that are available for scheduling. Defaults to Capacity.
     * 
     */
    public Map<String,String> allocatable() {
        return this.allocatable == null ? Map.of() : this.allocatable;
    }
    /**
     * @return Capacity represents the total resources of a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
     * 
     */
    public Map<String,String> capacity() {
        return this.capacity == null ? Map.of() : this.capacity;
    }
    /**
     * @return Conditions is an array of current observed node conditions. More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
     * 
     */
    public List<NodeConditionPatch> conditions() {
        return this.conditions == null ? List.of() : this.conditions;
    }
    /**
     * @return Status of the config assigned to the node via the dynamic Kubelet config feature.
     * 
     */
    public Optional<NodeConfigStatusPatch> config() {
        return Optional.ofNullable(this.config);
    }
    /**
     * @return Endpoints of daemons running on the Node.
     * 
     */
    public Optional<NodeDaemonEndpointsPatch> daemonEndpoints() {
        return Optional.ofNullable(this.daemonEndpoints);
    }
    /**
     * @return List of container images on this node
     * 
     */
    public List<ContainerImagePatch> images() {
        return this.images == null ? List.of() : this.images;
    }
    /**
     * @return Set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
     * 
     */
    public Optional<NodeSystemInfoPatch> nodeInfo() {
        return Optional.ofNullable(this.nodeInfo);
    }
    /**
     * @return NodePhase is the recently observed lifecycle phase of the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and now is deprecated.
     * 
     */
    public Optional<String> phase() {
        return Optional.ofNullable(this.phase);
    }
    /**
     * @return The available runtime handlers.
     * 
     */
    public List<NodeRuntimeHandlerPatch> runtimeHandlers() {
        return this.runtimeHandlers == null ? List.of() : this.runtimeHandlers;
    }
    /**
     * @return List of volumes that are attached to the node.
     * 
     */
    public List<AttachedVolumePatch> volumesAttached() {
        return this.volumesAttached == null ? List.of() : this.volumesAttached;
    }
    /**
     * @return List of attachable volumes in use (mounted) by the node.
     * 
     */
    public List<String> volumesInUse() {
        return this.volumesInUse == null ? List.of() : this.volumesInUse;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(NodeStatusPatch defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable List<NodeAddressPatch> addresses;
        private @Nullable Map<String,String> allocatable;
        private @Nullable Map<String,String> capacity;
        private @Nullable List<NodeConditionPatch> conditions;
        private @Nullable NodeConfigStatusPatch config;
        private @Nullable NodeDaemonEndpointsPatch daemonEndpoints;
        private @Nullable List<ContainerImagePatch> images;
        private @Nullable NodeSystemInfoPatch nodeInfo;
        private @Nullable String phase;
        private @Nullable List<NodeRuntimeHandlerPatch> runtimeHandlers;
        private @Nullable List<AttachedVolumePatch> volumesAttached;
        private @Nullable List<String> volumesInUse;
        public Builder() {}
        public Builder(NodeStatusPatch defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.addresses = defaults.addresses;
    	      this.allocatable = defaults.allocatable;
    	      this.capacity = defaults.capacity;
    	      this.conditions = defaults.conditions;
    	      this.config = defaults.config;
    	      this.daemonEndpoints = defaults.daemonEndpoints;
    	      this.images = defaults.images;
    	      this.nodeInfo = defaults.nodeInfo;
    	      this.phase = defaults.phase;
    	      this.runtimeHandlers = defaults.runtimeHandlers;
    	      this.volumesAttached = defaults.volumesAttached;
    	      this.volumesInUse = defaults.volumesInUse;
        }

        @CustomType.Setter
        public Builder addresses(@Nullable List<NodeAddressPatch> addresses) {
            this.addresses = addresses;
            return this;
        }
        public Builder addresses(NodeAddressPatch... addresses) {
            return addresses(List.of(addresses));
        }
        @CustomType.Setter
        public Builder allocatable(@Nullable Map<String,String> allocatable) {
            this.allocatable = allocatable;
            return this;
        }
        @CustomType.Setter
        public Builder capacity(@Nullable Map<String,String> capacity) {
            this.capacity = capacity;
            return this;
        }
        @CustomType.Setter
        public Builder conditions(@Nullable List<NodeConditionPatch> conditions) {
            this.conditions = conditions;
            return this;
        }
        public Builder conditions(NodeConditionPatch... conditions) {
            return conditions(List.of(conditions));
        }
        @CustomType.Setter
        public Builder config(@Nullable NodeConfigStatusPatch config) {
            this.config = config;
            return this;
        }
        @CustomType.Setter
        public Builder daemonEndpoints(@Nullable NodeDaemonEndpointsPatch daemonEndpoints) {
            this.daemonEndpoints = daemonEndpoints;
            return this;
        }
        @CustomType.Setter
        public Builder images(@Nullable List<ContainerImagePatch> images) {
            this.images = images;
            return this;
        }
        public Builder images(ContainerImagePatch... images) {
            return images(List.of(images));
        }
        @CustomType.Setter
        public Builder nodeInfo(@Nullable NodeSystemInfoPatch nodeInfo) {
            this.nodeInfo = nodeInfo;
            return this;
        }
        @CustomType.Setter
        public Builder phase(@Nullable String phase) {
            this.phase = phase;
            return this;
        }
        @CustomType.Setter
        public Builder runtimeHandlers(@Nullable List<NodeRuntimeHandlerPatch> runtimeHandlers) {
            this.runtimeHandlers = runtimeHandlers;
            return this;
        }
        public Builder runtimeHandlers(NodeRuntimeHandlerPatch... runtimeHandlers) {
            return runtimeHandlers(List.of(runtimeHandlers));
        }
        @CustomType.Setter
        public Builder volumesAttached(@Nullable List<AttachedVolumePatch> volumesAttached) {
            this.volumesAttached = volumesAttached;
            return this;
        }
        public Builder volumesAttached(AttachedVolumePatch... volumesAttached) {
            return volumesAttached(List.of(volumesAttached));
        }
        @CustomType.Setter
        public Builder volumesInUse(@Nullable List<String> volumesInUse) {
            this.volumesInUse = volumesInUse;
            return this;
        }
        public Builder volumesInUse(String... volumesInUse) {
            return volumesInUse(List.of(volumesInUse));
        }
        public NodeStatusPatch build() {
            final var o = new NodeStatusPatch();
            o.addresses = addresses;
            o.allocatable = allocatable;
            o.capacity = capacity;
            o.conditions = conditions;
            o.config = config;
            o.daemonEndpoints = daemonEndpoints;
            o.images = images;
            o.nodeInfo = nodeInfo;
            o.phase = phase;
            o.runtimeHandlers = runtimeHandlers;
            o.volumesAttached = volumesAttached;
            o.volumesInUse = volumesInUse;
            return o;
        }
    }
}
