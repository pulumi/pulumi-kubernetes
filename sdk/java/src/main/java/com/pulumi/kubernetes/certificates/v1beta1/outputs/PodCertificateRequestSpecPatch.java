// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.kubernetes.certificates.v1beta1.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class PodCertificateRequestSpecPatch {
    /**
     * @return maxExpirationSeconds is the maximum lifetime permitted for the certificate.
     * 
     * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
     * 
     * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
     * 
     */
    private @Nullable Integer maxExpirationSeconds;
    /**
     * @return nodeName is the name of the node the pod is assigned to.
     * 
     */
    private @Nullable String nodeName;
    /**
     * @return nodeUID is the UID of the node the pod is assigned to.
     * 
     */
    private @Nullable String nodeUID;
    /**
     * @return pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
     * 
     * The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
     * 
     * Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of &#34;Denied&#34; and a reason of &#34;UnsupportedKeyType&#34;. It may also suggest a key type that it does support in the message field.
     * 
     */
    private @Nullable String pkixPublicKey;
    /**
     * @return podName is the name of the pod into which the certificate will be mounted.
     * 
     */
    private @Nullable String podName;
    /**
     * @return podUID is the UID of the pod into which the certificate will be mounted.
     * 
     */
    private @Nullable String podUID;
    /**
     * @return proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
     * 
     * It is contructed by signing the ASCII bytes of the pod&#39;s UID using `pkixPublicKey`.
     * 
     * kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
     * 
     * If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
     * 
     * If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
     * 
     * If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
     * 
     */
    private @Nullable String proofOfPossession;
    /**
     * @return serviceAccountName is the name of the service account the pod is running as.
     * 
     */
    private @Nullable String serviceAccountName;
    /**
     * @return serviceAccountUID is the UID of the service account the pod is running as.
     * 
     */
    private @Nullable String serviceAccountUID;
    /**
     * @return signerName indicates the requested signer.
     * 
     * All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
     * 
     */
    private @Nullable String signerName;
    /**
     * @return unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
     * 
     * Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
     * 
     * Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
     * 
     */
    private @Nullable Map<String,String> unverifiedUserAnnotations;

    private PodCertificateRequestSpecPatch() {}
    /**
     * @return maxExpirationSeconds is the maximum lifetime permitted for the certificate.
     * 
     * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
     * 
     * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
     * 
     */
    public Optional<Integer> maxExpirationSeconds() {
        return Optional.ofNullable(this.maxExpirationSeconds);
    }
    /**
     * @return nodeName is the name of the node the pod is assigned to.
     * 
     */
    public Optional<String> nodeName() {
        return Optional.ofNullable(this.nodeName);
    }
    /**
     * @return nodeUID is the UID of the node the pod is assigned to.
     * 
     */
    public Optional<String> nodeUID() {
        return Optional.ofNullable(this.nodeUID);
    }
    /**
     * @return pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
     * 
     * The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
     * 
     * Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of &#34;Denied&#34; and a reason of &#34;UnsupportedKeyType&#34;. It may also suggest a key type that it does support in the message field.
     * 
     */
    public Optional<String> pkixPublicKey() {
        return Optional.ofNullable(this.pkixPublicKey);
    }
    /**
     * @return podName is the name of the pod into which the certificate will be mounted.
     * 
     */
    public Optional<String> podName() {
        return Optional.ofNullable(this.podName);
    }
    /**
     * @return podUID is the UID of the pod into which the certificate will be mounted.
     * 
     */
    public Optional<String> podUID() {
        return Optional.ofNullable(this.podUID);
    }
    /**
     * @return proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
     * 
     * It is contructed by signing the ASCII bytes of the pod&#39;s UID using `pkixPublicKey`.
     * 
     * kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
     * 
     * If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
     * 
     * If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
     * 
     * If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
     * 
     */
    public Optional<String> proofOfPossession() {
        return Optional.ofNullable(this.proofOfPossession);
    }
    /**
     * @return serviceAccountName is the name of the service account the pod is running as.
     * 
     */
    public Optional<String> serviceAccountName() {
        return Optional.ofNullable(this.serviceAccountName);
    }
    /**
     * @return serviceAccountUID is the UID of the service account the pod is running as.
     * 
     */
    public Optional<String> serviceAccountUID() {
        return Optional.ofNullable(this.serviceAccountUID);
    }
    /**
     * @return signerName indicates the requested signer.
     * 
     * All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
     * 
     */
    public Optional<String> signerName() {
        return Optional.ofNullable(this.signerName);
    }
    /**
     * @return unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
     * 
     * Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
     * 
     * Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
     * 
     */
    public Map<String,String> unverifiedUserAnnotations() {
        return this.unverifiedUserAnnotations == null ? Map.of() : this.unverifiedUserAnnotations;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(PodCertificateRequestSpecPatch defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Integer maxExpirationSeconds;
        private @Nullable String nodeName;
        private @Nullable String nodeUID;
        private @Nullable String pkixPublicKey;
        private @Nullable String podName;
        private @Nullable String podUID;
        private @Nullable String proofOfPossession;
        private @Nullable String serviceAccountName;
        private @Nullable String serviceAccountUID;
        private @Nullable String signerName;
        private @Nullable Map<String,String> unverifiedUserAnnotations;
        public Builder() {}
        public Builder(PodCertificateRequestSpecPatch defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.maxExpirationSeconds = defaults.maxExpirationSeconds;
    	      this.nodeName = defaults.nodeName;
    	      this.nodeUID = defaults.nodeUID;
    	      this.pkixPublicKey = defaults.pkixPublicKey;
    	      this.podName = defaults.podName;
    	      this.podUID = defaults.podUID;
    	      this.proofOfPossession = defaults.proofOfPossession;
    	      this.serviceAccountName = defaults.serviceAccountName;
    	      this.serviceAccountUID = defaults.serviceAccountUID;
    	      this.signerName = defaults.signerName;
    	      this.unverifiedUserAnnotations = defaults.unverifiedUserAnnotations;
        }

        @CustomType.Setter
        public Builder maxExpirationSeconds(@Nullable Integer maxExpirationSeconds) {

            this.maxExpirationSeconds = maxExpirationSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder nodeName(@Nullable String nodeName) {

            this.nodeName = nodeName;
            return this;
        }
        @CustomType.Setter
        public Builder nodeUID(@Nullable String nodeUID) {

            this.nodeUID = nodeUID;
            return this;
        }
        @CustomType.Setter
        public Builder pkixPublicKey(@Nullable String pkixPublicKey) {

            this.pkixPublicKey = pkixPublicKey;
            return this;
        }
        @CustomType.Setter
        public Builder podName(@Nullable String podName) {

            this.podName = podName;
            return this;
        }
        @CustomType.Setter
        public Builder podUID(@Nullable String podUID) {

            this.podUID = podUID;
            return this;
        }
        @CustomType.Setter
        public Builder proofOfPossession(@Nullable String proofOfPossession) {

            this.proofOfPossession = proofOfPossession;
            return this;
        }
        @CustomType.Setter
        public Builder serviceAccountName(@Nullable String serviceAccountName) {

            this.serviceAccountName = serviceAccountName;
            return this;
        }
        @CustomType.Setter
        public Builder serviceAccountUID(@Nullable String serviceAccountUID) {

            this.serviceAccountUID = serviceAccountUID;
            return this;
        }
        @CustomType.Setter
        public Builder signerName(@Nullable String signerName) {

            this.signerName = signerName;
            return this;
        }
        @CustomType.Setter
        public Builder unverifiedUserAnnotations(@Nullable Map<String,String> unverifiedUserAnnotations) {

            this.unverifiedUserAnnotations = unverifiedUserAnnotations;
            return this;
        }
        public PodCertificateRequestSpecPatch build() {
            final var _resultValue = new PodCertificateRequestSpecPatch();
            _resultValue.maxExpirationSeconds = maxExpirationSeconds;
            _resultValue.nodeName = nodeName;
            _resultValue.nodeUID = nodeUID;
            _resultValue.pkixPublicKey = pkixPublicKey;
            _resultValue.podName = podName;
            _resultValue.podUID = podUID;
            _resultValue.proofOfPossession = proofOfPossession;
            _resultValue.serviceAccountName = serviceAccountName;
            _resultValue.serviceAccountUID = serviceAccountUID;
            _resultValue.signerName = signerName;
            _resultValue.unverifiedUserAnnotations = unverifiedUserAnnotations;
            return _resultValue;
        }
    }
}
