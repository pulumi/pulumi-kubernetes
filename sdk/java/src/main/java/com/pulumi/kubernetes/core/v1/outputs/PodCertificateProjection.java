// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.kubernetes.core.v1.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class PodCertificateProjection {
    /**
     * @return Write the certificate chain at this path in the projected volume.
     * 
     * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
     * 
     */
    private @Nullable String certificateChainPath;
    /**
     * @return Write the credential bundle at this path in the projected volume.
     * 
     * The credential bundle is a single file that contains multiple PEM blocks. The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private key.
     * 
     * The remaining blocks are CERTIFICATE blocks, containing the issued certificate chain from the signer (leaf and any intermediates).
     * 
     * Using credentialBundlePath lets your Pod&#39;s application code make a single atomic read that retrieves a consistent key and certificate chain.  If you project them to separate files, your application code will need to additionally check that the leaf certificate was issued to the key.
     * 
     */
    private @Nullable String credentialBundlePath;
    /**
     * @return Write the key at this path in the projected volume.
     * 
     * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
     * 
     */
    private @Nullable String keyPath;
    /**
     * @return The type of keypair Kubelet will generate for the pod.
     * 
     * Valid values are &#34;RSA3072&#34;, &#34;RSA4096&#34;, &#34;ECDSAP256&#34;, &#34;ECDSAP384&#34;, &#34;ECDSAP521&#34;, and &#34;ED25519&#34;.
     * 
     */
    private String keyType;
    /**
     * @return maxExpirationSeconds is the maximum lifetime permitted for the certificate.
     * 
     * Kubelet copies this value verbatim into the PodCertificateRequests it generates for this projection.
     * 
     * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
     * 
     * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
     * 
     */
    private @Nullable Integer maxExpirationSeconds;
    /**
     * @return Kubelet&#39;s generated CSRs will be addressed to this signer.
     * 
     */
    private String signerName;
    /**
     * @return userAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
     * 
     * These values are copied verbatim into the `spec.unverifiedUserAnnotations` field of the PodCertificateRequest objects that Kubelet creates.
     * 
     * Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
     * 
     * Signers should document the keys and values they support. Signers should deny requests that contain keys they do not recognize.
     * 
     */
    private @Nullable Map<String,String> userAnnotations;

    private PodCertificateProjection() {}
    /**
     * @return Write the certificate chain at this path in the projected volume.
     * 
     * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
     * 
     */
    public Optional<String> certificateChainPath() {
        return Optional.ofNullable(this.certificateChainPath);
    }
    /**
     * @return Write the credential bundle at this path in the projected volume.
     * 
     * The credential bundle is a single file that contains multiple PEM blocks. The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private key.
     * 
     * The remaining blocks are CERTIFICATE blocks, containing the issued certificate chain from the signer (leaf and any intermediates).
     * 
     * Using credentialBundlePath lets your Pod&#39;s application code make a single atomic read that retrieves a consistent key and certificate chain.  If you project them to separate files, your application code will need to additionally check that the leaf certificate was issued to the key.
     * 
     */
    public Optional<String> credentialBundlePath() {
        return Optional.ofNullable(this.credentialBundlePath);
    }
    /**
     * @return Write the key at this path in the projected volume.
     * 
     * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
     * 
     */
    public Optional<String> keyPath() {
        return Optional.ofNullable(this.keyPath);
    }
    /**
     * @return The type of keypair Kubelet will generate for the pod.
     * 
     * Valid values are &#34;RSA3072&#34;, &#34;RSA4096&#34;, &#34;ECDSAP256&#34;, &#34;ECDSAP384&#34;, &#34;ECDSAP521&#34;, and &#34;ED25519&#34;.
     * 
     */
    public String keyType() {
        return this.keyType;
    }
    /**
     * @return maxExpirationSeconds is the maximum lifetime permitted for the certificate.
     * 
     * Kubelet copies this value verbatim into the PodCertificateRequests it generates for this projection.
     * 
     * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
     * 
     * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
     * 
     */
    public Optional<Integer> maxExpirationSeconds() {
        return Optional.ofNullable(this.maxExpirationSeconds);
    }
    /**
     * @return Kubelet&#39;s generated CSRs will be addressed to this signer.
     * 
     */
    public String signerName() {
        return this.signerName;
    }
    /**
     * @return userAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
     * 
     * These values are copied verbatim into the `spec.unverifiedUserAnnotations` field of the PodCertificateRequest objects that Kubelet creates.
     * 
     * Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
     * 
     * Signers should document the keys and values they support. Signers should deny requests that contain keys they do not recognize.
     * 
     */
    public Map<String,String> userAnnotations() {
        return this.userAnnotations == null ? Map.of() : this.userAnnotations;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(PodCertificateProjection defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String certificateChainPath;
        private @Nullable String credentialBundlePath;
        private @Nullable String keyPath;
        private String keyType;
        private @Nullable Integer maxExpirationSeconds;
        private String signerName;
        private @Nullable Map<String,String> userAnnotations;
        public Builder() {}
        public Builder(PodCertificateProjection defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.certificateChainPath = defaults.certificateChainPath;
    	      this.credentialBundlePath = defaults.credentialBundlePath;
    	      this.keyPath = defaults.keyPath;
    	      this.keyType = defaults.keyType;
    	      this.maxExpirationSeconds = defaults.maxExpirationSeconds;
    	      this.signerName = defaults.signerName;
    	      this.userAnnotations = defaults.userAnnotations;
        }

        @CustomType.Setter
        public Builder certificateChainPath(@Nullable String certificateChainPath) {

            this.certificateChainPath = certificateChainPath;
            return this;
        }
        @CustomType.Setter
        public Builder credentialBundlePath(@Nullable String credentialBundlePath) {

            this.credentialBundlePath = credentialBundlePath;
            return this;
        }
        @CustomType.Setter
        public Builder keyPath(@Nullable String keyPath) {

            this.keyPath = keyPath;
            return this;
        }
        @CustomType.Setter
        public Builder keyType(String keyType) {
            if (keyType == null) {
              throw new MissingRequiredPropertyException("PodCertificateProjection", "keyType");
            }
            this.keyType = keyType;
            return this;
        }
        @CustomType.Setter
        public Builder maxExpirationSeconds(@Nullable Integer maxExpirationSeconds) {

            this.maxExpirationSeconds = maxExpirationSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder signerName(String signerName) {
            if (signerName == null) {
              throw new MissingRequiredPropertyException("PodCertificateProjection", "signerName");
            }
            this.signerName = signerName;
            return this;
        }
        @CustomType.Setter
        public Builder userAnnotations(@Nullable Map<String,String> userAnnotations) {

            this.userAnnotations = userAnnotations;
            return this;
        }
        public PodCertificateProjection build() {
            final var _resultValue = new PodCertificateProjection();
            _resultValue.certificateChainPath = certificateChainPath;
            _resultValue.credentialBundlePath = credentialBundlePath;
            _resultValue.keyPath = keyPath;
            _resultValue.keyType = keyType;
            _resultValue.maxExpirationSeconds = maxExpirationSeconds;
            _resultValue.signerName = signerName;
            _resultValue.userAnnotations = userAnnotations;
            return _resultValue;
        }
    }
}
