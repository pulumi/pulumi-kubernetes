// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.kubernetes.core.v1.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * PodCertificateProjection provides a private key and X.509 certificate in the pod filesystem.
 * 
 */
public final class PodCertificateProjectionPatchArgs extends com.pulumi.resources.ResourceArgs {

    public static final PodCertificateProjectionPatchArgs Empty = new PodCertificateProjectionPatchArgs();

    /**
     * Write the certificate chain at this path in the projected volume.
     * 
     * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
     * 
     */
    @Import(name="certificateChainPath")
    private @Nullable Output<String> certificateChainPath;

    /**
     * @return Write the certificate chain at this path in the projected volume.
     * 
     * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
     * 
     */
    public Optional<Output<String>> certificateChainPath() {
        return Optional.ofNullable(this.certificateChainPath);
    }

    /**
     * Write the credential bundle at this path in the projected volume.
     * 
     * The credential bundle is a single file that contains multiple PEM blocks. The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private key.
     * 
     * The remaining blocks are CERTIFICATE blocks, containing the issued certificate chain from the signer (leaf and any intermediates).
     * 
     * Using credentialBundlePath lets your Pod&#39;s application code make a single atomic read that retrieves a consistent key and certificate chain.  If you project them to separate files, your application code will need to additionally check that the leaf certificate was issued to the key.
     * 
     */
    @Import(name="credentialBundlePath")
    private @Nullable Output<String> credentialBundlePath;

    /**
     * @return Write the credential bundle at this path in the projected volume.
     * 
     * The credential bundle is a single file that contains multiple PEM blocks. The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private key.
     * 
     * The remaining blocks are CERTIFICATE blocks, containing the issued certificate chain from the signer (leaf and any intermediates).
     * 
     * Using credentialBundlePath lets your Pod&#39;s application code make a single atomic read that retrieves a consistent key and certificate chain.  If you project them to separate files, your application code will need to additionally check that the leaf certificate was issued to the key.
     * 
     */
    public Optional<Output<String>> credentialBundlePath() {
        return Optional.ofNullable(this.credentialBundlePath);
    }

    /**
     * Write the key at this path in the projected volume.
     * 
     * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
     * 
     */
    @Import(name="keyPath")
    private @Nullable Output<String> keyPath;

    /**
     * @return Write the key at this path in the projected volume.
     * 
     * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
     * 
     */
    public Optional<Output<String>> keyPath() {
        return Optional.ofNullable(this.keyPath);
    }

    /**
     * The type of keypair Kubelet will generate for the pod.
     * 
     * Valid values are &#34;RSA3072&#34;, &#34;RSA4096&#34;, &#34;ECDSAP256&#34;, &#34;ECDSAP384&#34;, &#34;ECDSAP521&#34;, and &#34;ED25519&#34;.
     * 
     */
    @Import(name="keyType")
    private @Nullable Output<String> keyType;

    /**
     * @return The type of keypair Kubelet will generate for the pod.
     * 
     * Valid values are &#34;RSA3072&#34;, &#34;RSA4096&#34;, &#34;ECDSAP256&#34;, &#34;ECDSAP384&#34;, &#34;ECDSAP521&#34;, and &#34;ED25519&#34;.
     * 
     */
    public Optional<Output<String>> keyType() {
        return Optional.ofNullable(this.keyType);
    }

    /**
     * maxExpirationSeconds is the maximum lifetime permitted for the certificate.
     * 
     * Kubelet copies this value verbatim into the PodCertificateRequests it generates for this projection.
     * 
     * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
     * 
     * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
     * 
     */
    @Import(name="maxExpirationSeconds")
    private @Nullable Output<Integer> maxExpirationSeconds;

    /**
     * @return maxExpirationSeconds is the maximum lifetime permitted for the certificate.
     * 
     * Kubelet copies this value verbatim into the PodCertificateRequests it generates for this projection.
     * 
     * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
     * 
     * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
     * 
     */
    public Optional<Output<Integer>> maxExpirationSeconds() {
        return Optional.ofNullable(this.maxExpirationSeconds);
    }

    /**
     * Kubelet&#39;s generated CSRs will be addressed to this signer.
     * 
     */
    @Import(name="signerName")
    private @Nullable Output<String> signerName;

    /**
     * @return Kubelet&#39;s generated CSRs will be addressed to this signer.
     * 
     */
    public Optional<Output<String>> signerName() {
        return Optional.ofNullable(this.signerName);
    }

    private PodCertificateProjectionPatchArgs() {}

    private PodCertificateProjectionPatchArgs(PodCertificateProjectionPatchArgs $) {
        this.certificateChainPath = $.certificateChainPath;
        this.credentialBundlePath = $.credentialBundlePath;
        this.keyPath = $.keyPath;
        this.keyType = $.keyType;
        this.maxExpirationSeconds = $.maxExpirationSeconds;
        this.signerName = $.signerName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(PodCertificateProjectionPatchArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private PodCertificateProjectionPatchArgs $;

        public Builder() {
            $ = new PodCertificateProjectionPatchArgs();
        }

        public Builder(PodCertificateProjectionPatchArgs defaults) {
            $ = new PodCertificateProjectionPatchArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param certificateChainPath Write the certificate chain at this path in the projected volume.
         * 
         * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
         * 
         * @return builder
         * 
         */
        public Builder certificateChainPath(@Nullable Output<String> certificateChainPath) {
            $.certificateChainPath = certificateChainPath;
            return this;
        }

        /**
         * @param certificateChainPath Write the certificate chain at this path in the projected volume.
         * 
         * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
         * 
         * @return builder
         * 
         */
        public Builder certificateChainPath(String certificateChainPath) {
            return certificateChainPath(Output.of(certificateChainPath));
        }

        /**
         * @param credentialBundlePath Write the credential bundle at this path in the projected volume.
         * 
         * The credential bundle is a single file that contains multiple PEM blocks. The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private key.
         * 
         * The remaining blocks are CERTIFICATE blocks, containing the issued certificate chain from the signer (leaf and any intermediates).
         * 
         * Using credentialBundlePath lets your Pod&#39;s application code make a single atomic read that retrieves a consistent key and certificate chain.  If you project them to separate files, your application code will need to additionally check that the leaf certificate was issued to the key.
         * 
         * @return builder
         * 
         */
        public Builder credentialBundlePath(@Nullable Output<String> credentialBundlePath) {
            $.credentialBundlePath = credentialBundlePath;
            return this;
        }

        /**
         * @param credentialBundlePath Write the credential bundle at this path in the projected volume.
         * 
         * The credential bundle is a single file that contains multiple PEM blocks. The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private key.
         * 
         * The remaining blocks are CERTIFICATE blocks, containing the issued certificate chain from the signer (leaf and any intermediates).
         * 
         * Using credentialBundlePath lets your Pod&#39;s application code make a single atomic read that retrieves a consistent key and certificate chain.  If you project them to separate files, your application code will need to additionally check that the leaf certificate was issued to the key.
         * 
         * @return builder
         * 
         */
        public Builder credentialBundlePath(String credentialBundlePath) {
            return credentialBundlePath(Output.of(credentialBundlePath));
        }

        /**
         * @param keyPath Write the key at this path in the projected volume.
         * 
         * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
         * 
         * @return builder
         * 
         */
        public Builder keyPath(@Nullable Output<String> keyPath) {
            $.keyPath = keyPath;
            return this;
        }

        /**
         * @param keyPath Write the key at this path in the projected volume.
         * 
         * Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.
         * 
         * @return builder
         * 
         */
        public Builder keyPath(String keyPath) {
            return keyPath(Output.of(keyPath));
        }

        /**
         * @param keyType The type of keypair Kubelet will generate for the pod.
         * 
         * Valid values are &#34;RSA3072&#34;, &#34;RSA4096&#34;, &#34;ECDSAP256&#34;, &#34;ECDSAP384&#34;, &#34;ECDSAP521&#34;, and &#34;ED25519&#34;.
         * 
         * @return builder
         * 
         */
        public Builder keyType(@Nullable Output<String> keyType) {
            $.keyType = keyType;
            return this;
        }

        /**
         * @param keyType The type of keypair Kubelet will generate for the pod.
         * 
         * Valid values are &#34;RSA3072&#34;, &#34;RSA4096&#34;, &#34;ECDSAP256&#34;, &#34;ECDSAP384&#34;, &#34;ECDSAP521&#34;, and &#34;ED25519&#34;.
         * 
         * @return builder
         * 
         */
        public Builder keyType(String keyType) {
            return keyType(Output.of(keyType));
        }

        /**
         * @param maxExpirationSeconds maxExpirationSeconds is the maximum lifetime permitted for the certificate.
         * 
         * Kubelet copies this value verbatim into the PodCertificateRequests it generates for this projection.
         * 
         * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
         * 
         * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
         * 
         * @return builder
         * 
         */
        public Builder maxExpirationSeconds(@Nullable Output<Integer> maxExpirationSeconds) {
            $.maxExpirationSeconds = maxExpirationSeconds;
            return this;
        }

        /**
         * @param maxExpirationSeconds maxExpirationSeconds is the maximum lifetime permitted for the certificate.
         * 
         * Kubelet copies this value verbatim into the PodCertificateRequests it generates for this projection.
         * 
         * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
         * 
         * The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
         * 
         * @return builder
         * 
         */
        public Builder maxExpirationSeconds(Integer maxExpirationSeconds) {
            return maxExpirationSeconds(Output.of(maxExpirationSeconds));
        }

        /**
         * @param signerName Kubelet&#39;s generated CSRs will be addressed to this signer.
         * 
         * @return builder
         * 
         */
        public Builder signerName(@Nullable Output<String> signerName) {
            $.signerName = signerName;
            return this;
        }

        /**
         * @param signerName Kubelet&#39;s generated CSRs will be addressed to this signer.
         * 
         * @return builder
         * 
         */
        public Builder signerName(String signerName) {
            return signerName(Output.of(signerName));
        }

        public PodCertificateProjectionPatchArgs build() {
            return $;
        }
    }

}
