// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../types/input";
import * as outputs from "../../types/output";
import * as enums from "../../types/enums";
import * as utilities from "../../utilities";

/**
 * Chart is a component representing a collection of resources described by an arbitrary Helm Chart.
 *
 * The Helm Chart can be fetched from any source that is accessible to the `helm` command line. Values in the `values.yml` file can be overridden using `ChartOpts.values` (equivalent to `--set` or having multiple `values.yml` files). Objects can be transformed arbitrarily by supplying callbacks to `ChartOpts.transformations`.
 *
 * The `Chart` resource renders the templates from your chart and then manage them directly with the Pulumi Kubernetes provider.
 *
 * `Chart` does not use Tiller. The Chart specified is copied and expanded locally; the semantics are equivalent to running `helm template` and then using Pulumi to manage the resulting YAML manifests. Any values that would be retrieved in-cluster are assigned fake values, and none of Tiller's server-side validity testing is executed.
 *
 * You may also want to consider the `Release` resource as an alternative method for managing helm charts. For more information about the trade-offs between these options see: [Choosing the right Helm resource for your use case](https://www.pulumi.com/registry/packages/kubernetes/how-to-guides/choosing-the-right-helm-resource-for-your-use-case)
 *
 * ## Example Usage
 * ### Local Chart Directory
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *     path: "./nginx-ingress",
 * });
 * ```
 * ### Remote Chart
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *     chart: "nginx-ingress",
 *     version: "1.24.4",
 *     fetchOpts:{
 *         repo: "https://charts.helm.sh/stable",
 *     },
 * });
 * ```
 * ### Set Chart Values
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *     chart: "nginx-ingress",
 *     version: "1.24.4",
 *     fetchOpts:{
 *         repo: "https://charts.helm.sh/stable",
 *     },
 *     values: {
 *         controller: {
 *             metrics: {
 *                 enabled: true,
 *             }
 *         }
 *     },
 * });
 * ```
 * ### Deploy Chart into Namespace
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *     chart: "nginx-ingress",
 *     version: "1.24.4",
 *     namespace: "test-namespace",
 *     fetchOpts:{
 *         repo: "https://charts.helm.sh/stable",
 *     },
 * });
 * ```
 * ### Depend on a Chart resource
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *     chart: "nginx-ingress",
 *     version: "1.24.4",
 *     namespace: "test-namespace",
 *     fetchOpts:{
 *         repo: "https://charts.helm.sh/stable",
 *     },
 * });
 *
 * // Create a ConfigMap depending on the Chart. The ConfigMap will not be created until after all of the Chart
 * // resources are ready. Note the use of the `ready` attribute; depending on the Chart resource directly will not work.
 * new k8s.core.v1.ConfigMap("foo", {
 *     metadata: { namespace: namespaceName },
 *     data: {foo: "bar"}
 * }, {dependsOn: nginxIngress.ready})
 * ```
 * ### Chart with Transformations
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *     chart: "nginx-ingress",
 *     version: "1.24.4",
 *     fetchOpts:{
 *         repo: "https://charts.helm.sh/stable",
 *     },
 *     transformations: [
 *         // Make every service private to the cluster, i.e., turn all services into ClusterIP instead of LoadBalancer.
 *         (obj: any, opts: pulumi.CustomResourceOptions) => {
 *             if (obj.kind === "Service" && obj.apiVersion === "v1") {
 *                 if (obj.spec && obj.spec.type && obj.spec.type === "LoadBalancer") {
 *                     obj.spec.type = "ClusterIP";
 *                 }
 *             }
 *         },
 *
 *         // Set a resource alias for a previous name.
 *         (obj: any, opts: pulumi.CustomResourceOptions) => {
 *             if (obj.kind === "Deployment") {
 *                 opts.aliases = [{ name: "oldName" }]
 *             }
 *         },
 *
 *         // Omit a resource from the Chart by transforming the specified resource definition to an empty List.
 *         (obj: any, opts: pulumi.CustomResourceOptions) => {
 *             if (obj.kind === "Pod" && obj.metadata.name === "test") {
 *                 obj.apiVersion = "v1"
 *                 obj.kind = "List"
 *             }
 *         },
 *     ],
 * });
 * ```
 */
export class Chart extends pulumi.ComponentResource {
    /** @internal */
    public static readonly __pulumiType = 'kubernetes:helm.sh/v4:Chart';

    /**
     * Returns true if the given object is an instance of Chart.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Chart {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Chart.__pulumiType;
    }

    /**
     * Resources created by the Chart.
     */
    public /*out*/ readonly resources!: pulumi.Output<any[]>;

    /**
     * Create a Chart resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: ChartArgs, opts?: pulumi.ComponentResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (!opts.id) {
            if ((!args || args.chart === undefined) && !opts.urn) {
                throw new Error("Missing required property 'chart'");
            }
            resourceInputs["chart"] = args ? args.chart : undefined;
            resourceInputs["dependencyUpdate"] = args ? args.dependencyUpdate : undefined;
            resourceInputs["devel"] = args ? args.devel : undefined;
            resourceInputs["keyring"] = args ? args.keyring : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["namespace"] = args ? args.namespace : undefined;
            resourceInputs["postRenderer"] = args ? args.postRenderer : undefined;
            resourceInputs["repositoryOpts"] = args ? args.repositoryOpts : undefined;
            resourceInputs["resourcePrefix"] = args ? args.resourcePrefix : undefined;
            resourceInputs["skipAwait"] = args ? args.skipAwait : undefined;
            resourceInputs["skipCrds"] = args ? args.skipCrds : undefined;
            resourceInputs["valueYamlFiles"] = args ? args.valueYamlFiles : undefined;
            resourceInputs["values"] = args ? args.values : undefined;
            resourceInputs["verify"] = args ? args.verify : undefined;
            resourceInputs["version"] = args ? args.version : undefined;
            resourceInputs["resources"] = undefined /*out*/;
        } else {
            resourceInputs["resources"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Chart.__pulumiType, name, resourceInputs, opts, true /*remote*/);
    }
}

/**
 * The set of arguments for constructing a Chart resource.
 */
export interface ChartArgs {
    /**
     * Chart name to be installed. A path may be used.
     */
    chart: pulumi.Input<string>;
    /**
     * Run helm dependency update before installing the chart.
     */
    dependencyUpdate?: pulumi.Input<boolean>;
    /**
     * Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
     */
    devel?: pulumi.Input<boolean>;
    /**
     * Location of public keys used for verification. Used only if `verify` is true
     */
    keyring?: pulumi.Input<pulumi.asset.Asset | pulumi.asset.Archive>;
    /**
     * Release name.
     */
    name?: pulumi.Input<string>;
    /**
     * Namespace for the release.
     */
    namespace?: pulumi.Input<string>;
    /**
     * Specification defining the post-renderer to use.
     */
    postRenderer?: pulumi.Input<inputs.helm.v4.PostRenderer>;
    /**
     * Specification defining the Helm chart repository to use.
     */
    repositoryOpts?: pulumi.Input<inputs.helm.v3.RepositoryOpts>;
    /**
     * An optional prefix for the auto-generated resource names. Example: A resource created with resourcePrefix="foo" would produce a resource named "foo:resourceName".
     */
    resourcePrefix?: pulumi.Input<string>;
    /**
     * By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
     */
    skipAwait?: pulumi.Input<boolean>;
    /**
     * If set, no CRDs will be installed. By default, CRDs are installed if not already present.
     */
    skipCrds?: pulumi.Input<boolean>;
    /**
     * List of assets (raw yaml files). Content is read and merged with values.
     */
    valueYamlFiles?: pulumi.Input<pulumi.Input<pulumi.asset.Asset | pulumi.asset.Archive>[]>;
    /**
     * Custom values set for the release.
     */
    values?: pulumi.Input<{[key: string]: any}>;
    /**
     * Verify the chart's integrity.
     */
    verify?: pulumi.Input<boolean>;
    /**
     * Specify the chart version to install. If this is not specified, the latest version is installed.
     */
    version?: pulumi.Input<string>;
}
