// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package yaml

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"path/filepath"
	"reflect"

	"github.com/pkg/errors"
	admissionregistrationv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/admissionregistration/v1"
	admissionregistrationv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/admissionregistration/v1beta1"
	apiextensionsv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/apiextensions/v1"
	apiextensionsv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/apiextensions/v1beta1"
	apiregistrationv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/apiregistration/v1"
	apiregistrationv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/apiregistration/v1beta1"
	appsv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/apps/v1"
	appsv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/apps/v1beta1"
	appsv1beta2 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/apps/v1beta2"
	auditregistrationv1alpha1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/auditregistration/v1alpha1"
	authenticationv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/authentication/v1"
	authenticationv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/authentication/v1beta1"
	authorizationv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/authorization/v1"
	authorizationv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/authorization/v1beta1"
	autoscalingv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/autoscaling/v1"
	autoscalingv2beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/autoscaling/v2beta1"
	autoscalingv2beta2 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/autoscaling/v2beta2"
	batchv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/batch/v1"
	batchv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/batch/v1beta1"
	batchv2alpha1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/batch/v2alpha1"
	certificatesv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/certificates/v1beta1"
	coordinationv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/coordination/v1"
	coordinationv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/coordination/v1beta1"
	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/core/v1"
	discoveryv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/discovery/v1beta1"
	eventsv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/events/v1beta1"
	extensionsv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/extensions/v1beta1"
	flowcontrolv1alpha1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/flowcontrol/v1alpha1"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/meta/v1"
	networkingv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/networking/v1"
	networkingv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/networking/v1beta1"
	nodev1alpha1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/node/v1alpha1"
	nodev1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/node/v1beta1"
	policyv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/policy/v1beta1"
	rbacv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/rbac/v1"
	rbacv1alpha1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/rbac/v1alpha1"
	rbacv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/rbac/v1beta1"
	schedulingv1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/scheduling/v1"
	schedulingv1alpha1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/scheduling/v1alpha1"
	schedulingv1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/scheduling/v1beta1"
	settingsv1alpha1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/settings/v1alpha1"
	storagev1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/storage/v1"
	storagev1alpha1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/storage/v1alpha1"
	storagev1beta1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/storage/v1beta1"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

func parseDecodeYamlFiles(ctx *pulumi.Context, args *ConfigGroupArgs, glob bool, opts ...pulumi.ResourceOption,
) (map[string]pulumi.Resource, error) {

	// Start with the provided objects and YAML arrays, if any, and we'll append to them.
	objs := args.Objs
	yamls := args.YAML

	// Start by gathering up any other YAML from files provided.
	for _, file := range args.Files {
		// Read the raw YAML file(s) specified in the input file parameter. It might be a URL or a file path.
		var yaml []byte
		u, err := url.Parse(file)
		if err != nil && u.IsAbs() {
			// If the string looks like a URL, in that it begins with a scheme, fetch it over the network.
			resp, err := http.Get(file)
			if err != nil {
				return nil, errors.Wrapf(err, "fetching YAML over network")
			}
			defer resp.Body.Close()
			yaml, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, errors.Wrapf(err, "reading YAML over network")
			}
			yamls = append(yamls, string(yaml))
		} else {
			// Otherwise, assume this is a path to a file on disk. If globbing is enabled, we might have
			// multiple files -- otherwise just read a singular file.
			var files []string
			if glob {
				files, err = filepath.Glob(file)
				if err != nil {
					return nil, errors.Wrapf(err, "expanding glob")
				}
			} else {
				files = []string{file}
			}
			for _, f := range files {
				yaml, err = ioutil.ReadFile(f)
				if err != nil {
					return nil, errors.Wrapf(err, "reading YAML file from disk")
				}
				yamls = append(yamls, string(yaml))
			}
		}
	}

	// Next parse all YAML documents into objects.
	for _, yaml := range yamls {
		// Parse the resulting YAML bytes and turn them into raw Kubernetes objects.
		dec, err := yamlDecode(ctx, yaml, opts...)
		if err != nil {
			return nil, errors.Wrapf(err, "decoding YAML")
		}
		objs = append(objs, dec...)
	}

	// Now process the resulting list of Kubernetes objects.
	return parseYamlObjects(ctx, objs, args.Transformations, args.ResourcePrefix, opts...)
}

// yamlDecode invokes the function to decode a single YAML file and decompose it into object structures.
func yamlDecode(ctx *pulumi.Context, text string, opts ...pulumi.ResourceOption) ([]map[string]interface{}, error) {
	args := struct {
		Text string `pulumi:"text"`
	}{Text: text}
	var ret struct {
		Result []map[string]interface{} `pulumi:"result"`
	}
	if err := ctx.Invoke("kubernetes:yaml:decode", &args, &ret); err != nil {
		return nil, err
	}
	return ret.Result, nil
}

func parseYamlObjects(ctx *pulumi.Context, objs []map[string]interface{}, transformations []Transformation,
	resourcePrefix string, opts ...pulumi.ResourceOption,
) (map[string]pulumi.Resource, error) {
	var intermediates []resourceTuple
	for _, obj := range objs {
		res, err := parseYamlObject(ctx, obj, transformations, resourcePrefix, opts...)
		if err != nil {
			return nil, err
		}
		for _, r := range res {
			intermediates = append(intermediates, r)
		}
	}

	resources := map[string]pulumi.Resource{}
	for _, r := range intermediates {
		resources[r.Name] = r.Resource
	}
	return resources, nil
}

type resourceTuple struct {
	Name     string
	Resource pulumi.Resource
}

type UntypedArgs map[string]interface{}

func (UntypedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]interface{})(nil)).Elem()
}

func parseYamlObject(ctx *pulumi.Context, obj map[string]interface{}, transformations []Transformation,
	resourcePrefix string, opts ...pulumi.ResourceOption,
) ([]resourceTuple, error) {

	// Allow users to change API objects before any validation.
	for _, t := range transformations {
		t(obj, opts...)
	}

	// Ensure there is a kind and API version.
	kind, hasKind := obj["kind"]
	apiVersion, hasAPIVersion := obj["apiVersion"]
	if !hasKind || !hasAPIVersion {
		return nil, errors.Errorf("Kubernetes resources require a kind and apiVersion: %+v", obj)
	}
	fullKind := fmt.Sprintf("%s/%s", apiVersion, kind)

	// Recursively traverse built-in Kubernetes list types into a single set of "naked" resource
	// definitions that we can register with the Pulumi engine.
	//
	// Kubernetes does not instantiate list types like `v1.List`. When the API server receives
	// a list, it will recursively traverse it and perform the necessary operations on the
	// each "instantiable" resource it finds. For example, `kubectl apply` on a
	// `v1.ConfigMapList` will cause the API server to traverse the list, and `apply` each
	// `v1.ConfigMap` it finds.
	//
	// Since Kubernetes does not instantiate list types directly, Pulumi also traverses lists
	// for resource definitions that can be managed by Kubernetes, and registers those with the
	// engine instead.
	switch fullKind {
	case "admissionregistration.k8s.io/v1/MutatingWebhookConfigurationList",
		"admissionregistration.k8s.io/v1/ValidatingWebhookConfigurationList",
		"admissionregistration.k8s.io/v1beta1/MutatingWebhookConfigurationList",
		"admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfigurationList",
		"apiextensions.k8s.io/v1/CustomResourceDefinitionList",
		"apiextensions.k8s.io/v1beta1/CustomResourceDefinitionList",
		"apiregistration.k8s.io/v1/APIServiceList",
		"apiregistration.k8s.io/v1beta1/APIServiceList",
		"apps/v1/ControllerRevisionList",
		"apps/v1/DaemonSetList",
		"apps/v1/DeploymentList",
		"apps/v1/ReplicaSetList",
		"apps/v1/StatefulSetList",
		"apps/v1beta1/ControllerRevisionList",
		"apps/v1beta1/DeploymentList",
		"apps/v1beta1/StatefulSetList",
		"apps/v1beta2/ControllerRevisionList",
		"apps/v1beta2/DaemonSetList",
		"apps/v1beta2/DeploymentList",
		"apps/v1beta2/ReplicaSetList",
		"apps/v1beta2/StatefulSetList",
		"auditregistration.k8s.io/v1alpha1/AuditSinkList",
		"autoscaling/v1/HorizontalPodAutoscalerList",
		"autoscaling/v2beta1/HorizontalPodAutoscalerList",
		"autoscaling/v2beta2/HorizontalPodAutoscalerList",
		"batch/v1/JobList",
		"batch/v1beta1/CronJobList",
		"batch/v2alpha1/CronJobList",
		"certificates.k8s.io/v1beta1/CertificateSigningRequestList",
		"coordination.k8s.io/v1/LeaseList",
		"coordination.k8s.io/v1beta1/LeaseList",
		"v1/ComponentStatusList",
		"v1/ConfigMapList",
		"v1/EndpointsList",
		"v1/EventList",
		"v1/LimitRangeList",
		"v1/NamespaceList",
		"v1/NodeList",
		"v1/PersistentVolumeClaimList",
		"v1/PersistentVolumeList",
		"v1/PodList",
		"v1/PodTemplateList",
		"v1/ReplicationControllerList",
		"v1/ResourceQuotaList",
		"v1/SecretList",
		"v1/ServiceAccountList",
		"v1/ServiceList",
		"discovery.k8s.io/v1beta1/EndpointSliceList",
		"events.k8s.io/v1beta1/EventList",
		"extensions/v1beta1/DaemonSetList",
		"extensions/v1beta1/DeploymentList",
		"extensions/v1beta1/IngressList",
		"extensions/v1beta1/NetworkPolicyList",
		"extensions/v1beta1/PodSecurityPolicyList",
		"extensions/v1beta1/ReplicaSetList",
		"flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchemaList",
		"flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfigurationList",
		"networking.k8s.io/v1/NetworkPolicyList",
		"networking.k8s.io/v1beta1/IngressClassList",
		"networking.k8s.io/v1beta1/IngressList",
		"node.k8s.io/v1alpha1/RuntimeClassList",
		"node.k8s.io/v1beta1/RuntimeClassList",
		"policy/v1beta1/PodDisruptionBudgetList",
		"policy/v1beta1/PodSecurityPolicyList",
		"rbac.authorization.k8s.io/v1/ClusterRoleBindingList",
		"rbac.authorization.k8s.io/v1/ClusterRoleList",
		"rbac.authorization.k8s.io/v1/RoleBindingList",
		"rbac.authorization.k8s.io/v1/RoleList",
		"rbac.authorization.k8s.io/v1alpha1/ClusterRoleBindingList",
		"rbac.authorization.k8s.io/v1alpha1/ClusterRoleList",
		"rbac.authorization.k8s.io/v1alpha1/RoleBindingList",
		"rbac.authorization.k8s.io/v1alpha1/RoleList",
		"rbac.authorization.k8s.io/v1beta1/ClusterRoleBindingList",
		"rbac.authorization.k8s.io/v1beta1/ClusterRoleList",
		"rbac.authorization.k8s.io/v1beta1/RoleBindingList",
		"rbac.authorization.k8s.io/v1beta1/RoleList",
		"scheduling.k8s.io/v1/PriorityClassList",
		"scheduling.k8s.io/v1alpha1/PriorityClassList",
		"scheduling.k8s.io/v1beta1/PriorityClassList",
		"settings.k8s.io/v1alpha1/PodPresetList",
		"storage.k8s.io/v1/CSIDriverList",
		"storage.k8s.io/v1/CSINodeList",
		"storage.k8s.io/v1/StorageClassList",
		"storage.k8s.io/v1/VolumeAttachmentList",
		"storage.k8s.io/v1alpha1/VolumeAttachmentList",
		"storage.k8s.io/v1beta1/CSIDriverList",
		"storage.k8s.io/v1beta1/CSINodeList",
		"storage.k8s.io/v1beta1/StorageClassList",
		"storage.k8s.io/v1beta1/VolumeAttachmentList":
		var resources []resourceTuple
		if rawItems, hasItems := obj["items"]; hasItems {
			if items, ok := rawItems.([]interface{}); ok {
				for _, item := range items {
					if obj, ok := item.(map[string]interface{}); ok {
						rs, err := parseYamlObject(ctx, obj, transformations, resourcePrefix, opts...)
						if err != nil {
							return nil, err
						}
						for _, r := range rs {
							resources = append(resources, r)
						}
					}
				}
			}
		}
		return resources, nil
	}

	// If we got here, it's not a recursively traversed type, so process it directly.
	// First, validate that it has the requisite metadata and name properties.
	meta, hasMeta := obj["metadata"]
	if !hasMeta {
		return nil, errors.Errorf("YAML object does not have a .metadata field: %s %+v", fullKind, obj)
	}
	metaDict, hasMetaDict := meta.(map[string]interface{})
	if !hasMetaDict {
		return nil, errors.Errorf("YAML object does not have a .metadata dictionary: %s %+v", fullKind, obj)
	}
	metaName, hasMetaName := metaDict["name"].(string)
	if !hasMetaName || metaName == "" {
		return nil, errors.Errorf("YAML object does not have a .metadata.name: %s %+v", fullKind, obj)
	}

	// Manufacture a name as appropriate, out of the meta name, namespace, and optional prefix.
	if ns, hasNS := metaDict["namespace"]; hasNS {
		metaName = fmt.Sprintf("%s/%s", ns, metaName)
	}
	if resourcePrefix != "" {
		metaName = fmt.Sprintf("%s-%s", resourcePrefix, metaName)
	}

	key := fmt.Sprintf("%s::%s", fullKind, metaName)

	// Finally allocate a resource of the correct type.
	switch fullKind {
	case "admissionregistration.k8s.io/v1/MutatingWebhookConfiguration":
		var res admissionregistrationv1.MutatingWebhookConfiguration
		err := ctx.RegisterResource("kubernetes:admissionregistration.k8s.io/v1:MutatingWebhookConfiguration", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "admissionregistration.k8s.io/v1/ValidatingWebhookConfiguration":
		var res admissionregistrationv1.ValidatingWebhookConfiguration
		err := ctx.RegisterResource("kubernetes:admissionregistration.k8s.io/v1:ValidatingWebhookConfiguration", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "admissionregistration.k8s.io/v1beta1/MutatingWebhookConfiguration":
		var res admissionregistrationv1beta1.MutatingWebhookConfiguration
		err := ctx.RegisterResource("kubernetes:admissionregistration.k8s.io/v1beta1:MutatingWebhookConfiguration", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfiguration":
		var res admissionregistrationv1beta1.ValidatingWebhookConfiguration
		err := ctx.RegisterResource("kubernetes:admissionregistration.k8s.io/v1beta1:ValidatingWebhookConfiguration", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apiextensions.k8s.io/v1/CustomResourceDefinition":
		var res apiextensionsv1.CustomResourceDefinition
		err := ctx.RegisterResource("kubernetes:apiextensions.k8s.io/v1:CustomResourceDefinition", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apiextensions.k8s.io/v1beta1/CustomResourceDefinition":
		var res apiextensionsv1beta1.CustomResourceDefinition
		err := ctx.RegisterResource("kubernetes:apiextensions.k8s.io/v1beta1:CustomResourceDefinition", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apiregistration.k8s.io/v1/APIService":
		var res apiregistrationv1.APIService
		err := ctx.RegisterResource("kubernetes:apiregistration.k8s.io/v1:APIService", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apiregistration.k8s.io/v1beta1/APIService":
		var res apiregistrationv1beta1.APIService
		err := ctx.RegisterResource("kubernetes:apiregistration.k8s.io/v1beta1:APIService", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1/ControllerRevision":
		var res appsv1.ControllerRevision
		err := ctx.RegisterResource("kubernetes:apps/v1:ControllerRevision", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1/DaemonSet":
		var res appsv1.DaemonSet
		err := ctx.RegisterResource("kubernetes:apps/v1:DaemonSet", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1/Deployment":
		var res appsv1.Deployment
		err := ctx.RegisterResource("kubernetes:apps/v1:Deployment", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1/ReplicaSet":
		var res appsv1.ReplicaSet
		err := ctx.RegisterResource("kubernetes:apps/v1:ReplicaSet", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1/StatefulSet":
		var res appsv1.StatefulSet
		err := ctx.RegisterResource("kubernetes:apps/v1:StatefulSet", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1beta1/ControllerRevision":
		var res appsv1beta1.ControllerRevision
		err := ctx.RegisterResource("kubernetes:apps/v1beta1:ControllerRevision", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1beta1/Deployment":
		var res appsv1beta1.Deployment
		err := ctx.RegisterResource("kubernetes:apps/v1beta1:Deployment", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1beta1/StatefulSet":
		var res appsv1beta1.StatefulSet
		err := ctx.RegisterResource("kubernetes:apps/v1beta1:StatefulSet", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1beta2/ControllerRevision":
		var res appsv1beta2.ControllerRevision
		err := ctx.RegisterResource("kubernetes:apps/v1beta2:ControllerRevision", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1beta2/DaemonSet":
		var res appsv1beta2.DaemonSet
		err := ctx.RegisterResource("kubernetes:apps/v1beta2:DaemonSet", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1beta2/Deployment":
		var res appsv1beta2.Deployment
		err := ctx.RegisterResource("kubernetes:apps/v1beta2:Deployment", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1beta2/ReplicaSet":
		var res appsv1beta2.ReplicaSet
		err := ctx.RegisterResource("kubernetes:apps/v1beta2:ReplicaSet", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "apps/v1beta2/StatefulSet":
		var res appsv1beta2.StatefulSet
		err := ctx.RegisterResource("kubernetes:apps/v1beta2:StatefulSet", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "auditregistration.k8s.io/v1alpha1/AuditSink":
		var res auditregistrationv1alpha1.AuditSink
		err := ctx.RegisterResource("kubernetes:auditregistration.k8s.io/v1alpha1:AuditSink", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authentication.k8s.io/v1/TokenRequest":
		var res authenticationv1.TokenRequest
		err := ctx.RegisterResource("kubernetes:authentication.k8s.io/v1:TokenRequest", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authentication.k8s.io/v1/TokenReview":
		var res authenticationv1.TokenReview
		err := ctx.RegisterResource("kubernetes:authentication.k8s.io/v1:TokenReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authentication.k8s.io/v1beta1/TokenReview":
		var res authenticationv1beta1.TokenReview
		err := ctx.RegisterResource("kubernetes:authentication.k8s.io/v1beta1:TokenReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authorization.k8s.io/v1/LocalSubjectAccessReview":
		var res authorizationv1.LocalSubjectAccessReview
		err := ctx.RegisterResource("kubernetes:authorization.k8s.io/v1:LocalSubjectAccessReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authorization.k8s.io/v1/SelfSubjectAccessReview":
		var res authorizationv1.SelfSubjectAccessReview
		err := ctx.RegisterResource("kubernetes:authorization.k8s.io/v1:SelfSubjectAccessReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authorization.k8s.io/v1/SelfSubjectRulesReview":
		var res authorizationv1.SelfSubjectRulesReview
		err := ctx.RegisterResource("kubernetes:authorization.k8s.io/v1:SelfSubjectRulesReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authorization.k8s.io/v1/SubjectAccessReview":
		var res authorizationv1.SubjectAccessReview
		err := ctx.RegisterResource("kubernetes:authorization.k8s.io/v1:SubjectAccessReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authorization.k8s.io/v1beta1/LocalSubjectAccessReview":
		var res authorizationv1beta1.LocalSubjectAccessReview
		err := ctx.RegisterResource("kubernetes:authorization.k8s.io/v1beta1:LocalSubjectAccessReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authorization.k8s.io/v1beta1/SelfSubjectAccessReview":
		var res authorizationv1beta1.SelfSubjectAccessReview
		err := ctx.RegisterResource("kubernetes:authorization.k8s.io/v1beta1:SelfSubjectAccessReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authorization.k8s.io/v1beta1/SelfSubjectRulesReview":
		var res authorizationv1beta1.SelfSubjectRulesReview
		err := ctx.RegisterResource("kubernetes:authorization.k8s.io/v1beta1:SelfSubjectRulesReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "authorization.k8s.io/v1beta1/SubjectAccessReview":
		var res authorizationv1beta1.SubjectAccessReview
		err := ctx.RegisterResource("kubernetes:authorization.k8s.io/v1beta1:SubjectAccessReview", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "autoscaling/v1/HorizontalPodAutoscaler":
		var res autoscalingv1.HorizontalPodAutoscaler
		err := ctx.RegisterResource("kubernetes:autoscaling/v1:HorizontalPodAutoscaler", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "autoscaling/v2beta1/HorizontalPodAutoscaler":
		var res autoscalingv2beta1.HorizontalPodAutoscaler
		err := ctx.RegisterResource("kubernetes:autoscaling/v2beta1:HorizontalPodAutoscaler", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "autoscaling/v2beta2/HorizontalPodAutoscaler":
		var res autoscalingv2beta2.HorizontalPodAutoscaler
		err := ctx.RegisterResource("kubernetes:autoscaling/v2beta2:HorizontalPodAutoscaler", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "batch/v1/Job":
		var res batchv1.Job
		err := ctx.RegisterResource("kubernetes:batch/v1:Job", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "batch/v1beta1/CronJob":
		var res batchv1beta1.CronJob
		err := ctx.RegisterResource("kubernetes:batch/v1beta1:CronJob", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "batch/v2alpha1/CronJob":
		var res batchv2alpha1.CronJob
		err := ctx.RegisterResource("kubernetes:batch/v2alpha1:CronJob", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "certificates.k8s.io/v1beta1/CertificateSigningRequest":
		var res certificatesv1beta1.CertificateSigningRequest
		err := ctx.RegisterResource("kubernetes:certificates.k8s.io/v1beta1:CertificateSigningRequest", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "coordination.k8s.io/v1/Lease":
		var res coordinationv1.Lease
		err := ctx.RegisterResource("kubernetes:coordination.k8s.io/v1:Lease", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "coordination.k8s.io/v1beta1/Lease":
		var res coordinationv1beta1.Lease
		err := ctx.RegisterResource("kubernetes:coordination.k8s.io/v1beta1:Lease", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/Binding":
		var res corev1.Binding
		err := ctx.RegisterResource("kubernetes:core/v1:Binding", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/ComponentStatus":
		var res corev1.ComponentStatus
		err := ctx.RegisterResource("kubernetes:core/v1:ComponentStatus", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/ConfigMap":
		var res corev1.ConfigMap
		err := ctx.RegisterResource("kubernetes:core/v1:ConfigMap", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/Endpoints":
		var res corev1.Endpoints
		err := ctx.RegisterResource("kubernetes:core/v1:Endpoints", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/Event":
		var res corev1.Event
		err := ctx.RegisterResource("kubernetes:core/v1:Event", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/LimitRange":
		var res corev1.LimitRange
		err := ctx.RegisterResource("kubernetes:core/v1:LimitRange", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/Namespace":
		var res corev1.Namespace
		err := ctx.RegisterResource("kubernetes:core/v1:Namespace", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/Node":
		var res corev1.Node
		err := ctx.RegisterResource("kubernetes:core/v1:Node", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/PersistentVolume":
		var res corev1.PersistentVolume
		err := ctx.RegisterResource("kubernetes:core/v1:PersistentVolume", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/PersistentVolumeClaim":
		var res corev1.PersistentVolumeClaim
		err := ctx.RegisterResource("kubernetes:core/v1:PersistentVolumeClaim", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/Pod":
		var res corev1.Pod
		err := ctx.RegisterResource("kubernetes:core/v1:Pod", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/PodTemplate":
		var res corev1.PodTemplate
		err := ctx.RegisterResource("kubernetes:core/v1:PodTemplate", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/ReplicationController":
		var res corev1.ReplicationController
		err := ctx.RegisterResource("kubernetes:core/v1:ReplicationController", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/ResourceQuota":
		var res corev1.ResourceQuota
		err := ctx.RegisterResource("kubernetes:core/v1:ResourceQuota", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/Secret":
		var res corev1.Secret
		err := ctx.RegisterResource("kubernetes:core/v1:Secret", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/Service":
		var res corev1.Service
		err := ctx.RegisterResource("kubernetes:core/v1:Service", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "v1/ServiceAccount":
		var res corev1.ServiceAccount
		err := ctx.RegisterResource("kubernetes:core/v1:ServiceAccount", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "discovery.k8s.io/v1beta1/EndpointSlice":
		var res discoveryv1beta1.EndpointSlice
		err := ctx.RegisterResource("kubernetes:discovery.k8s.io/v1beta1:EndpointSlice", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "events.k8s.io/v1beta1/Event":
		var res eventsv1beta1.Event
		err := ctx.RegisterResource("kubernetes:events.k8s.io/v1beta1:Event", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "extensions/v1beta1/DaemonSet":
		var res extensionsv1beta1.DaemonSet
		err := ctx.RegisterResource("kubernetes:extensions/v1beta1:DaemonSet", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "extensions/v1beta1/Deployment":
		var res extensionsv1beta1.Deployment
		err := ctx.RegisterResource("kubernetes:extensions/v1beta1:Deployment", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "extensions/v1beta1/Ingress":
		var res extensionsv1beta1.Ingress
		err := ctx.RegisterResource("kubernetes:extensions/v1beta1:Ingress", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "extensions/v1beta1/NetworkPolicy":
		var res extensionsv1beta1.NetworkPolicy
		err := ctx.RegisterResource("kubernetes:extensions/v1beta1:NetworkPolicy", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "extensions/v1beta1/PodSecurityPolicy":
		var res extensionsv1beta1.PodSecurityPolicy
		err := ctx.RegisterResource("kubernetes:extensions/v1beta1:PodSecurityPolicy", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "extensions/v1beta1/ReplicaSet":
		var res extensionsv1beta1.ReplicaSet
		err := ctx.RegisterResource("kubernetes:extensions/v1beta1:ReplicaSet", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchema":
		var res flowcontrolv1alpha1.FlowSchema
		err := ctx.RegisterResource("kubernetes:flowcontrol.apiserver.k8s.io/v1alpha1:FlowSchema", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfiguration":
		var res flowcontrolv1alpha1.PriorityLevelConfiguration
		err := ctx.RegisterResource("kubernetes:flowcontrol.apiserver.k8s.io/v1alpha1:PriorityLevelConfiguration", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "meta/v1/Status":
		var res metav1.Status
		err := ctx.RegisterResource("kubernetes:meta/v1:Status", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "networking.k8s.io/v1/NetworkPolicy":
		var res networkingv1.NetworkPolicy
		err := ctx.RegisterResource("kubernetes:networking.k8s.io/v1:NetworkPolicy", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "networking.k8s.io/v1beta1/Ingress":
		var res networkingv1beta1.Ingress
		err := ctx.RegisterResource("kubernetes:networking.k8s.io/v1beta1:Ingress", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "networking.k8s.io/v1beta1/IngressClass":
		var res networkingv1beta1.IngressClass
		err := ctx.RegisterResource("kubernetes:networking.k8s.io/v1beta1:IngressClass", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "node.k8s.io/v1alpha1/RuntimeClass":
		var res nodev1alpha1.RuntimeClass
		err := ctx.RegisterResource("kubernetes:node.k8s.io/v1alpha1:RuntimeClass", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "node.k8s.io/v1beta1/RuntimeClass":
		var res nodev1beta1.RuntimeClass
		err := ctx.RegisterResource("kubernetes:node.k8s.io/v1beta1:RuntimeClass", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "policy/v1beta1/PodDisruptionBudget":
		var res policyv1beta1.PodDisruptionBudget
		err := ctx.RegisterResource("kubernetes:policy/v1beta1:PodDisruptionBudget", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "policy/v1beta1/PodSecurityPolicy":
		var res policyv1beta1.PodSecurityPolicy
		err := ctx.RegisterResource("kubernetes:policy/v1beta1:PodSecurityPolicy", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1/ClusterRole":
		var res rbacv1.ClusterRole
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1:ClusterRole", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1/ClusterRoleBinding":
		var res rbacv1.ClusterRoleBinding
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1:ClusterRoleBinding", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1/Role":
		var res rbacv1.Role
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1:Role", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1/RoleBinding":
		var res rbacv1.RoleBinding
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1:RoleBinding", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1alpha1/ClusterRole":
		var res rbacv1alpha1.ClusterRole
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1alpha1:ClusterRole", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1alpha1/ClusterRoleBinding":
		var res rbacv1alpha1.ClusterRoleBinding
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1alpha1:ClusterRoleBinding", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1alpha1/Role":
		var res rbacv1alpha1.Role
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1alpha1:Role", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1alpha1/RoleBinding":
		var res rbacv1alpha1.RoleBinding
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1alpha1:RoleBinding", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1beta1/ClusterRole":
		var res rbacv1beta1.ClusterRole
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1beta1:ClusterRole", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1beta1/ClusterRoleBinding":
		var res rbacv1beta1.ClusterRoleBinding
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1beta1:ClusterRoleBinding", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1beta1/Role":
		var res rbacv1beta1.Role
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1beta1:Role", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "rbac.authorization.k8s.io/v1beta1/RoleBinding":
		var res rbacv1beta1.RoleBinding
		err := ctx.RegisterResource("kubernetes:rbac.authorization.k8s.io/v1beta1:RoleBinding", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "scheduling.k8s.io/v1/PriorityClass":
		var res schedulingv1.PriorityClass
		err := ctx.RegisterResource("kubernetes:scheduling.k8s.io/v1:PriorityClass", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "scheduling.k8s.io/v1alpha1/PriorityClass":
		var res schedulingv1alpha1.PriorityClass
		err := ctx.RegisterResource("kubernetes:scheduling.k8s.io/v1alpha1:PriorityClass", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "scheduling.k8s.io/v1beta1/PriorityClass":
		var res schedulingv1beta1.PriorityClass
		err := ctx.RegisterResource("kubernetes:scheduling.k8s.io/v1beta1:PriorityClass", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "settings.k8s.io/v1alpha1/PodPreset":
		var res settingsv1alpha1.PodPreset
		err := ctx.RegisterResource("kubernetes:settings.k8s.io/v1alpha1:PodPreset", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "storage.k8s.io/v1/CSIDriver":
		var res storagev1.CSIDriver
		err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1:CSIDriver", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "storage.k8s.io/v1/CSINode":
		var res storagev1.CSINode
		err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1:CSINode", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "storage.k8s.io/v1/StorageClass":
		var res storagev1.StorageClass
		err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1:StorageClass", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "storage.k8s.io/v1/VolumeAttachment":
		var res storagev1.VolumeAttachment
		err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1:VolumeAttachment", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "storage.k8s.io/v1alpha1/VolumeAttachment":
		var res storagev1alpha1.VolumeAttachment
		err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1alpha1:VolumeAttachment", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "storage.k8s.io/v1beta1/CSIDriver":
		var res storagev1beta1.CSIDriver
		err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1beta1:CSIDriver", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "storage.k8s.io/v1beta1/CSINode":
		var res storagev1beta1.CSINode
		err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1beta1:CSINode", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "storage.k8s.io/v1beta1/StorageClass":
		var res storagev1beta1.StorageClass
		err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1beta1:StorageClass", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	case "storage.k8s.io/v1beta1/VolumeAttachment":
		var res storagev1beta1.VolumeAttachment
		err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1beta1:VolumeAttachment", metaName, UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		return []resourceTuple{{Name: key, Resource: &res}}, nil
	default:
		return nil, errors.Errorf("unrecognized kind %s %+v", fullKind, obj)
	}
}
