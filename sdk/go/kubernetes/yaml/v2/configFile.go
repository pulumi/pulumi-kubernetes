// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v2

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ConfigFile creates a set of Kubernetes resources from a Kubernetes YAML file.
//
// ## Dependency ordering
// Sometimes resources must be applied in a specific order. For example, a namespace resource must be
// created before any namespaced resources, or a Custom Resource Definition (CRD) must be pre-installed.
//
// Pulumi uses heuristics to determine which order to apply and delete objects within the ConfigFile.  Pulumi also
// waits for each object to be fully reconciled, unless `skipAwait` is enabled.
//
// ### Explicit Dependency Ordering
// Pulumi supports the `config.kubernetes.io/depends-on` annotation to declare an explicit dependency on a given resource.
// The annotation accepts a list of resource references, delimited by commas.
//
// Note that references to resources outside the ConfigFile aren't supported.
//
// **Resource reference**
//
// A resource reference is a string that uniquely identifies a resource.
//
// It consists of the group, kind, name, and optionally the namespace, delimited by forward slashes.
//
// | Resource Scope   | Format                                         |
// | :--------------- | :--------------------------------------------- |
// | namespace-scoped | `<group>/namespaces/<namespace>/<kind>/<name>` |
// | cluster-scoped   | `<group>/<kind>/<name>`                        |
//
// For resources in the “core” group, the empty string is used instead (for example: `/namespaces/test/Pod/pod-a`).
//
// ### Ordering across ConfigFiles
// The `dependsOn` resource option creates a list of explicit dependencies between Pulumi resources.
// Use it on another resource to make it dependent on the ConfigFile and to wait for the resources within
// the group to be deployed.
//
// A best practice is to deploy each application using its own ConfigFile, especially when that application
// installs custom resource definitions.
//
// ## Example Usage
// ### Local File
// ```go
// package main
//
// import (
//
//	yamlv2 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/yaml/v2"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//	    pulumi.Run(func(ctx *pulumi.Context) error {
//	        _, err := yamlv2.NewConfigFile(ctx, "example",
//	            &yamlv2.ConfigFileArgs{
//	                File: "foo.yaml",
//	            },
//	        )
//	        if err != nil {
//	            return err
//	        }
//
//	        return nil
//	    })
//	}
//
// ```
// {% /examples %}}
type ConfigFile struct {
	pulumi.ResourceState

	// Resources created by the ConfigFile.
	Resources pulumi.ArrayOutput `pulumi:"resources"`
}

// NewConfigFile registers a new resource with the given unique name, arguments, and options.
func NewConfigFile(ctx *pulumi.Context,
	name string, args *ConfigFileArgs, opts ...pulumi.ResourceOption) (*ConfigFile, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.File == nil {
		return nil, errors.New("invalid value for required argument 'File'")
	}
	opts = utilities.PkgResourceDefaultOpts(opts)
	var resource ConfigFile
	err := ctx.RegisterRemoteComponentResource("kubernetes:yaml/v2:ConfigFile", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type configFileArgs struct {
	// Path or URL to a Kubernetes manifest file. File must exist.
	File string `pulumi:"file"`
	// A prefix for the auto-generated resource names. Defaults to the name of the ConfigFile. Example: A resource created with resourcePrefix="foo" would produce a resource named "foo-resourceName".
	ResourcePrefix *string `pulumi:"resourcePrefix"`
	// Indicates that child resources should skip the await logic.
	SkipAwait *bool `pulumi:"skipAwait"`
}

// The set of arguments for constructing a ConfigFile resource.
type ConfigFileArgs struct {
	// Path or URL to a Kubernetes manifest file. File must exist.
	File pulumi.StringInput
	// A prefix for the auto-generated resource names. Defaults to the name of the ConfigFile. Example: A resource created with resourcePrefix="foo" would produce a resource named "foo-resourceName".
	ResourcePrefix pulumi.StringPtrInput
	// Indicates that child resources should skip the await logic.
	SkipAwait pulumi.BoolPtrInput
}

func (ConfigFileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*configFileArgs)(nil)).Elem()
}

type ConfigFileInput interface {
	pulumi.Input

	ToConfigFileOutput() ConfigFileOutput
	ToConfigFileOutputWithContext(ctx context.Context) ConfigFileOutput
}

func (*ConfigFile) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigFile)(nil)).Elem()
}

func (i *ConfigFile) ToConfigFileOutput() ConfigFileOutput {
	return i.ToConfigFileOutputWithContext(context.Background())
}

func (i *ConfigFile) ToConfigFileOutputWithContext(ctx context.Context) ConfigFileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigFileOutput)
}

// ConfigFileArrayInput is an input type that accepts ConfigFileArray and ConfigFileArrayOutput values.
// You can construct a concrete instance of `ConfigFileArrayInput` via:
//
//	ConfigFileArray{ ConfigFileArgs{...} }
type ConfigFileArrayInput interface {
	pulumi.Input

	ToConfigFileArrayOutput() ConfigFileArrayOutput
	ToConfigFileArrayOutputWithContext(context.Context) ConfigFileArrayOutput
}

type ConfigFileArray []ConfigFileInput

func (ConfigFileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ConfigFile)(nil)).Elem()
}

func (i ConfigFileArray) ToConfigFileArrayOutput() ConfigFileArrayOutput {
	return i.ToConfigFileArrayOutputWithContext(context.Background())
}

func (i ConfigFileArray) ToConfigFileArrayOutputWithContext(ctx context.Context) ConfigFileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigFileArrayOutput)
}

// ConfigFileMapInput is an input type that accepts ConfigFileMap and ConfigFileMapOutput values.
// You can construct a concrete instance of `ConfigFileMapInput` via:
//
//	ConfigFileMap{ "key": ConfigFileArgs{...} }
type ConfigFileMapInput interface {
	pulumi.Input

	ToConfigFileMapOutput() ConfigFileMapOutput
	ToConfigFileMapOutputWithContext(context.Context) ConfigFileMapOutput
}

type ConfigFileMap map[string]ConfigFileInput

func (ConfigFileMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ConfigFile)(nil)).Elem()
}

func (i ConfigFileMap) ToConfigFileMapOutput() ConfigFileMapOutput {
	return i.ToConfigFileMapOutputWithContext(context.Background())
}

func (i ConfigFileMap) ToConfigFileMapOutputWithContext(ctx context.Context) ConfigFileMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigFileMapOutput)
}

type ConfigFileOutput struct{ *pulumi.OutputState }

func (ConfigFileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigFile)(nil)).Elem()
}

func (o ConfigFileOutput) ToConfigFileOutput() ConfigFileOutput {
	return o
}

func (o ConfigFileOutput) ToConfigFileOutputWithContext(ctx context.Context) ConfigFileOutput {
	return o
}

// Resources created by the ConfigFile.
func (o ConfigFileOutput) Resources() pulumi.ArrayOutput {
	return o.ApplyT(func(v *ConfigFile) pulumi.ArrayOutput { return v.Resources }).(pulumi.ArrayOutput)
}

type ConfigFileArrayOutput struct{ *pulumi.OutputState }

func (ConfigFileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ConfigFile)(nil)).Elem()
}

func (o ConfigFileArrayOutput) ToConfigFileArrayOutput() ConfigFileArrayOutput {
	return o
}

func (o ConfigFileArrayOutput) ToConfigFileArrayOutputWithContext(ctx context.Context) ConfigFileArrayOutput {
	return o
}

func (o ConfigFileArrayOutput) Index(i pulumi.IntInput) ConfigFileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ConfigFile {
		return vs[0].([]*ConfigFile)[vs[1].(int)]
	}).(ConfigFileOutput)
}

type ConfigFileMapOutput struct{ *pulumi.OutputState }

func (ConfigFileMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ConfigFile)(nil)).Elem()
}

func (o ConfigFileMapOutput) ToConfigFileMapOutput() ConfigFileMapOutput {
	return o
}

func (o ConfigFileMapOutput) ToConfigFileMapOutputWithContext(ctx context.Context) ConfigFileMapOutput {
	return o
}

func (o ConfigFileMapOutput) MapIndex(k pulumi.StringInput) ConfigFileOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ConfigFile {
		return vs[0].(map[string]*ConfigFile)[vs[1].(string)]
	}).(ConfigFileOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConfigFileInput)(nil)).Elem(), &ConfigFile{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConfigFileArrayInput)(nil)).Elem(), ConfigFileArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConfigFileMapInput)(nil)).Elem(), ConfigFileMap{})
	pulumi.RegisterOutputType(ConfigFileOutput{})
	pulumi.RegisterOutputType(ConfigFileArrayOutput{})
	pulumi.RegisterOutputType(ConfigFileMapOutput{})
}
