// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/core/v1"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.
type AllocatedDeviceStatus struct {
	// Conditions contains the latest observation of the device's state. If the device has been configured according to the class and claim config references, the `Ready` condition should be True.
	//
	// Must not contain more than 8 entries.
	Conditions []metav1.Condition `pulumi:"conditions"`
	// Data contains arbitrary driver-specific data.
	//
	// The length of the raw data must be smaller or equal to 10 Ki.
	Data interface{} `pulumi:"data"`
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device string `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver string `pulumi:"driver"`
	// NetworkData contains network-related information specific to the device.
	NetworkData *NetworkDeviceData `pulumi:"networkData"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool string `pulumi:"pool"`
}

// AllocatedDeviceStatusInput is an input type that accepts AllocatedDeviceStatusArgs and AllocatedDeviceStatusOutput values.
// You can construct a concrete instance of `AllocatedDeviceStatusInput` via:
//
//	AllocatedDeviceStatusArgs{...}
type AllocatedDeviceStatusInput interface {
	pulumi.Input

	ToAllocatedDeviceStatusOutput() AllocatedDeviceStatusOutput
	ToAllocatedDeviceStatusOutputWithContext(context.Context) AllocatedDeviceStatusOutput
}

// AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.
type AllocatedDeviceStatusArgs struct {
	// Conditions contains the latest observation of the device's state. If the device has been configured according to the class and claim config references, the `Ready` condition should be True.
	//
	// Must not contain more than 8 entries.
	Conditions metav1.ConditionArrayInput `pulumi:"conditions"`
	// Data contains arbitrary driver-specific data.
	//
	// The length of the raw data must be smaller or equal to 10 Ki.
	Data pulumi.Input `pulumi:"data"`
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device pulumi.StringInput `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringInput `pulumi:"driver"`
	// NetworkData contains network-related information specific to the device.
	NetworkData NetworkDeviceDataPtrInput `pulumi:"networkData"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool pulumi.StringInput `pulumi:"pool"`
}

func (AllocatedDeviceStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocatedDeviceStatus)(nil)).Elem()
}

func (i AllocatedDeviceStatusArgs) ToAllocatedDeviceStatusOutput() AllocatedDeviceStatusOutput {
	return i.ToAllocatedDeviceStatusOutputWithContext(context.Background())
}

func (i AllocatedDeviceStatusArgs) ToAllocatedDeviceStatusOutputWithContext(ctx context.Context) AllocatedDeviceStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocatedDeviceStatusOutput)
}

// AllocatedDeviceStatusArrayInput is an input type that accepts AllocatedDeviceStatusArray and AllocatedDeviceStatusArrayOutput values.
// You can construct a concrete instance of `AllocatedDeviceStatusArrayInput` via:
//
//	AllocatedDeviceStatusArray{ AllocatedDeviceStatusArgs{...} }
type AllocatedDeviceStatusArrayInput interface {
	pulumi.Input

	ToAllocatedDeviceStatusArrayOutput() AllocatedDeviceStatusArrayOutput
	ToAllocatedDeviceStatusArrayOutputWithContext(context.Context) AllocatedDeviceStatusArrayOutput
}

type AllocatedDeviceStatusArray []AllocatedDeviceStatusInput

func (AllocatedDeviceStatusArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AllocatedDeviceStatus)(nil)).Elem()
}

func (i AllocatedDeviceStatusArray) ToAllocatedDeviceStatusArrayOutput() AllocatedDeviceStatusArrayOutput {
	return i.ToAllocatedDeviceStatusArrayOutputWithContext(context.Background())
}

func (i AllocatedDeviceStatusArray) ToAllocatedDeviceStatusArrayOutputWithContext(ctx context.Context) AllocatedDeviceStatusArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocatedDeviceStatusArrayOutput)
}

// AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.
type AllocatedDeviceStatusOutput struct{ *pulumi.OutputState }

func (AllocatedDeviceStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocatedDeviceStatus)(nil)).Elem()
}

func (o AllocatedDeviceStatusOutput) ToAllocatedDeviceStatusOutput() AllocatedDeviceStatusOutput {
	return o
}

func (o AllocatedDeviceStatusOutput) ToAllocatedDeviceStatusOutputWithContext(ctx context.Context) AllocatedDeviceStatusOutput {
	return o
}

// Conditions contains the latest observation of the device's state. If the device has been configured according to the class and claim config references, the `Ready` condition should be True.
//
// Must not contain more than 8 entries.
func (o AllocatedDeviceStatusOutput) Conditions() metav1.ConditionArrayOutput {
	return o.ApplyT(func(v AllocatedDeviceStatus) []metav1.Condition { return v.Conditions }).(metav1.ConditionArrayOutput)
}

// Data contains arbitrary driver-specific data.
//
// The length of the raw data must be smaller or equal to 10 Ki.
func (o AllocatedDeviceStatusOutput) Data() pulumi.AnyOutput {
	return o.ApplyT(func(v AllocatedDeviceStatus) interface{} { return v.Data }).(pulumi.AnyOutput)
}

// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
func (o AllocatedDeviceStatusOutput) Device() pulumi.StringOutput {
	return o.ApplyT(func(v AllocatedDeviceStatus) string { return v.Device }).(pulumi.StringOutput)
}

// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o AllocatedDeviceStatusOutput) Driver() pulumi.StringOutput {
	return o.ApplyT(func(v AllocatedDeviceStatus) string { return v.Driver }).(pulumi.StringOutput)
}

// NetworkData contains network-related information specific to the device.
func (o AllocatedDeviceStatusOutput) NetworkData() NetworkDeviceDataPtrOutput {
	return o.ApplyT(func(v AllocatedDeviceStatus) *NetworkDeviceData { return v.NetworkData }).(NetworkDeviceDataPtrOutput)
}

// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
//
// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
func (o AllocatedDeviceStatusOutput) Pool() pulumi.StringOutput {
	return o.ApplyT(func(v AllocatedDeviceStatus) string { return v.Pool }).(pulumi.StringOutput)
}

type AllocatedDeviceStatusArrayOutput struct{ *pulumi.OutputState }

func (AllocatedDeviceStatusArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AllocatedDeviceStatus)(nil)).Elem()
}

func (o AllocatedDeviceStatusArrayOutput) ToAllocatedDeviceStatusArrayOutput() AllocatedDeviceStatusArrayOutput {
	return o
}

func (o AllocatedDeviceStatusArrayOutput) ToAllocatedDeviceStatusArrayOutputWithContext(ctx context.Context) AllocatedDeviceStatusArrayOutput {
	return o
}

func (o AllocatedDeviceStatusArrayOutput) Index(i pulumi.IntInput) AllocatedDeviceStatusOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AllocatedDeviceStatus {
		return vs[0].([]AllocatedDeviceStatus)[vs[1].(int)]
	}).(AllocatedDeviceStatusOutput)
}

// AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.
type AllocatedDeviceStatusPatch struct {
	// Conditions contains the latest observation of the device's state. If the device has been configured according to the class and claim config references, the `Ready` condition should be True.
	//
	// Must not contain more than 8 entries.
	Conditions []metav1.ConditionPatch `pulumi:"conditions"`
	// Data contains arbitrary driver-specific data.
	//
	// The length of the raw data must be smaller or equal to 10 Ki.
	Data interface{} `pulumi:"data"`
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device *string `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver *string `pulumi:"driver"`
	// NetworkData contains network-related information specific to the device.
	NetworkData *NetworkDeviceDataPatch `pulumi:"networkData"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool *string `pulumi:"pool"`
}

// AllocatedDeviceStatusPatchInput is an input type that accepts AllocatedDeviceStatusPatchArgs and AllocatedDeviceStatusPatchOutput values.
// You can construct a concrete instance of `AllocatedDeviceStatusPatchInput` via:
//
//	AllocatedDeviceStatusPatchArgs{...}
type AllocatedDeviceStatusPatchInput interface {
	pulumi.Input

	ToAllocatedDeviceStatusPatchOutput() AllocatedDeviceStatusPatchOutput
	ToAllocatedDeviceStatusPatchOutputWithContext(context.Context) AllocatedDeviceStatusPatchOutput
}

// AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.
type AllocatedDeviceStatusPatchArgs struct {
	// Conditions contains the latest observation of the device's state. If the device has been configured according to the class and claim config references, the `Ready` condition should be True.
	//
	// Must not contain more than 8 entries.
	Conditions metav1.ConditionPatchArrayInput `pulumi:"conditions"`
	// Data contains arbitrary driver-specific data.
	//
	// The length of the raw data must be smaller or equal to 10 Ki.
	Data pulumi.Input `pulumi:"data"`
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device pulumi.StringPtrInput `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringPtrInput `pulumi:"driver"`
	// NetworkData contains network-related information specific to the device.
	NetworkData NetworkDeviceDataPatchPtrInput `pulumi:"networkData"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool pulumi.StringPtrInput `pulumi:"pool"`
}

func (AllocatedDeviceStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocatedDeviceStatusPatch)(nil)).Elem()
}

func (i AllocatedDeviceStatusPatchArgs) ToAllocatedDeviceStatusPatchOutput() AllocatedDeviceStatusPatchOutput {
	return i.ToAllocatedDeviceStatusPatchOutputWithContext(context.Background())
}

func (i AllocatedDeviceStatusPatchArgs) ToAllocatedDeviceStatusPatchOutputWithContext(ctx context.Context) AllocatedDeviceStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocatedDeviceStatusPatchOutput)
}

// AllocatedDeviceStatusPatchArrayInput is an input type that accepts AllocatedDeviceStatusPatchArray and AllocatedDeviceStatusPatchArrayOutput values.
// You can construct a concrete instance of `AllocatedDeviceStatusPatchArrayInput` via:
//
//	AllocatedDeviceStatusPatchArray{ AllocatedDeviceStatusPatchArgs{...} }
type AllocatedDeviceStatusPatchArrayInput interface {
	pulumi.Input

	ToAllocatedDeviceStatusPatchArrayOutput() AllocatedDeviceStatusPatchArrayOutput
	ToAllocatedDeviceStatusPatchArrayOutputWithContext(context.Context) AllocatedDeviceStatusPatchArrayOutput
}

type AllocatedDeviceStatusPatchArray []AllocatedDeviceStatusPatchInput

func (AllocatedDeviceStatusPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AllocatedDeviceStatusPatch)(nil)).Elem()
}

func (i AllocatedDeviceStatusPatchArray) ToAllocatedDeviceStatusPatchArrayOutput() AllocatedDeviceStatusPatchArrayOutput {
	return i.ToAllocatedDeviceStatusPatchArrayOutputWithContext(context.Background())
}

func (i AllocatedDeviceStatusPatchArray) ToAllocatedDeviceStatusPatchArrayOutputWithContext(ctx context.Context) AllocatedDeviceStatusPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocatedDeviceStatusPatchArrayOutput)
}

// AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.
type AllocatedDeviceStatusPatchOutput struct{ *pulumi.OutputState }

func (AllocatedDeviceStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocatedDeviceStatusPatch)(nil)).Elem()
}

func (o AllocatedDeviceStatusPatchOutput) ToAllocatedDeviceStatusPatchOutput() AllocatedDeviceStatusPatchOutput {
	return o
}

func (o AllocatedDeviceStatusPatchOutput) ToAllocatedDeviceStatusPatchOutputWithContext(ctx context.Context) AllocatedDeviceStatusPatchOutput {
	return o
}

// Conditions contains the latest observation of the device's state. If the device has been configured according to the class and claim config references, the `Ready` condition should be True.
//
// Must not contain more than 8 entries.
func (o AllocatedDeviceStatusPatchOutput) Conditions() metav1.ConditionPatchArrayOutput {
	return o.ApplyT(func(v AllocatedDeviceStatusPatch) []metav1.ConditionPatch { return v.Conditions }).(metav1.ConditionPatchArrayOutput)
}

// Data contains arbitrary driver-specific data.
//
// The length of the raw data must be smaller or equal to 10 Ki.
func (o AllocatedDeviceStatusPatchOutput) Data() pulumi.AnyOutput {
	return o.ApplyT(func(v AllocatedDeviceStatusPatch) interface{} { return v.Data }).(pulumi.AnyOutput)
}

// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
func (o AllocatedDeviceStatusPatchOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AllocatedDeviceStatusPatch) *string { return v.Device }).(pulumi.StringPtrOutput)
}

// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o AllocatedDeviceStatusPatchOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AllocatedDeviceStatusPatch) *string { return v.Driver }).(pulumi.StringPtrOutput)
}

// NetworkData contains network-related information specific to the device.
func (o AllocatedDeviceStatusPatchOutput) NetworkData() NetworkDeviceDataPatchPtrOutput {
	return o.ApplyT(func(v AllocatedDeviceStatusPatch) *NetworkDeviceDataPatch { return v.NetworkData }).(NetworkDeviceDataPatchPtrOutput)
}

// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
//
// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
func (o AllocatedDeviceStatusPatchOutput) Pool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AllocatedDeviceStatusPatch) *string { return v.Pool }).(pulumi.StringPtrOutput)
}

type AllocatedDeviceStatusPatchArrayOutput struct{ *pulumi.OutputState }

func (AllocatedDeviceStatusPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AllocatedDeviceStatusPatch)(nil)).Elem()
}

func (o AllocatedDeviceStatusPatchArrayOutput) ToAllocatedDeviceStatusPatchArrayOutput() AllocatedDeviceStatusPatchArrayOutput {
	return o
}

func (o AllocatedDeviceStatusPatchArrayOutput) ToAllocatedDeviceStatusPatchArrayOutputWithContext(ctx context.Context) AllocatedDeviceStatusPatchArrayOutput {
	return o
}

func (o AllocatedDeviceStatusPatchArrayOutput) Index(i pulumi.IntInput) AllocatedDeviceStatusPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AllocatedDeviceStatusPatch {
		return vs[0].([]AllocatedDeviceStatusPatch)[vs[1].(int)]
	}).(AllocatedDeviceStatusPatchOutput)
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResult struct {
	// Devices is the result of allocating devices.
	Devices *DeviceAllocationResult `pulumi:"devices"`
	// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
	NodeSelector *corev1.NodeSelector `pulumi:"nodeSelector"`
}

// AllocationResultInput is an input type that accepts AllocationResultArgs and AllocationResultOutput values.
// You can construct a concrete instance of `AllocationResultInput` via:
//
//	AllocationResultArgs{...}
type AllocationResultInput interface {
	pulumi.Input

	ToAllocationResultOutput() AllocationResultOutput
	ToAllocationResultOutputWithContext(context.Context) AllocationResultOutput
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultArgs struct {
	// Devices is the result of allocating devices.
	Devices DeviceAllocationResultPtrInput `pulumi:"devices"`
	// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
	NodeSelector corev1.NodeSelectorPtrInput `pulumi:"nodeSelector"`
}

func (AllocationResultArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationResult)(nil)).Elem()
}

func (i AllocationResultArgs) ToAllocationResultOutput() AllocationResultOutput {
	return i.ToAllocationResultOutputWithContext(context.Background())
}

func (i AllocationResultArgs) ToAllocationResultOutputWithContext(ctx context.Context) AllocationResultOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultOutput)
}

func (i AllocationResultArgs) ToAllocationResultPtrOutput() AllocationResultPtrOutput {
	return i.ToAllocationResultPtrOutputWithContext(context.Background())
}

func (i AllocationResultArgs) ToAllocationResultPtrOutputWithContext(ctx context.Context) AllocationResultPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultOutput).ToAllocationResultPtrOutputWithContext(ctx)
}

// AllocationResultPtrInput is an input type that accepts AllocationResultArgs, AllocationResultPtr and AllocationResultPtrOutput values.
// You can construct a concrete instance of `AllocationResultPtrInput` via:
//
//	        AllocationResultArgs{...}
//
//	or:
//
//	        nil
type AllocationResultPtrInput interface {
	pulumi.Input

	ToAllocationResultPtrOutput() AllocationResultPtrOutput
	ToAllocationResultPtrOutputWithContext(context.Context) AllocationResultPtrOutput
}

type allocationResultPtrType AllocationResultArgs

func AllocationResultPtr(v *AllocationResultArgs) AllocationResultPtrInput {
	return (*allocationResultPtrType)(v)
}

func (*allocationResultPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationResult)(nil)).Elem()
}

func (i *allocationResultPtrType) ToAllocationResultPtrOutput() AllocationResultPtrOutput {
	return i.ToAllocationResultPtrOutputWithContext(context.Background())
}

func (i *allocationResultPtrType) ToAllocationResultPtrOutputWithContext(ctx context.Context) AllocationResultPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultPtrOutput)
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultOutput struct{ *pulumi.OutputState }

func (AllocationResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationResult)(nil)).Elem()
}

func (o AllocationResultOutput) ToAllocationResultOutput() AllocationResultOutput {
	return o
}

func (o AllocationResultOutput) ToAllocationResultOutputWithContext(ctx context.Context) AllocationResultOutput {
	return o
}

func (o AllocationResultOutput) ToAllocationResultPtrOutput() AllocationResultPtrOutput {
	return o.ToAllocationResultPtrOutputWithContext(context.Background())
}

func (o AllocationResultOutput) ToAllocationResultPtrOutputWithContext(ctx context.Context) AllocationResultPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AllocationResult) *AllocationResult {
		return &v
	}).(AllocationResultPtrOutput)
}

// Devices is the result of allocating devices.
func (o AllocationResultOutput) Devices() DeviceAllocationResultPtrOutput {
	return o.ApplyT(func(v AllocationResult) *DeviceAllocationResult { return v.Devices }).(DeviceAllocationResultPtrOutput)
}

// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
func (o AllocationResultOutput) NodeSelector() corev1.NodeSelectorPtrOutput {
	return o.ApplyT(func(v AllocationResult) *corev1.NodeSelector { return v.NodeSelector }).(corev1.NodeSelectorPtrOutput)
}

type AllocationResultPtrOutput struct{ *pulumi.OutputState }

func (AllocationResultPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationResult)(nil)).Elem()
}

func (o AllocationResultPtrOutput) ToAllocationResultPtrOutput() AllocationResultPtrOutput {
	return o
}

func (o AllocationResultPtrOutput) ToAllocationResultPtrOutputWithContext(ctx context.Context) AllocationResultPtrOutput {
	return o
}

func (o AllocationResultPtrOutput) Elem() AllocationResultOutput {
	return o.ApplyT(func(v *AllocationResult) AllocationResult {
		if v != nil {
			return *v
		}
		var ret AllocationResult
		return ret
	}).(AllocationResultOutput)
}

// Devices is the result of allocating devices.
func (o AllocationResultPtrOutput) Devices() DeviceAllocationResultPtrOutput {
	return o.ApplyT(func(v *AllocationResult) *DeviceAllocationResult {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(DeviceAllocationResultPtrOutput)
}

// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
func (o AllocationResultPtrOutput) NodeSelector() corev1.NodeSelectorPtrOutput {
	return o.ApplyT(func(v *AllocationResult) *corev1.NodeSelector {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(corev1.NodeSelectorPtrOutput)
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultPatch struct {
	// Devices is the result of allocating devices.
	Devices *DeviceAllocationResultPatch `pulumi:"devices"`
	// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
	NodeSelector *corev1.NodeSelectorPatch `pulumi:"nodeSelector"`
}

// AllocationResultPatchInput is an input type that accepts AllocationResultPatchArgs and AllocationResultPatchOutput values.
// You can construct a concrete instance of `AllocationResultPatchInput` via:
//
//	AllocationResultPatchArgs{...}
type AllocationResultPatchInput interface {
	pulumi.Input

	ToAllocationResultPatchOutput() AllocationResultPatchOutput
	ToAllocationResultPatchOutputWithContext(context.Context) AllocationResultPatchOutput
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultPatchArgs struct {
	// Devices is the result of allocating devices.
	Devices DeviceAllocationResultPatchPtrInput `pulumi:"devices"`
	// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
	NodeSelector corev1.NodeSelectorPatchPtrInput `pulumi:"nodeSelector"`
}

func (AllocationResultPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationResultPatch)(nil)).Elem()
}

func (i AllocationResultPatchArgs) ToAllocationResultPatchOutput() AllocationResultPatchOutput {
	return i.ToAllocationResultPatchOutputWithContext(context.Background())
}

func (i AllocationResultPatchArgs) ToAllocationResultPatchOutputWithContext(ctx context.Context) AllocationResultPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultPatchOutput)
}

func (i AllocationResultPatchArgs) ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput {
	return i.ToAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (i AllocationResultPatchArgs) ToAllocationResultPatchPtrOutputWithContext(ctx context.Context) AllocationResultPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultPatchOutput).ToAllocationResultPatchPtrOutputWithContext(ctx)
}

// AllocationResultPatchPtrInput is an input type that accepts AllocationResultPatchArgs, AllocationResultPatchPtr and AllocationResultPatchPtrOutput values.
// You can construct a concrete instance of `AllocationResultPatchPtrInput` via:
//
//	        AllocationResultPatchArgs{...}
//
//	or:
//
//	        nil
type AllocationResultPatchPtrInput interface {
	pulumi.Input

	ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput
	ToAllocationResultPatchPtrOutputWithContext(context.Context) AllocationResultPatchPtrOutput
}

type allocationResultPatchPtrType AllocationResultPatchArgs

func AllocationResultPatchPtr(v *AllocationResultPatchArgs) AllocationResultPatchPtrInput {
	return (*allocationResultPatchPtrType)(v)
}

func (*allocationResultPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationResultPatch)(nil)).Elem()
}

func (i *allocationResultPatchPtrType) ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput {
	return i.ToAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (i *allocationResultPatchPtrType) ToAllocationResultPatchPtrOutputWithContext(ctx context.Context) AllocationResultPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultPatchPtrOutput)
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultPatchOutput struct{ *pulumi.OutputState }

func (AllocationResultPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationResultPatch)(nil)).Elem()
}

func (o AllocationResultPatchOutput) ToAllocationResultPatchOutput() AllocationResultPatchOutput {
	return o
}

func (o AllocationResultPatchOutput) ToAllocationResultPatchOutputWithContext(ctx context.Context) AllocationResultPatchOutput {
	return o
}

func (o AllocationResultPatchOutput) ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput {
	return o.ToAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (o AllocationResultPatchOutput) ToAllocationResultPatchPtrOutputWithContext(ctx context.Context) AllocationResultPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AllocationResultPatch) *AllocationResultPatch {
		return &v
	}).(AllocationResultPatchPtrOutput)
}

// Devices is the result of allocating devices.
func (o AllocationResultPatchOutput) Devices() DeviceAllocationResultPatchPtrOutput {
	return o.ApplyT(func(v AllocationResultPatch) *DeviceAllocationResultPatch { return v.Devices }).(DeviceAllocationResultPatchPtrOutput)
}

// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
func (o AllocationResultPatchOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v AllocationResultPatch) *corev1.NodeSelectorPatch { return v.NodeSelector }).(corev1.NodeSelectorPatchPtrOutput)
}

type AllocationResultPatchPtrOutput struct{ *pulumi.OutputState }

func (AllocationResultPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationResultPatch)(nil)).Elem()
}

func (o AllocationResultPatchPtrOutput) ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput {
	return o
}

func (o AllocationResultPatchPtrOutput) ToAllocationResultPatchPtrOutputWithContext(ctx context.Context) AllocationResultPatchPtrOutput {
	return o
}

func (o AllocationResultPatchPtrOutput) Elem() AllocationResultPatchOutput {
	return o.ApplyT(func(v *AllocationResultPatch) AllocationResultPatch {
		if v != nil {
			return *v
		}
		var ret AllocationResultPatch
		return ret
	}).(AllocationResultPatchOutput)
}

// Devices is the result of allocating devices.
func (o AllocationResultPatchPtrOutput) Devices() DeviceAllocationResultPatchPtrOutput {
	return o.ApplyT(func(v *AllocationResultPatch) *DeviceAllocationResultPatch {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(DeviceAllocationResultPatchPtrOutput)
}

// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
func (o AllocationResultPatchPtrOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v *AllocationResultPatch) *corev1.NodeSelectorPatch {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(corev1.NodeSelectorPatchPtrOutput)
}

// BasicDevice defines one device instance.
type BasicDevice struct {
	// AllNodes indicates that all nodes have access to the device.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	AllNodes *bool `pulumi:"allNodes"`
	// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Attributes map[string]DeviceAttribute `pulumi:"attributes"`
	// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Capacity map[string]DeviceCapacity `pulumi:"capacity"`
	// ConsumesCounters defines a list of references to sharedCounters and the set of counters that the device will consume from those counter sets.
	//
	// There can only be a single entry per counterSet.
	//
	// The total number of device counter consumption entries must be <= 32. In addition, the total number in the entire ResourceSlice must be <= 1024 (for example, 64 devices with 16 counters each).
	ConsumesCounters []DeviceCounterConsumption `pulumi:"consumesCounters"`
	// NodeName identifies the node where the device is available.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	NodeName *string `pulumi:"nodeName"`
	// NodeSelector defines the nodes where the device is available.
	//
	// Must use exactly one term.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	NodeSelector *corev1.NodeSelector `pulumi:"nodeSelector"`
	// If specified, these are the driver-defined taints.
	//
	// The maximum number of taints is 4.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Taints []DeviceTaint `pulumi:"taints"`
}

// BasicDeviceInput is an input type that accepts BasicDeviceArgs and BasicDeviceOutput values.
// You can construct a concrete instance of `BasicDeviceInput` via:
//
//	BasicDeviceArgs{...}
type BasicDeviceInput interface {
	pulumi.Input

	ToBasicDeviceOutput() BasicDeviceOutput
	ToBasicDeviceOutputWithContext(context.Context) BasicDeviceOutput
}

// BasicDevice defines one device instance.
type BasicDeviceArgs struct {
	// AllNodes indicates that all nodes have access to the device.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	AllNodes pulumi.BoolPtrInput `pulumi:"allNodes"`
	// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Attributes DeviceAttributeMapInput `pulumi:"attributes"`
	// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Capacity DeviceCapacityMapInput `pulumi:"capacity"`
	// ConsumesCounters defines a list of references to sharedCounters and the set of counters that the device will consume from those counter sets.
	//
	// There can only be a single entry per counterSet.
	//
	// The total number of device counter consumption entries must be <= 32. In addition, the total number in the entire ResourceSlice must be <= 1024 (for example, 64 devices with 16 counters each).
	ConsumesCounters DeviceCounterConsumptionArrayInput `pulumi:"consumesCounters"`
	// NodeName identifies the node where the device is available.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	NodeName pulumi.StringPtrInput `pulumi:"nodeName"`
	// NodeSelector defines the nodes where the device is available.
	//
	// Must use exactly one term.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	NodeSelector corev1.NodeSelectorPtrInput `pulumi:"nodeSelector"`
	// If specified, these are the driver-defined taints.
	//
	// The maximum number of taints is 4.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Taints DeviceTaintArrayInput `pulumi:"taints"`
}

func (BasicDeviceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicDevice)(nil)).Elem()
}

func (i BasicDeviceArgs) ToBasicDeviceOutput() BasicDeviceOutput {
	return i.ToBasicDeviceOutputWithContext(context.Background())
}

func (i BasicDeviceArgs) ToBasicDeviceOutputWithContext(ctx context.Context) BasicDeviceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDeviceOutput)
}

func (i BasicDeviceArgs) ToBasicDevicePtrOutput() BasicDevicePtrOutput {
	return i.ToBasicDevicePtrOutputWithContext(context.Background())
}

func (i BasicDeviceArgs) ToBasicDevicePtrOutputWithContext(ctx context.Context) BasicDevicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDeviceOutput).ToBasicDevicePtrOutputWithContext(ctx)
}

// BasicDevicePtrInput is an input type that accepts BasicDeviceArgs, BasicDevicePtr and BasicDevicePtrOutput values.
// You can construct a concrete instance of `BasicDevicePtrInput` via:
//
//	        BasicDeviceArgs{...}
//
//	or:
//
//	        nil
type BasicDevicePtrInput interface {
	pulumi.Input

	ToBasicDevicePtrOutput() BasicDevicePtrOutput
	ToBasicDevicePtrOutputWithContext(context.Context) BasicDevicePtrOutput
}

type basicDevicePtrType BasicDeviceArgs

func BasicDevicePtr(v *BasicDeviceArgs) BasicDevicePtrInput {
	return (*basicDevicePtrType)(v)
}

func (*basicDevicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicDevice)(nil)).Elem()
}

func (i *basicDevicePtrType) ToBasicDevicePtrOutput() BasicDevicePtrOutput {
	return i.ToBasicDevicePtrOutputWithContext(context.Background())
}

func (i *basicDevicePtrType) ToBasicDevicePtrOutputWithContext(ctx context.Context) BasicDevicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDevicePtrOutput)
}

// BasicDevice defines one device instance.
type BasicDeviceOutput struct{ *pulumi.OutputState }

func (BasicDeviceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicDevice)(nil)).Elem()
}

func (o BasicDeviceOutput) ToBasicDeviceOutput() BasicDeviceOutput {
	return o
}

func (o BasicDeviceOutput) ToBasicDeviceOutputWithContext(ctx context.Context) BasicDeviceOutput {
	return o
}

func (o BasicDeviceOutput) ToBasicDevicePtrOutput() BasicDevicePtrOutput {
	return o.ToBasicDevicePtrOutputWithContext(context.Background())
}

func (o BasicDeviceOutput) ToBasicDevicePtrOutputWithContext(ctx context.Context) BasicDevicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicDevice) *BasicDevice {
		return &v
	}).(BasicDevicePtrOutput)
}

// AllNodes indicates that all nodes have access to the device.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDeviceOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v BasicDevice) *bool { return v.AllNodes }).(pulumi.BoolPtrOutput)
}

// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDeviceOutput) Attributes() DeviceAttributeMapOutput {
	return o.ApplyT(func(v BasicDevice) map[string]DeviceAttribute { return v.Attributes }).(DeviceAttributeMapOutput)
}

// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDeviceOutput) Capacity() DeviceCapacityMapOutput {
	return o.ApplyT(func(v BasicDevice) map[string]DeviceCapacity { return v.Capacity }).(DeviceCapacityMapOutput)
}

// ConsumesCounters defines a list of references to sharedCounters and the set of counters that the device will consume from those counter sets.
//
// There can only be a single entry per counterSet.
//
// The total number of device counter consumption entries must be <= 32. In addition, the total number in the entire ResourceSlice must be <= 1024 (for example, 64 devices with 16 counters each).
func (o BasicDeviceOutput) ConsumesCounters() DeviceCounterConsumptionArrayOutput {
	return o.ApplyT(func(v BasicDevice) []DeviceCounterConsumption { return v.ConsumesCounters }).(DeviceCounterConsumptionArrayOutput)
}

// NodeName identifies the node where the device is available.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDeviceOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BasicDevice) *string { return v.NodeName }).(pulumi.StringPtrOutput)
}

// NodeSelector defines the nodes where the device is available.
//
// Must use exactly one term.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDeviceOutput) NodeSelector() corev1.NodeSelectorPtrOutput {
	return o.ApplyT(func(v BasicDevice) *corev1.NodeSelector { return v.NodeSelector }).(corev1.NodeSelectorPtrOutput)
}

// If specified, these are the driver-defined taints.
//
// The maximum number of taints is 4.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o BasicDeviceOutput) Taints() DeviceTaintArrayOutput {
	return o.ApplyT(func(v BasicDevice) []DeviceTaint { return v.Taints }).(DeviceTaintArrayOutput)
}

type BasicDevicePtrOutput struct{ *pulumi.OutputState }

func (BasicDevicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicDevice)(nil)).Elem()
}

func (o BasicDevicePtrOutput) ToBasicDevicePtrOutput() BasicDevicePtrOutput {
	return o
}

func (o BasicDevicePtrOutput) ToBasicDevicePtrOutputWithContext(ctx context.Context) BasicDevicePtrOutput {
	return o
}

func (o BasicDevicePtrOutput) Elem() BasicDeviceOutput {
	return o.ApplyT(func(v *BasicDevice) BasicDevice {
		if v != nil {
			return *v
		}
		var ret BasicDevice
		return ret
	}).(BasicDeviceOutput)
}

// AllNodes indicates that all nodes have access to the device.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDevicePtrOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *BasicDevice) *bool {
		if v == nil {
			return nil
		}
		return v.AllNodes
	}).(pulumi.BoolPtrOutput)
}

// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePtrOutput) Attributes() DeviceAttributeMapOutput {
	return o.ApplyT(func(v *BasicDevice) map[string]DeviceAttribute {
		if v == nil {
			return nil
		}
		return v.Attributes
	}).(DeviceAttributeMapOutput)
}

// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePtrOutput) Capacity() DeviceCapacityMapOutput {
	return o.ApplyT(func(v *BasicDevice) map[string]DeviceCapacity {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(DeviceCapacityMapOutput)
}

// ConsumesCounters defines a list of references to sharedCounters and the set of counters that the device will consume from those counter sets.
//
// There can only be a single entry per counterSet.
//
// The total number of device counter consumption entries must be <= 32. In addition, the total number in the entire ResourceSlice must be <= 1024 (for example, 64 devices with 16 counters each).
func (o BasicDevicePtrOutput) ConsumesCounters() DeviceCounterConsumptionArrayOutput {
	return o.ApplyT(func(v *BasicDevice) []DeviceCounterConsumption {
		if v == nil {
			return nil
		}
		return v.ConsumesCounters
	}).(DeviceCounterConsumptionArrayOutput)
}

// NodeName identifies the node where the device is available.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDevicePtrOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicDevice) *string {
		if v == nil {
			return nil
		}
		return v.NodeName
	}).(pulumi.StringPtrOutput)
}

// NodeSelector defines the nodes where the device is available.
//
// Must use exactly one term.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDevicePtrOutput) NodeSelector() corev1.NodeSelectorPtrOutput {
	return o.ApplyT(func(v *BasicDevice) *corev1.NodeSelector {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(corev1.NodeSelectorPtrOutput)
}

// If specified, these are the driver-defined taints.
//
// The maximum number of taints is 4.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o BasicDevicePtrOutput) Taints() DeviceTaintArrayOutput {
	return o.ApplyT(func(v *BasicDevice) []DeviceTaint {
		if v == nil {
			return nil
		}
		return v.Taints
	}).(DeviceTaintArrayOutput)
}

// BasicDevice defines one device instance.
type BasicDevicePatch struct {
	// AllNodes indicates that all nodes have access to the device.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	AllNodes *bool `pulumi:"allNodes"`
	// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Attributes map[string]DeviceAttribute `pulumi:"attributes"`
	// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Capacity map[string]DeviceCapacity `pulumi:"capacity"`
	// ConsumesCounters defines a list of references to sharedCounters and the set of counters that the device will consume from those counter sets.
	//
	// There can only be a single entry per counterSet.
	//
	// The total number of device counter consumption entries must be <= 32. In addition, the total number in the entire ResourceSlice must be <= 1024 (for example, 64 devices with 16 counters each).
	ConsumesCounters []DeviceCounterConsumptionPatch `pulumi:"consumesCounters"`
	// NodeName identifies the node where the device is available.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	NodeName *string `pulumi:"nodeName"`
	// NodeSelector defines the nodes where the device is available.
	//
	// Must use exactly one term.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	NodeSelector *corev1.NodeSelectorPatch `pulumi:"nodeSelector"`
	// If specified, these are the driver-defined taints.
	//
	// The maximum number of taints is 4.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Taints []DeviceTaintPatch `pulumi:"taints"`
}

// BasicDevicePatchInput is an input type that accepts BasicDevicePatchArgs and BasicDevicePatchOutput values.
// You can construct a concrete instance of `BasicDevicePatchInput` via:
//
//	BasicDevicePatchArgs{...}
type BasicDevicePatchInput interface {
	pulumi.Input

	ToBasicDevicePatchOutput() BasicDevicePatchOutput
	ToBasicDevicePatchOutputWithContext(context.Context) BasicDevicePatchOutput
}

// BasicDevice defines one device instance.
type BasicDevicePatchArgs struct {
	// AllNodes indicates that all nodes have access to the device.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	AllNodes pulumi.BoolPtrInput `pulumi:"allNodes"`
	// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Attributes DeviceAttributeMapInput `pulumi:"attributes"`
	// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Capacity DeviceCapacityMapInput `pulumi:"capacity"`
	// ConsumesCounters defines a list of references to sharedCounters and the set of counters that the device will consume from those counter sets.
	//
	// There can only be a single entry per counterSet.
	//
	// The total number of device counter consumption entries must be <= 32. In addition, the total number in the entire ResourceSlice must be <= 1024 (for example, 64 devices with 16 counters each).
	ConsumesCounters DeviceCounterConsumptionPatchArrayInput `pulumi:"consumesCounters"`
	// NodeName identifies the node where the device is available.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	NodeName pulumi.StringPtrInput `pulumi:"nodeName"`
	// NodeSelector defines the nodes where the device is available.
	//
	// Must use exactly one term.
	//
	// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
	NodeSelector corev1.NodeSelectorPatchPtrInput `pulumi:"nodeSelector"`
	// If specified, these are the driver-defined taints.
	//
	// The maximum number of taints is 4.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Taints DeviceTaintPatchArrayInput `pulumi:"taints"`
}

func (BasicDevicePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicDevicePatch)(nil)).Elem()
}

func (i BasicDevicePatchArgs) ToBasicDevicePatchOutput() BasicDevicePatchOutput {
	return i.ToBasicDevicePatchOutputWithContext(context.Background())
}

func (i BasicDevicePatchArgs) ToBasicDevicePatchOutputWithContext(ctx context.Context) BasicDevicePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDevicePatchOutput)
}

func (i BasicDevicePatchArgs) ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput {
	return i.ToBasicDevicePatchPtrOutputWithContext(context.Background())
}

func (i BasicDevicePatchArgs) ToBasicDevicePatchPtrOutputWithContext(ctx context.Context) BasicDevicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDevicePatchOutput).ToBasicDevicePatchPtrOutputWithContext(ctx)
}

// BasicDevicePatchPtrInput is an input type that accepts BasicDevicePatchArgs, BasicDevicePatchPtr and BasicDevicePatchPtrOutput values.
// You can construct a concrete instance of `BasicDevicePatchPtrInput` via:
//
//	        BasicDevicePatchArgs{...}
//
//	or:
//
//	        nil
type BasicDevicePatchPtrInput interface {
	pulumi.Input

	ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput
	ToBasicDevicePatchPtrOutputWithContext(context.Context) BasicDevicePatchPtrOutput
}

type basicDevicePatchPtrType BasicDevicePatchArgs

func BasicDevicePatchPtr(v *BasicDevicePatchArgs) BasicDevicePatchPtrInput {
	return (*basicDevicePatchPtrType)(v)
}

func (*basicDevicePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicDevicePatch)(nil)).Elem()
}

func (i *basicDevicePatchPtrType) ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput {
	return i.ToBasicDevicePatchPtrOutputWithContext(context.Background())
}

func (i *basicDevicePatchPtrType) ToBasicDevicePatchPtrOutputWithContext(ctx context.Context) BasicDevicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDevicePatchPtrOutput)
}

// BasicDevice defines one device instance.
type BasicDevicePatchOutput struct{ *pulumi.OutputState }

func (BasicDevicePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicDevicePatch)(nil)).Elem()
}

func (o BasicDevicePatchOutput) ToBasicDevicePatchOutput() BasicDevicePatchOutput {
	return o
}

func (o BasicDevicePatchOutput) ToBasicDevicePatchOutputWithContext(ctx context.Context) BasicDevicePatchOutput {
	return o
}

func (o BasicDevicePatchOutput) ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput {
	return o.ToBasicDevicePatchPtrOutputWithContext(context.Background())
}

func (o BasicDevicePatchOutput) ToBasicDevicePatchPtrOutputWithContext(ctx context.Context) BasicDevicePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicDevicePatch) *BasicDevicePatch {
		return &v
	}).(BasicDevicePatchPtrOutput)
}

// AllNodes indicates that all nodes have access to the device.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDevicePatchOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v BasicDevicePatch) *bool { return v.AllNodes }).(pulumi.BoolPtrOutput)
}

// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePatchOutput) Attributes() DeviceAttributeMapOutput {
	return o.ApplyT(func(v BasicDevicePatch) map[string]DeviceAttribute { return v.Attributes }).(DeviceAttributeMapOutput)
}

// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePatchOutput) Capacity() DeviceCapacityMapOutput {
	return o.ApplyT(func(v BasicDevicePatch) map[string]DeviceCapacity { return v.Capacity }).(DeviceCapacityMapOutput)
}

// ConsumesCounters defines a list of references to sharedCounters and the set of counters that the device will consume from those counter sets.
//
// There can only be a single entry per counterSet.
//
// The total number of device counter consumption entries must be <= 32. In addition, the total number in the entire ResourceSlice must be <= 1024 (for example, 64 devices with 16 counters each).
func (o BasicDevicePatchOutput) ConsumesCounters() DeviceCounterConsumptionPatchArrayOutput {
	return o.ApplyT(func(v BasicDevicePatch) []DeviceCounterConsumptionPatch { return v.ConsumesCounters }).(DeviceCounterConsumptionPatchArrayOutput)
}

// NodeName identifies the node where the device is available.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDevicePatchOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BasicDevicePatch) *string { return v.NodeName }).(pulumi.StringPtrOutput)
}

// NodeSelector defines the nodes where the device is available.
//
// Must use exactly one term.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDevicePatchOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v BasicDevicePatch) *corev1.NodeSelectorPatch { return v.NodeSelector }).(corev1.NodeSelectorPatchPtrOutput)
}

// If specified, these are the driver-defined taints.
//
// The maximum number of taints is 4.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o BasicDevicePatchOutput) Taints() DeviceTaintPatchArrayOutput {
	return o.ApplyT(func(v BasicDevicePatch) []DeviceTaintPatch { return v.Taints }).(DeviceTaintPatchArrayOutput)
}

type BasicDevicePatchPtrOutput struct{ *pulumi.OutputState }

func (BasicDevicePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicDevicePatch)(nil)).Elem()
}

func (o BasicDevicePatchPtrOutput) ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput {
	return o
}

func (o BasicDevicePatchPtrOutput) ToBasicDevicePatchPtrOutputWithContext(ctx context.Context) BasicDevicePatchPtrOutput {
	return o
}

func (o BasicDevicePatchPtrOutput) Elem() BasicDevicePatchOutput {
	return o.ApplyT(func(v *BasicDevicePatch) BasicDevicePatch {
		if v != nil {
			return *v
		}
		var ret BasicDevicePatch
		return ret
	}).(BasicDevicePatchOutput)
}

// AllNodes indicates that all nodes have access to the device.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDevicePatchPtrOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *BasicDevicePatch) *bool {
		if v == nil {
			return nil
		}
		return v.AllNodes
	}).(pulumi.BoolPtrOutput)
}

// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePatchPtrOutput) Attributes() DeviceAttributeMapOutput {
	return o.ApplyT(func(v *BasicDevicePatch) map[string]DeviceAttribute {
		if v == nil {
			return nil
		}
		return v.Attributes
	}).(DeviceAttributeMapOutput)
}

// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePatchPtrOutput) Capacity() DeviceCapacityMapOutput {
	return o.ApplyT(func(v *BasicDevicePatch) map[string]DeviceCapacity {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(DeviceCapacityMapOutput)
}

// ConsumesCounters defines a list of references to sharedCounters and the set of counters that the device will consume from those counter sets.
//
// There can only be a single entry per counterSet.
//
// The total number of device counter consumption entries must be <= 32. In addition, the total number in the entire ResourceSlice must be <= 1024 (for example, 64 devices with 16 counters each).
func (o BasicDevicePatchPtrOutput) ConsumesCounters() DeviceCounterConsumptionPatchArrayOutput {
	return o.ApplyT(func(v *BasicDevicePatch) []DeviceCounterConsumptionPatch {
		if v == nil {
			return nil
		}
		return v.ConsumesCounters
	}).(DeviceCounterConsumptionPatchArrayOutput)
}

// NodeName identifies the node where the device is available.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDevicePatchPtrOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicDevicePatch) *string {
		if v == nil {
			return nil
		}
		return v.NodeName
	}).(pulumi.StringPtrOutput)
}

// NodeSelector defines the nodes where the device is available.
//
// Must use exactly one term.
//
// Must only be set if Spec.PerDeviceNodeSelection is set to true. At most one of NodeName, NodeSelector and AllNodes can be set.
func (o BasicDevicePatchPtrOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v *BasicDevicePatch) *corev1.NodeSelectorPatch {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(corev1.NodeSelectorPatchPtrOutput)
}

// If specified, these are the driver-defined taints.
//
// The maximum number of taints is 4.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o BasicDevicePatchPtrOutput) Taints() DeviceTaintPatchArrayOutput {
	return o.ApplyT(func(v *BasicDevicePatch) []DeviceTaintPatch {
		if v == nil {
			return nil
		}
		return v.Taints
	}).(DeviceTaintPatchArrayOutput)
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelector struct {
	// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
	//
	// The expression's input is an object named "device", which carries the following properties:
	//  - driver (string): the name of the driver which defines this device.
	//  - attributes (map[string]object): the device's attributes, grouped by prefix
	//    (e.g. device.attributes["dra.example.com"] evaluates to an object with all
	//    of the attributes which were prefixed by "dra.example.com".
	//  - capacity (map[string]object): the device's capacities, grouped by prefix.
	//
	// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
	//
	//     device.driver
	//     device.attributes["dra.example.com"].model
	//     device.attributes["ext.example.com"].family
	//     device.capacity["dra.example.com"].modules
	//
	// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
	//
	// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
	//
	// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
	//
	// A robust expression should check for the existence of attributes before referencing them.
	//
	// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
	//
	//     cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
	//
	// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
	Expression string `pulumi:"expression"`
}

// CELDeviceSelectorInput is an input type that accepts CELDeviceSelectorArgs and CELDeviceSelectorOutput values.
// You can construct a concrete instance of `CELDeviceSelectorInput` via:
//
//	CELDeviceSelectorArgs{...}
type CELDeviceSelectorInput interface {
	pulumi.Input

	ToCELDeviceSelectorOutput() CELDeviceSelectorOutput
	ToCELDeviceSelectorOutputWithContext(context.Context) CELDeviceSelectorOutput
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorArgs struct {
	// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
	//
	// The expression's input is an object named "device", which carries the following properties:
	//  - driver (string): the name of the driver which defines this device.
	//  - attributes (map[string]object): the device's attributes, grouped by prefix
	//    (e.g. device.attributes["dra.example.com"] evaluates to an object with all
	//    of the attributes which were prefixed by "dra.example.com".
	//  - capacity (map[string]object): the device's capacities, grouped by prefix.
	//
	// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
	//
	//     device.driver
	//     device.attributes["dra.example.com"].model
	//     device.attributes["ext.example.com"].family
	//     device.capacity["dra.example.com"].modules
	//
	// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
	//
	// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
	//
	// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
	//
	// A robust expression should check for the existence of attributes before referencing them.
	//
	// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
	//
	//     cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
	//
	// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
	Expression pulumi.StringInput `pulumi:"expression"`
}

func (CELDeviceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CELDeviceSelector)(nil)).Elem()
}

func (i CELDeviceSelectorArgs) ToCELDeviceSelectorOutput() CELDeviceSelectorOutput {
	return i.ToCELDeviceSelectorOutputWithContext(context.Background())
}

func (i CELDeviceSelectorArgs) ToCELDeviceSelectorOutputWithContext(ctx context.Context) CELDeviceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorOutput)
}

func (i CELDeviceSelectorArgs) ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput {
	return i.ToCELDeviceSelectorPtrOutputWithContext(context.Background())
}

func (i CELDeviceSelectorArgs) ToCELDeviceSelectorPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorOutput).ToCELDeviceSelectorPtrOutputWithContext(ctx)
}

// CELDeviceSelectorPtrInput is an input type that accepts CELDeviceSelectorArgs, CELDeviceSelectorPtr and CELDeviceSelectorPtrOutput values.
// You can construct a concrete instance of `CELDeviceSelectorPtrInput` via:
//
//	        CELDeviceSelectorArgs{...}
//
//	or:
//
//	        nil
type CELDeviceSelectorPtrInput interface {
	pulumi.Input

	ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput
	ToCELDeviceSelectorPtrOutputWithContext(context.Context) CELDeviceSelectorPtrOutput
}

type celdeviceSelectorPtrType CELDeviceSelectorArgs

func CELDeviceSelectorPtr(v *CELDeviceSelectorArgs) CELDeviceSelectorPtrInput {
	return (*celdeviceSelectorPtrType)(v)
}

func (*celdeviceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CELDeviceSelector)(nil)).Elem()
}

func (i *celdeviceSelectorPtrType) ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput {
	return i.ToCELDeviceSelectorPtrOutputWithContext(context.Background())
}

func (i *celdeviceSelectorPtrType) ToCELDeviceSelectorPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorPtrOutput)
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorOutput struct{ *pulumi.OutputState }

func (CELDeviceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CELDeviceSelector)(nil)).Elem()
}

func (o CELDeviceSelectorOutput) ToCELDeviceSelectorOutput() CELDeviceSelectorOutput {
	return o
}

func (o CELDeviceSelectorOutput) ToCELDeviceSelectorOutputWithContext(ctx context.Context) CELDeviceSelectorOutput {
	return o
}

func (o CELDeviceSelectorOutput) ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput {
	return o.ToCELDeviceSelectorPtrOutputWithContext(context.Background())
}

func (o CELDeviceSelectorOutput) ToCELDeviceSelectorPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CELDeviceSelector) *CELDeviceSelector {
		return &v
	}).(CELDeviceSelectorPtrOutput)
}

// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
//
// The expression's input is an object named "device", which carries the following properties:
//   - driver (string): the name of the driver which defines this device.
//   - attributes (map[string]object): the device's attributes, grouped by prefix
//     (e.g. device.attributes["dra.example.com"] evaluates to an object with all
//     of the attributes which were prefixed by "dra.example.com".
//   - capacity (map[string]object): the device's capacities, grouped by prefix.
//
// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
//
//	device.driver
//	device.attributes["dra.example.com"].model
//	device.attributes["ext.example.com"].family
//	device.capacity["dra.example.com"].modules
//
// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
//
// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
//
// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
//
// A robust expression should check for the existence of attributes before referencing them.
//
// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
//
//	cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
//
// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
func (o CELDeviceSelectorOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v CELDeviceSelector) string { return v.Expression }).(pulumi.StringOutput)
}

type CELDeviceSelectorPtrOutput struct{ *pulumi.OutputState }

func (CELDeviceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CELDeviceSelector)(nil)).Elem()
}

func (o CELDeviceSelectorPtrOutput) ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput {
	return o
}

func (o CELDeviceSelectorPtrOutput) ToCELDeviceSelectorPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPtrOutput {
	return o
}

func (o CELDeviceSelectorPtrOutput) Elem() CELDeviceSelectorOutput {
	return o.ApplyT(func(v *CELDeviceSelector) CELDeviceSelector {
		if v != nil {
			return *v
		}
		var ret CELDeviceSelector
		return ret
	}).(CELDeviceSelectorOutput)
}

// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
//
// The expression's input is an object named "device", which carries the following properties:
//   - driver (string): the name of the driver which defines this device.
//   - attributes (map[string]object): the device's attributes, grouped by prefix
//     (e.g. device.attributes["dra.example.com"] evaluates to an object with all
//     of the attributes which were prefixed by "dra.example.com".
//   - capacity (map[string]object): the device's capacities, grouped by prefix.
//
// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
//
//	device.driver
//	device.attributes["dra.example.com"].model
//	device.attributes["ext.example.com"].family
//	device.capacity["dra.example.com"].modules
//
// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
//
// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
//
// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
//
// A robust expression should check for the existence of attributes before referencing them.
//
// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
//
//	cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
//
// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
func (o CELDeviceSelectorPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CELDeviceSelector) *string {
		if v == nil {
			return nil
		}
		return &v.Expression
	}).(pulumi.StringPtrOutput)
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorPatch struct {
	// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
	//
	// The expression's input is an object named "device", which carries the following properties:
	//  - driver (string): the name of the driver which defines this device.
	//  - attributes (map[string]object): the device's attributes, grouped by prefix
	//    (e.g. device.attributes["dra.example.com"] evaluates to an object with all
	//    of the attributes which were prefixed by "dra.example.com".
	//  - capacity (map[string]object): the device's capacities, grouped by prefix.
	//
	// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
	//
	//     device.driver
	//     device.attributes["dra.example.com"].model
	//     device.attributes["ext.example.com"].family
	//     device.capacity["dra.example.com"].modules
	//
	// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
	//
	// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
	//
	// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
	//
	// A robust expression should check for the existence of attributes before referencing them.
	//
	// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
	//
	//     cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
	//
	// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
	Expression *string `pulumi:"expression"`
}

// CELDeviceSelectorPatchInput is an input type that accepts CELDeviceSelectorPatchArgs and CELDeviceSelectorPatchOutput values.
// You can construct a concrete instance of `CELDeviceSelectorPatchInput` via:
//
//	CELDeviceSelectorPatchArgs{...}
type CELDeviceSelectorPatchInput interface {
	pulumi.Input

	ToCELDeviceSelectorPatchOutput() CELDeviceSelectorPatchOutput
	ToCELDeviceSelectorPatchOutputWithContext(context.Context) CELDeviceSelectorPatchOutput
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorPatchArgs struct {
	// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
	//
	// The expression's input is an object named "device", which carries the following properties:
	//  - driver (string): the name of the driver which defines this device.
	//  - attributes (map[string]object): the device's attributes, grouped by prefix
	//    (e.g. device.attributes["dra.example.com"] evaluates to an object with all
	//    of the attributes which were prefixed by "dra.example.com".
	//  - capacity (map[string]object): the device's capacities, grouped by prefix.
	//
	// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
	//
	//     device.driver
	//     device.attributes["dra.example.com"].model
	//     device.attributes["ext.example.com"].family
	//     device.capacity["dra.example.com"].modules
	//
	// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
	//
	// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
	//
	// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
	//
	// A robust expression should check for the existence of attributes before referencing them.
	//
	// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
	//
	//     cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
	//
	// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
}

func (CELDeviceSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CELDeviceSelectorPatch)(nil)).Elem()
}

func (i CELDeviceSelectorPatchArgs) ToCELDeviceSelectorPatchOutput() CELDeviceSelectorPatchOutput {
	return i.ToCELDeviceSelectorPatchOutputWithContext(context.Background())
}

func (i CELDeviceSelectorPatchArgs) ToCELDeviceSelectorPatchOutputWithContext(ctx context.Context) CELDeviceSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorPatchOutput)
}

func (i CELDeviceSelectorPatchArgs) ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput {
	return i.ToCELDeviceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i CELDeviceSelectorPatchArgs) ToCELDeviceSelectorPatchPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorPatchOutput).ToCELDeviceSelectorPatchPtrOutputWithContext(ctx)
}

// CELDeviceSelectorPatchPtrInput is an input type that accepts CELDeviceSelectorPatchArgs, CELDeviceSelectorPatchPtr and CELDeviceSelectorPatchPtrOutput values.
// You can construct a concrete instance of `CELDeviceSelectorPatchPtrInput` via:
//
//	        CELDeviceSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type CELDeviceSelectorPatchPtrInput interface {
	pulumi.Input

	ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput
	ToCELDeviceSelectorPatchPtrOutputWithContext(context.Context) CELDeviceSelectorPatchPtrOutput
}

type celdeviceSelectorPatchPtrType CELDeviceSelectorPatchArgs

func CELDeviceSelectorPatchPtr(v *CELDeviceSelectorPatchArgs) CELDeviceSelectorPatchPtrInput {
	return (*celdeviceSelectorPatchPtrType)(v)
}

func (*celdeviceSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CELDeviceSelectorPatch)(nil)).Elem()
}

func (i *celdeviceSelectorPatchPtrType) ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput {
	return i.ToCELDeviceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *celdeviceSelectorPatchPtrType) ToCELDeviceSelectorPatchPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorPatchPtrOutput)
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorPatchOutput struct{ *pulumi.OutputState }

func (CELDeviceSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CELDeviceSelectorPatch)(nil)).Elem()
}

func (o CELDeviceSelectorPatchOutput) ToCELDeviceSelectorPatchOutput() CELDeviceSelectorPatchOutput {
	return o
}

func (o CELDeviceSelectorPatchOutput) ToCELDeviceSelectorPatchOutputWithContext(ctx context.Context) CELDeviceSelectorPatchOutput {
	return o
}

func (o CELDeviceSelectorPatchOutput) ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput {
	return o.ToCELDeviceSelectorPatchPtrOutputWithContext(context.Background())
}

func (o CELDeviceSelectorPatchOutput) ToCELDeviceSelectorPatchPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CELDeviceSelectorPatch) *CELDeviceSelectorPatch {
		return &v
	}).(CELDeviceSelectorPatchPtrOutput)
}

// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
//
// The expression's input is an object named "device", which carries the following properties:
//   - driver (string): the name of the driver which defines this device.
//   - attributes (map[string]object): the device's attributes, grouped by prefix
//     (e.g. device.attributes["dra.example.com"] evaluates to an object with all
//     of the attributes which were prefixed by "dra.example.com".
//   - capacity (map[string]object): the device's capacities, grouped by prefix.
//
// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
//
//	device.driver
//	device.attributes["dra.example.com"].model
//	device.attributes["ext.example.com"].family
//	device.capacity["dra.example.com"].modules
//
// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
//
// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
//
// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
//
// A robust expression should check for the existence of attributes before referencing them.
//
// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
//
//	cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
//
// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
func (o CELDeviceSelectorPatchOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CELDeviceSelectorPatch) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

type CELDeviceSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (CELDeviceSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CELDeviceSelectorPatch)(nil)).Elem()
}

func (o CELDeviceSelectorPatchPtrOutput) ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput {
	return o
}

func (o CELDeviceSelectorPatchPtrOutput) ToCELDeviceSelectorPatchPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPatchPtrOutput {
	return o
}

func (o CELDeviceSelectorPatchPtrOutput) Elem() CELDeviceSelectorPatchOutput {
	return o.ApplyT(func(v *CELDeviceSelectorPatch) CELDeviceSelectorPatch {
		if v != nil {
			return *v
		}
		var ret CELDeviceSelectorPatch
		return ret
	}).(CELDeviceSelectorPatchOutput)
}

// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
//
// The expression's input is an object named "device", which carries the following properties:
//   - driver (string): the name of the driver which defines this device.
//   - attributes (map[string]object): the device's attributes, grouped by prefix
//     (e.g. device.attributes["dra.example.com"] evaluates to an object with all
//     of the attributes which were prefixed by "dra.example.com".
//   - capacity (map[string]object): the device's capacities, grouped by prefix.
//
// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
//
//	device.driver
//	device.attributes["dra.example.com"].model
//	device.attributes["ext.example.com"].family
//	device.capacity["dra.example.com"].modules
//
// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
//
// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
//
// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
//
// A robust expression should check for the existence of attributes before referencing them.
//
// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
//
//	cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
//
// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
func (o CELDeviceSelectorPatchPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CELDeviceSelectorPatch) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Counter describes a quantity associated with a device.
type Counter struct {
	// Value defines how much of a certain device counter is available.
	Value string `pulumi:"value"`
}

// CounterInput is an input type that accepts CounterArgs and CounterOutput values.
// You can construct a concrete instance of `CounterInput` via:
//
//	CounterArgs{...}
type CounterInput interface {
	pulumi.Input

	ToCounterOutput() CounterOutput
	ToCounterOutputWithContext(context.Context) CounterOutput
}

// Counter describes a quantity associated with a device.
type CounterArgs struct {
	// Value defines how much of a certain device counter is available.
	Value pulumi.StringInput `pulumi:"value"`
}

func (CounterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Counter)(nil)).Elem()
}

func (i CounterArgs) ToCounterOutput() CounterOutput {
	return i.ToCounterOutputWithContext(context.Background())
}

func (i CounterArgs) ToCounterOutputWithContext(ctx context.Context) CounterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CounterOutput)
}

// CounterMapInput is an input type that accepts CounterMap and CounterMapOutput values.
// You can construct a concrete instance of `CounterMapInput` via:
//
//	CounterMap{ "key": CounterArgs{...} }
type CounterMapInput interface {
	pulumi.Input

	ToCounterMapOutput() CounterMapOutput
	ToCounterMapOutputWithContext(context.Context) CounterMapOutput
}

type CounterMap map[string]CounterInput

func (CounterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Counter)(nil)).Elem()
}

func (i CounterMap) ToCounterMapOutput() CounterMapOutput {
	return i.ToCounterMapOutputWithContext(context.Background())
}

func (i CounterMap) ToCounterMapOutputWithContext(ctx context.Context) CounterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CounterMapOutput)
}

// Counter describes a quantity associated with a device.
type CounterOutput struct{ *pulumi.OutputState }

func (CounterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Counter)(nil)).Elem()
}

func (o CounterOutput) ToCounterOutput() CounterOutput {
	return o
}

func (o CounterOutput) ToCounterOutputWithContext(ctx context.Context) CounterOutput {
	return o
}

// Value defines how much of a certain device counter is available.
func (o CounterOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v Counter) string { return v.Value }).(pulumi.StringOutput)
}

type CounterMapOutput struct{ *pulumi.OutputState }

func (CounterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Counter)(nil)).Elem()
}

func (o CounterMapOutput) ToCounterMapOutput() CounterMapOutput {
	return o
}

func (o CounterMapOutput) ToCounterMapOutputWithContext(ctx context.Context) CounterMapOutput {
	return o
}

func (o CounterMapOutput) MapIndex(k pulumi.StringInput) CounterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Counter {
		return vs[0].(map[string]Counter)[vs[1].(string)]
	}).(CounterOutput)
}

// Counter describes a quantity associated with a device.
type CounterPatch struct {
	// Value defines how much of a certain device counter is available.
	Value *string `pulumi:"value"`
}

// CounterPatchInput is an input type that accepts CounterPatchArgs and CounterPatchOutput values.
// You can construct a concrete instance of `CounterPatchInput` via:
//
//	CounterPatchArgs{...}
type CounterPatchInput interface {
	pulumi.Input

	ToCounterPatchOutput() CounterPatchOutput
	ToCounterPatchOutputWithContext(context.Context) CounterPatchOutput
}

// Counter describes a quantity associated with a device.
type CounterPatchArgs struct {
	// Value defines how much of a certain device counter is available.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (CounterPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CounterPatch)(nil)).Elem()
}

func (i CounterPatchArgs) ToCounterPatchOutput() CounterPatchOutput {
	return i.ToCounterPatchOutputWithContext(context.Background())
}

func (i CounterPatchArgs) ToCounterPatchOutputWithContext(ctx context.Context) CounterPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CounterPatchOutput)
}

// Counter describes a quantity associated with a device.
type CounterPatchOutput struct{ *pulumi.OutputState }

func (CounterPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CounterPatch)(nil)).Elem()
}

func (o CounterPatchOutput) ToCounterPatchOutput() CounterPatchOutput {
	return o
}

func (o CounterPatchOutput) ToCounterPatchOutputWithContext(ctx context.Context) CounterPatchOutput {
	return o
}

// Value defines how much of a certain device counter is available.
func (o CounterPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CounterPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

// CounterSet defines a named set of counters that are available to be used by devices defined in the ResourceSlice.
//
// The counters are not allocatable by themselves, but can be referenced by devices. When a device is allocated, the portion of counters it uses will no longer be available for use by other devices.
type CounterSet struct {
	// Counters defines the set of counters for this CounterSet The name of each counter must be unique in that set and must be a DNS label.
	//
	// The maximum number of counters is 32.
	Counters map[string]Counter `pulumi:"counters"`
	// Name defines the name of the counter set. It must be a DNS label.
	Name string `pulumi:"name"`
}

// CounterSetInput is an input type that accepts CounterSetArgs and CounterSetOutput values.
// You can construct a concrete instance of `CounterSetInput` via:
//
//	CounterSetArgs{...}
type CounterSetInput interface {
	pulumi.Input

	ToCounterSetOutput() CounterSetOutput
	ToCounterSetOutputWithContext(context.Context) CounterSetOutput
}

// CounterSet defines a named set of counters that are available to be used by devices defined in the ResourceSlice.
//
// The counters are not allocatable by themselves, but can be referenced by devices. When a device is allocated, the portion of counters it uses will no longer be available for use by other devices.
type CounterSetArgs struct {
	// Counters defines the set of counters for this CounterSet The name of each counter must be unique in that set and must be a DNS label.
	//
	// The maximum number of counters is 32.
	Counters CounterMapInput `pulumi:"counters"`
	// Name defines the name of the counter set. It must be a DNS label.
	Name pulumi.StringInput `pulumi:"name"`
}

func (CounterSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CounterSet)(nil)).Elem()
}

func (i CounterSetArgs) ToCounterSetOutput() CounterSetOutput {
	return i.ToCounterSetOutputWithContext(context.Background())
}

func (i CounterSetArgs) ToCounterSetOutputWithContext(ctx context.Context) CounterSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CounterSetOutput)
}

// CounterSetArrayInput is an input type that accepts CounterSetArray and CounterSetArrayOutput values.
// You can construct a concrete instance of `CounterSetArrayInput` via:
//
//	CounterSetArray{ CounterSetArgs{...} }
type CounterSetArrayInput interface {
	pulumi.Input

	ToCounterSetArrayOutput() CounterSetArrayOutput
	ToCounterSetArrayOutputWithContext(context.Context) CounterSetArrayOutput
}

type CounterSetArray []CounterSetInput

func (CounterSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CounterSet)(nil)).Elem()
}

func (i CounterSetArray) ToCounterSetArrayOutput() CounterSetArrayOutput {
	return i.ToCounterSetArrayOutputWithContext(context.Background())
}

func (i CounterSetArray) ToCounterSetArrayOutputWithContext(ctx context.Context) CounterSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CounterSetArrayOutput)
}

// CounterSet defines a named set of counters that are available to be used by devices defined in the ResourceSlice.
//
// The counters are not allocatable by themselves, but can be referenced by devices. When a device is allocated, the portion of counters it uses will no longer be available for use by other devices.
type CounterSetOutput struct{ *pulumi.OutputState }

func (CounterSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CounterSet)(nil)).Elem()
}

func (o CounterSetOutput) ToCounterSetOutput() CounterSetOutput {
	return o
}

func (o CounterSetOutput) ToCounterSetOutputWithContext(ctx context.Context) CounterSetOutput {
	return o
}

// Counters defines the set of counters for this CounterSet The name of each counter must be unique in that set and must be a DNS label.
//
// The maximum number of counters is 32.
func (o CounterSetOutput) Counters() CounterMapOutput {
	return o.ApplyT(func(v CounterSet) map[string]Counter { return v.Counters }).(CounterMapOutput)
}

// Name defines the name of the counter set. It must be a DNS label.
func (o CounterSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v CounterSet) string { return v.Name }).(pulumi.StringOutput)
}

type CounterSetArrayOutput struct{ *pulumi.OutputState }

func (CounterSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CounterSet)(nil)).Elem()
}

func (o CounterSetArrayOutput) ToCounterSetArrayOutput() CounterSetArrayOutput {
	return o
}

func (o CounterSetArrayOutput) ToCounterSetArrayOutputWithContext(ctx context.Context) CounterSetArrayOutput {
	return o
}

func (o CounterSetArrayOutput) Index(i pulumi.IntInput) CounterSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CounterSet {
		return vs[0].([]CounterSet)[vs[1].(int)]
	}).(CounterSetOutput)
}

// CounterSet defines a named set of counters that are available to be used by devices defined in the ResourceSlice.
//
// The counters are not allocatable by themselves, but can be referenced by devices. When a device is allocated, the portion of counters it uses will no longer be available for use by other devices.
type CounterSetPatch struct {
	// Counters defines the set of counters for this CounterSet The name of each counter must be unique in that set and must be a DNS label.
	//
	// The maximum number of counters is 32.
	Counters map[string]Counter `pulumi:"counters"`
	// Name defines the name of the counter set. It must be a DNS label.
	Name *string `pulumi:"name"`
}

// CounterSetPatchInput is an input type that accepts CounterSetPatchArgs and CounterSetPatchOutput values.
// You can construct a concrete instance of `CounterSetPatchInput` via:
//
//	CounterSetPatchArgs{...}
type CounterSetPatchInput interface {
	pulumi.Input

	ToCounterSetPatchOutput() CounterSetPatchOutput
	ToCounterSetPatchOutputWithContext(context.Context) CounterSetPatchOutput
}

// CounterSet defines a named set of counters that are available to be used by devices defined in the ResourceSlice.
//
// The counters are not allocatable by themselves, but can be referenced by devices. When a device is allocated, the portion of counters it uses will no longer be available for use by other devices.
type CounterSetPatchArgs struct {
	// Counters defines the set of counters for this CounterSet The name of each counter must be unique in that set and must be a DNS label.
	//
	// The maximum number of counters is 32.
	Counters CounterMapInput `pulumi:"counters"`
	// Name defines the name of the counter set. It must be a DNS label.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (CounterSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CounterSetPatch)(nil)).Elem()
}

func (i CounterSetPatchArgs) ToCounterSetPatchOutput() CounterSetPatchOutput {
	return i.ToCounterSetPatchOutputWithContext(context.Background())
}

func (i CounterSetPatchArgs) ToCounterSetPatchOutputWithContext(ctx context.Context) CounterSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CounterSetPatchOutput)
}

// CounterSetPatchArrayInput is an input type that accepts CounterSetPatchArray and CounterSetPatchArrayOutput values.
// You can construct a concrete instance of `CounterSetPatchArrayInput` via:
//
//	CounterSetPatchArray{ CounterSetPatchArgs{...} }
type CounterSetPatchArrayInput interface {
	pulumi.Input

	ToCounterSetPatchArrayOutput() CounterSetPatchArrayOutput
	ToCounterSetPatchArrayOutputWithContext(context.Context) CounterSetPatchArrayOutput
}

type CounterSetPatchArray []CounterSetPatchInput

func (CounterSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CounterSetPatch)(nil)).Elem()
}

func (i CounterSetPatchArray) ToCounterSetPatchArrayOutput() CounterSetPatchArrayOutput {
	return i.ToCounterSetPatchArrayOutputWithContext(context.Background())
}

func (i CounterSetPatchArray) ToCounterSetPatchArrayOutputWithContext(ctx context.Context) CounterSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CounterSetPatchArrayOutput)
}

// CounterSet defines a named set of counters that are available to be used by devices defined in the ResourceSlice.
//
// The counters are not allocatable by themselves, but can be referenced by devices. When a device is allocated, the portion of counters it uses will no longer be available for use by other devices.
type CounterSetPatchOutput struct{ *pulumi.OutputState }

func (CounterSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CounterSetPatch)(nil)).Elem()
}

func (o CounterSetPatchOutput) ToCounterSetPatchOutput() CounterSetPatchOutput {
	return o
}

func (o CounterSetPatchOutput) ToCounterSetPatchOutputWithContext(ctx context.Context) CounterSetPatchOutput {
	return o
}

// Counters defines the set of counters for this CounterSet The name of each counter must be unique in that set and must be a DNS label.
//
// The maximum number of counters is 32.
func (o CounterSetPatchOutput) Counters() CounterMapOutput {
	return o.ApplyT(func(v CounterSetPatch) map[string]Counter { return v.Counters }).(CounterMapOutput)
}

// Name defines the name of the counter set. It must be a DNS label.
func (o CounterSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CounterSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type CounterSetPatchArrayOutput struct{ *pulumi.OutputState }

func (CounterSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CounterSetPatch)(nil)).Elem()
}

func (o CounterSetPatchArrayOutput) ToCounterSetPatchArrayOutput() CounterSetPatchArrayOutput {
	return o
}

func (o CounterSetPatchArrayOutput) ToCounterSetPatchArrayOutputWithContext(ctx context.Context) CounterSetPatchArrayOutput {
	return o
}

func (o CounterSetPatchArrayOutput) Index(i pulumi.IntInput) CounterSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CounterSetPatch {
		return vs[0].([]CounterSetPatch)[vs[1].(int)]
	}).(CounterSetPatchOutput)
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type Device struct {
	// Basic defines one device instance.
	Basic *BasicDevice `pulumi:"basic"`
	// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
	Name string `pulumi:"name"`
}

// DeviceInput is an input type that accepts DeviceArgs and DeviceOutput values.
// You can construct a concrete instance of `DeviceInput` via:
//
//	DeviceArgs{...}
type DeviceInput interface {
	pulumi.Input

	ToDeviceOutput() DeviceOutput
	ToDeviceOutputWithContext(context.Context) DeviceOutput
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DeviceArgs struct {
	// Basic defines one device instance.
	Basic BasicDevicePtrInput `pulumi:"basic"`
	// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
	Name pulumi.StringInput `pulumi:"name"`
}

func (DeviceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Device)(nil)).Elem()
}

func (i DeviceArgs) ToDeviceOutput() DeviceOutput {
	return i.ToDeviceOutputWithContext(context.Background())
}

func (i DeviceArgs) ToDeviceOutputWithContext(ctx context.Context) DeviceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceOutput)
}

// DeviceArrayInput is an input type that accepts DeviceArray and DeviceArrayOutput values.
// You can construct a concrete instance of `DeviceArrayInput` via:
//
//	DeviceArray{ DeviceArgs{...} }
type DeviceArrayInput interface {
	pulumi.Input

	ToDeviceArrayOutput() DeviceArrayOutput
	ToDeviceArrayOutputWithContext(context.Context) DeviceArrayOutput
}

type DeviceArray []DeviceInput

func (DeviceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Device)(nil)).Elem()
}

func (i DeviceArray) ToDeviceArrayOutput() DeviceArrayOutput {
	return i.ToDeviceArrayOutputWithContext(context.Background())
}

func (i DeviceArray) ToDeviceArrayOutputWithContext(ctx context.Context) DeviceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceArrayOutput)
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DeviceOutput struct{ *pulumi.OutputState }

func (DeviceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Device)(nil)).Elem()
}

func (o DeviceOutput) ToDeviceOutput() DeviceOutput {
	return o
}

func (o DeviceOutput) ToDeviceOutputWithContext(ctx context.Context) DeviceOutput {
	return o
}

// Basic defines one device instance.
func (o DeviceOutput) Basic() BasicDevicePtrOutput {
	return o.ApplyT(func(v Device) *BasicDevice { return v.Basic }).(BasicDevicePtrOutput)
}

// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
func (o DeviceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Device) string { return v.Name }).(pulumi.StringOutput)
}

type DeviceArrayOutput struct{ *pulumi.OutputState }

func (DeviceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Device)(nil)).Elem()
}

func (o DeviceArrayOutput) ToDeviceArrayOutput() DeviceArrayOutput {
	return o
}

func (o DeviceArrayOutput) ToDeviceArrayOutputWithContext(ctx context.Context) DeviceArrayOutput {
	return o
}

func (o DeviceArrayOutput) Index(i pulumi.IntInput) DeviceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Device {
		return vs[0].([]Device)[vs[1].(int)]
	}).(DeviceOutput)
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfiguration struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfiguration `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
	Requests []string `pulumi:"requests"`
	// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
	Source string `pulumi:"source"`
}

// DeviceAllocationConfigurationInput is an input type that accepts DeviceAllocationConfigurationArgs and DeviceAllocationConfigurationOutput values.
// You can construct a concrete instance of `DeviceAllocationConfigurationInput` via:
//
//	DeviceAllocationConfigurationArgs{...}
type DeviceAllocationConfigurationInput interface {
	pulumi.Input

	ToDeviceAllocationConfigurationOutput() DeviceAllocationConfigurationOutput
	ToDeviceAllocationConfigurationOutputWithContext(context.Context) DeviceAllocationConfigurationOutput
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPtrInput `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
	// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
	Source pulumi.StringInput `pulumi:"source"`
}

func (DeviceAllocationConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationConfiguration)(nil)).Elem()
}

func (i DeviceAllocationConfigurationArgs) ToDeviceAllocationConfigurationOutput() DeviceAllocationConfigurationOutput {
	return i.ToDeviceAllocationConfigurationOutputWithContext(context.Background())
}

func (i DeviceAllocationConfigurationArgs) ToDeviceAllocationConfigurationOutputWithContext(ctx context.Context) DeviceAllocationConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationConfigurationOutput)
}

// DeviceAllocationConfigurationArrayInput is an input type that accepts DeviceAllocationConfigurationArray and DeviceAllocationConfigurationArrayOutput values.
// You can construct a concrete instance of `DeviceAllocationConfigurationArrayInput` via:
//
//	DeviceAllocationConfigurationArray{ DeviceAllocationConfigurationArgs{...} }
type DeviceAllocationConfigurationArrayInput interface {
	pulumi.Input

	ToDeviceAllocationConfigurationArrayOutput() DeviceAllocationConfigurationArrayOutput
	ToDeviceAllocationConfigurationArrayOutputWithContext(context.Context) DeviceAllocationConfigurationArrayOutput
}

type DeviceAllocationConfigurationArray []DeviceAllocationConfigurationInput

func (DeviceAllocationConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceAllocationConfiguration)(nil)).Elem()
}

func (i DeviceAllocationConfigurationArray) ToDeviceAllocationConfigurationArrayOutput() DeviceAllocationConfigurationArrayOutput {
	return i.ToDeviceAllocationConfigurationArrayOutputWithContext(context.Background())
}

func (i DeviceAllocationConfigurationArray) ToDeviceAllocationConfigurationArrayOutputWithContext(ctx context.Context) DeviceAllocationConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationConfigurationArrayOutput)
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationOutput struct{ *pulumi.OutputState }

func (DeviceAllocationConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationConfiguration)(nil)).Elem()
}

func (o DeviceAllocationConfigurationOutput) ToDeviceAllocationConfigurationOutput() DeviceAllocationConfigurationOutput {
	return o
}

func (o DeviceAllocationConfigurationOutput) ToDeviceAllocationConfigurationOutputWithContext(ctx context.Context) DeviceAllocationConfigurationOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceAllocationConfigurationOutput) Opaque() OpaqueDeviceConfigurationPtrOutput {
	return o.ApplyT(func(v DeviceAllocationConfiguration) *OpaqueDeviceConfiguration { return v.Opaque }).(OpaqueDeviceConfigurationPtrOutput)
}

// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
//
// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
func (o DeviceAllocationConfigurationOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceAllocationConfiguration) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
func (o DeviceAllocationConfigurationOutput) Source() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceAllocationConfiguration) string { return v.Source }).(pulumi.StringOutput)
}

type DeviceAllocationConfigurationArrayOutput struct{ *pulumi.OutputState }

func (DeviceAllocationConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceAllocationConfiguration)(nil)).Elem()
}

func (o DeviceAllocationConfigurationArrayOutput) ToDeviceAllocationConfigurationArrayOutput() DeviceAllocationConfigurationArrayOutput {
	return o
}

func (o DeviceAllocationConfigurationArrayOutput) ToDeviceAllocationConfigurationArrayOutputWithContext(ctx context.Context) DeviceAllocationConfigurationArrayOutput {
	return o
}

func (o DeviceAllocationConfigurationArrayOutput) Index(i pulumi.IntInput) DeviceAllocationConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceAllocationConfiguration {
		return vs[0].([]DeviceAllocationConfiguration)[vs[1].(int)]
	}).(DeviceAllocationConfigurationOutput)
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationPatch struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfigurationPatch `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
	Requests []string `pulumi:"requests"`
	// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
	Source *string `pulumi:"source"`
}

// DeviceAllocationConfigurationPatchInput is an input type that accepts DeviceAllocationConfigurationPatchArgs and DeviceAllocationConfigurationPatchOutput values.
// You can construct a concrete instance of `DeviceAllocationConfigurationPatchInput` via:
//
//	DeviceAllocationConfigurationPatchArgs{...}
type DeviceAllocationConfigurationPatchInput interface {
	pulumi.Input

	ToDeviceAllocationConfigurationPatchOutput() DeviceAllocationConfigurationPatchOutput
	ToDeviceAllocationConfigurationPatchOutputWithContext(context.Context) DeviceAllocationConfigurationPatchOutput
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationPatchArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPatchPtrInput `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
	// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
	Source pulumi.StringPtrInput `pulumi:"source"`
}

func (DeviceAllocationConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationConfigurationPatch)(nil)).Elem()
}

func (i DeviceAllocationConfigurationPatchArgs) ToDeviceAllocationConfigurationPatchOutput() DeviceAllocationConfigurationPatchOutput {
	return i.ToDeviceAllocationConfigurationPatchOutputWithContext(context.Background())
}

func (i DeviceAllocationConfigurationPatchArgs) ToDeviceAllocationConfigurationPatchOutputWithContext(ctx context.Context) DeviceAllocationConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationConfigurationPatchOutput)
}

// DeviceAllocationConfigurationPatchArrayInput is an input type that accepts DeviceAllocationConfigurationPatchArray and DeviceAllocationConfigurationPatchArrayOutput values.
// You can construct a concrete instance of `DeviceAllocationConfigurationPatchArrayInput` via:
//
//	DeviceAllocationConfigurationPatchArray{ DeviceAllocationConfigurationPatchArgs{...} }
type DeviceAllocationConfigurationPatchArrayInput interface {
	pulumi.Input

	ToDeviceAllocationConfigurationPatchArrayOutput() DeviceAllocationConfigurationPatchArrayOutput
	ToDeviceAllocationConfigurationPatchArrayOutputWithContext(context.Context) DeviceAllocationConfigurationPatchArrayOutput
}

type DeviceAllocationConfigurationPatchArray []DeviceAllocationConfigurationPatchInput

func (DeviceAllocationConfigurationPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceAllocationConfigurationPatch)(nil)).Elem()
}

func (i DeviceAllocationConfigurationPatchArray) ToDeviceAllocationConfigurationPatchArrayOutput() DeviceAllocationConfigurationPatchArrayOutput {
	return i.ToDeviceAllocationConfigurationPatchArrayOutputWithContext(context.Background())
}

func (i DeviceAllocationConfigurationPatchArray) ToDeviceAllocationConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceAllocationConfigurationPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationConfigurationPatchArrayOutput)
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationPatchOutput struct{ *pulumi.OutputState }

func (DeviceAllocationConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationConfigurationPatch)(nil)).Elem()
}

func (o DeviceAllocationConfigurationPatchOutput) ToDeviceAllocationConfigurationPatchOutput() DeviceAllocationConfigurationPatchOutput {
	return o
}

func (o DeviceAllocationConfigurationPatchOutput) ToDeviceAllocationConfigurationPatchOutputWithContext(ctx context.Context) DeviceAllocationConfigurationPatchOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceAllocationConfigurationPatchOutput) Opaque() OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ApplyT(func(v DeviceAllocationConfigurationPatch) *OpaqueDeviceConfigurationPatch { return v.Opaque }).(OpaqueDeviceConfigurationPatchPtrOutput)
}

// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
//
// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
func (o DeviceAllocationConfigurationPatchOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceAllocationConfigurationPatch) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
func (o DeviceAllocationConfigurationPatchOutput) Source() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAllocationConfigurationPatch) *string { return v.Source }).(pulumi.StringPtrOutput)
}

type DeviceAllocationConfigurationPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceAllocationConfigurationPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceAllocationConfigurationPatch)(nil)).Elem()
}

func (o DeviceAllocationConfigurationPatchArrayOutput) ToDeviceAllocationConfigurationPatchArrayOutput() DeviceAllocationConfigurationPatchArrayOutput {
	return o
}

func (o DeviceAllocationConfigurationPatchArrayOutput) ToDeviceAllocationConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceAllocationConfigurationPatchArrayOutput {
	return o
}

func (o DeviceAllocationConfigurationPatchArrayOutput) Index(i pulumi.IntInput) DeviceAllocationConfigurationPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceAllocationConfigurationPatch {
		return vs[0].([]DeviceAllocationConfigurationPatch)[vs[1].(int)]
	}).(DeviceAllocationConfigurationPatchOutput)
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResult struct {
	// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
	//
	// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
	Config []DeviceAllocationConfiguration `pulumi:"config"`
	// Results lists all allocated devices.
	Results []DeviceRequestAllocationResult `pulumi:"results"`
}

// DeviceAllocationResultInput is an input type that accepts DeviceAllocationResultArgs and DeviceAllocationResultOutput values.
// You can construct a concrete instance of `DeviceAllocationResultInput` via:
//
//	DeviceAllocationResultArgs{...}
type DeviceAllocationResultInput interface {
	pulumi.Input

	ToDeviceAllocationResultOutput() DeviceAllocationResultOutput
	ToDeviceAllocationResultOutputWithContext(context.Context) DeviceAllocationResultOutput
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultArgs struct {
	// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
	//
	// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
	Config DeviceAllocationConfigurationArrayInput `pulumi:"config"`
	// Results lists all allocated devices.
	Results DeviceRequestAllocationResultArrayInput `pulumi:"results"`
}

func (DeviceAllocationResultArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationResult)(nil)).Elem()
}

func (i DeviceAllocationResultArgs) ToDeviceAllocationResultOutput() DeviceAllocationResultOutput {
	return i.ToDeviceAllocationResultOutputWithContext(context.Background())
}

func (i DeviceAllocationResultArgs) ToDeviceAllocationResultOutputWithContext(ctx context.Context) DeviceAllocationResultOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultOutput)
}

func (i DeviceAllocationResultArgs) ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput {
	return i.ToDeviceAllocationResultPtrOutputWithContext(context.Background())
}

func (i DeviceAllocationResultArgs) ToDeviceAllocationResultPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultOutput).ToDeviceAllocationResultPtrOutputWithContext(ctx)
}

// DeviceAllocationResultPtrInput is an input type that accepts DeviceAllocationResultArgs, DeviceAllocationResultPtr and DeviceAllocationResultPtrOutput values.
// You can construct a concrete instance of `DeviceAllocationResultPtrInput` via:
//
//	        DeviceAllocationResultArgs{...}
//
//	or:
//
//	        nil
type DeviceAllocationResultPtrInput interface {
	pulumi.Input

	ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput
	ToDeviceAllocationResultPtrOutputWithContext(context.Context) DeviceAllocationResultPtrOutput
}

type deviceAllocationResultPtrType DeviceAllocationResultArgs

func DeviceAllocationResultPtr(v *DeviceAllocationResultArgs) DeviceAllocationResultPtrInput {
	return (*deviceAllocationResultPtrType)(v)
}

func (*deviceAllocationResultPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceAllocationResult)(nil)).Elem()
}

func (i *deviceAllocationResultPtrType) ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput {
	return i.ToDeviceAllocationResultPtrOutputWithContext(context.Background())
}

func (i *deviceAllocationResultPtrType) ToDeviceAllocationResultPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultPtrOutput)
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultOutput struct{ *pulumi.OutputState }

func (DeviceAllocationResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationResult)(nil)).Elem()
}

func (o DeviceAllocationResultOutput) ToDeviceAllocationResultOutput() DeviceAllocationResultOutput {
	return o
}

func (o DeviceAllocationResultOutput) ToDeviceAllocationResultOutputWithContext(ctx context.Context) DeviceAllocationResultOutput {
	return o
}

func (o DeviceAllocationResultOutput) ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput {
	return o.ToDeviceAllocationResultPtrOutputWithContext(context.Background())
}

func (o DeviceAllocationResultOutput) ToDeviceAllocationResultPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceAllocationResult) *DeviceAllocationResult {
		return &v
	}).(DeviceAllocationResultPtrOutput)
}

// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
//
// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
func (o DeviceAllocationResultOutput) Config() DeviceAllocationConfigurationArrayOutput {
	return o.ApplyT(func(v DeviceAllocationResult) []DeviceAllocationConfiguration { return v.Config }).(DeviceAllocationConfigurationArrayOutput)
}

// Results lists all allocated devices.
func (o DeviceAllocationResultOutput) Results() DeviceRequestAllocationResultArrayOutput {
	return o.ApplyT(func(v DeviceAllocationResult) []DeviceRequestAllocationResult { return v.Results }).(DeviceRequestAllocationResultArrayOutput)
}

type DeviceAllocationResultPtrOutput struct{ *pulumi.OutputState }

func (DeviceAllocationResultPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceAllocationResult)(nil)).Elem()
}

func (o DeviceAllocationResultPtrOutput) ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput {
	return o
}

func (o DeviceAllocationResultPtrOutput) ToDeviceAllocationResultPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPtrOutput {
	return o
}

func (o DeviceAllocationResultPtrOutput) Elem() DeviceAllocationResultOutput {
	return o.ApplyT(func(v *DeviceAllocationResult) DeviceAllocationResult {
		if v != nil {
			return *v
		}
		var ret DeviceAllocationResult
		return ret
	}).(DeviceAllocationResultOutput)
}

// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
//
// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
func (o DeviceAllocationResultPtrOutput) Config() DeviceAllocationConfigurationArrayOutput {
	return o.ApplyT(func(v *DeviceAllocationResult) []DeviceAllocationConfiguration {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceAllocationConfigurationArrayOutput)
}

// Results lists all allocated devices.
func (o DeviceAllocationResultPtrOutput) Results() DeviceRequestAllocationResultArrayOutput {
	return o.ApplyT(func(v *DeviceAllocationResult) []DeviceRequestAllocationResult {
		if v == nil {
			return nil
		}
		return v.Results
	}).(DeviceRequestAllocationResultArrayOutput)
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultPatch struct {
	// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
	//
	// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
	Config []DeviceAllocationConfigurationPatch `pulumi:"config"`
	// Results lists all allocated devices.
	Results []DeviceRequestAllocationResultPatch `pulumi:"results"`
}

// DeviceAllocationResultPatchInput is an input type that accepts DeviceAllocationResultPatchArgs and DeviceAllocationResultPatchOutput values.
// You can construct a concrete instance of `DeviceAllocationResultPatchInput` via:
//
//	DeviceAllocationResultPatchArgs{...}
type DeviceAllocationResultPatchInput interface {
	pulumi.Input

	ToDeviceAllocationResultPatchOutput() DeviceAllocationResultPatchOutput
	ToDeviceAllocationResultPatchOutputWithContext(context.Context) DeviceAllocationResultPatchOutput
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultPatchArgs struct {
	// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
	//
	// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
	Config DeviceAllocationConfigurationPatchArrayInput `pulumi:"config"`
	// Results lists all allocated devices.
	Results DeviceRequestAllocationResultPatchArrayInput `pulumi:"results"`
}

func (DeviceAllocationResultPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationResultPatch)(nil)).Elem()
}

func (i DeviceAllocationResultPatchArgs) ToDeviceAllocationResultPatchOutput() DeviceAllocationResultPatchOutput {
	return i.ToDeviceAllocationResultPatchOutputWithContext(context.Background())
}

func (i DeviceAllocationResultPatchArgs) ToDeviceAllocationResultPatchOutputWithContext(ctx context.Context) DeviceAllocationResultPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultPatchOutput)
}

func (i DeviceAllocationResultPatchArgs) ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput {
	return i.ToDeviceAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (i DeviceAllocationResultPatchArgs) ToDeviceAllocationResultPatchPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultPatchOutput).ToDeviceAllocationResultPatchPtrOutputWithContext(ctx)
}

// DeviceAllocationResultPatchPtrInput is an input type that accepts DeviceAllocationResultPatchArgs, DeviceAllocationResultPatchPtr and DeviceAllocationResultPatchPtrOutput values.
// You can construct a concrete instance of `DeviceAllocationResultPatchPtrInput` via:
//
//	        DeviceAllocationResultPatchArgs{...}
//
//	or:
//
//	        nil
type DeviceAllocationResultPatchPtrInput interface {
	pulumi.Input

	ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput
	ToDeviceAllocationResultPatchPtrOutputWithContext(context.Context) DeviceAllocationResultPatchPtrOutput
}

type deviceAllocationResultPatchPtrType DeviceAllocationResultPatchArgs

func DeviceAllocationResultPatchPtr(v *DeviceAllocationResultPatchArgs) DeviceAllocationResultPatchPtrInput {
	return (*deviceAllocationResultPatchPtrType)(v)
}

func (*deviceAllocationResultPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceAllocationResultPatch)(nil)).Elem()
}

func (i *deviceAllocationResultPatchPtrType) ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput {
	return i.ToDeviceAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (i *deviceAllocationResultPatchPtrType) ToDeviceAllocationResultPatchPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultPatchPtrOutput)
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultPatchOutput struct{ *pulumi.OutputState }

func (DeviceAllocationResultPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationResultPatch)(nil)).Elem()
}

func (o DeviceAllocationResultPatchOutput) ToDeviceAllocationResultPatchOutput() DeviceAllocationResultPatchOutput {
	return o
}

func (o DeviceAllocationResultPatchOutput) ToDeviceAllocationResultPatchOutputWithContext(ctx context.Context) DeviceAllocationResultPatchOutput {
	return o
}

func (o DeviceAllocationResultPatchOutput) ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput {
	return o.ToDeviceAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (o DeviceAllocationResultPatchOutput) ToDeviceAllocationResultPatchPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceAllocationResultPatch) *DeviceAllocationResultPatch {
		return &v
	}).(DeviceAllocationResultPatchPtrOutput)
}

// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
//
// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
func (o DeviceAllocationResultPatchOutput) Config() DeviceAllocationConfigurationPatchArrayOutput {
	return o.ApplyT(func(v DeviceAllocationResultPatch) []DeviceAllocationConfigurationPatch { return v.Config }).(DeviceAllocationConfigurationPatchArrayOutput)
}

// Results lists all allocated devices.
func (o DeviceAllocationResultPatchOutput) Results() DeviceRequestAllocationResultPatchArrayOutput {
	return o.ApplyT(func(v DeviceAllocationResultPatch) []DeviceRequestAllocationResultPatch { return v.Results }).(DeviceRequestAllocationResultPatchArrayOutput)
}

type DeviceAllocationResultPatchPtrOutput struct{ *pulumi.OutputState }

func (DeviceAllocationResultPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceAllocationResultPatch)(nil)).Elem()
}

func (o DeviceAllocationResultPatchPtrOutput) ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput {
	return o
}

func (o DeviceAllocationResultPatchPtrOutput) ToDeviceAllocationResultPatchPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPatchPtrOutput {
	return o
}

func (o DeviceAllocationResultPatchPtrOutput) Elem() DeviceAllocationResultPatchOutput {
	return o.ApplyT(func(v *DeviceAllocationResultPatch) DeviceAllocationResultPatch {
		if v != nil {
			return *v
		}
		var ret DeviceAllocationResultPatch
		return ret
	}).(DeviceAllocationResultPatchOutput)
}

// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
//
// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
func (o DeviceAllocationResultPatchPtrOutput) Config() DeviceAllocationConfigurationPatchArrayOutput {
	return o.ApplyT(func(v *DeviceAllocationResultPatch) []DeviceAllocationConfigurationPatch {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceAllocationConfigurationPatchArrayOutput)
}

// Results lists all allocated devices.
func (o DeviceAllocationResultPatchPtrOutput) Results() DeviceRequestAllocationResultPatchArrayOutput {
	return o.ApplyT(func(v *DeviceAllocationResultPatch) []DeviceRequestAllocationResultPatch {
		if v == nil {
			return nil
		}
		return v.Results
	}).(DeviceRequestAllocationResultPatchArrayOutput)
}

// DeviceAttribute must have exactly one field set.
type DeviceAttribute struct {
	// BoolValue is a true/false value.
	Bool *bool `pulumi:"bool"`
	// IntValue is a number.
	Int *int `pulumi:"int"`
	// StringValue is a string. Must not be longer than 64 characters.
	String *string `pulumi:"string"`
	// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
	Version *string `pulumi:"version"`
}

// DeviceAttributeInput is an input type that accepts DeviceAttributeArgs and DeviceAttributeOutput values.
// You can construct a concrete instance of `DeviceAttributeInput` via:
//
//	DeviceAttributeArgs{...}
type DeviceAttributeInput interface {
	pulumi.Input

	ToDeviceAttributeOutput() DeviceAttributeOutput
	ToDeviceAttributeOutputWithContext(context.Context) DeviceAttributeOutput
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributeArgs struct {
	// BoolValue is a true/false value.
	Bool pulumi.BoolPtrInput `pulumi:"bool"`
	// IntValue is a number.
	Int pulumi.IntPtrInput `pulumi:"int"`
	// StringValue is a string. Must not be longer than 64 characters.
	String pulumi.StringPtrInput `pulumi:"string"`
	// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (DeviceAttributeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAttribute)(nil)).Elem()
}

func (i DeviceAttributeArgs) ToDeviceAttributeOutput() DeviceAttributeOutput {
	return i.ToDeviceAttributeOutputWithContext(context.Background())
}

func (i DeviceAttributeArgs) ToDeviceAttributeOutputWithContext(ctx context.Context) DeviceAttributeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAttributeOutput)
}

// DeviceAttributeMapInput is an input type that accepts DeviceAttributeMap and DeviceAttributeMapOutput values.
// You can construct a concrete instance of `DeviceAttributeMapInput` via:
//
//	DeviceAttributeMap{ "key": DeviceAttributeArgs{...} }
type DeviceAttributeMapInput interface {
	pulumi.Input

	ToDeviceAttributeMapOutput() DeviceAttributeMapOutput
	ToDeviceAttributeMapOutputWithContext(context.Context) DeviceAttributeMapOutput
}

type DeviceAttributeMap map[string]DeviceAttributeInput

func (DeviceAttributeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]DeviceAttribute)(nil)).Elem()
}

func (i DeviceAttributeMap) ToDeviceAttributeMapOutput() DeviceAttributeMapOutput {
	return i.ToDeviceAttributeMapOutputWithContext(context.Background())
}

func (i DeviceAttributeMap) ToDeviceAttributeMapOutputWithContext(ctx context.Context) DeviceAttributeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAttributeMapOutput)
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributeOutput struct{ *pulumi.OutputState }

func (DeviceAttributeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAttribute)(nil)).Elem()
}

func (o DeviceAttributeOutput) ToDeviceAttributeOutput() DeviceAttributeOutput {
	return o
}

func (o DeviceAttributeOutput) ToDeviceAttributeOutputWithContext(ctx context.Context) DeviceAttributeOutput {
	return o
}

// BoolValue is a true/false value.
func (o DeviceAttributeOutput) Bool() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceAttribute) *bool { return v.Bool }).(pulumi.BoolPtrOutput)
}

// IntValue is a number.
func (o DeviceAttributeOutput) Int() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceAttribute) *int { return v.Int }).(pulumi.IntPtrOutput)
}

// StringValue is a string. Must not be longer than 64 characters.
func (o DeviceAttributeOutput) String() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAttribute) *string { return v.String }).(pulumi.StringPtrOutput)
}

// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
func (o DeviceAttributeOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAttribute) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type DeviceAttributeMapOutput struct{ *pulumi.OutputState }

func (DeviceAttributeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]DeviceAttribute)(nil)).Elem()
}

func (o DeviceAttributeMapOutput) ToDeviceAttributeMapOutput() DeviceAttributeMapOutput {
	return o
}

func (o DeviceAttributeMapOutput) ToDeviceAttributeMapOutputWithContext(ctx context.Context) DeviceAttributeMapOutput {
	return o
}

func (o DeviceAttributeMapOutput) MapIndex(k pulumi.StringInput) DeviceAttributeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) DeviceAttribute {
		return vs[0].(map[string]DeviceAttribute)[vs[1].(string)]
	}).(DeviceAttributeOutput)
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributePatch struct {
	// BoolValue is a true/false value.
	Bool *bool `pulumi:"bool"`
	// IntValue is a number.
	Int *int `pulumi:"int"`
	// StringValue is a string. Must not be longer than 64 characters.
	String *string `pulumi:"string"`
	// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
	Version *string `pulumi:"version"`
}

// DeviceAttributePatchInput is an input type that accepts DeviceAttributePatchArgs and DeviceAttributePatchOutput values.
// You can construct a concrete instance of `DeviceAttributePatchInput` via:
//
//	DeviceAttributePatchArgs{...}
type DeviceAttributePatchInput interface {
	pulumi.Input

	ToDeviceAttributePatchOutput() DeviceAttributePatchOutput
	ToDeviceAttributePatchOutputWithContext(context.Context) DeviceAttributePatchOutput
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributePatchArgs struct {
	// BoolValue is a true/false value.
	Bool pulumi.BoolPtrInput `pulumi:"bool"`
	// IntValue is a number.
	Int pulumi.IntPtrInput `pulumi:"int"`
	// StringValue is a string. Must not be longer than 64 characters.
	String pulumi.StringPtrInput `pulumi:"string"`
	// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (DeviceAttributePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAttributePatch)(nil)).Elem()
}

func (i DeviceAttributePatchArgs) ToDeviceAttributePatchOutput() DeviceAttributePatchOutput {
	return i.ToDeviceAttributePatchOutputWithContext(context.Background())
}

func (i DeviceAttributePatchArgs) ToDeviceAttributePatchOutputWithContext(ctx context.Context) DeviceAttributePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAttributePatchOutput)
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributePatchOutput struct{ *pulumi.OutputState }

func (DeviceAttributePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAttributePatch)(nil)).Elem()
}

func (o DeviceAttributePatchOutput) ToDeviceAttributePatchOutput() DeviceAttributePatchOutput {
	return o
}

func (o DeviceAttributePatchOutput) ToDeviceAttributePatchOutputWithContext(ctx context.Context) DeviceAttributePatchOutput {
	return o
}

// BoolValue is a true/false value.
func (o DeviceAttributePatchOutput) Bool() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceAttributePatch) *bool { return v.Bool }).(pulumi.BoolPtrOutput)
}

// IntValue is a number.
func (o DeviceAttributePatchOutput) Int() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceAttributePatch) *int { return v.Int }).(pulumi.IntPtrOutput)
}

// StringValue is a string. Must not be longer than 64 characters.
func (o DeviceAttributePatchOutput) String() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAttributePatch) *string { return v.String }).(pulumi.StringPtrOutput)
}

// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
func (o DeviceAttributePatchOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAttributePatch) *string { return v.Version }).(pulumi.StringPtrOutput)
}

// DeviceCapacity describes a quantity associated with a device.
type DeviceCapacity struct {
	// Value defines how much of a certain device capacity is available.
	Value string `pulumi:"value"`
}

// DeviceCapacityInput is an input type that accepts DeviceCapacityArgs and DeviceCapacityOutput values.
// You can construct a concrete instance of `DeviceCapacityInput` via:
//
//	DeviceCapacityArgs{...}
type DeviceCapacityInput interface {
	pulumi.Input

	ToDeviceCapacityOutput() DeviceCapacityOutput
	ToDeviceCapacityOutputWithContext(context.Context) DeviceCapacityOutput
}

// DeviceCapacity describes a quantity associated with a device.
type DeviceCapacityArgs struct {
	// Value defines how much of a certain device capacity is available.
	Value pulumi.StringInput `pulumi:"value"`
}

func (DeviceCapacityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceCapacity)(nil)).Elem()
}

func (i DeviceCapacityArgs) ToDeviceCapacityOutput() DeviceCapacityOutput {
	return i.ToDeviceCapacityOutputWithContext(context.Background())
}

func (i DeviceCapacityArgs) ToDeviceCapacityOutputWithContext(ctx context.Context) DeviceCapacityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceCapacityOutput)
}

// DeviceCapacityMapInput is an input type that accepts DeviceCapacityMap and DeviceCapacityMapOutput values.
// You can construct a concrete instance of `DeviceCapacityMapInput` via:
//
//	DeviceCapacityMap{ "key": DeviceCapacityArgs{...} }
type DeviceCapacityMapInput interface {
	pulumi.Input

	ToDeviceCapacityMapOutput() DeviceCapacityMapOutput
	ToDeviceCapacityMapOutputWithContext(context.Context) DeviceCapacityMapOutput
}

type DeviceCapacityMap map[string]DeviceCapacityInput

func (DeviceCapacityMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]DeviceCapacity)(nil)).Elem()
}

func (i DeviceCapacityMap) ToDeviceCapacityMapOutput() DeviceCapacityMapOutput {
	return i.ToDeviceCapacityMapOutputWithContext(context.Background())
}

func (i DeviceCapacityMap) ToDeviceCapacityMapOutputWithContext(ctx context.Context) DeviceCapacityMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceCapacityMapOutput)
}

// DeviceCapacity describes a quantity associated with a device.
type DeviceCapacityOutput struct{ *pulumi.OutputState }

func (DeviceCapacityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceCapacity)(nil)).Elem()
}

func (o DeviceCapacityOutput) ToDeviceCapacityOutput() DeviceCapacityOutput {
	return o
}

func (o DeviceCapacityOutput) ToDeviceCapacityOutputWithContext(ctx context.Context) DeviceCapacityOutput {
	return o
}

// Value defines how much of a certain device capacity is available.
func (o DeviceCapacityOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceCapacity) string { return v.Value }).(pulumi.StringOutput)
}

type DeviceCapacityMapOutput struct{ *pulumi.OutputState }

func (DeviceCapacityMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]DeviceCapacity)(nil)).Elem()
}

func (o DeviceCapacityMapOutput) ToDeviceCapacityMapOutput() DeviceCapacityMapOutput {
	return o
}

func (o DeviceCapacityMapOutput) ToDeviceCapacityMapOutputWithContext(ctx context.Context) DeviceCapacityMapOutput {
	return o
}

func (o DeviceCapacityMapOutput) MapIndex(k pulumi.StringInput) DeviceCapacityOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) DeviceCapacity {
		return vs[0].(map[string]DeviceCapacity)[vs[1].(string)]
	}).(DeviceCapacityOutput)
}

// DeviceCapacity describes a quantity associated with a device.
type DeviceCapacityPatch struct {
	// Value defines how much of a certain device capacity is available.
	Value *string `pulumi:"value"`
}

// DeviceCapacityPatchInput is an input type that accepts DeviceCapacityPatchArgs and DeviceCapacityPatchOutput values.
// You can construct a concrete instance of `DeviceCapacityPatchInput` via:
//
//	DeviceCapacityPatchArgs{...}
type DeviceCapacityPatchInput interface {
	pulumi.Input

	ToDeviceCapacityPatchOutput() DeviceCapacityPatchOutput
	ToDeviceCapacityPatchOutputWithContext(context.Context) DeviceCapacityPatchOutput
}

// DeviceCapacity describes a quantity associated with a device.
type DeviceCapacityPatchArgs struct {
	// Value defines how much of a certain device capacity is available.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (DeviceCapacityPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceCapacityPatch)(nil)).Elem()
}

func (i DeviceCapacityPatchArgs) ToDeviceCapacityPatchOutput() DeviceCapacityPatchOutput {
	return i.ToDeviceCapacityPatchOutputWithContext(context.Background())
}

func (i DeviceCapacityPatchArgs) ToDeviceCapacityPatchOutputWithContext(ctx context.Context) DeviceCapacityPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceCapacityPatchOutput)
}

// DeviceCapacity describes a quantity associated with a device.
type DeviceCapacityPatchOutput struct{ *pulumi.OutputState }

func (DeviceCapacityPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceCapacityPatch)(nil)).Elem()
}

func (o DeviceCapacityPatchOutput) ToDeviceCapacityPatchOutput() DeviceCapacityPatchOutput {
	return o
}

func (o DeviceCapacityPatchOutput) ToDeviceCapacityPatchOutputWithContext(ctx context.Context) DeviceCapacityPatchOutput {
	return o
}

// Value defines how much of a certain device capacity is available.
func (o DeviceCapacityPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceCapacityPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaim struct {
	// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
	Config []DeviceClaimConfiguration `pulumi:"config"`
	// These constraints must be satisfied by the set of devices that get allocated for the claim.
	Constraints []DeviceConstraint `pulumi:"constraints"`
	// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
	Requests []DeviceRequest `pulumi:"requests"`
}

// DeviceClaimInput is an input type that accepts DeviceClaimArgs and DeviceClaimOutput values.
// You can construct a concrete instance of `DeviceClaimInput` via:
//
//	DeviceClaimArgs{...}
type DeviceClaimInput interface {
	pulumi.Input

	ToDeviceClaimOutput() DeviceClaimOutput
	ToDeviceClaimOutputWithContext(context.Context) DeviceClaimOutput
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimArgs struct {
	// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
	Config DeviceClaimConfigurationArrayInput `pulumi:"config"`
	// These constraints must be satisfied by the set of devices that get allocated for the claim.
	Constraints DeviceConstraintArrayInput `pulumi:"constraints"`
	// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
	Requests DeviceRequestArrayInput `pulumi:"requests"`
}

func (DeviceClaimArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaim)(nil)).Elem()
}

func (i DeviceClaimArgs) ToDeviceClaimOutput() DeviceClaimOutput {
	return i.ToDeviceClaimOutputWithContext(context.Background())
}

func (i DeviceClaimArgs) ToDeviceClaimOutputWithContext(ctx context.Context) DeviceClaimOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimOutput)
}

func (i DeviceClaimArgs) ToDeviceClaimPtrOutput() DeviceClaimPtrOutput {
	return i.ToDeviceClaimPtrOutputWithContext(context.Background())
}

func (i DeviceClaimArgs) ToDeviceClaimPtrOutputWithContext(ctx context.Context) DeviceClaimPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimOutput).ToDeviceClaimPtrOutputWithContext(ctx)
}

// DeviceClaimPtrInput is an input type that accepts DeviceClaimArgs, DeviceClaimPtr and DeviceClaimPtrOutput values.
// You can construct a concrete instance of `DeviceClaimPtrInput` via:
//
//	        DeviceClaimArgs{...}
//
//	or:
//
//	        nil
type DeviceClaimPtrInput interface {
	pulumi.Input

	ToDeviceClaimPtrOutput() DeviceClaimPtrOutput
	ToDeviceClaimPtrOutputWithContext(context.Context) DeviceClaimPtrOutput
}

type deviceClaimPtrType DeviceClaimArgs

func DeviceClaimPtr(v *DeviceClaimArgs) DeviceClaimPtrInput {
	return (*deviceClaimPtrType)(v)
}

func (*deviceClaimPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClaim)(nil)).Elem()
}

func (i *deviceClaimPtrType) ToDeviceClaimPtrOutput() DeviceClaimPtrOutput {
	return i.ToDeviceClaimPtrOutputWithContext(context.Background())
}

func (i *deviceClaimPtrType) ToDeviceClaimPtrOutputWithContext(ctx context.Context) DeviceClaimPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimPtrOutput)
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimOutput struct{ *pulumi.OutputState }

func (DeviceClaimOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaim)(nil)).Elem()
}

func (o DeviceClaimOutput) ToDeviceClaimOutput() DeviceClaimOutput {
	return o
}

func (o DeviceClaimOutput) ToDeviceClaimOutputWithContext(ctx context.Context) DeviceClaimOutput {
	return o
}

func (o DeviceClaimOutput) ToDeviceClaimPtrOutput() DeviceClaimPtrOutput {
	return o.ToDeviceClaimPtrOutputWithContext(context.Background())
}

func (o DeviceClaimOutput) ToDeviceClaimPtrOutputWithContext(ctx context.Context) DeviceClaimPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceClaim) *DeviceClaim {
		return &v
	}).(DeviceClaimPtrOutput)
}

// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
func (o DeviceClaimOutput) Config() DeviceClaimConfigurationArrayOutput {
	return o.ApplyT(func(v DeviceClaim) []DeviceClaimConfiguration { return v.Config }).(DeviceClaimConfigurationArrayOutput)
}

// These constraints must be satisfied by the set of devices that get allocated for the claim.
func (o DeviceClaimOutput) Constraints() DeviceConstraintArrayOutput {
	return o.ApplyT(func(v DeviceClaim) []DeviceConstraint { return v.Constraints }).(DeviceConstraintArrayOutput)
}

// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
func (o DeviceClaimOutput) Requests() DeviceRequestArrayOutput {
	return o.ApplyT(func(v DeviceClaim) []DeviceRequest { return v.Requests }).(DeviceRequestArrayOutput)
}

type DeviceClaimPtrOutput struct{ *pulumi.OutputState }

func (DeviceClaimPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClaim)(nil)).Elem()
}

func (o DeviceClaimPtrOutput) ToDeviceClaimPtrOutput() DeviceClaimPtrOutput {
	return o
}

func (o DeviceClaimPtrOutput) ToDeviceClaimPtrOutputWithContext(ctx context.Context) DeviceClaimPtrOutput {
	return o
}

func (o DeviceClaimPtrOutput) Elem() DeviceClaimOutput {
	return o.ApplyT(func(v *DeviceClaim) DeviceClaim {
		if v != nil {
			return *v
		}
		var ret DeviceClaim
		return ret
	}).(DeviceClaimOutput)
}

// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
func (o DeviceClaimPtrOutput) Config() DeviceClaimConfigurationArrayOutput {
	return o.ApplyT(func(v *DeviceClaim) []DeviceClaimConfiguration {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceClaimConfigurationArrayOutput)
}

// These constraints must be satisfied by the set of devices that get allocated for the claim.
func (o DeviceClaimPtrOutput) Constraints() DeviceConstraintArrayOutput {
	return o.ApplyT(func(v *DeviceClaim) []DeviceConstraint {
		if v == nil {
			return nil
		}
		return v.Constraints
	}).(DeviceConstraintArrayOutput)
}

// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
func (o DeviceClaimPtrOutput) Requests() DeviceRequestArrayOutput {
	return o.ApplyT(func(v *DeviceClaim) []DeviceRequest {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(DeviceRequestArrayOutput)
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfiguration struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfiguration `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
	Requests []string `pulumi:"requests"`
}

// DeviceClaimConfigurationInput is an input type that accepts DeviceClaimConfigurationArgs and DeviceClaimConfigurationOutput values.
// You can construct a concrete instance of `DeviceClaimConfigurationInput` via:
//
//	DeviceClaimConfigurationArgs{...}
type DeviceClaimConfigurationInput interface {
	pulumi.Input

	ToDeviceClaimConfigurationOutput() DeviceClaimConfigurationOutput
	ToDeviceClaimConfigurationOutputWithContext(context.Context) DeviceClaimConfigurationOutput
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPtrInput `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
}

func (DeviceClaimConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimConfiguration)(nil)).Elem()
}

func (i DeviceClaimConfigurationArgs) ToDeviceClaimConfigurationOutput() DeviceClaimConfigurationOutput {
	return i.ToDeviceClaimConfigurationOutputWithContext(context.Background())
}

func (i DeviceClaimConfigurationArgs) ToDeviceClaimConfigurationOutputWithContext(ctx context.Context) DeviceClaimConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimConfigurationOutput)
}

// DeviceClaimConfigurationArrayInput is an input type that accepts DeviceClaimConfigurationArray and DeviceClaimConfigurationArrayOutput values.
// You can construct a concrete instance of `DeviceClaimConfigurationArrayInput` via:
//
//	DeviceClaimConfigurationArray{ DeviceClaimConfigurationArgs{...} }
type DeviceClaimConfigurationArrayInput interface {
	pulumi.Input

	ToDeviceClaimConfigurationArrayOutput() DeviceClaimConfigurationArrayOutput
	ToDeviceClaimConfigurationArrayOutputWithContext(context.Context) DeviceClaimConfigurationArrayOutput
}

type DeviceClaimConfigurationArray []DeviceClaimConfigurationInput

func (DeviceClaimConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClaimConfiguration)(nil)).Elem()
}

func (i DeviceClaimConfigurationArray) ToDeviceClaimConfigurationArrayOutput() DeviceClaimConfigurationArrayOutput {
	return i.ToDeviceClaimConfigurationArrayOutputWithContext(context.Background())
}

func (i DeviceClaimConfigurationArray) ToDeviceClaimConfigurationArrayOutputWithContext(ctx context.Context) DeviceClaimConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimConfigurationArrayOutput)
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationOutput struct{ *pulumi.OutputState }

func (DeviceClaimConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimConfiguration)(nil)).Elem()
}

func (o DeviceClaimConfigurationOutput) ToDeviceClaimConfigurationOutput() DeviceClaimConfigurationOutput {
	return o
}

func (o DeviceClaimConfigurationOutput) ToDeviceClaimConfigurationOutputWithContext(ctx context.Context) DeviceClaimConfigurationOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceClaimConfigurationOutput) Opaque() OpaqueDeviceConfigurationPtrOutput {
	return o.ApplyT(func(v DeviceClaimConfiguration) *OpaqueDeviceConfiguration { return v.Opaque }).(OpaqueDeviceConfigurationPtrOutput)
}

// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
//
// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
func (o DeviceClaimConfigurationOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceClaimConfiguration) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

type DeviceClaimConfigurationArrayOutput struct{ *pulumi.OutputState }

func (DeviceClaimConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClaimConfiguration)(nil)).Elem()
}

func (o DeviceClaimConfigurationArrayOutput) ToDeviceClaimConfigurationArrayOutput() DeviceClaimConfigurationArrayOutput {
	return o
}

func (o DeviceClaimConfigurationArrayOutput) ToDeviceClaimConfigurationArrayOutputWithContext(ctx context.Context) DeviceClaimConfigurationArrayOutput {
	return o
}

func (o DeviceClaimConfigurationArrayOutput) Index(i pulumi.IntInput) DeviceClaimConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClaimConfiguration {
		return vs[0].([]DeviceClaimConfiguration)[vs[1].(int)]
	}).(DeviceClaimConfigurationOutput)
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationPatch struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfigurationPatch `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
	Requests []string `pulumi:"requests"`
}

// DeviceClaimConfigurationPatchInput is an input type that accepts DeviceClaimConfigurationPatchArgs and DeviceClaimConfigurationPatchOutput values.
// You can construct a concrete instance of `DeviceClaimConfigurationPatchInput` via:
//
//	DeviceClaimConfigurationPatchArgs{...}
type DeviceClaimConfigurationPatchInput interface {
	pulumi.Input

	ToDeviceClaimConfigurationPatchOutput() DeviceClaimConfigurationPatchOutput
	ToDeviceClaimConfigurationPatchOutputWithContext(context.Context) DeviceClaimConfigurationPatchOutput
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationPatchArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPatchPtrInput `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
}

func (DeviceClaimConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimConfigurationPatch)(nil)).Elem()
}

func (i DeviceClaimConfigurationPatchArgs) ToDeviceClaimConfigurationPatchOutput() DeviceClaimConfigurationPatchOutput {
	return i.ToDeviceClaimConfigurationPatchOutputWithContext(context.Background())
}

func (i DeviceClaimConfigurationPatchArgs) ToDeviceClaimConfigurationPatchOutputWithContext(ctx context.Context) DeviceClaimConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimConfigurationPatchOutput)
}

// DeviceClaimConfigurationPatchArrayInput is an input type that accepts DeviceClaimConfigurationPatchArray and DeviceClaimConfigurationPatchArrayOutput values.
// You can construct a concrete instance of `DeviceClaimConfigurationPatchArrayInput` via:
//
//	DeviceClaimConfigurationPatchArray{ DeviceClaimConfigurationPatchArgs{...} }
type DeviceClaimConfigurationPatchArrayInput interface {
	pulumi.Input

	ToDeviceClaimConfigurationPatchArrayOutput() DeviceClaimConfigurationPatchArrayOutput
	ToDeviceClaimConfigurationPatchArrayOutputWithContext(context.Context) DeviceClaimConfigurationPatchArrayOutput
}

type DeviceClaimConfigurationPatchArray []DeviceClaimConfigurationPatchInput

func (DeviceClaimConfigurationPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClaimConfigurationPatch)(nil)).Elem()
}

func (i DeviceClaimConfigurationPatchArray) ToDeviceClaimConfigurationPatchArrayOutput() DeviceClaimConfigurationPatchArrayOutput {
	return i.ToDeviceClaimConfigurationPatchArrayOutputWithContext(context.Background())
}

func (i DeviceClaimConfigurationPatchArray) ToDeviceClaimConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceClaimConfigurationPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimConfigurationPatchArrayOutput)
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationPatchOutput struct{ *pulumi.OutputState }

func (DeviceClaimConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimConfigurationPatch)(nil)).Elem()
}

func (o DeviceClaimConfigurationPatchOutput) ToDeviceClaimConfigurationPatchOutput() DeviceClaimConfigurationPatchOutput {
	return o
}

func (o DeviceClaimConfigurationPatchOutput) ToDeviceClaimConfigurationPatchOutputWithContext(ctx context.Context) DeviceClaimConfigurationPatchOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceClaimConfigurationPatchOutput) Opaque() OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ApplyT(func(v DeviceClaimConfigurationPatch) *OpaqueDeviceConfigurationPatch { return v.Opaque }).(OpaqueDeviceConfigurationPatchPtrOutput)
}

// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
//
// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the configuration applies to all subrequests.
func (o DeviceClaimConfigurationPatchOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceClaimConfigurationPatch) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

type DeviceClaimConfigurationPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceClaimConfigurationPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClaimConfigurationPatch)(nil)).Elem()
}

func (o DeviceClaimConfigurationPatchArrayOutput) ToDeviceClaimConfigurationPatchArrayOutput() DeviceClaimConfigurationPatchArrayOutput {
	return o
}

func (o DeviceClaimConfigurationPatchArrayOutput) ToDeviceClaimConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceClaimConfigurationPatchArrayOutput {
	return o
}

func (o DeviceClaimConfigurationPatchArrayOutput) Index(i pulumi.IntInput) DeviceClaimConfigurationPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClaimConfigurationPatch {
		return vs[0].([]DeviceClaimConfigurationPatch)[vs[1].(int)]
	}).(DeviceClaimConfigurationPatchOutput)
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimPatch struct {
	// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
	Config []DeviceClaimConfigurationPatch `pulumi:"config"`
	// These constraints must be satisfied by the set of devices that get allocated for the claim.
	Constraints []DeviceConstraintPatch `pulumi:"constraints"`
	// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
	Requests []DeviceRequestPatch `pulumi:"requests"`
}

// DeviceClaimPatchInput is an input type that accepts DeviceClaimPatchArgs and DeviceClaimPatchOutput values.
// You can construct a concrete instance of `DeviceClaimPatchInput` via:
//
//	DeviceClaimPatchArgs{...}
type DeviceClaimPatchInput interface {
	pulumi.Input

	ToDeviceClaimPatchOutput() DeviceClaimPatchOutput
	ToDeviceClaimPatchOutputWithContext(context.Context) DeviceClaimPatchOutput
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimPatchArgs struct {
	// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
	Config DeviceClaimConfigurationPatchArrayInput `pulumi:"config"`
	// These constraints must be satisfied by the set of devices that get allocated for the claim.
	Constraints DeviceConstraintPatchArrayInput `pulumi:"constraints"`
	// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
	Requests DeviceRequestPatchArrayInput `pulumi:"requests"`
}

func (DeviceClaimPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimPatch)(nil)).Elem()
}

func (i DeviceClaimPatchArgs) ToDeviceClaimPatchOutput() DeviceClaimPatchOutput {
	return i.ToDeviceClaimPatchOutputWithContext(context.Background())
}

func (i DeviceClaimPatchArgs) ToDeviceClaimPatchOutputWithContext(ctx context.Context) DeviceClaimPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimPatchOutput)
}

func (i DeviceClaimPatchArgs) ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput {
	return i.ToDeviceClaimPatchPtrOutputWithContext(context.Background())
}

func (i DeviceClaimPatchArgs) ToDeviceClaimPatchPtrOutputWithContext(ctx context.Context) DeviceClaimPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimPatchOutput).ToDeviceClaimPatchPtrOutputWithContext(ctx)
}

// DeviceClaimPatchPtrInput is an input type that accepts DeviceClaimPatchArgs, DeviceClaimPatchPtr and DeviceClaimPatchPtrOutput values.
// You can construct a concrete instance of `DeviceClaimPatchPtrInput` via:
//
//	        DeviceClaimPatchArgs{...}
//
//	or:
//
//	        nil
type DeviceClaimPatchPtrInput interface {
	pulumi.Input

	ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput
	ToDeviceClaimPatchPtrOutputWithContext(context.Context) DeviceClaimPatchPtrOutput
}

type deviceClaimPatchPtrType DeviceClaimPatchArgs

func DeviceClaimPatchPtr(v *DeviceClaimPatchArgs) DeviceClaimPatchPtrInput {
	return (*deviceClaimPatchPtrType)(v)
}

func (*deviceClaimPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClaimPatch)(nil)).Elem()
}

func (i *deviceClaimPatchPtrType) ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput {
	return i.ToDeviceClaimPatchPtrOutputWithContext(context.Background())
}

func (i *deviceClaimPatchPtrType) ToDeviceClaimPatchPtrOutputWithContext(ctx context.Context) DeviceClaimPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimPatchPtrOutput)
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimPatchOutput struct{ *pulumi.OutputState }

func (DeviceClaimPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimPatch)(nil)).Elem()
}

func (o DeviceClaimPatchOutput) ToDeviceClaimPatchOutput() DeviceClaimPatchOutput {
	return o
}

func (o DeviceClaimPatchOutput) ToDeviceClaimPatchOutputWithContext(ctx context.Context) DeviceClaimPatchOutput {
	return o
}

func (o DeviceClaimPatchOutput) ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput {
	return o.ToDeviceClaimPatchPtrOutputWithContext(context.Background())
}

func (o DeviceClaimPatchOutput) ToDeviceClaimPatchPtrOutputWithContext(ctx context.Context) DeviceClaimPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceClaimPatch) *DeviceClaimPatch {
		return &v
	}).(DeviceClaimPatchPtrOutput)
}

// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
func (o DeviceClaimPatchOutput) Config() DeviceClaimConfigurationPatchArrayOutput {
	return o.ApplyT(func(v DeviceClaimPatch) []DeviceClaimConfigurationPatch { return v.Config }).(DeviceClaimConfigurationPatchArrayOutput)
}

// These constraints must be satisfied by the set of devices that get allocated for the claim.
func (o DeviceClaimPatchOutput) Constraints() DeviceConstraintPatchArrayOutput {
	return o.ApplyT(func(v DeviceClaimPatch) []DeviceConstraintPatch { return v.Constraints }).(DeviceConstraintPatchArrayOutput)
}

// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
func (o DeviceClaimPatchOutput) Requests() DeviceRequestPatchArrayOutput {
	return o.ApplyT(func(v DeviceClaimPatch) []DeviceRequestPatch { return v.Requests }).(DeviceRequestPatchArrayOutput)
}

type DeviceClaimPatchPtrOutput struct{ *pulumi.OutputState }

func (DeviceClaimPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClaimPatch)(nil)).Elem()
}

func (o DeviceClaimPatchPtrOutput) ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput {
	return o
}

func (o DeviceClaimPatchPtrOutput) ToDeviceClaimPatchPtrOutputWithContext(ctx context.Context) DeviceClaimPatchPtrOutput {
	return o
}

func (o DeviceClaimPatchPtrOutput) Elem() DeviceClaimPatchOutput {
	return o.ApplyT(func(v *DeviceClaimPatch) DeviceClaimPatch {
		if v != nil {
			return *v
		}
		var ret DeviceClaimPatch
		return ret
	}).(DeviceClaimPatchOutput)
}

// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
func (o DeviceClaimPatchPtrOutput) Config() DeviceClaimConfigurationPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClaimPatch) []DeviceClaimConfigurationPatch {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceClaimConfigurationPatchArrayOutput)
}

// These constraints must be satisfied by the set of devices that get allocated for the claim.
func (o DeviceClaimPatchPtrOutput) Constraints() DeviceConstraintPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClaimPatch) []DeviceConstraintPatch {
		if v == nil {
			return nil
		}
		return v.Constraints
	}).(DeviceConstraintPatchArrayOutput)
}

// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
func (o DeviceClaimPatchPtrOutput) Requests() DeviceRequestPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClaimPatch) []DeviceRequestPatch {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(DeviceRequestPatchArrayOutput)
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceClassSpec `pulumi:"spec"`
}

// DeviceClassTypeInput is an input type that accepts DeviceClassTypeArgs and DeviceClassTypeOutput values.
// You can construct a concrete instance of `DeviceClassTypeInput` via:
//
//	DeviceClassTypeArgs{...}
type DeviceClassTypeInput interface {
	pulumi.Input

	ToDeviceClassTypeOutput() DeviceClassTypeOutput
	ToDeviceClassTypeOutputWithContext(context.Context) DeviceClassTypeOutput
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceClassSpecInput `pulumi:"spec"`
}

func (DeviceClassTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassType)(nil)).Elem()
}

func (i DeviceClassTypeArgs) ToDeviceClassTypeOutput() DeviceClassTypeOutput {
	return i.ToDeviceClassTypeOutputWithContext(context.Background())
}

func (i DeviceClassTypeArgs) ToDeviceClassTypeOutputWithContext(ctx context.Context) DeviceClassTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassTypeOutput)
}

// DeviceClassTypeArrayInput is an input type that accepts DeviceClassTypeArray and DeviceClassTypeArrayOutput values.
// You can construct a concrete instance of `DeviceClassTypeArrayInput` via:
//
//	DeviceClassTypeArray{ DeviceClassTypeArgs{...} }
type DeviceClassTypeArrayInput interface {
	pulumi.Input

	ToDeviceClassTypeArrayOutput() DeviceClassTypeArrayOutput
	ToDeviceClassTypeArrayOutputWithContext(context.Context) DeviceClassTypeArrayOutput
}

type DeviceClassTypeArray []DeviceClassTypeInput

func (DeviceClassTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassType)(nil)).Elem()
}

func (i DeviceClassTypeArray) ToDeviceClassTypeArrayOutput() DeviceClassTypeArrayOutput {
	return i.ToDeviceClassTypeArrayOutputWithContext(context.Background())
}

func (i DeviceClassTypeArray) ToDeviceClassTypeArrayOutputWithContext(ctx context.Context) DeviceClassTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassTypeArrayOutput)
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassTypeOutput struct{ *pulumi.OutputState }

func (DeviceClassTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassType)(nil)).Elem()
}

func (o DeviceClassTypeOutput) ToDeviceClassTypeOutput() DeviceClassTypeOutput {
	return o
}

func (o DeviceClassTypeOutput) ToDeviceClassTypeOutputWithContext(ctx context.Context) DeviceClassTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceClassTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceClassTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o DeviceClassTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v DeviceClassType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec defines what can be allocated and how to configure it.
//
// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
//
// Changing the spec automatically increments the metadata.generation number.
func (o DeviceClassTypeOutput) Spec() DeviceClassSpecOutput {
	return o.ApplyT(func(v DeviceClassType) DeviceClassSpec { return v.Spec }).(DeviceClassSpecOutput)
}

type DeviceClassTypeArrayOutput struct{ *pulumi.OutputState }

func (DeviceClassTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassType)(nil)).Elem()
}

func (o DeviceClassTypeArrayOutput) ToDeviceClassTypeArrayOutput() DeviceClassTypeArrayOutput {
	return o
}

func (o DeviceClassTypeArrayOutput) ToDeviceClassTypeArrayOutputWithContext(ctx context.Context) DeviceClassTypeArrayOutput {
	return o
}

func (o DeviceClassTypeArrayOutput) Index(i pulumi.IntInput) DeviceClassTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClassType {
		return vs[0].([]DeviceClassType)[vs[1].(int)]
	}).(DeviceClassTypeOutput)
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfiguration struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfiguration `pulumi:"opaque"`
}

// DeviceClassConfigurationInput is an input type that accepts DeviceClassConfigurationArgs and DeviceClassConfigurationOutput values.
// You can construct a concrete instance of `DeviceClassConfigurationInput` via:
//
//	DeviceClassConfigurationArgs{...}
type DeviceClassConfigurationInput interface {
	pulumi.Input

	ToDeviceClassConfigurationOutput() DeviceClassConfigurationOutput
	ToDeviceClassConfigurationOutputWithContext(context.Context) DeviceClassConfigurationOutput
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPtrInput `pulumi:"opaque"`
}

func (DeviceClassConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassConfiguration)(nil)).Elem()
}

func (i DeviceClassConfigurationArgs) ToDeviceClassConfigurationOutput() DeviceClassConfigurationOutput {
	return i.ToDeviceClassConfigurationOutputWithContext(context.Background())
}

func (i DeviceClassConfigurationArgs) ToDeviceClassConfigurationOutputWithContext(ctx context.Context) DeviceClassConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassConfigurationOutput)
}

// DeviceClassConfigurationArrayInput is an input type that accepts DeviceClassConfigurationArray and DeviceClassConfigurationArrayOutput values.
// You can construct a concrete instance of `DeviceClassConfigurationArrayInput` via:
//
//	DeviceClassConfigurationArray{ DeviceClassConfigurationArgs{...} }
type DeviceClassConfigurationArrayInput interface {
	pulumi.Input

	ToDeviceClassConfigurationArrayOutput() DeviceClassConfigurationArrayOutput
	ToDeviceClassConfigurationArrayOutputWithContext(context.Context) DeviceClassConfigurationArrayOutput
}

type DeviceClassConfigurationArray []DeviceClassConfigurationInput

func (DeviceClassConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassConfiguration)(nil)).Elem()
}

func (i DeviceClassConfigurationArray) ToDeviceClassConfigurationArrayOutput() DeviceClassConfigurationArrayOutput {
	return i.ToDeviceClassConfigurationArrayOutputWithContext(context.Background())
}

func (i DeviceClassConfigurationArray) ToDeviceClassConfigurationArrayOutputWithContext(ctx context.Context) DeviceClassConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassConfigurationArrayOutput)
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationOutput struct{ *pulumi.OutputState }

func (DeviceClassConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassConfiguration)(nil)).Elem()
}

func (o DeviceClassConfigurationOutput) ToDeviceClassConfigurationOutput() DeviceClassConfigurationOutput {
	return o
}

func (o DeviceClassConfigurationOutput) ToDeviceClassConfigurationOutputWithContext(ctx context.Context) DeviceClassConfigurationOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceClassConfigurationOutput) Opaque() OpaqueDeviceConfigurationPtrOutput {
	return o.ApplyT(func(v DeviceClassConfiguration) *OpaqueDeviceConfiguration { return v.Opaque }).(OpaqueDeviceConfigurationPtrOutput)
}

type DeviceClassConfigurationArrayOutput struct{ *pulumi.OutputState }

func (DeviceClassConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassConfiguration)(nil)).Elem()
}

func (o DeviceClassConfigurationArrayOutput) ToDeviceClassConfigurationArrayOutput() DeviceClassConfigurationArrayOutput {
	return o
}

func (o DeviceClassConfigurationArrayOutput) ToDeviceClassConfigurationArrayOutputWithContext(ctx context.Context) DeviceClassConfigurationArrayOutput {
	return o
}

func (o DeviceClassConfigurationArrayOutput) Index(i pulumi.IntInput) DeviceClassConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClassConfiguration {
		return vs[0].([]DeviceClassConfiguration)[vs[1].(int)]
	}).(DeviceClassConfigurationOutput)
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationPatch struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfigurationPatch `pulumi:"opaque"`
}

// DeviceClassConfigurationPatchInput is an input type that accepts DeviceClassConfigurationPatchArgs and DeviceClassConfigurationPatchOutput values.
// You can construct a concrete instance of `DeviceClassConfigurationPatchInput` via:
//
//	DeviceClassConfigurationPatchArgs{...}
type DeviceClassConfigurationPatchInput interface {
	pulumi.Input

	ToDeviceClassConfigurationPatchOutput() DeviceClassConfigurationPatchOutput
	ToDeviceClassConfigurationPatchOutputWithContext(context.Context) DeviceClassConfigurationPatchOutput
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationPatchArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPatchPtrInput `pulumi:"opaque"`
}

func (DeviceClassConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassConfigurationPatch)(nil)).Elem()
}

func (i DeviceClassConfigurationPatchArgs) ToDeviceClassConfigurationPatchOutput() DeviceClassConfigurationPatchOutput {
	return i.ToDeviceClassConfigurationPatchOutputWithContext(context.Background())
}

func (i DeviceClassConfigurationPatchArgs) ToDeviceClassConfigurationPatchOutputWithContext(ctx context.Context) DeviceClassConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassConfigurationPatchOutput)
}

// DeviceClassConfigurationPatchArrayInput is an input type that accepts DeviceClassConfigurationPatchArray and DeviceClassConfigurationPatchArrayOutput values.
// You can construct a concrete instance of `DeviceClassConfigurationPatchArrayInput` via:
//
//	DeviceClassConfigurationPatchArray{ DeviceClassConfigurationPatchArgs{...} }
type DeviceClassConfigurationPatchArrayInput interface {
	pulumi.Input

	ToDeviceClassConfigurationPatchArrayOutput() DeviceClassConfigurationPatchArrayOutput
	ToDeviceClassConfigurationPatchArrayOutputWithContext(context.Context) DeviceClassConfigurationPatchArrayOutput
}

type DeviceClassConfigurationPatchArray []DeviceClassConfigurationPatchInput

func (DeviceClassConfigurationPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassConfigurationPatch)(nil)).Elem()
}

func (i DeviceClassConfigurationPatchArray) ToDeviceClassConfigurationPatchArrayOutput() DeviceClassConfigurationPatchArrayOutput {
	return i.ToDeviceClassConfigurationPatchArrayOutputWithContext(context.Background())
}

func (i DeviceClassConfigurationPatchArray) ToDeviceClassConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceClassConfigurationPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassConfigurationPatchArrayOutput)
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationPatchOutput struct{ *pulumi.OutputState }

func (DeviceClassConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassConfigurationPatch)(nil)).Elem()
}

func (o DeviceClassConfigurationPatchOutput) ToDeviceClassConfigurationPatchOutput() DeviceClassConfigurationPatchOutput {
	return o
}

func (o DeviceClassConfigurationPatchOutput) ToDeviceClassConfigurationPatchOutputWithContext(ctx context.Context) DeviceClassConfigurationPatchOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceClassConfigurationPatchOutput) Opaque() OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ApplyT(func(v DeviceClassConfigurationPatch) *OpaqueDeviceConfigurationPatch { return v.Opaque }).(OpaqueDeviceConfigurationPatchPtrOutput)
}

type DeviceClassConfigurationPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceClassConfigurationPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassConfigurationPatch)(nil)).Elem()
}

func (o DeviceClassConfigurationPatchArrayOutput) ToDeviceClassConfigurationPatchArrayOutput() DeviceClassConfigurationPatchArrayOutput {
	return o
}

func (o DeviceClassConfigurationPatchArrayOutput) ToDeviceClassConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceClassConfigurationPatchArrayOutput {
	return o
}

func (o DeviceClassConfigurationPatchArrayOutput) Index(i pulumi.IntInput) DeviceClassConfigurationPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClassConfigurationPatch {
		return vs[0].([]DeviceClassConfigurationPatch)[vs[1].(int)]
	}).(DeviceClassConfigurationPatchOutput)
}

// DeviceClassList is a collection of classes.
type DeviceClassListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of resource classes.
	Items []DeviceClassType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// DeviceClassListTypeInput is an input type that accepts DeviceClassListTypeArgs and DeviceClassListTypeOutput values.
// You can construct a concrete instance of `DeviceClassListTypeInput` via:
//
//	DeviceClassListTypeArgs{...}
type DeviceClassListTypeInput interface {
	pulumi.Input

	ToDeviceClassListTypeOutput() DeviceClassListTypeOutput
	ToDeviceClassListTypeOutputWithContext(context.Context) DeviceClassListTypeOutput
}

// DeviceClassList is a collection of classes.
type DeviceClassListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of resource classes.
	Items DeviceClassTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (DeviceClassListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassListType)(nil)).Elem()
}

func (i DeviceClassListTypeArgs) ToDeviceClassListTypeOutput() DeviceClassListTypeOutput {
	return i.ToDeviceClassListTypeOutputWithContext(context.Background())
}

func (i DeviceClassListTypeArgs) ToDeviceClassListTypeOutputWithContext(ctx context.Context) DeviceClassListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassListTypeOutput)
}

// DeviceClassList is a collection of classes.
type DeviceClassListTypeOutput struct{ *pulumi.OutputState }

func (DeviceClassListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassListType)(nil)).Elem()
}

func (o DeviceClassListTypeOutput) ToDeviceClassListTypeOutput() DeviceClassListTypeOutput {
	return o
}

func (o DeviceClassListTypeOutput) ToDeviceClassListTypeOutputWithContext(ctx context.Context) DeviceClassListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceClassListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of resource classes.
func (o DeviceClassListTypeOutput) Items() DeviceClassTypeArrayOutput {
	return o.ApplyT(func(v DeviceClassListType) []DeviceClassType { return v.Items }).(DeviceClassTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceClassListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o DeviceClassListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v DeviceClassListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec *DeviceClassSpecPatch `pulumi:"spec"`
}

// DeviceClassPatchTypeInput is an input type that accepts DeviceClassPatchTypeArgs and DeviceClassPatchTypeOutput values.
// You can construct a concrete instance of `DeviceClassPatchTypeInput` via:
//
//	DeviceClassPatchTypeArgs{...}
type DeviceClassPatchTypeInput interface {
	pulumi.Input

	ToDeviceClassPatchTypeOutput() DeviceClassPatchTypeOutput
	ToDeviceClassPatchTypeOutputWithContext(context.Context) DeviceClassPatchTypeOutput
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceClassSpecPatchPtrInput `pulumi:"spec"`
}

func (DeviceClassPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassPatchType)(nil)).Elem()
}

func (i DeviceClassPatchTypeArgs) ToDeviceClassPatchTypeOutput() DeviceClassPatchTypeOutput {
	return i.ToDeviceClassPatchTypeOutputWithContext(context.Background())
}

func (i DeviceClassPatchTypeArgs) ToDeviceClassPatchTypeOutputWithContext(ctx context.Context) DeviceClassPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassPatchTypeOutput)
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassPatchTypeOutput struct{ *pulumi.OutputState }

func (DeviceClassPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassPatchType)(nil)).Elem()
}

func (o DeviceClassPatchTypeOutput) ToDeviceClassPatchTypeOutput() DeviceClassPatchTypeOutput {
	return o
}

func (o DeviceClassPatchTypeOutput) ToDeviceClassPatchTypeOutputWithContext(ctx context.Context) DeviceClassPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceClassPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceClassPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o DeviceClassPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v DeviceClassPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec defines what can be allocated and how to configure it.
//
// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
//
// Changing the spec automatically increments the metadata.generation number.
func (o DeviceClassPatchTypeOutput) Spec() DeviceClassSpecPatchPtrOutput {
	return o.ApplyT(func(v DeviceClassPatchType) *DeviceClassSpecPatch { return v.Spec }).(DeviceClassSpecPatchPtrOutput)
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpec struct {
	// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
	//
	// They are passed to the driver, but are not considered while allocating the claim.
	Config []DeviceClassConfiguration `pulumi:"config"`
	// Each selector must be satisfied by a device which is claimed via this class.
	Selectors []DeviceSelector `pulumi:"selectors"`
}

// DeviceClassSpecInput is an input type that accepts DeviceClassSpecArgs and DeviceClassSpecOutput values.
// You can construct a concrete instance of `DeviceClassSpecInput` via:
//
//	DeviceClassSpecArgs{...}
type DeviceClassSpecInput interface {
	pulumi.Input

	ToDeviceClassSpecOutput() DeviceClassSpecOutput
	ToDeviceClassSpecOutputWithContext(context.Context) DeviceClassSpecOutput
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecArgs struct {
	// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
	//
	// They are passed to the driver, but are not considered while allocating the claim.
	Config DeviceClassConfigurationArrayInput `pulumi:"config"`
	// Each selector must be satisfied by a device which is claimed via this class.
	Selectors DeviceSelectorArrayInput `pulumi:"selectors"`
}

func (DeviceClassSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassSpec)(nil)).Elem()
}

func (i DeviceClassSpecArgs) ToDeviceClassSpecOutput() DeviceClassSpecOutput {
	return i.ToDeviceClassSpecOutputWithContext(context.Background())
}

func (i DeviceClassSpecArgs) ToDeviceClassSpecOutputWithContext(ctx context.Context) DeviceClassSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassSpecOutput)
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecOutput struct{ *pulumi.OutputState }

func (DeviceClassSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassSpec)(nil)).Elem()
}

func (o DeviceClassSpecOutput) ToDeviceClassSpecOutput() DeviceClassSpecOutput {
	return o
}

func (o DeviceClassSpecOutput) ToDeviceClassSpecOutputWithContext(ctx context.Context) DeviceClassSpecOutput {
	return o
}

// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
//
// They are passed to the driver, but are not considered while allocating the claim.
func (o DeviceClassSpecOutput) Config() DeviceClassConfigurationArrayOutput {
	return o.ApplyT(func(v DeviceClassSpec) []DeviceClassConfiguration { return v.Config }).(DeviceClassConfigurationArrayOutput)
}

// Each selector must be satisfied by a device which is claimed via this class.
func (o DeviceClassSpecOutput) Selectors() DeviceSelectorArrayOutput {
	return o.ApplyT(func(v DeviceClassSpec) []DeviceSelector { return v.Selectors }).(DeviceSelectorArrayOutput)
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecPatch struct {
	// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
	//
	// They are passed to the driver, but are not considered while allocating the claim.
	Config []DeviceClassConfigurationPatch `pulumi:"config"`
	// Each selector must be satisfied by a device which is claimed via this class.
	Selectors []DeviceSelectorPatch `pulumi:"selectors"`
}

// DeviceClassSpecPatchInput is an input type that accepts DeviceClassSpecPatchArgs and DeviceClassSpecPatchOutput values.
// You can construct a concrete instance of `DeviceClassSpecPatchInput` via:
//
//	DeviceClassSpecPatchArgs{...}
type DeviceClassSpecPatchInput interface {
	pulumi.Input

	ToDeviceClassSpecPatchOutput() DeviceClassSpecPatchOutput
	ToDeviceClassSpecPatchOutputWithContext(context.Context) DeviceClassSpecPatchOutput
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecPatchArgs struct {
	// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
	//
	// They are passed to the driver, but are not considered while allocating the claim.
	Config DeviceClassConfigurationPatchArrayInput `pulumi:"config"`
	// Each selector must be satisfied by a device which is claimed via this class.
	Selectors DeviceSelectorPatchArrayInput `pulumi:"selectors"`
}

func (DeviceClassSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassSpecPatch)(nil)).Elem()
}

func (i DeviceClassSpecPatchArgs) ToDeviceClassSpecPatchOutput() DeviceClassSpecPatchOutput {
	return i.ToDeviceClassSpecPatchOutputWithContext(context.Background())
}

func (i DeviceClassSpecPatchArgs) ToDeviceClassSpecPatchOutputWithContext(ctx context.Context) DeviceClassSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassSpecPatchOutput)
}

func (i DeviceClassSpecPatchArgs) ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput {
	return i.ToDeviceClassSpecPatchPtrOutputWithContext(context.Background())
}

func (i DeviceClassSpecPatchArgs) ToDeviceClassSpecPatchPtrOutputWithContext(ctx context.Context) DeviceClassSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassSpecPatchOutput).ToDeviceClassSpecPatchPtrOutputWithContext(ctx)
}

// DeviceClassSpecPatchPtrInput is an input type that accepts DeviceClassSpecPatchArgs, DeviceClassSpecPatchPtr and DeviceClassSpecPatchPtrOutput values.
// You can construct a concrete instance of `DeviceClassSpecPatchPtrInput` via:
//
//	        DeviceClassSpecPatchArgs{...}
//
//	or:
//
//	        nil
type DeviceClassSpecPatchPtrInput interface {
	pulumi.Input

	ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput
	ToDeviceClassSpecPatchPtrOutputWithContext(context.Context) DeviceClassSpecPatchPtrOutput
}

type deviceClassSpecPatchPtrType DeviceClassSpecPatchArgs

func DeviceClassSpecPatchPtr(v *DeviceClassSpecPatchArgs) DeviceClassSpecPatchPtrInput {
	return (*deviceClassSpecPatchPtrType)(v)
}

func (*deviceClassSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClassSpecPatch)(nil)).Elem()
}

func (i *deviceClassSpecPatchPtrType) ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput {
	return i.ToDeviceClassSpecPatchPtrOutputWithContext(context.Background())
}

func (i *deviceClassSpecPatchPtrType) ToDeviceClassSpecPatchPtrOutputWithContext(ctx context.Context) DeviceClassSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassSpecPatchPtrOutput)
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecPatchOutput struct{ *pulumi.OutputState }

func (DeviceClassSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassSpecPatch)(nil)).Elem()
}

func (o DeviceClassSpecPatchOutput) ToDeviceClassSpecPatchOutput() DeviceClassSpecPatchOutput {
	return o
}

func (o DeviceClassSpecPatchOutput) ToDeviceClassSpecPatchOutputWithContext(ctx context.Context) DeviceClassSpecPatchOutput {
	return o
}

func (o DeviceClassSpecPatchOutput) ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput {
	return o.ToDeviceClassSpecPatchPtrOutputWithContext(context.Background())
}

func (o DeviceClassSpecPatchOutput) ToDeviceClassSpecPatchPtrOutputWithContext(ctx context.Context) DeviceClassSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceClassSpecPatch) *DeviceClassSpecPatch {
		return &v
	}).(DeviceClassSpecPatchPtrOutput)
}

// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
//
// They are passed to the driver, but are not considered while allocating the claim.
func (o DeviceClassSpecPatchOutput) Config() DeviceClassConfigurationPatchArrayOutput {
	return o.ApplyT(func(v DeviceClassSpecPatch) []DeviceClassConfigurationPatch { return v.Config }).(DeviceClassConfigurationPatchArrayOutput)
}

// Each selector must be satisfied by a device which is claimed via this class.
func (o DeviceClassSpecPatchOutput) Selectors() DeviceSelectorPatchArrayOutput {
	return o.ApplyT(func(v DeviceClassSpecPatch) []DeviceSelectorPatch { return v.Selectors }).(DeviceSelectorPatchArrayOutput)
}

type DeviceClassSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (DeviceClassSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClassSpecPatch)(nil)).Elem()
}

func (o DeviceClassSpecPatchPtrOutput) ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput {
	return o
}

func (o DeviceClassSpecPatchPtrOutput) ToDeviceClassSpecPatchPtrOutputWithContext(ctx context.Context) DeviceClassSpecPatchPtrOutput {
	return o
}

func (o DeviceClassSpecPatchPtrOutput) Elem() DeviceClassSpecPatchOutput {
	return o.ApplyT(func(v *DeviceClassSpecPatch) DeviceClassSpecPatch {
		if v != nil {
			return *v
		}
		var ret DeviceClassSpecPatch
		return ret
	}).(DeviceClassSpecPatchOutput)
}

// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
//
// They are passed to the driver, but are not considered while allocating the claim.
func (o DeviceClassSpecPatchPtrOutput) Config() DeviceClassConfigurationPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClassSpecPatch) []DeviceClassConfigurationPatch {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceClassConfigurationPatchArrayOutput)
}

// Each selector must be satisfied by a device which is claimed via this class.
func (o DeviceClassSpecPatchPtrOutput) Selectors() DeviceSelectorPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClassSpecPatch) []DeviceSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selectors
	}).(DeviceSelectorPatchArrayOutput)
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraint struct {
	// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
	//
	// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
	//
	// Must include the domain qualifier.
	MatchAttribute *string `pulumi:"matchAttribute"`
	// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the constraint applies to all subrequests.
	Requests []string `pulumi:"requests"`
}

// DeviceConstraintInput is an input type that accepts DeviceConstraintArgs and DeviceConstraintOutput values.
// You can construct a concrete instance of `DeviceConstraintInput` via:
//
//	DeviceConstraintArgs{...}
type DeviceConstraintInput interface {
	pulumi.Input

	ToDeviceConstraintOutput() DeviceConstraintOutput
	ToDeviceConstraintOutputWithContext(context.Context) DeviceConstraintOutput
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintArgs struct {
	// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
	//
	// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
	//
	// Must include the domain qualifier.
	MatchAttribute pulumi.StringPtrInput `pulumi:"matchAttribute"`
	// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the constraint applies to all subrequests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
}

func (DeviceConstraintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceConstraint)(nil)).Elem()
}

func (i DeviceConstraintArgs) ToDeviceConstraintOutput() DeviceConstraintOutput {
	return i.ToDeviceConstraintOutputWithContext(context.Background())
}

func (i DeviceConstraintArgs) ToDeviceConstraintOutputWithContext(ctx context.Context) DeviceConstraintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceConstraintOutput)
}

// DeviceConstraintArrayInput is an input type that accepts DeviceConstraintArray and DeviceConstraintArrayOutput values.
// You can construct a concrete instance of `DeviceConstraintArrayInput` via:
//
//	DeviceConstraintArray{ DeviceConstraintArgs{...} }
type DeviceConstraintArrayInput interface {
	pulumi.Input

	ToDeviceConstraintArrayOutput() DeviceConstraintArrayOutput
	ToDeviceConstraintArrayOutputWithContext(context.Context) DeviceConstraintArrayOutput
}

type DeviceConstraintArray []DeviceConstraintInput

func (DeviceConstraintArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceConstraint)(nil)).Elem()
}

func (i DeviceConstraintArray) ToDeviceConstraintArrayOutput() DeviceConstraintArrayOutput {
	return i.ToDeviceConstraintArrayOutputWithContext(context.Background())
}

func (i DeviceConstraintArray) ToDeviceConstraintArrayOutputWithContext(ctx context.Context) DeviceConstraintArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceConstraintArrayOutput)
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintOutput struct{ *pulumi.OutputState }

func (DeviceConstraintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceConstraint)(nil)).Elem()
}

func (o DeviceConstraintOutput) ToDeviceConstraintOutput() DeviceConstraintOutput {
	return o
}

func (o DeviceConstraintOutput) ToDeviceConstraintOutputWithContext(ctx context.Context) DeviceConstraintOutput {
	return o
}

// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
//
// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
//
// Must include the domain qualifier.
func (o DeviceConstraintOutput) MatchAttribute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceConstraint) *string { return v.MatchAttribute }).(pulumi.StringPtrOutput)
}

// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
//
// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the constraint applies to all subrequests.
func (o DeviceConstraintOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceConstraint) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

type DeviceConstraintArrayOutput struct{ *pulumi.OutputState }

func (DeviceConstraintArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceConstraint)(nil)).Elem()
}

func (o DeviceConstraintArrayOutput) ToDeviceConstraintArrayOutput() DeviceConstraintArrayOutput {
	return o
}

func (o DeviceConstraintArrayOutput) ToDeviceConstraintArrayOutputWithContext(ctx context.Context) DeviceConstraintArrayOutput {
	return o
}

func (o DeviceConstraintArrayOutput) Index(i pulumi.IntInput) DeviceConstraintOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceConstraint {
		return vs[0].([]DeviceConstraint)[vs[1].(int)]
	}).(DeviceConstraintOutput)
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintPatch struct {
	// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
	//
	// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
	//
	// Must include the domain qualifier.
	MatchAttribute *string `pulumi:"matchAttribute"`
	// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the constraint applies to all subrequests.
	Requests []string `pulumi:"requests"`
}

// DeviceConstraintPatchInput is an input type that accepts DeviceConstraintPatchArgs and DeviceConstraintPatchOutput values.
// You can construct a concrete instance of `DeviceConstraintPatchInput` via:
//
//	DeviceConstraintPatchArgs{...}
type DeviceConstraintPatchInput interface {
	pulumi.Input

	ToDeviceConstraintPatchOutput() DeviceConstraintPatchOutput
	ToDeviceConstraintPatchOutputWithContext(context.Context) DeviceConstraintPatchOutput
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintPatchArgs struct {
	// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
	//
	// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
	//
	// Must include the domain qualifier.
	MatchAttribute pulumi.StringPtrInput `pulumi:"matchAttribute"`
	// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
	//
	// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the constraint applies to all subrequests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
}

func (DeviceConstraintPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceConstraintPatch)(nil)).Elem()
}

func (i DeviceConstraintPatchArgs) ToDeviceConstraintPatchOutput() DeviceConstraintPatchOutput {
	return i.ToDeviceConstraintPatchOutputWithContext(context.Background())
}

func (i DeviceConstraintPatchArgs) ToDeviceConstraintPatchOutputWithContext(ctx context.Context) DeviceConstraintPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceConstraintPatchOutput)
}

// DeviceConstraintPatchArrayInput is an input type that accepts DeviceConstraintPatchArray and DeviceConstraintPatchArrayOutput values.
// You can construct a concrete instance of `DeviceConstraintPatchArrayInput` via:
//
//	DeviceConstraintPatchArray{ DeviceConstraintPatchArgs{...} }
type DeviceConstraintPatchArrayInput interface {
	pulumi.Input

	ToDeviceConstraintPatchArrayOutput() DeviceConstraintPatchArrayOutput
	ToDeviceConstraintPatchArrayOutputWithContext(context.Context) DeviceConstraintPatchArrayOutput
}

type DeviceConstraintPatchArray []DeviceConstraintPatchInput

func (DeviceConstraintPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceConstraintPatch)(nil)).Elem()
}

func (i DeviceConstraintPatchArray) ToDeviceConstraintPatchArrayOutput() DeviceConstraintPatchArrayOutput {
	return i.ToDeviceConstraintPatchArrayOutputWithContext(context.Background())
}

func (i DeviceConstraintPatchArray) ToDeviceConstraintPatchArrayOutputWithContext(ctx context.Context) DeviceConstraintPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceConstraintPatchArrayOutput)
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintPatchOutput struct{ *pulumi.OutputState }

func (DeviceConstraintPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceConstraintPatch)(nil)).Elem()
}

func (o DeviceConstraintPatchOutput) ToDeviceConstraintPatchOutput() DeviceConstraintPatchOutput {
	return o
}

func (o DeviceConstraintPatchOutput) ToDeviceConstraintPatchOutputWithContext(ctx context.Context) DeviceConstraintPatchOutput {
	return o
}

// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
//
// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
//
// Must include the domain qualifier.
func (o DeviceConstraintPatchOutput) MatchAttribute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceConstraintPatch) *string { return v.MatchAttribute }).(pulumi.StringPtrOutput)
}

// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
//
// References to subrequests must include the name of the main request and may include the subrequest using the format <main request>[/<subrequest>]. If just the main request is given, the constraint applies to all subrequests.
func (o DeviceConstraintPatchOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceConstraintPatch) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

type DeviceConstraintPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceConstraintPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceConstraintPatch)(nil)).Elem()
}

func (o DeviceConstraintPatchArrayOutput) ToDeviceConstraintPatchArrayOutput() DeviceConstraintPatchArrayOutput {
	return o
}

func (o DeviceConstraintPatchArrayOutput) ToDeviceConstraintPatchArrayOutputWithContext(ctx context.Context) DeviceConstraintPatchArrayOutput {
	return o
}

func (o DeviceConstraintPatchArrayOutput) Index(i pulumi.IntInput) DeviceConstraintPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceConstraintPatch {
		return vs[0].([]DeviceConstraintPatch)[vs[1].(int)]
	}).(DeviceConstraintPatchOutput)
}

// DeviceCounterConsumption defines a set of counters that a device will consume from a CounterSet.
type DeviceCounterConsumption struct {
	// CounterSet is the name of the set from which the counters defined will be consumed.
	CounterSet string `pulumi:"counterSet"`
	// Counters defines the counters that will be consumed by the device.
	//
	// The maximum number counters in a device is 32. In addition, the maximum number of all counters in all devices is 1024 (for example, 64 devices with 16 counters each).
	Counters map[string]Counter `pulumi:"counters"`
}

// DeviceCounterConsumptionInput is an input type that accepts DeviceCounterConsumptionArgs and DeviceCounterConsumptionOutput values.
// You can construct a concrete instance of `DeviceCounterConsumptionInput` via:
//
//	DeviceCounterConsumptionArgs{...}
type DeviceCounterConsumptionInput interface {
	pulumi.Input

	ToDeviceCounterConsumptionOutput() DeviceCounterConsumptionOutput
	ToDeviceCounterConsumptionOutputWithContext(context.Context) DeviceCounterConsumptionOutput
}

// DeviceCounterConsumption defines a set of counters that a device will consume from a CounterSet.
type DeviceCounterConsumptionArgs struct {
	// CounterSet is the name of the set from which the counters defined will be consumed.
	CounterSet pulumi.StringInput `pulumi:"counterSet"`
	// Counters defines the counters that will be consumed by the device.
	//
	// The maximum number counters in a device is 32. In addition, the maximum number of all counters in all devices is 1024 (for example, 64 devices with 16 counters each).
	Counters CounterMapInput `pulumi:"counters"`
}

func (DeviceCounterConsumptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceCounterConsumption)(nil)).Elem()
}

func (i DeviceCounterConsumptionArgs) ToDeviceCounterConsumptionOutput() DeviceCounterConsumptionOutput {
	return i.ToDeviceCounterConsumptionOutputWithContext(context.Background())
}

func (i DeviceCounterConsumptionArgs) ToDeviceCounterConsumptionOutputWithContext(ctx context.Context) DeviceCounterConsumptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceCounterConsumptionOutput)
}

// DeviceCounterConsumptionArrayInput is an input type that accepts DeviceCounterConsumptionArray and DeviceCounterConsumptionArrayOutput values.
// You can construct a concrete instance of `DeviceCounterConsumptionArrayInput` via:
//
//	DeviceCounterConsumptionArray{ DeviceCounterConsumptionArgs{...} }
type DeviceCounterConsumptionArrayInput interface {
	pulumi.Input

	ToDeviceCounterConsumptionArrayOutput() DeviceCounterConsumptionArrayOutput
	ToDeviceCounterConsumptionArrayOutputWithContext(context.Context) DeviceCounterConsumptionArrayOutput
}

type DeviceCounterConsumptionArray []DeviceCounterConsumptionInput

func (DeviceCounterConsumptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceCounterConsumption)(nil)).Elem()
}

func (i DeviceCounterConsumptionArray) ToDeviceCounterConsumptionArrayOutput() DeviceCounterConsumptionArrayOutput {
	return i.ToDeviceCounterConsumptionArrayOutputWithContext(context.Background())
}

func (i DeviceCounterConsumptionArray) ToDeviceCounterConsumptionArrayOutputWithContext(ctx context.Context) DeviceCounterConsumptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceCounterConsumptionArrayOutput)
}

// DeviceCounterConsumption defines a set of counters that a device will consume from a CounterSet.
type DeviceCounterConsumptionOutput struct{ *pulumi.OutputState }

func (DeviceCounterConsumptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceCounterConsumption)(nil)).Elem()
}

func (o DeviceCounterConsumptionOutput) ToDeviceCounterConsumptionOutput() DeviceCounterConsumptionOutput {
	return o
}

func (o DeviceCounterConsumptionOutput) ToDeviceCounterConsumptionOutputWithContext(ctx context.Context) DeviceCounterConsumptionOutput {
	return o
}

// CounterSet is the name of the set from which the counters defined will be consumed.
func (o DeviceCounterConsumptionOutput) CounterSet() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceCounterConsumption) string { return v.CounterSet }).(pulumi.StringOutput)
}

// Counters defines the counters that will be consumed by the device.
//
// The maximum number counters in a device is 32. In addition, the maximum number of all counters in all devices is 1024 (for example, 64 devices with 16 counters each).
func (o DeviceCounterConsumptionOutput) Counters() CounterMapOutput {
	return o.ApplyT(func(v DeviceCounterConsumption) map[string]Counter { return v.Counters }).(CounterMapOutput)
}

type DeviceCounterConsumptionArrayOutput struct{ *pulumi.OutputState }

func (DeviceCounterConsumptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceCounterConsumption)(nil)).Elem()
}

func (o DeviceCounterConsumptionArrayOutput) ToDeviceCounterConsumptionArrayOutput() DeviceCounterConsumptionArrayOutput {
	return o
}

func (o DeviceCounterConsumptionArrayOutput) ToDeviceCounterConsumptionArrayOutputWithContext(ctx context.Context) DeviceCounterConsumptionArrayOutput {
	return o
}

func (o DeviceCounterConsumptionArrayOutput) Index(i pulumi.IntInput) DeviceCounterConsumptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceCounterConsumption {
		return vs[0].([]DeviceCounterConsumption)[vs[1].(int)]
	}).(DeviceCounterConsumptionOutput)
}

// DeviceCounterConsumption defines a set of counters that a device will consume from a CounterSet.
type DeviceCounterConsumptionPatch struct {
	// CounterSet is the name of the set from which the counters defined will be consumed.
	CounterSet *string `pulumi:"counterSet"`
	// Counters defines the counters that will be consumed by the device.
	//
	// The maximum number counters in a device is 32. In addition, the maximum number of all counters in all devices is 1024 (for example, 64 devices with 16 counters each).
	Counters map[string]Counter `pulumi:"counters"`
}

// DeviceCounterConsumptionPatchInput is an input type that accepts DeviceCounterConsumptionPatchArgs and DeviceCounterConsumptionPatchOutput values.
// You can construct a concrete instance of `DeviceCounterConsumptionPatchInput` via:
//
//	DeviceCounterConsumptionPatchArgs{...}
type DeviceCounterConsumptionPatchInput interface {
	pulumi.Input

	ToDeviceCounterConsumptionPatchOutput() DeviceCounterConsumptionPatchOutput
	ToDeviceCounterConsumptionPatchOutputWithContext(context.Context) DeviceCounterConsumptionPatchOutput
}

// DeviceCounterConsumption defines a set of counters that a device will consume from a CounterSet.
type DeviceCounterConsumptionPatchArgs struct {
	// CounterSet is the name of the set from which the counters defined will be consumed.
	CounterSet pulumi.StringPtrInput `pulumi:"counterSet"`
	// Counters defines the counters that will be consumed by the device.
	//
	// The maximum number counters in a device is 32. In addition, the maximum number of all counters in all devices is 1024 (for example, 64 devices with 16 counters each).
	Counters CounterMapInput `pulumi:"counters"`
}

func (DeviceCounterConsumptionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceCounterConsumptionPatch)(nil)).Elem()
}

func (i DeviceCounterConsumptionPatchArgs) ToDeviceCounterConsumptionPatchOutput() DeviceCounterConsumptionPatchOutput {
	return i.ToDeviceCounterConsumptionPatchOutputWithContext(context.Background())
}

func (i DeviceCounterConsumptionPatchArgs) ToDeviceCounterConsumptionPatchOutputWithContext(ctx context.Context) DeviceCounterConsumptionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceCounterConsumptionPatchOutput)
}

// DeviceCounterConsumptionPatchArrayInput is an input type that accepts DeviceCounterConsumptionPatchArray and DeviceCounterConsumptionPatchArrayOutput values.
// You can construct a concrete instance of `DeviceCounterConsumptionPatchArrayInput` via:
//
//	DeviceCounterConsumptionPatchArray{ DeviceCounterConsumptionPatchArgs{...} }
type DeviceCounterConsumptionPatchArrayInput interface {
	pulumi.Input

	ToDeviceCounterConsumptionPatchArrayOutput() DeviceCounterConsumptionPatchArrayOutput
	ToDeviceCounterConsumptionPatchArrayOutputWithContext(context.Context) DeviceCounterConsumptionPatchArrayOutput
}

type DeviceCounterConsumptionPatchArray []DeviceCounterConsumptionPatchInput

func (DeviceCounterConsumptionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceCounterConsumptionPatch)(nil)).Elem()
}

func (i DeviceCounterConsumptionPatchArray) ToDeviceCounterConsumptionPatchArrayOutput() DeviceCounterConsumptionPatchArrayOutput {
	return i.ToDeviceCounterConsumptionPatchArrayOutputWithContext(context.Background())
}

func (i DeviceCounterConsumptionPatchArray) ToDeviceCounterConsumptionPatchArrayOutputWithContext(ctx context.Context) DeviceCounterConsumptionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceCounterConsumptionPatchArrayOutput)
}

// DeviceCounterConsumption defines a set of counters that a device will consume from a CounterSet.
type DeviceCounterConsumptionPatchOutput struct{ *pulumi.OutputState }

func (DeviceCounterConsumptionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceCounterConsumptionPatch)(nil)).Elem()
}

func (o DeviceCounterConsumptionPatchOutput) ToDeviceCounterConsumptionPatchOutput() DeviceCounterConsumptionPatchOutput {
	return o
}

func (o DeviceCounterConsumptionPatchOutput) ToDeviceCounterConsumptionPatchOutputWithContext(ctx context.Context) DeviceCounterConsumptionPatchOutput {
	return o
}

// CounterSet is the name of the set from which the counters defined will be consumed.
func (o DeviceCounterConsumptionPatchOutput) CounterSet() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceCounterConsumptionPatch) *string { return v.CounterSet }).(pulumi.StringPtrOutput)
}

// Counters defines the counters that will be consumed by the device.
//
// The maximum number counters in a device is 32. In addition, the maximum number of all counters in all devices is 1024 (for example, 64 devices with 16 counters each).
func (o DeviceCounterConsumptionPatchOutput) Counters() CounterMapOutput {
	return o.ApplyT(func(v DeviceCounterConsumptionPatch) map[string]Counter { return v.Counters }).(CounterMapOutput)
}

type DeviceCounterConsumptionPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceCounterConsumptionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceCounterConsumptionPatch)(nil)).Elem()
}

func (o DeviceCounterConsumptionPatchArrayOutput) ToDeviceCounterConsumptionPatchArrayOutput() DeviceCounterConsumptionPatchArrayOutput {
	return o
}

func (o DeviceCounterConsumptionPatchArrayOutput) ToDeviceCounterConsumptionPatchArrayOutputWithContext(ctx context.Context) DeviceCounterConsumptionPatchArrayOutput {
	return o
}

func (o DeviceCounterConsumptionPatchArrayOutput) Index(i pulumi.IntInput) DeviceCounterConsumptionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceCounterConsumptionPatch {
		return vs[0].([]DeviceCounterConsumptionPatch)[vs[1].(int)]
	}).(DeviceCounterConsumptionPatchOutput)
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DevicePatch struct {
	// Basic defines one device instance.
	Basic *BasicDevicePatch `pulumi:"basic"`
	// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
	Name *string `pulumi:"name"`
}

// DevicePatchInput is an input type that accepts DevicePatchArgs and DevicePatchOutput values.
// You can construct a concrete instance of `DevicePatchInput` via:
//
//	DevicePatchArgs{...}
type DevicePatchInput interface {
	pulumi.Input

	ToDevicePatchOutput() DevicePatchOutput
	ToDevicePatchOutputWithContext(context.Context) DevicePatchOutput
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DevicePatchArgs struct {
	// Basic defines one device instance.
	Basic BasicDevicePatchPtrInput `pulumi:"basic"`
	// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (DevicePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePatch)(nil)).Elem()
}

func (i DevicePatchArgs) ToDevicePatchOutput() DevicePatchOutput {
	return i.ToDevicePatchOutputWithContext(context.Background())
}

func (i DevicePatchArgs) ToDevicePatchOutputWithContext(ctx context.Context) DevicePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePatchOutput)
}

// DevicePatchArrayInput is an input type that accepts DevicePatchArray and DevicePatchArrayOutput values.
// You can construct a concrete instance of `DevicePatchArrayInput` via:
//
//	DevicePatchArray{ DevicePatchArgs{...} }
type DevicePatchArrayInput interface {
	pulumi.Input

	ToDevicePatchArrayOutput() DevicePatchArrayOutput
	ToDevicePatchArrayOutputWithContext(context.Context) DevicePatchArrayOutput
}

type DevicePatchArray []DevicePatchInput

func (DevicePatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DevicePatch)(nil)).Elem()
}

func (i DevicePatchArray) ToDevicePatchArrayOutput() DevicePatchArrayOutput {
	return i.ToDevicePatchArrayOutputWithContext(context.Background())
}

func (i DevicePatchArray) ToDevicePatchArrayOutputWithContext(ctx context.Context) DevicePatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePatchArrayOutput)
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DevicePatchOutput struct{ *pulumi.OutputState }

func (DevicePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePatch)(nil)).Elem()
}

func (o DevicePatchOutput) ToDevicePatchOutput() DevicePatchOutput {
	return o
}

func (o DevicePatchOutput) ToDevicePatchOutputWithContext(ctx context.Context) DevicePatchOutput {
	return o
}

// Basic defines one device instance.
func (o DevicePatchOutput) Basic() BasicDevicePatchPtrOutput {
	return o.ApplyT(func(v DevicePatch) *BasicDevicePatch { return v.Basic }).(BasicDevicePatchPtrOutput)
}

// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
func (o DevicePatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DevicePatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type DevicePatchArrayOutput struct{ *pulumi.OutputState }

func (DevicePatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DevicePatch)(nil)).Elem()
}

func (o DevicePatchArrayOutput) ToDevicePatchArrayOutput() DevicePatchArrayOutput {
	return o
}

func (o DevicePatchArrayOutput) ToDevicePatchArrayOutputWithContext(ctx context.Context) DevicePatchArrayOutput {
	return o
}

func (o DevicePatchArrayOutput) Index(i pulumi.IntInput) DevicePatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DevicePatch {
		return vs[0].([]DevicePatch)[vs[1].(int)]
	}).(DevicePatchOutput)
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
type DeviceRequest struct {
	// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
	AdminAccess *bool `pulumi:"adminAccess"`
	// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This request is for all of the matching devices in a pool.
	// At least one device must exist on the node for the allocation to succeed.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode *string `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	Count *int `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
	//
	// A class is required if no subrequests are specified in the firstAvailable list and no class can be set if subrequests are specified in the firstAvailable list. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName *string `pulumi:"deviceClassName"`
	// FirstAvailable contains subrequests, of which exactly one will be satisfied by the scheduler to satisfy this request. It tries to satisfy them in the order in which they are listed here. So if there are two entries in the list, the scheduler will only check the second one if it determines that the first one cannot be used.
	//
	// This field may only be set in the entries of DeviceClaim.Requests.
	//
	// DRA does not yet implement scoring, so the scheduler will select the first set of devices that satisfies all the requests in the claim. And if the requirements can be satisfied on more than one node, other scheduling features will determine which node is chosen. This means that the set of devices allocated to a claim might not be the optimal set available to the cluster. Scoring will be implemented later.
	FirstAvailable []DeviceSubRequest `pulumi:"firstAvailable"`
	// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
	//
	// Must be a DNS label and unique among all DeviceRequests in a ResourceClaim.
	Name string `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	Selectors []DeviceSelector `pulumi:"selectors"`
	// If specified, the request's tolerations.
	//
	// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
	//
	// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations []DeviceToleration `pulumi:"tolerations"`
}

// DeviceRequestInput is an input type that accepts DeviceRequestArgs and DeviceRequestOutput values.
// You can construct a concrete instance of `DeviceRequestInput` via:
//
//	DeviceRequestArgs{...}
type DeviceRequestInput interface {
	pulumi.Input

	ToDeviceRequestOutput() DeviceRequestOutput
	ToDeviceRequestOutputWithContext(context.Context) DeviceRequestOutput
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
type DeviceRequestArgs struct {
	// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
	AdminAccess pulumi.BoolPtrInput `pulumi:"adminAccess"`
	// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This request is for all of the matching devices in a pool.
	// At least one device must exist on the node for the allocation to succeed.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode pulumi.StringPtrInput `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
	//
	// A class is required if no subrequests are specified in the firstAvailable list and no class can be set if subrequests are specified in the firstAvailable list. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName pulumi.StringPtrInput `pulumi:"deviceClassName"`
	// FirstAvailable contains subrequests, of which exactly one will be satisfied by the scheduler to satisfy this request. It tries to satisfy them in the order in which they are listed here. So if there are two entries in the list, the scheduler will only check the second one if it determines that the first one cannot be used.
	//
	// This field may only be set in the entries of DeviceClaim.Requests.
	//
	// DRA does not yet implement scoring, so the scheduler will select the first set of devices that satisfies all the requests in the claim. And if the requirements can be satisfied on more than one node, other scheduling features will determine which node is chosen. This means that the set of devices allocated to a claim might not be the optimal set available to the cluster. Scoring will be implemented later.
	FirstAvailable DeviceSubRequestArrayInput `pulumi:"firstAvailable"`
	// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
	//
	// Must be a DNS label and unique among all DeviceRequests in a ResourceClaim.
	Name pulumi.StringInput `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	Selectors DeviceSelectorArrayInput `pulumi:"selectors"`
	// If specified, the request's tolerations.
	//
	// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
	//
	// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations DeviceTolerationArrayInput `pulumi:"tolerations"`
}

func (DeviceRequestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequest)(nil)).Elem()
}

func (i DeviceRequestArgs) ToDeviceRequestOutput() DeviceRequestOutput {
	return i.ToDeviceRequestOutputWithContext(context.Background())
}

func (i DeviceRequestArgs) ToDeviceRequestOutputWithContext(ctx context.Context) DeviceRequestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestOutput)
}

// DeviceRequestArrayInput is an input type that accepts DeviceRequestArray and DeviceRequestArrayOutput values.
// You can construct a concrete instance of `DeviceRequestArrayInput` via:
//
//	DeviceRequestArray{ DeviceRequestArgs{...} }
type DeviceRequestArrayInput interface {
	pulumi.Input

	ToDeviceRequestArrayOutput() DeviceRequestArrayOutput
	ToDeviceRequestArrayOutputWithContext(context.Context) DeviceRequestArrayOutput
}

type DeviceRequestArray []DeviceRequestInput

func (DeviceRequestArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequest)(nil)).Elem()
}

func (i DeviceRequestArray) ToDeviceRequestArrayOutput() DeviceRequestArrayOutput {
	return i.ToDeviceRequestArrayOutputWithContext(context.Background())
}

func (i DeviceRequestArray) ToDeviceRequestArrayOutputWithContext(ctx context.Context) DeviceRequestArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestArrayOutput)
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
type DeviceRequestOutput struct{ *pulumi.OutputState }

func (DeviceRequestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequest)(nil)).Elem()
}

func (o DeviceRequestOutput) ToDeviceRequestOutput() DeviceRequestOutput {
	return o
}

func (o DeviceRequestOutput) ToDeviceRequestOutputWithContext(ctx context.Context) DeviceRequestOutput {
	return o
}

// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
//
// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
func (o DeviceRequestOutput) AdminAccess() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceRequest) *bool { return v.AdminAccess }).(pulumi.BoolPtrOutput)
}

// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
//
// - ExactCount: This request is for a specific number of devices.
// This is the default. The exact number is provided in the
// count field.
//
// - All: This request is for all of the matching devices in a pool.
// At least one device must exist on the node for the allocation to succeed.
// Allocation will fail if some devices are already allocated,
// unless adminAccess is requested.
//
// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
//
// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
func (o DeviceRequestOutput) AllocationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequest) *string { return v.AllocationMode }).(pulumi.StringPtrOutput)
}

// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
func (o DeviceRequestOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceRequest) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
//
// A class is required if no subrequests are specified in the firstAvailable list and no class can be set if subrequests are specified in the firstAvailable list. Which classes are available depends on the cluster.
//
// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
func (o DeviceRequestOutput) DeviceClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequest) *string { return v.DeviceClassName }).(pulumi.StringPtrOutput)
}

// FirstAvailable contains subrequests, of which exactly one will be satisfied by the scheduler to satisfy this request. It tries to satisfy them in the order in which they are listed here. So if there are two entries in the list, the scheduler will only check the second one if it determines that the first one cannot be used.
//
// This field may only be set in the entries of DeviceClaim.Requests.
//
// DRA does not yet implement scoring, so the scheduler will select the first set of devices that satisfies all the requests in the claim. And if the requirements can be satisfied on more than one node, other scheduling features will determine which node is chosen. This means that the set of devices allocated to a claim might not be the optimal set available to the cluster. Scoring will be implemented later.
func (o DeviceRequestOutput) FirstAvailable() DeviceSubRequestArrayOutput {
	return o.ApplyT(func(v DeviceRequest) []DeviceSubRequest { return v.FirstAvailable }).(DeviceSubRequestArrayOutput)
}

// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
//
// Must be a DNS label and unique among all DeviceRequests in a ResourceClaim.
func (o DeviceRequestOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequest) string { return v.Name }).(pulumi.StringOutput)
}

// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
func (o DeviceRequestOutput) Selectors() DeviceSelectorArrayOutput {
	return o.ApplyT(func(v DeviceRequest) []DeviceSelector { return v.Selectors }).(DeviceSelectorArrayOutput)
}

// If specified, the request's tolerations.
//
// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
//
// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
//
// The maximum number of tolerations is 16.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o DeviceRequestOutput) Tolerations() DeviceTolerationArrayOutput {
	return o.ApplyT(func(v DeviceRequest) []DeviceToleration { return v.Tolerations }).(DeviceTolerationArrayOutput)
}

type DeviceRequestArrayOutput struct{ *pulumi.OutputState }

func (DeviceRequestArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequest)(nil)).Elem()
}

func (o DeviceRequestArrayOutput) ToDeviceRequestArrayOutput() DeviceRequestArrayOutput {
	return o
}

func (o DeviceRequestArrayOutput) ToDeviceRequestArrayOutputWithContext(ctx context.Context) DeviceRequestArrayOutput {
	return o
}

func (o DeviceRequestArrayOutput) Index(i pulumi.IntInput) DeviceRequestOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceRequest {
		return vs[0].([]DeviceRequest)[vs[1].(int)]
	}).(DeviceRequestOutput)
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResult struct {
	// AdminAccess indicates that this device was allocated for administrative access. See the corresponding request field for a definition of mode.
	//
	// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
	AdminAccess *bool `pulumi:"adminAccess"`
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device string `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver string `pulumi:"driver"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool string `pulumi:"pool"`
	// Request is the name of the request in the claim which caused this device to be allocated. If it references a subrequest in the firstAvailable list on a DeviceRequest, this field must include both the name of the main request and the subrequest using the format <main request>/<subrequest>.
	//
	// Multiple devices may have been allocated per request.
	Request string `pulumi:"request"`
	// A copy of all tolerations specified in the request at the time when the device got allocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations []DeviceToleration `pulumi:"tolerations"`
}

// DeviceRequestAllocationResultInput is an input type that accepts DeviceRequestAllocationResultArgs and DeviceRequestAllocationResultOutput values.
// You can construct a concrete instance of `DeviceRequestAllocationResultInput` via:
//
//	DeviceRequestAllocationResultArgs{...}
type DeviceRequestAllocationResultInput interface {
	pulumi.Input

	ToDeviceRequestAllocationResultOutput() DeviceRequestAllocationResultOutput
	ToDeviceRequestAllocationResultOutputWithContext(context.Context) DeviceRequestAllocationResultOutput
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultArgs struct {
	// AdminAccess indicates that this device was allocated for administrative access. See the corresponding request field for a definition of mode.
	//
	// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
	AdminAccess pulumi.BoolPtrInput `pulumi:"adminAccess"`
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device pulumi.StringInput `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringInput `pulumi:"driver"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool pulumi.StringInput `pulumi:"pool"`
	// Request is the name of the request in the claim which caused this device to be allocated. If it references a subrequest in the firstAvailable list on a DeviceRequest, this field must include both the name of the main request and the subrequest using the format <main request>/<subrequest>.
	//
	// Multiple devices may have been allocated per request.
	Request pulumi.StringInput `pulumi:"request"`
	// A copy of all tolerations specified in the request at the time when the device got allocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations DeviceTolerationArrayInput `pulumi:"tolerations"`
}

func (DeviceRequestAllocationResultArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestAllocationResult)(nil)).Elem()
}

func (i DeviceRequestAllocationResultArgs) ToDeviceRequestAllocationResultOutput() DeviceRequestAllocationResultOutput {
	return i.ToDeviceRequestAllocationResultOutputWithContext(context.Background())
}

func (i DeviceRequestAllocationResultArgs) ToDeviceRequestAllocationResultOutputWithContext(ctx context.Context) DeviceRequestAllocationResultOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestAllocationResultOutput)
}

// DeviceRequestAllocationResultArrayInput is an input type that accepts DeviceRequestAllocationResultArray and DeviceRequestAllocationResultArrayOutput values.
// You can construct a concrete instance of `DeviceRequestAllocationResultArrayInput` via:
//
//	DeviceRequestAllocationResultArray{ DeviceRequestAllocationResultArgs{...} }
type DeviceRequestAllocationResultArrayInput interface {
	pulumi.Input

	ToDeviceRequestAllocationResultArrayOutput() DeviceRequestAllocationResultArrayOutput
	ToDeviceRequestAllocationResultArrayOutputWithContext(context.Context) DeviceRequestAllocationResultArrayOutput
}

type DeviceRequestAllocationResultArray []DeviceRequestAllocationResultInput

func (DeviceRequestAllocationResultArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestAllocationResult)(nil)).Elem()
}

func (i DeviceRequestAllocationResultArray) ToDeviceRequestAllocationResultArrayOutput() DeviceRequestAllocationResultArrayOutput {
	return i.ToDeviceRequestAllocationResultArrayOutputWithContext(context.Background())
}

func (i DeviceRequestAllocationResultArray) ToDeviceRequestAllocationResultArrayOutputWithContext(ctx context.Context) DeviceRequestAllocationResultArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestAllocationResultArrayOutput)
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultOutput struct{ *pulumi.OutputState }

func (DeviceRequestAllocationResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestAllocationResult)(nil)).Elem()
}

func (o DeviceRequestAllocationResultOutput) ToDeviceRequestAllocationResultOutput() DeviceRequestAllocationResultOutput {
	return o
}

func (o DeviceRequestAllocationResultOutput) ToDeviceRequestAllocationResultOutputWithContext(ctx context.Context) DeviceRequestAllocationResultOutput {
	return o
}

// AdminAccess indicates that this device was allocated for administrative access. See the corresponding request field for a definition of mode.
//
// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
func (o DeviceRequestAllocationResultOutput) AdminAccess() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) *bool { return v.AdminAccess }).(pulumi.BoolPtrOutput)
}

// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
func (o DeviceRequestAllocationResultOutput) Device() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) string { return v.Device }).(pulumi.StringOutput)
}

// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o DeviceRequestAllocationResultOutput) Driver() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) string { return v.Driver }).(pulumi.StringOutput)
}

// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
//
// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
func (o DeviceRequestAllocationResultOutput) Pool() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) string { return v.Pool }).(pulumi.StringOutput)
}

// Request is the name of the request in the claim which caused this device to be allocated. If it references a subrequest in the firstAvailable list on a DeviceRequest, this field must include both the name of the main request and the subrequest using the format <main request>/<subrequest>.
//
// Multiple devices may have been allocated per request.
func (o DeviceRequestAllocationResultOutput) Request() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) string { return v.Request }).(pulumi.StringOutput)
}

// A copy of all tolerations specified in the request at the time when the device got allocated.
//
// The maximum number of tolerations is 16.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o DeviceRequestAllocationResultOutput) Tolerations() DeviceTolerationArrayOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) []DeviceToleration { return v.Tolerations }).(DeviceTolerationArrayOutput)
}

type DeviceRequestAllocationResultArrayOutput struct{ *pulumi.OutputState }

func (DeviceRequestAllocationResultArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestAllocationResult)(nil)).Elem()
}

func (o DeviceRequestAllocationResultArrayOutput) ToDeviceRequestAllocationResultArrayOutput() DeviceRequestAllocationResultArrayOutput {
	return o
}

func (o DeviceRequestAllocationResultArrayOutput) ToDeviceRequestAllocationResultArrayOutputWithContext(ctx context.Context) DeviceRequestAllocationResultArrayOutput {
	return o
}

func (o DeviceRequestAllocationResultArrayOutput) Index(i pulumi.IntInput) DeviceRequestAllocationResultOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceRequestAllocationResult {
		return vs[0].([]DeviceRequestAllocationResult)[vs[1].(int)]
	}).(DeviceRequestAllocationResultOutput)
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultPatch struct {
	// AdminAccess indicates that this device was allocated for administrative access. See the corresponding request field for a definition of mode.
	//
	// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
	AdminAccess *bool `pulumi:"adminAccess"`
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device *string `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver *string `pulumi:"driver"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool *string `pulumi:"pool"`
	// Request is the name of the request in the claim which caused this device to be allocated. If it references a subrequest in the firstAvailable list on a DeviceRequest, this field must include both the name of the main request and the subrequest using the format <main request>/<subrequest>.
	//
	// Multiple devices may have been allocated per request.
	Request *string `pulumi:"request"`
	// A copy of all tolerations specified in the request at the time when the device got allocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations []DeviceTolerationPatch `pulumi:"tolerations"`
}

// DeviceRequestAllocationResultPatchInput is an input type that accepts DeviceRequestAllocationResultPatchArgs and DeviceRequestAllocationResultPatchOutput values.
// You can construct a concrete instance of `DeviceRequestAllocationResultPatchInput` via:
//
//	DeviceRequestAllocationResultPatchArgs{...}
type DeviceRequestAllocationResultPatchInput interface {
	pulumi.Input

	ToDeviceRequestAllocationResultPatchOutput() DeviceRequestAllocationResultPatchOutput
	ToDeviceRequestAllocationResultPatchOutputWithContext(context.Context) DeviceRequestAllocationResultPatchOutput
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultPatchArgs struct {
	// AdminAccess indicates that this device was allocated for administrative access. See the corresponding request field for a definition of mode.
	//
	// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
	AdminAccess pulumi.BoolPtrInput `pulumi:"adminAccess"`
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device pulumi.StringPtrInput `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringPtrInput `pulumi:"driver"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool pulumi.StringPtrInput `pulumi:"pool"`
	// Request is the name of the request in the claim which caused this device to be allocated. If it references a subrequest in the firstAvailable list on a DeviceRequest, this field must include both the name of the main request and the subrequest using the format <main request>/<subrequest>.
	//
	// Multiple devices may have been allocated per request.
	Request pulumi.StringPtrInput `pulumi:"request"`
	// A copy of all tolerations specified in the request at the time when the device got allocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations DeviceTolerationPatchArrayInput `pulumi:"tolerations"`
}

func (DeviceRequestAllocationResultPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestAllocationResultPatch)(nil)).Elem()
}

func (i DeviceRequestAllocationResultPatchArgs) ToDeviceRequestAllocationResultPatchOutput() DeviceRequestAllocationResultPatchOutput {
	return i.ToDeviceRequestAllocationResultPatchOutputWithContext(context.Background())
}

func (i DeviceRequestAllocationResultPatchArgs) ToDeviceRequestAllocationResultPatchOutputWithContext(ctx context.Context) DeviceRequestAllocationResultPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestAllocationResultPatchOutput)
}

// DeviceRequestAllocationResultPatchArrayInput is an input type that accepts DeviceRequestAllocationResultPatchArray and DeviceRequestAllocationResultPatchArrayOutput values.
// You can construct a concrete instance of `DeviceRequestAllocationResultPatchArrayInput` via:
//
//	DeviceRequestAllocationResultPatchArray{ DeviceRequestAllocationResultPatchArgs{...} }
type DeviceRequestAllocationResultPatchArrayInput interface {
	pulumi.Input

	ToDeviceRequestAllocationResultPatchArrayOutput() DeviceRequestAllocationResultPatchArrayOutput
	ToDeviceRequestAllocationResultPatchArrayOutputWithContext(context.Context) DeviceRequestAllocationResultPatchArrayOutput
}

type DeviceRequestAllocationResultPatchArray []DeviceRequestAllocationResultPatchInput

func (DeviceRequestAllocationResultPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestAllocationResultPatch)(nil)).Elem()
}

func (i DeviceRequestAllocationResultPatchArray) ToDeviceRequestAllocationResultPatchArrayOutput() DeviceRequestAllocationResultPatchArrayOutput {
	return i.ToDeviceRequestAllocationResultPatchArrayOutputWithContext(context.Background())
}

func (i DeviceRequestAllocationResultPatchArray) ToDeviceRequestAllocationResultPatchArrayOutputWithContext(ctx context.Context) DeviceRequestAllocationResultPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestAllocationResultPatchArrayOutput)
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultPatchOutput struct{ *pulumi.OutputState }

func (DeviceRequestAllocationResultPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestAllocationResultPatch)(nil)).Elem()
}

func (o DeviceRequestAllocationResultPatchOutput) ToDeviceRequestAllocationResultPatchOutput() DeviceRequestAllocationResultPatchOutput {
	return o
}

func (o DeviceRequestAllocationResultPatchOutput) ToDeviceRequestAllocationResultPatchOutputWithContext(ctx context.Context) DeviceRequestAllocationResultPatchOutput {
	return o
}

// AdminAccess indicates that this device was allocated for administrative access. See the corresponding request field for a definition of mode.
//
// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
func (o DeviceRequestAllocationResultPatchOutput) AdminAccess() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) *bool { return v.AdminAccess }).(pulumi.BoolPtrOutput)
}

// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
func (o DeviceRequestAllocationResultPatchOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) *string { return v.Device }).(pulumi.StringPtrOutput)
}

// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o DeviceRequestAllocationResultPatchOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) *string { return v.Driver }).(pulumi.StringPtrOutput)
}

// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
//
// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
func (o DeviceRequestAllocationResultPatchOutput) Pool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) *string { return v.Pool }).(pulumi.StringPtrOutput)
}

// Request is the name of the request in the claim which caused this device to be allocated. If it references a subrequest in the firstAvailable list on a DeviceRequest, this field must include both the name of the main request and the subrequest using the format <main request>/<subrequest>.
//
// Multiple devices may have been allocated per request.
func (o DeviceRequestAllocationResultPatchOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) *string { return v.Request }).(pulumi.StringPtrOutput)
}

// A copy of all tolerations specified in the request at the time when the device got allocated.
//
// The maximum number of tolerations is 16.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o DeviceRequestAllocationResultPatchOutput) Tolerations() DeviceTolerationPatchArrayOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) []DeviceTolerationPatch { return v.Tolerations }).(DeviceTolerationPatchArrayOutput)
}

type DeviceRequestAllocationResultPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceRequestAllocationResultPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestAllocationResultPatch)(nil)).Elem()
}

func (o DeviceRequestAllocationResultPatchArrayOutput) ToDeviceRequestAllocationResultPatchArrayOutput() DeviceRequestAllocationResultPatchArrayOutput {
	return o
}

func (o DeviceRequestAllocationResultPatchArrayOutput) ToDeviceRequestAllocationResultPatchArrayOutputWithContext(ctx context.Context) DeviceRequestAllocationResultPatchArrayOutput {
	return o
}

func (o DeviceRequestAllocationResultPatchArrayOutput) Index(i pulumi.IntInput) DeviceRequestAllocationResultPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceRequestAllocationResultPatch {
		return vs[0].([]DeviceRequestAllocationResultPatch)[vs[1].(int)]
	}).(DeviceRequestAllocationResultPatchOutput)
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
type DeviceRequestPatch struct {
	// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
	AdminAccess *bool `pulumi:"adminAccess"`
	// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This request is for all of the matching devices in a pool.
	// At least one device must exist on the node for the allocation to succeed.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode *string `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	Count *int `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
	//
	// A class is required if no subrequests are specified in the firstAvailable list and no class can be set if subrequests are specified in the firstAvailable list. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName *string `pulumi:"deviceClassName"`
	// FirstAvailable contains subrequests, of which exactly one will be satisfied by the scheduler to satisfy this request. It tries to satisfy them in the order in which they are listed here. So if there are two entries in the list, the scheduler will only check the second one if it determines that the first one cannot be used.
	//
	// This field may only be set in the entries of DeviceClaim.Requests.
	//
	// DRA does not yet implement scoring, so the scheduler will select the first set of devices that satisfies all the requests in the claim. And if the requirements can be satisfied on more than one node, other scheduling features will determine which node is chosen. This means that the set of devices allocated to a claim might not be the optimal set available to the cluster. Scoring will be implemented later.
	FirstAvailable []DeviceSubRequestPatch `pulumi:"firstAvailable"`
	// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
	//
	// Must be a DNS label and unique among all DeviceRequests in a ResourceClaim.
	Name *string `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	Selectors []DeviceSelectorPatch `pulumi:"selectors"`
	// If specified, the request's tolerations.
	//
	// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
	//
	// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations []DeviceTolerationPatch `pulumi:"tolerations"`
}

// DeviceRequestPatchInput is an input type that accepts DeviceRequestPatchArgs and DeviceRequestPatchOutput values.
// You can construct a concrete instance of `DeviceRequestPatchInput` via:
//
//	DeviceRequestPatchArgs{...}
type DeviceRequestPatchInput interface {
	pulumi.Input

	ToDeviceRequestPatchOutput() DeviceRequestPatchOutput
	ToDeviceRequestPatchOutputWithContext(context.Context) DeviceRequestPatchOutput
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
type DeviceRequestPatchArgs struct {
	// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
	AdminAccess pulumi.BoolPtrInput `pulumi:"adminAccess"`
	// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This request is for all of the matching devices in a pool.
	// At least one device must exist on the node for the allocation to succeed.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode pulumi.StringPtrInput `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
	//
	// A class is required if no subrequests are specified in the firstAvailable list and no class can be set if subrequests are specified in the firstAvailable list. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName pulumi.StringPtrInput `pulumi:"deviceClassName"`
	// FirstAvailable contains subrequests, of which exactly one will be satisfied by the scheduler to satisfy this request. It tries to satisfy them in the order in which they are listed here. So if there are two entries in the list, the scheduler will only check the second one if it determines that the first one cannot be used.
	//
	// This field may only be set in the entries of DeviceClaim.Requests.
	//
	// DRA does not yet implement scoring, so the scheduler will select the first set of devices that satisfies all the requests in the claim. And if the requirements can be satisfied on more than one node, other scheduling features will determine which node is chosen. This means that the set of devices allocated to a claim might not be the optimal set available to the cluster. Scoring will be implemented later.
	FirstAvailable DeviceSubRequestPatchArrayInput `pulumi:"firstAvailable"`
	// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
	//
	// Must be a DNS label and unique among all DeviceRequests in a ResourceClaim.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	Selectors DeviceSelectorPatchArrayInput `pulumi:"selectors"`
	// If specified, the request's tolerations.
	//
	// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
	//
	// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations DeviceTolerationPatchArrayInput `pulumi:"tolerations"`
}

func (DeviceRequestPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestPatch)(nil)).Elem()
}

func (i DeviceRequestPatchArgs) ToDeviceRequestPatchOutput() DeviceRequestPatchOutput {
	return i.ToDeviceRequestPatchOutputWithContext(context.Background())
}

func (i DeviceRequestPatchArgs) ToDeviceRequestPatchOutputWithContext(ctx context.Context) DeviceRequestPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestPatchOutput)
}

// DeviceRequestPatchArrayInput is an input type that accepts DeviceRequestPatchArray and DeviceRequestPatchArrayOutput values.
// You can construct a concrete instance of `DeviceRequestPatchArrayInput` via:
//
//	DeviceRequestPatchArray{ DeviceRequestPatchArgs{...} }
type DeviceRequestPatchArrayInput interface {
	pulumi.Input

	ToDeviceRequestPatchArrayOutput() DeviceRequestPatchArrayOutput
	ToDeviceRequestPatchArrayOutputWithContext(context.Context) DeviceRequestPatchArrayOutput
}

type DeviceRequestPatchArray []DeviceRequestPatchInput

func (DeviceRequestPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestPatch)(nil)).Elem()
}

func (i DeviceRequestPatchArray) ToDeviceRequestPatchArrayOutput() DeviceRequestPatchArrayOutput {
	return i.ToDeviceRequestPatchArrayOutputWithContext(context.Background())
}

func (i DeviceRequestPatchArray) ToDeviceRequestPatchArrayOutputWithContext(ctx context.Context) DeviceRequestPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestPatchArrayOutput)
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
type DeviceRequestPatchOutput struct{ *pulumi.OutputState }

func (DeviceRequestPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestPatch)(nil)).Elem()
}

func (o DeviceRequestPatchOutput) ToDeviceRequestPatchOutput() DeviceRequestPatchOutput {
	return o
}

func (o DeviceRequestPatchOutput) ToDeviceRequestPatchOutputWithContext(ctx context.Context) DeviceRequestPatchOutput {
	return o
}

// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
//
// This is an alpha field and requires enabling the DRAAdminAccess feature gate. Admin access is disabled if this field is unset or set to false, otherwise it is enabled.
func (o DeviceRequestPatchOutput) AdminAccess() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *bool { return v.AdminAccess }).(pulumi.BoolPtrOutput)
}

// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
//
// - ExactCount: This request is for a specific number of devices.
// This is the default. The exact number is provided in the
// count field.
//
// - All: This request is for all of the matching devices in a pool.
// At least one device must exist on the node for the allocation to succeed.
// Allocation will fail if some devices are already allocated,
// unless adminAccess is requested.
//
// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
//
// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
func (o DeviceRequestPatchOutput) AllocationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *string { return v.AllocationMode }).(pulumi.StringPtrOutput)
}

// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
func (o DeviceRequestPatchOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
//
// A class is required if no subrequests are specified in the firstAvailable list and no class can be set if subrequests are specified in the firstAvailable list. Which classes are available depends on the cluster.
//
// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
func (o DeviceRequestPatchOutput) DeviceClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *string { return v.DeviceClassName }).(pulumi.StringPtrOutput)
}

// FirstAvailable contains subrequests, of which exactly one will be satisfied by the scheduler to satisfy this request. It tries to satisfy them in the order in which they are listed here. So if there are two entries in the list, the scheduler will only check the second one if it determines that the first one cannot be used.
//
// This field may only be set in the entries of DeviceClaim.Requests.
//
// DRA does not yet implement scoring, so the scheduler will select the first set of devices that satisfies all the requests in the claim. And if the requirements can be satisfied on more than one node, other scheduling features will determine which node is chosen. This means that the set of devices allocated to a claim might not be the optimal set available to the cluster. Scoring will be implemented later.
func (o DeviceRequestPatchOutput) FirstAvailable() DeviceSubRequestPatchArrayOutput {
	return o.ApplyT(func(v DeviceRequestPatch) []DeviceSubRequestPatch { return v.FirstAvailable }).(DeviceSubRequestPatchArrayOutput)
}

// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
//
// Must be a DNS label and unique among all DeviceRequests in a ResourceClaim.
func (o DeviceRequestPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
func (o DeviceRequestPatchOutput) Selectors() DeviceSelectorPatchArrayOutput {
	return o.ApplyT(func(v DeviceRequestPatch) []DeviceSelectorPatch { return v.Selectors }).(DeviceSelectorPatchArrayOutput)
}

// If specified, the request's tolerations.
//
// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
//
// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
//
// The maximum number of tolerations is 16.
//
// This field can only be set when deviceClassName is set and no subrequests are specified in the firstAvailable list.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o DeviceRequestPatchOutput) Tolerations() DeviceTolerationPatchArrayOutput {
	return o.ApplyT(func(v DeviceRequestPatch) []DeviceTolerationPatch { return v.Tolerations }).(DeviceTolerationPatchArrayOutput)
}

type DeviceRequestPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceRequestPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestPatch)(nil)).Elem()
}

func (o DeviceRequestPatchArrayOutput) ToDeviceRequestPatchArrayOutput() DeviceRequestPatchArrayOutput {
	return o
}

func (o DeviceRequestPatchArrayOutput) ToDeviceRequestPatchArrayOutputWithContext(ctx context.Context) DeviceRequestPatchArrayOutput {
	return o
}

func (o DeviceRequestPatchArrayOutput) Index(i pulumi.IntInput) DeviceRequestPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceRequestPatch {
		return vs[0].([]DeviceRequestPatch)[vs[1].(int)]
	}).(DeviceRequestPatchOutput)
}

// DeviceSelector must have exactly one field set.
type DeviceSelector struct {
	// CEL contains a CEL expression for selecting a device.
	Cel *CELDeviceSelector `pulumi:"cel"`
}

// DeviceSelectorInput is an input type that accepts DeviceSelectorArgs and DeviceSelectorOutput values.
// You can construct a concrete instance of `DeviceSelectorInput` via:
//
//	DeviceSelectorArgs{...}
type DeviceSelectorInput interface {
	pulumi.Input

	ToDeviceSelectorOutput() DeviceSelectorOutput
	ToDeviceSelectorOutputWithContext(context.Context) DeviceSelectorOutput
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorArgs struct {
	// CEL contains a CEL expression for selecting a device.
	Cel CELDeviceSelectorPtrInput `pulumi:"cel"`
}

func (DeviceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSelector)(nil)).Elem()
}

func (i DeviceSelectorArgs) ToDeviceSelectorOutput() DeviceSelectorOutput {
	return i.ToDeviceSelectorOutputWithContext(context.Background())
}

func (i DeviceSelectorArgs) ToDeviceSelectorOutputWithContext(ctx context.Context) DeviceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSelectorOutput)
}

// DeviceSelectorArrayInput is an input type that accepts DeviceSelectorArray and DeviceSelectorArrayOutput values.
// You can construct a concrete instance of `DeviceSelectorArrayInput` via:
//
//	DeviceSelectorArray{ DeviceSelectorArgs{...} }
type DeviceSelectorArrayInput interface {
	pulumi.Input

	ToDeviceSelectorArrayOutput() DeviceSelectorArrayOutput
	ToDeviceSelectorArrayOutputWithContext(context.Context) DeviceSelectorArrayOutput
}

type DeviceSelectorArray []DeviceSelectorInput

func (DeviceSelectorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSelector)(nil)).Elem()
}

func (i DeviceSelectorArray) ToDeviceSelectorArrayOutput() DeviceSelectorArrayOutput {
	return i.ToDeviceSelectorArrayOutputWithContext(context.Background())
}

func (i DeviceSelectorArray) ToDeviceSelectorArrayOutputWithContext(ctx context.Context) DeviceSelectorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSelectorArrayOutput)
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorOutput struct{ *pulumi.OutputState }

func (DeviceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSelector)(nil)).Elem()
}

func (o DeviceSelectorOutput) ToDeviceSelectorOutput() DeviceSelectorOutput {
	return o
}

func (o DeviceSelectorOutput) ToDeviceSelectorOutputWithContext(ctx context.Context) DeviceSelectorOutput {
	return o
}

// CEL contains a CEL expression for selecting a device.
func (o DeviceSelectorOutput) Cel() CELDeviceSelectorPtrOutput {
	return o.ApplyT(func(v DeviceSelector) *CELDeviceSelector { return v.Cel }).(CELDeviceSelectorPtrOutput)
}

type DeviceSelectorArrayOutput struct{ *pulumi.OutputState }

func (DeviceSelectorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSelector)(nil)).Elem()
}

func (o DeviceSelectorArrayOutput) ToDeviceSelectorArrayOutput() DeviceSelectorArrayOutput {
	return o
}

func (o DeviceSelectorArrayOutput) ToDeviceSelectorArrayOutputWithContext(ctx context.Context) DeviceSelectorArrayOutput {
	return o
}

func (o DeviceSelectorArrayOutput) Index(i pulumi.IntInput) DeviceSelectorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceSelector {
		return vs[0].([]DeviceSelector)[vs[1].(int)]
	}).(DeviceSelectorOutput)
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorPatch struct {
	// CEL contains a CEL expression for selecting a device.
	Cel *CELDeviceSelectorPatch `pulumi:"cel"`
}

// DeviceSelectorPatchInput is an input type that accepts DeviceSelectorPatchArgs and DeviceSelectorPatchOutput values.
// You can construct a concrete instance of `DeviceSelectorPatchInput` via:
//
//	DeviceSelectorPatchArgs{...}
type DeviceSelectorPatchInput interface {
	pulumi.Input

	ToDeviceSelectorPatchOutput() DeviceSelectorPatchOutput
	ToDeviceSelectorPatchOutputWithContext(context.Context) DeviceSelectorPatchOutput
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorPatchArgs struct {
	// CEL contains a CEL expression for selecting a device.
	Cel CELDeviceSelectorPatchPtrInput `pulumi:"cel"`
}

func (DeviceSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSelectorPatch)(nil)).Elem()
}

func (i DeviceSelectorPatchArgs) ToDeviceSelectorPatchOutput() DeviceSelectorPatchOutput {
	return i.ToDeviceSelectorPatchOutputWithContext(context.Background())
}

func (i DeviceSelectorPatchArgs) ToDeviceSelectorPatchOutputWithContext(ctx context.Context) DeviceSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSelectorPatchOutput)
}

// DeviceSelectorPatchArrayInput is an input type that accepts DeviceSelectorPatchArray and DeviceSelectorPatchArrayOutput values.
// You can construct a concrete instance of `DeviceSelectorPatchArrayInput` via:
//
//	DeviceSelectorPatchArray{ DeviceSelectorPatchArgs{...} }
type DeviceSelectorPatchArrayInput interface {
	pulumi.Input

	ToDeviceSelectorPatchArrayOutput() DeviceSelectorPatchArrayOutput
	ToDeviceSelectorPatchArrayOutputWithContext(context.Context) DeviceSelectorPatchArrayOutput
}

type DeviceSelectorPatchArray []DeviceSelectorPatchInput

func (DeviceSelectorPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSelectorPatch)(nil)).Elem()
}

func (i DeviceSelectorPatchArray) ToDeviceSelectorPatchArrayOutput() DeviceSelectorPatchArrayOutput {
	return i.ToDeviceSelectorPatchArrayOutputWithContext(context.Background())
}

func (i DeviceSelectorPatchArray) ToDeviceSelectorPatchArrayOutputWithContext(ctx context.Context) DeviceSelectorPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSelectorPatchArrayOutput)
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorPatchOutput struct{ *pulumi.OutputState }

func (DeviceSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSelectorPatch)(nil)).Elem()
}

func (o DeviceSelectorPatchOutput) ToDeviceSelectorPatchOutput() DeviceSelectorPatchOutput {
	return o
}

func (o DeviceSelectorPatchOutput) ToDeviceSelectorPatchOutputWithContext(ctx context.Context) DeviceSelectorPatchOutput {
	return o
}

// CEL contains a CEL expression for selecting a device.
func (o DeviceSelectorPatchOutput) Cel() CELDeviceSelectorPatchPtrOutput {
	return o.ApplyT(func(v DeviceSelectorPatch) *CELDeviceSelectorPatch { return v.Cel }).(CELDeviceSelectorPatchPtrOutput)
}

type DeviceSelectorPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceSelectorPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSelectorPatch)(nil)).Elem()
}

func (o DeviceSelectorPatchArrayOutput) ToDeviceSelectorPatchArrayOutput() DeviceSelectorPatchArrayOutput {
	return o
}

func (o DeviceSelectorPatchArrayOutput) ToDeviceSelectorPatchArrayOutputWithContext(ctx context.Context) DeviceSelectorPatchArrayOutput {
	return o
}

func (o DeviceSelectorPatchArrayOutput) Index(i pulumi.IntInput) DeviceSelectorPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceSelectorPatch {
		return vs[0].([]DeviceSelectorPatch)[vs[1].(int)]
	}).(DeviceSelectorPatchOutput)
}

// DeviceSubRequest describes a request for device provided in the claim.spec.devices.requests[].firstAvailable array. Each is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// DeviceSubRequest is similar to Request, but doesn't expose the AdminAccess or FirstAvailable fields, as those can only be set on the top-level request. AdminAccess is not supported for requests with a prioritized list, and recursive FirstAvailable fields are not supported.
type DeviceSubRequest struct {
	// AllocationMode and its related fields define how devices are allocated to satisfy this subrequest. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This subrequest is for all of the matching devices in a pool.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other subrequests must specify this field.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode *string `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	Count *int `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this subrequest.
	//
	// A class is required. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName string `pulumi:"deviceClassName"`
	// Name can be used to reference this subrequest in the list of constraints or the list of configurations for the claim. References must use the format <main request>/<subrequest>.
	//
	// Must be a DNS label.
	Name string `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this subrequest. All selectors must be satisfied for a device to be considered.
	Selectors []DeviceSelector `pulumi:"selectors"`
	// If specified, the request's tolerations.
	//
	// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
	//
	// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations []DeviceToleration `pulumi:"tolerations"`
}

// DeviceSubRequestInput is an input type that accepts DeviceSubRequestArgs and DeviceSubRequestOutput values.
// You can construct a concrete instance of `DeviceSubRequestInput` via:
//
//	DeviceSubRequestArgs{...}
type DeviceSubRequestInput interface {
	pulumi.Input

	ToDeviceSubRequestOutput() DeviceSubRequestOutput
	ToDeviceSubRequestOutputWithContext(context.Context) DeviceSubRequestOutput
}

// DeviceSubRequest describes a request for device provided in the claim.spec.devices.requests[].firstAvailable array. Each is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// DeviceSubRequest is similar to Request, but doesn't expose the AdminAccess or FirstAvailable fields, as those can only be set on the top-level request. AdminAccess is not supported for requests with a prioritized list, and recursive FirstAvailable fields are not supported.
type DeviceSubRequestArgs struct {
	// AllocationMode and its related fields define how devices are allocated to satisfy this subrequest. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This subrequest is for all of the matching devices in a pool.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other subrequests must specify this field.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode pulumi.StringPtrInput `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this subrequest.
	//
	// A class is required. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName pulumi.StringInput `pulumi:"deviceClassName"`
	// Name can be used to reference this subrequest in the list of constraints or the list of configurations for the claim. References must use the format <main request>/<subrequest>.
	//
	// Must be a DNS label.
	Name pulumi.StringInput `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this subrequest. All selectors must be satisfied for a device to be considered.
	Selectors DeviceSelectorArrayInput `pulumi:"selectors"`
	// If specified, the request's tolerations.
	//
	// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
	//
	// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations DeviceTolerationArrayInput `pulumi:"tolerations"`
}

func (DeviceSubRequestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSubRequest)(nil)).Elem()
}

func (i DeviceSubRequestArgs) ToDeviceSubRequestOutput() DeviceSubRequestOutput {
	return i.ToDeviceSubRequestOutputWithContext(context.Background())
}

func (i DeviceSubRequestArgs) ToDeviceSubRequestOutputWithContext(ctx context.Context) DeviceSubRequestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSubRequestOutput)
}

// DeviceSubRequestArrayInput is an input type that accepts DeviceSubRequestArray and DeviceSubRequestArrayOutput values.
// You can construct a concrete instance of `DeviceSubRequestArrayInput` via:
//
//	DeviceSubRequestArray{ DeviceSubRequestArgs{...} }
type DeviceSubRequestArrayInput interface {
	pulumi.Input

	ToDeviceSubRequestArrayOutput() DeviceSubRequestArrayOutput
	ToDeviceSubRequestArrayOutputWithContext(context.Context) DeviceSubRequestArrayOutput
}

type DeviceSubRequestArray []DeviceSubRequestInput

func (DeviceSubRequestArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSubRequest)(nil)).Elem()
}

func (i DeviceSubRequestArray) ToDeviceSubRequestArrayOutput() DeviceSubRequestArrayOutput {
	return i.ToDeviceSubRequestArrayOutputWithContext(context.Background())
}

func (i DeviceSubRequestArray) ToDeviceSubRequestArrayOutputWithContext(ctx context.Context) DeviceSubRequestArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSubRequestArrayOutput)
}

// DeviceSubRequest describes a request for device provided in the claim.spec.devices.requests[].firstAvailable array. Each is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// DeviceSubRequest is similar to Request, but doesn't expose the AdminAccess or FirstAvailable fields, as those can only be set on the top-level request. AdminAccess is not supported for requests with a prioritized list, and recursive FirstAvailable fields are not supported.
type DeviceSubRequestOutput struct{ *pulumi.OutputState }

func (DeviceSubRequestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSubRequest)(nil)).Elem()
}

func (o DeviceSubRequestOutput) ToDeviceSubRequestOutput() DeviceSubRequestOutput {
	return o
}

func (o DeviceSubRequestOutput) ToDeviceSubRequestOutputWithContext(ctx context.Context) DeviceSubRequestOutput {
	return o
}

// AllocationMode and its related fields define how devices are allocated to satisfy this subrequest. Supported values are:
//
// - ExactCount: This request is for a specific number of devices.
// This is the default. The exact number is provided in the
// count field.
//
// - All: This subrequest is for all of the matching devices in a pool.
// Allocation will fail if some devices are already allocated,
// unless adminAccess is requested.
//
// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other subrequests must specify this field.
//
// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
func (o DeviceSubRequestOutput) AllocationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceSubRequest) *string { return v.AllocationMode }).(pulumi.StringPtrOutput)
}

// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
func (o DeviceSubRequestOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceSubRequest) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this subrequest.
//
// A class is required. Which classes are available depends on the cluster.
//
// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
func (o DeviceSubRequestOutput) DeviceClassName() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceSubRequest) string { return v.DeviceClassName }).(pulumi.StringOutput)
}

// Name can be used to reference this subrequest in the list of constraints or the list of configurations for the claim. References must use the format <main request>/<subrequest>.
//
// Must be a DNS label.
func (o DeviceSubRequestOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceSubRequest) string { return v.Name }).(pulumi.StringOutput)
}

// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this subrequest. All selectors must be satisfied for a device to be considered.
func (o DeviceSubRequestOutput) Selectors() DeviceSelectorArrayOutput {
	return o.ApplyT(func(v DeviceSubRequest) []DeviceSelector { return v.Selectors }).(DeviceSelectorArrayOutput)
}

// If specified, the request's tolerations.
//
// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
//
// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
//
// The maximum number of tolerations is 16.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o DeviceSubRequestOutput) Tolerations() DeviceTolerationArrayOutput {
	return o.ApplyT(func(v DeviceSubRequest) []DeviceToleration { return v.Tolerations }).(DeviceTolerationArrayOutput)
}

type DeviceSubRequestArrayOutput struct{ *pulumi.OutputState }

func (DeviceSubRequestArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSubRequest)(nil)).Elem()
}

func (o DeviceSubRequestArrayOutput) ToDeviceSubRequestArrayOutput() DeviceSubRequestArrayOutput {
	return o
}

func (o DeviceSubRequestArrayOutput) ToDeviceSubRequestArrayOutputWithContext(ctx context.Context) DeviceSubRequestArrayOutput {
	return o
}

func (o DeviceSubRequestArrayOutput) Index(i pulumi.IntInput) DeviceSubRequestOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceSubRequest {
		return vs[0].([]DeviceSubRequest)[vs[1].(int)]
	}).(DeviceSubRequestOutput)
}

// DeviceSubRequest describes a request for device provided in the claim.spec.devices.requests[].firstAvailable array. Each is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// DeviceSubRequest is similar to Request, but doesn't expose the AdminAccess or FirstAvailable fields, as those can only be set on the top-level request. AdminAccess is not supported for requests with a prioritized list, and recursive FirstAvailable fields are not supported.
type DeviceSubRequestPatch struct {
	// AllocationMode and its related fields define how devices are allocated to satisfy this subrequest. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This subrequest is for all of the matching devices in a pool.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other subrequests must specify this field.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode *string `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	Count *int `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this subrequest.
	//
	// A class is required. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName *string `pulumi:"deviceClassName"`
	// Name can be used to reference this subrequest in the list of constraints or the list of configurations for the claim. References must use the format <main request>/<subrequest>.
	//
	// Must be a DNS label.
	Name *string `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this subrequest. All selectors must be satisfied for a device to be considered.
	Selectors []DeviceSelectorPatch `pulumi:"selectors"`
	// If specified, the request's tolerations.
	//
	// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
	//
	// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations []DeviceTolerationPatch `pulumi:"tolerations"`
}

// DeviceSubRequestPatchInput is an input type that accepts DeviceSubRequestPatchArgs and DeviceSubRequestPatchOutput values.
// You can construct a concrete instance of `DeviceSubRequestPatchInput` via:
//
//	DeviceSubRequestPatchArgs{...}
type DeviceSubRequestPatchInput interface {
	pulumi.Input

	ToDeviceSubRequestPatchOutput() DeviceSubRequestPatchOutput
	ToDeviceSubRequestPatchOutputWithContext(context.Context) DeviceSubRequestPatchOutput
}

// DeviceSubRequest describes a request for device provided in the claim.spec.devices.requests[].firstAvailable array. Each is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// DeviceSubRequest is similar to Request, but doesn't expose the AdminAccess or FirstAvailable fields, as those can only be set on the top-level request. AdminAccess is not supported for requests with a prioritized list, and recursive FirstAvailable fields are not supported.
type DeviceSubRequestPatchArgs struct {
	// AllocationMode and its related fields define how devices are allocated to satisfy this subrequest. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This subrequest is for all of the matching devices in a pool.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other subrequests must specify this field.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode pulumi.StringPtrInput `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this subrequest.
	//
	// A class is required. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName pulumi.StringPtrInput `pulumi:"deviceClassName"`
	// Name can be used to reference this subrequest in the list of constraints or the list of configurations for the claim. References must use the format <main request>/<subrequest>.
	//
	// Must be a DNS label.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this subrequest. All selectors must be satisfied for a device to be considered.
	Selectors DeviceSelectorPatchArrayInput `pulumi:"selectors"`
	// If specified, the request's tolerations.
	//
	// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
	//
	// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
	//
	// The maximum number of tolerations is 16.
	//
	// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
	Tolerations DeviceTolerationPatchArrayInput `pulumi:"tolerations"`
}

func (DeviceSubRequestPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSubRequestPatch)(nil)).Elem()
}

func (i DeviceSubRequestPatchArgs) ToDeviceSubRequestPatchOutput() DeviceSubRequestPatchOutput {
	return i.ToDeviceSubRequestPatchOutputWithContext(context.Background())
}

func (i DeviceSubRequestPatchArgs) ToDeviceSubRequestPatchOutputWithContext(ctx context.Context) DeviceSubRequestPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSubRequestPatchOutput)
}

// DeviceSubRequestPatchArrayInput is an input type that accepts DeviceSubRequestPatchArray and DeviceSubRequestPatchArrayOutput values.
// You can construct a concrete instance of `DeviceSubRequestPatchArrayInput` via:
//
//	DeviceSubRequestPatchArray{ DeviceSubRequestPatchArgs{...} }
type DeviceSubRequestPatchArrayInput interface {
	pulumi.Input

	ToDeviceSubRequestPatchArrayOutput() DeviceSubRequestPatchArrayOutput
	ToDeviceSubRequestPatchArrayOutputWithContext(context.Context) DeviceSubRequestPatchArrayOutput
}

type DeviceSubRequestPatchArray []DeviceSubRequestPatchInput

func (DeviceSubRequestPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSubRequestPatch)(nil)).Elem()
}

func (i DeviceSubRequestPatchArray) ToDeviceSubRequestPatchArrayOutput() DeviceSubRequestPatchArrayOutput {
	return i.ToDeviceSubRequestPatchArrayOutputWithContext(context.Background())
}

func (i DeviceSubRequestPatchArray) ToDeviceSubRequestPatchArrayOutputWithContext(ctx context.Context) DeviceSubRequestPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSubRequestPatchArrayOutput)
}

// DeviceSubRequest describes a request for device provided in the claim.spec.devices.requests[].firstAvailable array. Each is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// DeviceSubRequest is similar to Request, but doesn't expose the AdminAccess or FirstAvailable fields, as those can only be set on the top-level request. AdminAccess is not supported for requests with a prioritized list, and recursive FirstAvailable fields are not supported.
type DeviceSubRequestPatchOutput struct{ *pulumi.OutputState }

func (DeviceSubRequestPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSubRequestPatch)(nil)).Elem()
}

func (o DeviceSubRequestPatchOutput) ToDeviceSubRequestPatchOutput() DeviceSubRequestPatchOutput {
	return o
}

func (o DeviceSubRequestPatchOutput) ToDeviceSubRequestPatchOutputWithContext(ctx context.Context) DeviceSubRequestPatchOutput {
	return o
}

// AllocationMode and its related fields define how devices are allocated to satisfy this subrequest. Supported values are:
//
// - ExactCount: This request is for a specific number of devices.
// This is the default. The exact number is provided in the
// count field.
//
// - All: This subrequest is for all of the matching devices in a pool.
// Allocation will fail if some devices are already allocated,
// unless adminAccess is requested.
//
// If AllocationMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other subrequests must specify this field.
//
// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
func (o DeviceSubRequestPatchOutput) AllocationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceSubRequestPatch) *string { return v.AllocationMode }).(pulumi.StringPtrOutput)
}

// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
func (o DeviceSubRequestPatchOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceSubRequestPatch) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this subrequest.
//
// A class is required. Which classes are available depends on the cluster.
//
// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
func (o DeviceSubRequestPatchOutput) DeviceClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceSubRequestPatch) *string { return v.DeviceClassName }).(pulumi.StringPtrOutput)
}

// Name can be used to reference this subrequest in the list of constraints or the list of configurations for the claim. References must use the format <main request>/<subrequest>.
//
// Must be a DNS label.
func (o DeviceSubRequestPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceSubRequestPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this subrequest. All selectors must be satisfied for a device to be considered.
func (o DeviceSubRequestPatchOutput) Selectors() DeviceSelectorPatchArrayOutput {
	return o.ApplyT(func(v DeviceSubRequestPatch) []DeviceSelectorPatch { return v.Selectors }).(DeviceSelectorPatchArrayOutput)
}

// If specified, the request's tolerations.
//
// Tolerations for NoSchedule are required to allocate a device which has a taint with that effect. The same applies to NoExecute.
//
// In addition, should any of the allocated devices get tainted with NoExecute after allocation and that effect is not tolerated, then all pods consuming the ResourceClaim get deleted to evict them. The scheduler will not let new pods reserve the claim while it has these tainted devices. Once all pods are evicted, the claim will get deallocated.
//
// The maximum number of tolerations is 16.
//
// This is an alpha field and requires enabling the DRADeviceTaints feature gate.
func (o DeviceSubRequestPatchOutput) Tolerations() DeviceTolerationPatchArrayOutput {
	return o.ApplyT(func(v DeviceSubRequestPatch) []DeviceTolerationPatch { return v.Tolerations }).(DeviceTolerationPatchArrayOutput)
}

type DeviceSubRequestPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceSubRequestPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSubRequestPatch)(nil)).Elem()
}

func (o DeviceSubRequestPatchArrayOutput) ToDeviceSubRequestPatchArrayOutput() DeviceSubRequestPatchArrayOutput {
	return o
}

func (o DeviceSubRequestPatchArrayOutput) ToDeviceSubRequestPatchArrayOutputWithContext(ctx context.Context) DeviceSubRequestPatchArrayOutput {
	return o
}

func (o DeviceSubRequestPatchArrayOutput) Index(i pulumi.IntInput) DeviceSubRequestPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceSubRequestPatch {
		return vs[0].([]DeviceSubRequestPatch)[vs[1].(int)]
	}).(DeviceSubRequestPatchOutput)
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaint struct {
	// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
	Effect string `pulumi:"effect"`
	// The taint key to be applied to a device. Must be a label name.
	Key string `pulumi:"key"`
	// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
	TimeAdded *string `pulumi:"timeAdded"`
	// The taint value corresponding to the taint key. Must be a label value.
	Value *string `pulumi:"value"`
}

// DeviceTaintInput is an input type that accepts DeviceTaintArgs and DeviceTaintOutput values.
// You can construct a concrete instance of `DeviceTaintInput` via:
//
//	DeviceTaintArgs{...}
type DeviceTaintInput interface {
	pulumi.Input

	ToDeviceTaintOutput() DeviceTaintOutput
	ToDeviceTaintOutputWithContext(context.Context) DeviceTaintOutput
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintArgs struct {
	// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
	Effect pulumi.StringInput `pulumi:"effect"`
	// The taint key to be applied to a device. Must be a label name.
	Key pulumi.StringInput `pulumi:"key"`
	// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
	TimeAdded pulumi.StringPtrInput `pulumi:"timeAdded"`
	// The taint value corresponding to the taint key. Must be a label value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (DeviceTaintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaint)(nil)).Elem()
}

func (i DeviceTaintArgs) ToDeviceTaintOutput() DeviceTaintOutput {
	return i.ToDeviceTaintOutputWithContext(context.Background())
}

func (i DeviceTaintArgs) ToDeviceTaintOutputWithContext(ctx context.Context) DeviceTaintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintOutput)
}

// DeviceTaintArrayInput is an input type that accepts DeviceTaintArray and DeviceTaintArrayOutput values.
// You can construct a concrete instance of `DeviceTaintArrayInput` via:
//
//	DeviceTaintArray{ DeviceTaintArgs{...} }
type DeviceTaintArrayInput interface {
	pulumi.Input

	ToDeviceTaintArrayOutput() DeviceTaintArrayOutput
	ToDeviceTaintArrayOutputWithContext(context.Context) DeviceTaintArrayOutput
}

type DeviceTaintArray []DeviceTaintInput

func (DeviceTaintArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceTaint)(nil)).Elem()
}

func (i DeviceTaintArray) ToDeviceTaintArrayOutput() DeviceTaintArrayOutput {
	return i.ToDeviceTaintArrayOutputWithContext(context.Background())
}

func (i DeviceTaintArray) ToDeviceTaintArrayOutputWithContext(ctx context.Context) DeviceTaintArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintArrayOutput)
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintOutput struct{ *pulumi.OutputState }

func (DeviceTaintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaint)(nil)).Elem()
}

func (o DeviceTaintOutput) ToDeviceTaintOutput() DeviceTaintOutput {
	return o
}

func (o DeviceTaintOutput) ToDeviceTaintOutputWithContext(ctx context.Context) DeviceTaintOutput {
	return o
}

// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
func (o DeviceTaintOutput) Effect() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceTaint) string { return v.Effect }).(pulumi.StringOutput)
}

// The taint key to be applied to a device. Must be a label name.
func (o DeviceTaintOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceTaint) string { return v.Key }).(pulumi.StringOutput)
}

// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
func (o DeviceTaintOutput) TimeAdded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaint) *string { return v.TimeAdded }).(pulumi.StringPtrOutput)
}

// The taint value corresponding to the taint key. Must be a label value.
func (o DeviceTaintOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaint) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type DeviceTaintArrayOutput struct{ *pulumi.OutputState }

func (DeviceTaintArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceTaint)(nil)).Elem()
}

func (o DeviceTaintArrayOutput) ToDeviceTaintArrayOutput() DeviceTaintArrayOutput {
	return o
}

func (o DeviceTaintArrayOutput) ToDeviceTaintArrayOutputWithContext(ctx context.Context) DeviceTaintArrayOutput {
	return o
}

func (o DeviceTaintArrayOutput) Index(i pulumi.IntInput) DeviceTaintOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceTaint {
		return vs[0].([]DeviceTaint)[vs[1].(int)]
	}).(DeviceTaintOutput)
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintPatch struct {
	// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
	Effect *string `pulumi:"effect"`
	// The taint key to be applied to a device. Must be a label name.
	Key *string `pulumi:"key"`
	// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
	TimeAdded *string `pulumi:"timeAdded"`
	// The taint value corresponding to the taint key. Must be a label value.
	Value *string `pulumi:"value"`
}

// DeviceTaintPatchInput is an input type that accepts DeviceTaintPatchArgs and DeviceTaintPatchOutput values.
// You can construct a concrete instance of `DeviceTaintPatchInput` via:
//
//	DeviceTaintPatchArgs{...}
type DeviceTaintPatchInput interface {
	pulumi.Input

	ToDeviceTaintPatchOutput() DeviceTaintPatchOutput
	ToDeviceTaintPatchOutputWithContext(context.Context) DeviceTaintPatchOutput
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintPatchArgs struct {
	// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// The taint key to be applied to a device. Must be a label name.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
	TimeAdded pulumi.StringPtrInput `pulumi:"timeAdded"`
	// The taint value corresponding to the taint key. Must be a label value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (DeviceTaintPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintPatch)(nil)).Elem()
}

func (i DeviceTaintPatchArgs) ToDeviceTaintPatchOutput() DeviceTaintPatchOutput {
	return i.ToDeviceTaintPatchOutputWithContext(context.Background())
}

func (i DeviceTaintPatchArgs) ToDeviceTaintPatchOutputWithContext(ctx context.Context) DeviceTaintPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintPatchOutput)
}

// DeviceTaintPatchArrayInput is an input type that accepts DeviceTaintPatchArray and DeviceTaintPatchArrayOutput values.
// You can construct a concrete instance of `DeviceTaintPatchArrayInput` via:
//
//	DeviceTaintPatchArray{ DeviceTaintPatchArgs{...} }
type DeviceTaintPatchArrayInput interface {
	pulumi.Input

	ToDeviceTaintPatchArrayOutput() DeviceTaintPatchArrayOutput
	ToDeviceTaintPatchArrayOutputWithContext(context.Context) DeviceTaintPatchArrayOutput
}

type DeviceTaintPatchArray []DeviceTaintPatchInput

func (DeviceTaintPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceTaintPatch)(nil)).Elem()
}

func (i DeviceTaintPatchArray) ToDeviceTaintPatchArrayOutput() DeviceTaintPatchArrayOutput {
	return i.ToDeviceTaintPatchArrayOutputWithContext(context.Background())
}

func (i DeviceTaintPatchArray) ToDeviceTaintPatchArrayOutputWithContext(ctx context.Context) DeviceTaintPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintPatchArrayOutput)
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintPatchOutput struct{ *pulumi.OutputState }

func (DeviceTaintPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintPatch)(nil)).Elem()
}

func (o DeviceTaintPatchOutput) ToDeviceTaintPatchOutput() DeviceTaintPatchOutput {
	return o
}

func (o DeviceTaintPatchOutput) ToDeviceTaintPatchOutputWithContext(ctx context.Context) DeviceTaintPatchOutput {
	return o
}

// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
func (o DeviceTaintPatchOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintPatch) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// The taint key to be applied to a device. Must be a label name.
func (o DeviceTaintPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
func (o DeviceTaintPatchOutput) TimeAdded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintPatch) *string { return v.TimeAdded }).(pulumi.StringPtrOutput)
}

// The taint value corresponding to the taint key. Must be a label value.
func (o DeviceTaintPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type DeviceTaintPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceTaintPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceTaintPatch)(nil)).Elem()
}

func (o DeviceTaintPatchArrayOutput) ToDeviceTaintPatchArrayOutput() DeviceTaintPatchArrayOutput {
	return o
}

func (o DeviceTaintPatchArrayOutput) ToDeviceTaintPatchArrayOutputWithContext(ctx context.Context) DeviceTaintPatchArrayOutput {
	return o
}

func (o DeviceTaintPatchArrayOutput) Index(i pulumi.IntInput) DeviceTaintPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceTaintPatch {
		return vs[0].([]DeviceTaintPatch)[vs[1].(int)]
	}).(DeviceTaintPatchOutput)
}

// The ResourceClaim this DeviceToleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
type DeviceToleration struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule and NoExecute.
	Effect *string `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. Must be a label name.
	Key *string `pulumi:"key"`
	// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a ResourceClaim can tolerate all taints of a particular category.
	Operator *string `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system. If larger than zero, the time when the pod needs to be evicted is calculated as <time when taint was adedd> + <toleration seconds>.
	TolerationSeconds *int `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to. If the operator is Exists, the value must be empty, otherwise just a regular string. Must be a label value.
	Value *string `pulumi:"value"`
}

// DeviceTolerationInput is an input type that accepts DeviceTolerationArgs and DeviceTolerationOutput values.
// You can construct a concrete instance of `DeviceTolerationInput` via:
//
//	DeviceTolerationArgs{...}
type DeviceTolerationInput interface {
	pulumi.Input

	ToDeviceTolerationOutput() DeviceTolerationOutput
	ToDeviceTolerationOutputWithContext(context.Context) DeviceTolerationOutput
}

// The ResourceClaim this DeviceToleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
type DeviceTolerationArgs struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule and NoExecute.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. Must be a label name.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a ResourceClaim can tolerate all taints of a particular category.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system. If larger than zero, the time when the pod needs to be evicted is calculated as <time when taint was adedd> + <toleration seconds>.
	TolerationSeconds pulumi.IntPtrInput `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to. If the operator is Exists, the value must be empty, otherwise just a regular string. Must be a label value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (DeviceTolerationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceToleration)(nil)).Elem()
}

func (i DeviceTolerationArgs) ToDeviceTolerationOutput() DeviceTolerationOutput {
	return i.ToDeviceTolerationOutputWithContext(context.Background())
}

func (i DeviceTolerationArgs) ToDeviceTolerationOutputWithContext(ctx context.Context) DeviceTolerationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTolerationOutput)
}

// DeviceTolerationArrayInput is an input type that accepts DeviceTolerationArray and DeviceTolerationArrayOutput values.
// You can construct a concrete instance of `DeviceTolerationArrayInput` via:
//
//	DeviceTolerationArray{ DeviceTolerationArgs{...} }
type DeviceTolerationArrayInput interface {
	pulumi.Input

	ToDeviceTolerationArrayOutput() DeviceTolerationArrayOutput
	ToDeviceTolerationArrayOutputWithContext(context.Context) DeviceTolerationArrayOutput
}

type DeviceTolerationArray []DeviceTolerationInput

func (DeviceTolerationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceToleration)(nil)).Elem()
}

func (i DeviceTolerationArray) ToDeviceTolerationArrayOutput() DeviceTolerationArrayOutput {
	return i.ToDeviceTolerationArrayOutputWithContext(context.Background())
}

func (i DeviceTolerationArray) ToDeviceTolerationArrayOutputWithContext(ctx context.Context) DeviceTolerationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTolerationArrayOutput)
}

// The ResourceClaim this DeviceToleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
type DeviceTolerationOutput struct{ *pulumi.OutputState }

func (DeviceTolerationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceToleration)(nil)).Elem()
}

func (o DeviceTolerationOutput) ToDeviceTolerationOutput() DeviceTolerationOutput {
	return o
}

func (o DeviceTolerationOutput) ToDeviceTolerationOutputWithContext(ctx context.Context) DeviceTolerationOutput {
	return o
}

// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule and NoExecute.
func (o DeviceTolerationOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceToleration) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. Must be a label name.
func (o DeviceTolerationOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceToleration) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a ResourceClaim can tolerate all taints of a particular category.
func (o DeviceTolerationOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceToleration) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system. If larger than zero, the time when the pod needs to be evicted is calculated as <time when taint was adedd> + <toleration seconds>.
func (o DeviceTolerationOutput) TolerationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceToleration) *int { return v.TolerationSeconds }).(pulumi.IntPtrOutput)
}

// Value is the taint value the toleration matches to. If the operator is Exists, the value must be empty, otherwise just a regular string. Must be a label value.
func (o DeviceTolerationOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceToleration) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type DeviceTolerationArrayOutput struct{ *pulumi.OutputState }

func (DeviceTolerationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceToleration)(nil)).Elem()
}

func (o DeviceTolerationArrayOutput) ToDeviceTolerationArrayOutput() DeviceTolerationArrayOutput {
	return o
}

func (o DeviceTolerationArrayOutput) ToDeviceTolerationArrayOutputWithContext(ctx context.Context) DeviceTolerationArrayOutput {
	return o
}

func (o DeviceTolerationArrayOutput) Index(i pulumi.IntInput) DeviceTolerationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceToleration {
		return vs[0].([]DeviceToleration)[vs[1].(int)]
	}).(DeviceTolerationOutput)
}

// The ResourceClaim this DeviceToleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
type DeviceTolerationPatch struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule and NoExecute.
	Effect *string `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. Must be a label name.
	Key *string `pulumi:"key"`
	// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a ResourceClaim can tolerate all taints of a particular category.
	Operator *string `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system. If larger than zero, the time when the pod needs to be evicted is calculated as <time when taint was adedd> + <toleration seconds>.
	TolerationSeconds *int `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to. If the operator is Exists, the value must be empty, otherwise just a regular string. Must be a label value.
	Value *string `pulumi:"value"`
}

// DeviceTolerationPatchInput is an input type that accepts DeviceTolerationPatchArgs and DeviceTolerationPatchOutput values.
// You can construct a concrete instance of `DeviceTolerationPatchInput` via:
//
//	DeviceTolerationPatchArgs{...}
type DeviceTolerationPatchInput interface {
	pulumi.Input

	ToDeviceTolerationPatchOutput() DeviceTolerationPatchOutput
	ToDeviceTolerationPatchOutputWithContext(context.Context) DeviceTolerationPatchOutput
}

// The ResourceClaim this DeviceToleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
type DeviceTolerationPatchArgs struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule and NoExecute.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. Must be a label name.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a ResourceClaim can tolerate all taints of a particular category.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system. If larger than zero, the time when the pod needs to be evicted is calculated as <time when taint was adedd> + <toleration seconds>.
	TolerationSeconds pulumi.IntPtrInput `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to. If the operator is Exists, the value must be empty, otherwise just a regular string. Must be a label value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (DeviceTolerationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTolerationPatch)(nil)).Elem()
}

func (i DeviceTolerationPatchArgs) ToDeviceTolerationPatchOutput() DeviceTolerationPatchOutput {
	return i.ToDeviceTolerationPatchOutputWithContext(context.Background())
}

func (i DeviceTolerationPatchArgs) ToDeviceTolerationPatchOutputWithContext(ctx context.Context) DeviceTolerationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTolerationPatchOutput)
}

// DeviceTolerationPatchArrayInput is an input type that accepts DeviceTolerationPatchArray and DeviceTolerationPatchArrayOutput values.
// You can construct a concrete instance of `DeviceTolerationPatchArrayInput` via:
//
//	DeviceTolerationPatchArray{ DeviceTolerationPatchArgs{...} }
type DeviceTolerationPatchArrayInput interface {
	pulumi.Input

	ToDeviceTolerationPatchArrayOutput() DeviceTolerationPatchArrayOutput
	ToDeviceTolerationPatchArrayOutputWithContext(context.Context) DeviceTolerationPatchArrayOutput
}

type DeviceTolerationPatchArray []DeviceTolerationPatchInput

func (DeviceTolerationPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceTolerationPatch)(nil)).Elem()
}

func (i DeviceTolerationPatchArray) ToDeviceTolerationPatchArrayOutput() DeviceTolerationPatchArrayOutput {
	return i.ToDeviceTolerationPatchArrayOutputWithContext(context.Background())
}

func (i DeviceTolerationPatchArray) ToDeviceTolerationPatchArrayOutputWithContext(ctx context.Context) DeviceTolerationPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTolerationPatchArrayOutput)
}

// The ResourceClaim this DeviceToleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
type DeviceTolerationPatchOutput struct{ *pulumi.OutputState }

func (DeviceTolerationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTolerationPatch)(nil)).Elem()
}

func (o DeviceTolerationPatchOutput) ToDeviceTolerationPatchOutput() DeviceTolerationPatchOutput {
	return o
}

func (o DeviceTolerationPatchOutput) ToDeviceTolerationPatchOutputWithContext(ctx context.Context) DeviceTolerationPatchOutput {
	return o
}

// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule and NoExecute.
func (o DeviceTolerationPatchOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTolerationPatch) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. Must be a label name.
func (o DeviceTolerationPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTolerationPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a ResourceClaim can tolerate all taints of a particular category.
func (o DeviceTolerationPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTolerationPatch) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system. If larger than zero, the time when the pod needs to be evicted is calculated as <time when taint was adedd> + <toleration seconds>.
func (o DeviceTolerationPatchOutput) TolerationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceTolerationPatch) *int { return v.TolerationSeconds }).(pulumi.IntPtrOutput)
}

// Value is the taint value the toleration matches to. If the operator is Exists, the value must be empty, otherwise just a regular string. Must be a label value.
func (o DeviceTolerationPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTolerationPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type DeviceTolerationPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceTolerationPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceTolerationPatch)(nil)).Elem()
}

func (o DeviceTolerationPatchArrayOutput) ToDeviceTolerationPatchArrayOutput() DeviceTolerationPatchArrayOutput {
	return o
}

func (o DeviceTolerationPatchArrayOutput) ToDeviceTolerationPatchArrayOutputWithContext(ctx context.Context) DeviceTolerationPatchArrayOutput {
	return o
}

func (o DeviceTolerationPatchArrayOutput) Index(i pulumi.IntInput) DeviceTolerationPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceTolerationPatch {
		return vs[0].([]DeviceTolerationPatch)[vs[1].(int)]
	}).(DeviceTolerationPatchOutput)
}

// NetworkDeviceData provides network-related details for the allocated device. This information may be filled by drivers or other components to configure or identify the device within a network context.
type NetworkDeviceData struct {
	// HardwareAddress represents the hardware address (e.g. MAC Address) of the device's network interface.
	//
	// Must not be longer than 128 characters.
	HardwareAddress *string `pulumi:"hardwareAddress"`
	// InterfaceName specifies the name of the network interface associated with the allocated device. This might be the name of a physical or virtual network interface being configured in the pod.
	//
	// Must not be longer than 256 characters.
	InterfaceName *string `pulumi:"interfaceName"`
	// IPs lists the network addresses assigned to the device's network interface. This can include both IPv4 and IPv6 addresses. The IPs are in the CIDR notation, which includes both the address and the associated subnet mask. e.g.: "192.0.2.5/24" for IPv4 and "2001:db8::5/64" for IPv6.
	//
	// Must not contain more than 16 entries.
	Ips []string `pulumi:"ips"`
}

// NetworkDeviceDataInput is an input type that accepts NetworkDeviceDataArgs and NetworkDeviceDataOutput values.
// You can construct a concrete instance of `NetworkDeviceDataInput` via:
//
//	NetworkDeviceDataArgs{...}
type NetworkDeviceDataInput interface {
	pulumi.Input

	ToNetworkDeviceDataOutput() NetworkDeviceDataOutput
	ToNetworkDeviceDataOutputWithContext(context.Context) NetworkDeviceDataOutput
}

// NetworkDeviceData provides network-related details for the allocated device. This information may be filled by drivers or other components to configure or identify the device within a network context.
type NetworkDeviceDataArgs struct {
	// HardwareAddress represents the hardware address (e.g. MAC Address) of the device's network interface.
	//
	// Must not be longer than 128 characters.
	HardwareAddress pulumi.StringPtrInput `pulumi:"hardwareAddress"`
	// InterfaceName specifies the name of the network interface associated with the allocated device. This might be the name of a physical or virtual network interface being configured in the pod.
	//
	// Must not be longer than 256 characters.
	InterfaceName pulumi.StringPtrInput `pulumi:"interfaceName"`
	// IPs lists the network addresses assigned to the device's network interface. This can include both IPv4 and IPv6 addresses. The IPs are in the CIDR notation, which includes both the address and the associated subnet mask. e.g.: "192.0.2.5/24" for IPv4 and "2001:db8::5/64" for IPv6.
	//
	// Must not contain more than 16 entries.
	Ips pulumi.StringArrayInput `pulumi:"ips"`
}

func (NetworkDeviceDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDeviceData)(nil)).Elem()
}

func (i NetworkDeviceDataArgs) ToNetworkDeviceDataOutput() NetworkDeviceDataOutput {
	return i.ToNetworkDeviceDataOutputWithContext(context.Background())
}

func (i NetworkDeviceDataArgs) ToNetworkDeviceDataOutputWithContext(ctx context.Context) NetworkDeviceDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDeviceDataOutput)
}

func (i NetworkDeviceDataArgs) ToNetworkDeviceDataPtrOutput() NetworkDeviceDataPtrOutput {
	return i.ToNetworkDeviceDataPtrOutputWithContext(context.Background())
}

func (i NetworkDeviceDataArgs) ToNetworkDeviceDataPtrOutputWithContext(ctx context.Context) NetworkDeviceDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDeviceDataOutput).ToNetworkDeviceDataPtrOutputWithContext(ctx)
}

// NetworkDeviceDataPtrInput is an input type that accepts NetworkDeviceDataArgs, NetworkDeviceDataPtr and NetworkDeviceDataPtrOutput values.
// You can construct a concrete instance of `NetworkDeviceDataPtrInput` via:
//
//	        NetworkDeviceDataArgs{...}
//
//	or:
//
//	        nil
type NetworkDeviceDataPtrInput interface {
	pulumi.Input

	ToNetworkDeviceDataPtrOutput() NetworkDeviceDataPtrOutput
	ToNetworkDeviceDataPtrOutputWithContext(context.Context) NetworkDeviceDataPtrOutput
}

type networkDeviceDataPtrType NetworkDeviceDataArgs

func NetworkDeviceDataPtr(v *NetworkDeviceDataArgs) NetworkDeviceDataPtrInput {
	return (*networkDeviceDataPtrType)(v)
}

func (*networkDeviceDataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDeviceData)(nil)).Elem()
}

func (i *networkDeviceDataPtrType) ToNetworkDeviceDataPtrOutput() NetworkDeviceDataPtrOutput {
	return i.ToNetworkDeviceDataPtrOutputWithContext(context.Background())
}

func (i *networkDeviceDataPtrType) ToNetworkDeviceDataPtrOutputWithContext(ctx context.Context) NetworkDeviceDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDeviceDataPtrOutput)
}

// NetworkDeviceData provides network-related details for the allocated device. This information may be filled by drivers or other components to configure or identify the device within a network context.
type NetworkDeviceDataOutput struct{ *pulumi.OutputState }

func (NetworkDeviceDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDeviceData)(nil)).Elem()
}

func (o NetworkDeviceDataOutput) ToNetworkDeviceDataOutput() NetworkDeviceDataOutput {
	return o
}

func (o NetworkDeviceDataOutput) ToNetworkDeviceDataOutputWithContext(ctx context.Context) NetworkDeviceDataOutput {
	return o
}

func (o NetworkDeviceDataOutput) ToNetworkDeviceDataPtrOutput() NetworkDeviceDataPtrOutput {
	return o.ToNetworkDeviceDataPtrOutputWithContext(context.Background())
}

func (o NetworkDeviceDataOutput) ToNetworkDeviceDataPtrOutputWithContext(ctx context.Context) NetworkDeviceDataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NetworkDeviceData) *NetworkDeviceData {
		return &v
	}).(NetworkDeviceDataPtrOutput)
}

// HardwareAddress represents the hardware address (e.g. MAC Address) of the device's network interface.
//
// Must not be longer than 128 characters.
func (o NetworkDeviceDataOutput) HardwareAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDeviceData) *string { return v.HardwareAddress }).(pulumi.StringPtrOutput)
}

// InterfaceName specifies the name of the network interface associated with the allocated device. This might be the name of a physical or virtual network interface being configured in the pod.
//
// Must not be longer than 256 characters.
func (o NetworkDeviceDataOutput) InterfaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDeviceData) *string { return v.InterfaceName }).(pulumi.StringPtrOutput)
}

// IPs lists the network addresses assigned to the device's network interface. This can include both IPv4 and IPv6 addresses. The IPs are in the CIDR notation, which includes both the address and the associated subnet mask. e.g.: "192.0.2.5/24" for IPv4 and "2001:db8::5/64" for IPv6.
//
// Must not contain more than 16 entries.
func (o NetworkDeviceDataOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkDeviceData) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

type NetworkDeviceDataPtrOutput struct{ *pulumi.OutputState }

func (NetworkDeviceDataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDeviceData)(nil)).Elem()
}

func (o NetworkDeviceDataPtrOutput) ToNetworkDeviceDataPtrOutput() NetworkDeviceDataPtrOutput {
	return o
}

func (o NetworkDeviceDataPtrOutput) ToNetworkDeviceDataPtrOutputWithContext(ctx context.Context) NetworkDeviceDataPtrOutput {
	return o
}

func (o NetworkDeviceDataPtrOutput) Elem() NetworkDeviceDataOutput {
	return o.ApplyT(func(v *NetworkDeviceData) NetworkDeviceData {
		if v != nil {
			return *v
		}
		var ret NetworkDeviceData
		return ret
	}).(NetworkDeviceDataOutput)
}

// HardwareAddress represents the hardware address (e.g. MAC Address) of the device's network interface.
//
// Must not be longer than 128 characters.
func (o NetworkDeviceDataPtrOutput) HardwareAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NetworkDeviceData) *string {
		if v == nil {
			return nil
		}
		return v.HardwareAddress
	}).(pulumi.StringPtrOutput)
}

// InterfaceName specifies the name of the network interface associated with the allocated device. This might be the name of a physical or virtual network interface being configured in the pod.
//
// Must not be longer than 256 characters.
func (o NetworkDeviceDataPtrOutput) InterfaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NetworkDeviceData) *string {
		if v == nil {
			return nil
		}
		return v.InterfaceName
	}).(pulumi.StringPtrOutput)
}

// IPs lists the network addresses assigned to the device's network interface. This can include both IPv4 and IPv6 addresses. The IPs are in the CIDR notation, which includes both the address and the associated subnet mask. e.g.: "192.0.2.5/24" for IPv4 and "2001:db8::5/64" for IPv6.
//
// Must not contain more than 16 entries.
func (o NetworkDeviceDataPtrOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NetworkDeviceData) []string {
		if v == nil {
			return nil
		}
		return v.Ips
	}).(pulumi.StringArrayOutput)
}

// NetworkDeviceData provides network-related details for the allocated device. This information may be filled by drivers or other components to configure or identify the device within a network context.
type NetworkDeviceDataPatch struct {
	// HardwareAddress represents the hardware address (e.g. MAC Address) of the device's network interface.
	//
	// Must not be longer than 128 characters.
	HardwareAddress *string `pulumi:"hardwareAddress"`
	// InterfaceName specifies the name of the network interface associated with the allocated device. This might be the name of a physical or virtual network interface being configured in the pod.
	//
	// Must not be longer than 256 characters.
	InterfaceName *string `pulumi:"interfaceName"`
	// IPs lists the network addresses assigned to the device's network interface. This can include both IPv4 and IPv6 addresses. The IPs are in the CIDR notation, which includes both the address and the associated subnet mask. e.g.: "192.0.2.5/24" for IPv4 and "2001:db8::5/64" for IPv6.
	//
	// Must not contain more than 16 entries.
	Ips []string `pulumi:"ips"`
}

// NetworkDeviceDataPatchInput is an input type that accepts NetworkDeviceDataPatchArgs and NetworkDeviceDataPatchOutput values.
// You can construct a concrete instance of `NetworkDeviceDataPatchInput` via:
//
//	NetworkDeviceDataPatchArgs{...}
type NetworkDeviceDataPatchInput interface {
	pulumi.Input

	ToNetworkDeviceDataPatchOutput() NetworkDeviceDataPatchOutput
	ToNetworkDeviceDataPatchOutputWithContext(context.Context) NetworkDeviceDataPatchOutput
}

// NetworkDeviceData provides network-related details for the allocated device. This information may be filled by drivers or other components to configure or identify the device within a network context.
type NetworkDeviceDataPatchArgs struct {
	// HardwareAddress represents the hardware address (e.g. MAC Address) of the device's network interface.
	//
	// Must not be longer than 128 characters.
	HardwareAddress pulumi.StringPtrInput `pulumi:"hardwareAddress"`
	// InterfaceName specifies the name of the network interface associated with the allocated device. This might be the name of a physical or virtual network interface being configured in the pod.
	//
	// Must not be longer than 256 characters.
	InterfaceName pulumi.StringPtrInput `pulumi:"interfaceName"`
	// IPs lists the network addresses assigned to the device's network interface. This can include both IPv4 and IPv6 addresses. The IPs are in the CIDR notation, which includes both the address and the associated subnet mask. e.g.: "192.0.2.5/24" for IPv4 and "2001:db8::5/64" for IPv6.
	//
	// Must not contain more than 16 entries.
	Ips pulumi.StringArrayInput `pulumi:"ips"`
}

func (NetworkDeviceDataPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDeviceDataPatch)(nil)).Elem()
}

func (i NetworkDeviceDataPatchArgs) ToNetworkDeviceDataPatchOutput() NetworkDeviceDataPatchOutput {
	return i.ToNetworkDeviceDataPatchOutputWithContext(context.Background())
}

func (i NetworkDeviceDataPatchArgs) ToNetworkDeviceDataPatchOutputWithContext(ctx context.Context) NetworkDeviceDataPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDeviceDataPatchOutput)
}

func (i NetworkDeviceDataPatchArgs) ToNetworkDeviceDataPatchPtrOutput() NetworkDeviceDataPatchPtrOutput {
	return i.ToNetworkDeviceDataPatchPtrOutputWithContext(context.Background())
}

func (i NetworkDeviceDataPatchArgs) ToNetworkDeviceDataPatchPtrOutputWithContext(ctx context.Context) NetworkDeviceDataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDeviceDataPatchOutput).ToNetworkDeviceDataPatchPtrOutputWithContext(ctx)
}

// NetworkDeviceDataPatchPtrInput is an input type that accepts NetworkDeviceDataPatchArgs, NetworkDeviceDataPatchPtr and NetworkDeviceDataPatchPtrOutput values.
// You can construct a concrete instance of `NetworkDeviceDataPatchPtrInput` via:
//
//	        NetworkDeviceDataPatchArgs{...}
//
//	or:
//
//	        nil
type NetworkDeviceDataPatchPtrInput interface {
	pulumi.Input

	ToNetworkDeviceDataPatchPtrOutput() NetworkDeviceDataPatchPtrOutput
	ToNetworkDeviceDataPatchPtrOutputWithContext(context.Context) NetworkDeviceDataPatchPtrOutput
}

type networkDeviceDataPatchPtrType NetworkDeviceDataPatchArgs

func NetworkDeviceDataPatchPtr(v *NetworkDeviceDataPatchArgs) NetworkDeviceDataPatchPtrInput {
	return (*networkDeviceDataPatchPtrType)(v)
}

func (*networkDeviceDataPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDeviceDataPatch)(nil)).Elem()
}

func (i *networkDeviceDataPatchPtrType) ToNetworkDeviceDataPatchPtrOutput() NetworkDeviceDataPatchPtrOutput {
	return i.ToNetworkDeviceDataPatchPtrOutputWithContext(context.Background())
}

func (i *networkDeviceDataPatchPtrType) ToNetworkDeviceDataPatchPtrOutputWithContext(ctx context.Context) NetworkDeviceDataPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDeviceDataPatchPtrOutput)
}

// NetworkDeviceData provides network-related details for the allocated device. This information may be filled by drivers or other components to configure or identify the device within a network context.
type NetworkDeviceDataPatchOutput struct{ *pulumi.OutputState }

func (NetworkDeviceDataPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDeviceDataPatch)(nil)).Elem()
}

func (o NetworkDeviceDataPatchOutput) ToNetworkDeviceDataPatchOutput() NetworkDeviceDataPatchOutput {
	return o
}

func (o NetworkDeviceDataPatchOutput) ToNetworkDeviceDataPatchOutputWithContext(ctx context.Context) NetworkDeviceDataPatchOutput {
	return o
}

func (o NetworkDeviceDataPatchOutput) ToNetworkDeviceDataPatchPtrOutput() NetworkDeviceDataPatchPtrOutput {
	return o.ToNetworkDeviceDataPatchPtrOutputWithContext(context.Background())
}

func (o NetworkDeviceDataPatchOutput) ToNetworkDeviceDataPatchPtrOutputWithContext(ctx context.Context) NetworkDeviceDataPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NetworkDeviceDataPatch) *NetworkDeviceDataPatch {
		return &v
	}).(NetworkDeviceDataPatchPtrOutput)
}

// HardwareAddress represents the hardware address (e.g. MAC Address) of the device's network interface.
//
// Must not be longer than 128 characters.
func (o NetworkDeviceDataPatchOutput) HardwareAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDeviceDataPatch) *string { return v.HardwareAddress }).(pulumi.StringPtrOutput)
}

// InterfaceName specifies the name of the network interface associated with the allocated device. This might be the name of a physical or virtual network interface being configured in the pod.
//
// Must not be longer than 256 characters.
func (o NetworkDeviceDataPatchOutput) InterfaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDeviceDataPatch) *string { return v.InterfaceName }).(pulumi.StringPtrOutput)
}

// IPs lists the network addresses assigned to the device's network interface. This can include both IPv4 and IPv6 addresses. The IPs are in the CIDR notation, which includes both the address and the associated subnet mask. e.g.: "192.0.2.5/24" for IPv4 and "2001:db8::5/64" for IPv6.
//
// Must not contain more than 16 entries.
func (o NetworkDeviceDataPatchOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkDeviceDataPatch) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

type NetworkDeviceDataPatchPtrOutput struct{ *pulumi.OutputState }

func (NetworkDeviceDataPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDeviceDataPatch)(nil)).Elem()
}

func (o NetworkDeviceDataPatchPtrOutput) ToNetworkDeviceDataPatchPtrOutput() NetworkDeviceDataPatchPtrOutput {
	return o
}

func (o NetworkDeviceDataPatchPtrOutput) ToNetworkDeviceDataPatchPtrOutputWithContext(ctx context.Context) NetworkDeviceDataPatchPtrOutput {
	return o
}

func (o NetworkDeviceDataPatchPtrOutput) Elem() NetworkDeviceDataPatchOutput {
	return o.ApplyT(func(v *NetworkDeviceDataPatch) NetworkDeviceDataPatch {
		if v != nil {
			return *v
		}
		var ret NetworkDeviceDataPatch
		return ret
	}).(NetworkDeviceDataPatchOutput)
}

// HardwareAddress represents the hardware address (e.g. MAC Address) of the device's network interface.
//
// Must not be longer than 128 characters.
func (o NetworkDeviceDataPatchPtrOutput) HardwareAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NetworkDeviceDataPatch) *string {
		if v == nil {
			return nil
		}
		return v.HardwareAddress
	}).(pulumi.StringPtrOutput)
}

// InterfaceName specifies the name of the network interface associated with the allocated device. This might be the name of a physical or virtual network interface being configured in the pod.
//
// Must not be longer than 256 characters.
func (o NetworkDeviceDataPatchPtrOutput) InterfaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NetworkDeviceDataPatch) *string {
		if v == nil {
			return nil
		}
		return v.InterfaceName
	}).(pulumi.StringPtrOutput)
}

// IPs lists the network addresses assigned to the device's network interface. This can include both IPv4 and IPv6 addresses. The IPs are in the CIDR notation, which includes both the address and the associated subnet mask. e.g.: "192.0.2.5/24" for IPv4 and "2001:db8::5/64" for IPv6.
//
// Must not contain more than 16 entries.
func (o NetworkDeviceDataPatchPtrOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NetworkDeviceDataPatch) []string {
		if v == nil {
			return nil
		}
		return v.Ips
	}).(pulumi.StringArrayOutput)
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfiguration struct {
	// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
	//
	// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver string `pulumi:"driver"`
	// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
	//
	// The length of the raw data must be smaller or equal to 10 Ki.
	Parameters interface{} `pulumi:"parameters"`
}

// OpaqueDeviceConfigurationInput is an input type that accepts OpaqueDeviceConfigurationArgs and OpaqueDeviceConfigurationOutput values.
// You can construct a concrete instance of `OpaqueDeviceConfigurationInput` via:
//
//	OpaqueDeviceConfigurationArgs{...}
type OpaqueDeviceConfigurationInput interface {
	pulumi.Input

	ToOpaqueDeviceConfigurationOutput() OpaqueDeviceConfigurationOutput
	ToOpaqueDeviceConfigurationOutputWithContext(context.Context) OpaqueDeviceConfigurationOutput
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationArgs struct {
	// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
	//
	// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringInput `pulumi:"driver"`
	// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
	//
	// The length of the raw data must be smaller or equal to 10 Ki.
	Parameters pulumi.Input `pulumi:"parameters"`
}

func (OpaqueDeviceConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpaqueDeviceConfiguration)(nil)).Elem()
}

func (i OpaqueDeviceConfigurationArgs) ToOpaqueDeviceConfigurationOutput() OpaqueDeviceConfigurationOutput {
	return i.ToOpaqueDeviceConfigurationOutputWithContext(context.Background())
}

func (i OpaqueDeviceConfigurationArgs) ToOpaqueDeviceConfigurationOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationOutput)
}

func (i OpaqueDeviceConfigurationArgs) ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput {
	return i.ToOpaqueDeviceConfigurationPtrOutputWithContext(context.Background())
}

func (i OpaqueDeviceConfigurationArgs) ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationOutput).ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx)
}

// OpaqueDeviceConfigurationPtrInput is an input type that accepts OpaqueDeviceConfigurationArgs, OpaqueDeviceConfigurationPtr and OpaqueDeviceConfigurationPtrOutput values.
// You can construct a concrete instance of `OpaqueDeviceConfigurationPtrInput` via:
//
//	        OpaqueDeviceConfigurationArgs{...}
//
//	or:
//
//	        nil
type OpaqueDeviceConfigurationPtrInput interface {
	pulumi.Input

	ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput
	ToOpaqueDeviceConfigurationPtrOutputWithContext(context.Context) OpaqueDeviceConfigurationPtrOutput
}

type opaqueDeviceConfigurationPtrType OpaqueDeviceConfigurationArgs

func OpaqueDeviceConfigurationPtr(v *OpaqueDeviceConfigurationArgs) OpaqueDeviceConfigurationPtrInput {
	return (*opaqueDeviceConfigurationPtrType)(v)
}

func (*opaqueDeviceConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OpaqueDeviceConfiguration)(nil)).Elem()
}

func (i *opaqueDeviceConfigurationPtrType) ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput {
	return i.ToOpaqueDeviceConfigurationPtrOutputWithContext(context.Background())
}

func (i *opaqueDeviceConfigurationPtrType) ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationPtrOutput)
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationOutput struct{ *pulumi.OutputState }

func (OpaqueDeviceConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpaqueDeviceConfiguration)(nil)).Elem()
}

func (o OpaqueDeviceConfigurationOutput) ToOpaqueDeviceConfigurationOutput() OpaqueDeviceConfigurationOutput {
	return o
}

func (o OpaqueDeviceConfigurationOutput) ToOpaqueDeviceConfigurationOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationOutput {
	return o
}

func (o OpaqueDeviceConfigurationOutput) ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput {
	return o.ToOpaqueDeviceConfigurationPtrOutputWithContext(context.Background())
}

func (o OpaqueDeviceConfigurationOutput) ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OpaqueDeviceConfiguration) *OpaqueDeviceConfiguration {
		return &v
	}).(OpaqueDeviceConfigurationPtrOutput)
}

// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
//
// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o OpaqueDeviceConfigurationOutput) Driver() pulumi.StringOutput {
	return o.ApplyT(func(v OpaqueDeviceConfiguration) string { return v.Driver }).(pulumi.StringOutput)
}

// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
//
// The length of the raw data must be smaller or equal to 10 Ki.
func (o OpaqueDeviceConfigurationOutput) Parameters() pulumi.AnyOutput {
	return o.ApplyT(func(v OpaqueDeviceConfiguration) interface{} { return v.Parameters }).(pulumi.AnyOutput)
}

type OpaqueDeviceConfigurationPtrOutput struct{ *pulumi.OutputState }

func (OpaqueDeviceConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OpaqueDeviceConfiguration)(nil)).Elem()
}

func (o OpaqueDeviceConfigurationPtrOutput) ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput {
	return o
}

func (o OpaqueDeviceConfigurationPtrOutput) ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPtrOutput {
	return o
}

func (o OpaqueDeviceConfigurationPtrOutput) Elem() OpaqueDeviceConfigurationOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfiguration) OpaqueDeviceConfiguration {
		if v != nil {
			return *v
		}
		var ret OpaqueDeviceConfiguration
		return ret
	}).(OpaqueDeviceConfigurationOutput)
}

// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
//
// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o OpaqueDeviceConfigurationPtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.Driver
	}).(pulumi.StringPtrOutput)
}

// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
//
// The length of the raw data must be smaller or equal to 10 Ki.
func (o OpaqueDeviceConfigurationPtrOutput) Parameters() pulumi.AnyOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfiguration) interface{} {
		if v == nil {
			return nil
		}
		return v.Parameters
	}).(pulumi.AnyOutput)
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationPatch struct {
	// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
	//
	// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver *string `pulumi:"driver"`
	// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
	//
	// The length of the raw data must be smaller or equal to 10 Ki.
	Parameters interface{} `pulumi:"parameters"`
}

// OpaqueDeviceConfigurationPatchInput is an input type that accepts OpaqueDeviceConfigurationPatchArgs and OpaqueDeviceConfigurationPatchOutput values.
// You can construct a concrete instance of `OpaqueDeviceConfigurationPatchInput` via:
//
//	OpaqueDeviceConfigurationPatchArgs{...}
type OpaqueDeviceConfigurationPatchInput interface {
	pulumi.Input

	ToOpaqueDeviceConfigurationPatchOutput() OpaqueDeviceConfigurationPatchOutput
	ToOpaqueDeviceConfigurationPatchOutputWithContext(context.Context) OpaqueDeviceConfigurationPatchOutput
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationPatchArgs struct {
	// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
	//
	// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringPtrInput `pulumi:"driver"`
	// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
	//
	// The length of the raw data must be smaller or equal to 10 Ki.
	Parameters pulumi.Input `pulumi:"parameters"`
}

func (OpaqueDeviceConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpaqueDeviceConfigurationPatch)(nil)).Elem()
}

func (i OpaqueDeviceConfigurationPatchArgs) ToOpaqueDeviceConfigurationPatchOutput() OpaqueDeviceConfigurationPatchOutput {
	return i.ToOpaqueDeviceConfigurationPatchOutputWithContext(context.Background())
}

func (i OpaqueDeviceConfigurationPatchArgs) ToOpaqueDeviceConfigurationPatchOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationPatchOutput)
}

func (i OpaqueDeviceConfigurationPatchArgs) ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput {
	return i.ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i OpaqueDeviceConfigurationPatchArgs) ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationPatchOutput).ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx)
}

// OpaqueDeviceConfigurationPatchPtrInput is an input type that accepts OpaqueDeviceConfigurationPatchArgs, OpaqueDeviceConfigurationPatchPtr and OpaqueDeviceConfigurationPatchPtrOutput values.
// You can construct a concrete instance of `OpaqueDeviceConfigurationPatchPtrInput` via:
//
//	        OpaqueDeviceConfigurationPatchArgs{...}
//
//	or:
//
//	        nil
type OpaqueDeviceConfigurationPatchPtrInput interface {
	pulumi.Input

	ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput
	ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(context.Context) OpaqueDeviceConfigurationPatchPtrOutput
}

type opaqueDeviceConfigurationPatchPtrType OpaqueDeviceConfigurationPatchArgs

func OpaqueDeviceConfigurationPatchPtr(v *OpaqueDeviceConfigurationPatchArgs) OpaqueDeviceConfigurationPatchPtrInput {
	return (*opaqueDeviceConfigurationPatchPtrType)(v)
}

func (*opaqueDeviceConfigurationPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OpaqueDeviceConfigurationPatch)(nil)).Elem()
}

func (i *opaqueDeviceConfigurationPatchPtrType) ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput {
	return i.ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i *opaqueDeviceConfigurationPatchPtrType) ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationPatchPtrOutput)
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationPatchOutput struct{ *pulumi.OutputState }

func (OpaqueDeviceConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpaqueDeviceConfigurationPatch)(nil)).Elem()
}

func (o OpaqueDeviceConfigurationPatchOutput) ToOpaqueDeviceConfigurationPatchOutput() OpaqueDeviceConfigurationPatchOutput {
	return o
}

func (o OpaqueDeviceConfigurationPatchOutput) ToOpaqueDeviceConfigurationPatchOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchOutput {
	return o
}

func (o OpaqueDeviceConfigurationPatchOutput) ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(context.Background())
}

func (o OpaqueDeviceConfigurationPatchOutput) ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OpaqueDeviceConfigurationPatch) *OpaqueDeviceConfigurationPatch {
		return &v
	}).(OpaqueDeviceConfigurationPatchPtrOutput)
}

// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
//
// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o OpaqueDeviceConfigurationPatchOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OpaqueDeviceConfigurationPatch) *string { return v.Driver }).(pulumi.StringPtrOutput)
}

// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
//
// The length of the raw data must be smaller or equal to 10 Ki.
func (o OpaqueDeviceConfigurationPatchOutput) Parameters() pulumi.AnyOutput {
	return o.ApplyT(func(v OpaqueDeviceConfigurationPatch) interface{} { return v.Parameters }).(pulumi.AnyOutput)
}

type OpaqueDeviceConfigurationPatchPtrOutput struct{ *pulumi.OutputState }

func (OpaqueDeviceConfigurationPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OpaqueDeviceConfigurationPatch)(nil)).Elem()
}

func (o OpaqueDeviceConfigurationPatchPtrOutput) ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput {
	return o
}

func (o OpaqueDeviceConfigurationPatchPtrOutput) ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchPtrOutput {
	return o
}

func (o OpaqueDeviceConfigurationPatchPtrOutput) Elem() OpaqueDeviceConfigurationPatchOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfigurationPatch) OpaqueDeviceConfigurationPatch {
		if v != nil {
			return *v
		}
		var ret OpaqueDeviceConfigurationPatch
		return ret
	}).(OpaqueDeviceConfigurationPatchOutput)
}

// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
//
// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o OpaqueDeviceConfigurationPatchPtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfigurationPatch) *string {
		if v == nil {
			return nil
		}
		return v.Driver
	}).(pulumi.StringPtrOutput)
}

// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
//
// The length of the raw data must be smaller or equal to 10 Ki.
func (o OpaqueDeviceConfigurationPatchPtrOutput) Parameters() pulumi.AnyOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfigurationPatch) interface{} {
		if v == nil {
			return nil
		}
		return v.Parameters
	}).(pulumi.AnyOutput)
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec describes what is being requested and how to configure it. The spec is immutable.
	Spec ResourceClaimSpec `pulumi:"spec"`
	// Status describes whether the claim is ready to use and what has been allocated.
	Status *ResourceClaimStatus `pulumi:"status"`
}

// ResourceClaimTypeInput is an input type that accepts ResourceClaimTypeArgs and ResourceClaimTypeOutput values.
// You can construct a concrete instance of `ResourceClaimTypeInput` via:
//
//	ResourceClaimTypeArgs{...}
type ResourceClaimTypeInput interface {
	pulumi.Input

	ToResourceClaimTypeOutput() ResourceClaimTypeOutput
	ToResourceClaimTypeOutputWithContext(context.Context) ResourceClaimTypeOutput
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec describes what is being requested and how to configure it. The spec is immutable.
	Spec ResourceClaimSpecInput `pulumi:"spec"`
	// Status describes whether the claim is ready to use and what has been allocated.
	Status ResourceClaimStatusPtrInput `pulumi:"status"`
}

func (ResourceClaimTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimType)(nil)).Elem()
}

func (i ResourceClaimTypeArgs) ToResourceClaimTypeOutput() ResourceClaimTypeOutput {
	return i.ToResourceClaimTypeOutputWithContext(context.Background())
}

func (i ResourceClaimTypeArgs) ToResourceClaimTypeOutputWithContext(ctx context.Context) ResourceClaimTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTypeOutput)
}

// ResourceClaimTypeArrayInput is an input type that accepts ResourceClaimTypeArray and ResourceClaimTypeArrayOutput values.
// You can construct a concrete instance of `ResourceClaimTypeArrayInput` via:
//
//	ResourceClaimTypeArray{ ResourceClaimTypeArgs{...} }
type ResourceClaimTypeArrayInput interface {
	pulumi.Input

	ToResourceClaimTypeArrayOutput() ResourceClaimTypeArrayOutput
	ToResourceClaimTypeArrayOutputWithContext(context.Context) ResourceClaimTypeArrayOutput
}

type ResourceClaimTypeArray []ResourceClaimTypeInput

func (ResourceClaimTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimType)(nil)).Elem()
}

func (i ResourceClaimTypeArray) ToResourceClaimTypeArrayOutput() ResourceClaimTypeArrayOutput {
	return i.ToResourceClaimTypeArrayOutputWithContext(context.Background())
}

func (i ResourceClaimTypeArray) ToResourceClaimTypeArrayOutputWithContext(ctx context.Context) ResourceClaimTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTypeArrayOutput)
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimType)(nil)).Elem()
}

func (o ResourceClaimTypeOutput) ToResourceClaimTypeOutput() ResourceClaimTypeOutput {
	return o
}

func (o ResourceClaimTypeOutput) ToResourceClaimTypeOutputWithContext(ctx context.Context) ResourceClaimTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceClaimTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec describes what is being requested and how to configure it. The spec is immutable.
func (o ResourceClaimTypeOutput) Spec() ResourceClaimSpecOutput {
	return o.ApplyT(func(v ResourceClaimType) ResourceClaimSpec { return v.Spec }).(ResourceClaimSpecOutput)
}

// Status describes whether the claim is ready to use and what has been allocated.
func (o ResourceClaimTypeOutput) Status() ResourceClaimStatusPtrOutput {
	return o.ApplyT(func(v ResourceClaimType) *ResourceClaimStatus { return v.Status }).(ResourceClaimStatusPtrOutput)
}

type ResourceClaimTypeArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimType)(nil)).Elem()
}

func (o ResourceClaimTypeArrayOutput) ToResourceClaimTypeArrayOutput() ResourceClaimTypeArrayOutput {
	return o
}

func (o ResourceClaimTypeArrayOutput) ToResourceClaimTypeArrayOutputWithContext(ctx context.Context) ResourceClaimTypeArrayOutput {
	return o
}

func (o ResourceClaimTypeArrayOutput) Index(i pulumi.IntInput) ResourceClaimTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimType {
		return vs[0].([]ResourceClaimType)[vs[1].(int)]
	}).(ResourceClaimTypeOutput)
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReference struct {
	// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
	ApiGroup *string `pulumi:"apiGroup"`
	// Name is the name of resource being referenced.
	Name string `pulumi:"name"`
	// Resource is the type of resource being referenced, for example "pods".
	Resource string `pulumi:"resource"`
	// UID identifies exactly one incarnation of the resource.
	Uid string `pulumi:"uid"`
}

// ResourceClaimConsumerReferenceInput is an input type that accepts ResourceClaimConsumerReferenceArgs and ResourceClaimConsumerReferenceOutput values.
// You can construct a concrete instance of `ResourceClaimConsumerReferenceInput` via:
//
//	ResourceClaimConsumerReferenceArgs{...}
type ResourceClaimConsumerReferenceInput interface {
	pulumi.Input

	ToResourceClaimConsumerReferenceOutput() ResourceClaimConsumerReferenceOutput
	ToResourceClaimConsumerReferenceOutputWithContext(context.Context) ResourceClaimConsumerReferenceOutput
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferenceArgs struct {
	// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Name is the name of resource being referenced.
	Name pulumi.StringInput `pulumi:"name"`
	// Resource is the type of resource being referenced, for example "pods".
	Resource pulumi.StringInput `pulumi:"resource"`
	// UID identifies exactly one incarnation of the resource.
	Uid pulumi.StringInput `pulumi:"uid"`
}

func (ResourceClaimConsumerReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimConsumerReference)(nil)).Elem()
}

func (i ResourceClaimConsumerReferenceArgs) ToResourceClaimConsumerReferenceOutput() ResourceClaimConsumerReferenceOutput {
	return i.ToResourceClaimConsumerReferenceOutputWithContext(context.Background())
}

func (i ResourceClaimConsumerReferenceArgs) ToResourceClaimConsumerReferenceOutputWithContext(ctx context.Context) ResourceClaimConsumerReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimConsumerReferenceOutput)
}

// ResourceClaimConsumerReferenceArrayInput is an input type that accepts ResourceClaimConsumerReferenceArray and ResourceClaimConsumerReferenceArrayOutput values.
// You can construct a concrete instance of `ResourceClaimConsumerReferenceArrayInput` via:
//
//	ResourceClaimConsumerReferenceArray{ ResourceClaimConsumerReferenceArgs{...} }
type ResourceClaimConsumerReferenceArrayInput interface {
	pulumi.Input

	ToResourceClaimConsumerReferenceArrayOutput() ResourceClaimConsumerReferenceArrayOutput
	ToResourceClaimConsumerReferenceArrayOutputWithContext(context.Context) ResourceClaimConsumerReferenceArrayOutput
}

type ResourceClaimConsumerReferenceArray []ResourceClaimConsumerReferenceInput

func (ResourceClaimConsumerReferenceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimConsumerReference)(nil)).Elem()
}

func (i ResourceClaimConsumerReferenceArray) ToResourceClaimConsumerReferenceArrayOutput() ResourceClaimConsumerReferenceArrayOutput {
	return i.ToResourceClaimConsumerReferenceArrayOutputWithContext(context.Background())
}

func (i ResourceClaimConsumerReferenceArray) ToResourceClaimConsumerReferenceArrayOutputWithContext(ctx context.Context) ResourceClaimConsumerReferenceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimConsumerReferenceArrayOutput)
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferenceOutput struct{ *pulumi.OutputState }

func (ResourceClaimConsumerReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimConsumerReference)(nil)).Elem()
}

func (o ResourceClaimConsumerReferenceOutput) ToResourceClaimConsumerReferenceOutput() ResourceClaimConsumerReferenceOutput {
	return o
}

func (o ResourceClaimConsumerReferenceOutput) ToResourceClaimConsumerReferenceOutputWithContext(ctx context.Context) ResourceClaimConsumerReferenceOutput {
	return o
}

// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
func (o ResourceClaimConsumerReferenceOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReference) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced.
func (o ResourceClaimConsumerReferenceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReference) string { return v.Name }).(pulumi.StringOutput)
}

// Resource is the type of resource being referenced, for example "pods".
func (o ResourceClaimConsumerReferenceOutput) Resource() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReference) string { return v.Resource }).(pulumi.StringOutput)
}

// UID identifies exactly one incarnation of the resource.
func (o ResourceClaimConsumerReferenceOutput) Uid() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReference) string { return v.Uid }).(pulumi.StringOutput)
}

type ResourceClaimConsumerReferenceArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimConsumerReferenceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimConsumerReference)(nil)).Elem()
}

func (o ResourceClaimConsumerReferenceArrayOutput) ToResourceClaimConsumerReferenceArrayOutput() ResourceClaimConsumerReferenceArrayOutput {
	return o
}

func (o ResourceClaimConsumerReferenceArrayOutput) ToResourceClaimConsumerReferenceArrayOutputWithContext(ctx context.Context) ResourceClaimConsumerReferenceArrayOutput {
	return o
}

func (o ResourceClaimConsumerReferenceArrayOutput) Index(i pulumi.IntInput) ResourceClaimConsumerReferenceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimConsumerReference {
		return vs[0].([]ResourceClaimConsumerReference)[vs[1].(int)]
	}).(ResourceClaimConsumerReferenceOutput)
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferencePatch struct {
	// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
	ApiGroup *string `pulumi:"apiGroup"`
	// Name is the name of resource being referenced.
	Name *string `pulumi:"name"`
	// Resource is the type of resource being referenced, for example "pods".
	Resource *string `pulumi:"resource"`
	// UID identifies exactly one incarnation of the resource.
	Uid *string `pulumi:"uid"`
}

// ResourceClaimConsumerReferencePatchInput is an input type that accepts ResourceClaimConsumerReferencePatchArgs and ResourceClaimConsumerReferencePatchOutput values.
// You can construct a concrete instance of `ResourceClaimConsumerReferencePatchInput` via:
//
//	ResourceClaimConsumerReferencePatchArgs{...}
type ResourceClaimConsumerReferencePatchInput interface {
	pulumi.Input

	ToResourceClaimConsumerReferencePatchOutput() ResourceClaimConsumerReferencePatchOutput
	ToResourceClaimConsumerReferencePatchOutputWithContext(context.Context) ResourceClaimConsumerReferencePatchOutput
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferencePatchArgs struct {
	// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Name is the name of resource being referenced.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Resource is the type of resource being referenced, for example "pods".
	Resource pulumi.StringPtrInput `pulumi:"resource"`
	// UID identifies exactly one incarnation of the resource.
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (ResourceClaimConsumerReferencePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimConsumerReferencePatch)(nil)).Elem()
}

func (i ResourceClaimConsumerReferencePatchArgs) ToResourceClaimConsumerReferencePatchOutput() ResourceClaimConsumerReferencePatchOutput {
	return i.ToResourceClaimConsumerReferencePatchOutputWithContext(context.Background())
}

func (i ResourceClaimConsumerReferencePatchArgs) ToResourceClaimConsumerReferencePatchOutputWithContext(ctx context.Context) ResourceClaimConsumerReferencePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimConsumerReferencePatchOutput)
}

// ResourceClaimConsumerReferencePatchArrayInput is an input type that accepts ResourceClaimConsumerReferencePatchArray and ResourceClaimConsumerReferencePatchArrayOutput values.
// You can construct a concrete instance of `ResourceClaimConsumerReferencePatchArrayInput` via:
//
//	ResourceClaimConsumerReferencePatchArray{ ResourceClaimConsumerReferencePatchArgs{...} }
type ResourceClaimConsumerReferencePatchArrayInput interface {
	pulumi.Input

	ToResourceClaimConsumerReferencePatchArrayOutput() ResourceClaimConsumerReferencePatchArrayOutput
	ToResourceClaimConsumerReferencePatchArrayOutputWithContext(context.Context) ResourceClaimConsumerReferencePatchArrayOutput
}

type ResourceClaimConsumerReferencePatchArray []ResourceClaimConsumerReferencePatchInput

func (ResourceClaimConsumerReferencePatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimConsumerReferencePatch)(nil)).Elem()
}

func (i ResourceClaimConsumerReferencePatchArray) ToResourceClaimConsumerReferencePatchArrayOutput() ResourceClaimConsumerReferencePatchArrayOutput {
	return i.ToResourceClaimConsumerReferencePatchArrayOutputWithContext(context.Background())
}

func (i ResourceClaimConsumerReferencePatchArray) ToResourceClaimConsumerReferencePatchArrayOutputWithContext(ctx context.Context) ResourceClaimConsumerReferencePatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimConsumerReferencePatchArrayOutput)
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferencePatchOutput struct{ *pulumi.OutputState }

func (ResourceClaimConsumerReferencePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimConsumerReferencePatch)(nil)).Elem()
}

func (o ResourceClaimConsumerReferencePatchOutput) ToResourceClaimConsumerReferencePatchOutput() ResourceClaimConsumerReferencePatchOutput {
	return o
}

func (o ResourceClaimConsumerReferencePatchOutput) ToResourceClaimConsumerReferencePatchOutputWithContext(ctx context.Context) ResourceClaimConsumerReferencePatchOutput {
	return o
}

// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
func (o ResourceClaimConsumerReferencePatchOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReferencePatch) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced.
func (o ResourceClaimConsumerReferencePatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReferencePatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Resource is the type of resource being referenced, for example "pods".
func (o ResourceClaimConsumerReferencePatchOutput) Resource() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReferencePatch) *string { return v.Resource }).(pulumi.StringPtrOutput)
}

// UID identifies exactly one incarnation of the resource.
func (o ResourceClaimConsumerReferencePatchOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReferencePatch) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type ResourceClaimConsumerReferencePatchArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimConsumerReferencePatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimConsumerReferencePatch)(nil)).Elem()
}

func (o ResourceClaimConsumerReferencePatchArrayOutput) ToResourceClaimConsumerReferencePatchArrayOutput() ResourceClaimConsumerReferencePatchArrayOutput {
	return o
}

func (o ResourceClaimConsumerReferencePatchArrayOutput) ToResourceClaimConsumerReferencePatchArrayOutputWithContext(ctx context.Context) ResourceClaimConsumerReferencePatchArrayOutput {
	return o
}

func (o ResourceClaimConsumerReferencePatchArrayOutput) Index(i pulumi.IntInput) ResourceClaimConsumerReferencePatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimConsumerReferencePatch {
		return vs[0].([]ResourceClaimConsumerReferencePatch)[vs[1].(int)]
	}).(ResourceClaimConsumerReferencePatchOutput)
}

// ResourceClaimList is a collection of claims.
type ResourceClaimListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of resource claims.
	Items []ResourceClaimType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ResourceClaimListTypeInput is an input type that accepts ResourceClaimListTypeArgs and ResourceClaimListTypeOutput values.
// You can construct a concrete instance of `ResourceClaimListTypeInput` via:
//
//	ResourceClaimListTypeArgs{...}
type ResourceClaimListTypeInput interface {
	pulumi.Input

	ToResourceClaimListTypeOutput() ResourceClaimListTypeOutput
	ToResourceClaimListTypeOutputWithContext(context.Context) ResourceClaimListTypeOutput
}

// ResourceClaimList is a collection of claims.
type ResourceClaimListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of resource claims.
	Items ResourceClaimTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ResourceClaimListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimListType)(nil)).Elem()
}

func (i ResourceClaimListTypeArgs) ToResourceClaimListTypeOutput() ResourceClaimListTypeOutput {
	return i.ToResourceClaimListTypeOutputWithContext(context.Background())
}

func (i ResourceClaimListTypeArgs) ToResourceClaimListTypeOutputWithContext(ctx context.Context) ResourceClaimListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimListTypeOutput)
}

// ResourceClaimList is a collection of claims.
type ResourceClaimListTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimListType)(nil)).Elem()
}

func (o ResourceClaimListTypeOutput) ToResourceClaimListTypeOutput() ResourceClaimListTypeOutput {
	return o
}

func (o ResourceClaimListTypeOutput) ToResourceClaimListTypeOutputWithContext(ctx context.Context) ResourceClaimListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of resource claims.
func (o ResourceClaimListTypeOutput) Items() ResourceClaimTypeArrayOutput {
	return o.ApplyT(func(v ResourceClaimListType) []ResourceClaimType { return v.Items }).(ResourceClaimTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o ResourceClaimListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Spec describes what is being requested and how to configure it. The spec is immutable.
	Spec *ResourceClaimSpecPatch `pulumi:"spec"`
	// Status describes whether the claim is ready to use and what has been allocated.
	Status *ResourceClaimStatusPatch `pulumi:"status"`
}

// ResourceClaimPatchTypeInput is an input type that accepts ResourceClaimPatchTypeArgs and ResourceClaimPatchTypeOutput values.
// You can construct a concrete instance of `ResourceClaimPatchTypeInput` via:
//
//	ResourceClaimPatchTypeArgs{...}
type ResourceClaimPatchTypeInput interface {
	pulumi.Input

	ToResourceClaimPatchTypeOutput() ResourceClaimPatchTypeOutput
	ToResourceClaimPatchTypeOutputWithContext(context.Context) ResourceClaimPatchTypeOutput
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Spec describes what is being requested and how to configure it. The spec is immutable.
	Spec ResourceClaimSpecPatchPtrInput `pulumi:"spec"`
	// Status describes whether the claim is ready to use and what has been allocated.
	Status ResourceClaimStatusPatchPtrInput `pulumi:"status"`
}

func (ResourceClaimPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimPatchType)(nil)).Elem()
}

func (i ResourceClaimPatchTypeArgs) ToResourceClaimPatchTypeOutput() ResourceClaimPatchTypeOutput {
	return i.ToResourceClaimPatchTypeOutputWithContext(context.Background())
}

func (i ResourceClaimPatchTypeArgs) ToResourceClaimPatchTypeOutputWithContext(ctx context.Context) ResourceClaimPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimPatchTypeOutput)
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimPatchTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimPatchType)(nil)).Elem()
}

func (o ResourceClaimPatchTypeOutput) ToResourceClaimPatchTypeOutput() ResourceClaimPatchTypeOutput {
	return o
}

func (o ResourceClaimPatchTypeOutput) ToResourceClaimPatchTypeOutputWithContext(ctx context.Context) ResourceClaimPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceClaimPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec describes what is being requested and how to configure it. The spec is immutable.
func (o ResourceClaimPatchTypeOutput) Spec() ResourceClaimSpecPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *ResourceClaimSpecPatch { return v.Spec }).(ResourceClaimSpecPatchPtrOutput)
}

// Status describes whether the claim is ready to use and what has been allocated.
func (o ResourceClaimPatchTypeOutput) Status() ResourceClaimStatusPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *ResourceClaimStatusPatch { return v.Status }).(ResourceClaimStatusPatchPtrOutput)
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpec struct {
	// Devices defines how to request devices.
	Devices *DeviceClaim `pulumi:"devices"`
}

// ResourceClaimSpecInput is an input type that accepts ResourceClaimSpecArgs and ResourceClaimSpecOutput values.
// You can construct a concrete instance of `ResourceClaimSpecInput` via:
//
//	ResourceClaimSpecArgs{...}
type ResourceClaimSpecInput interface {
	pulumi.Input

	ToResourceClaimSpecOutput() ResourceClaimSpecOutput
	ToResourceClaimSpecOutputWithContext(context.Context) ResourceClaimSpecOutput
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecArgs struct {
	// Devices defines how to request devices.
	Devices DeviceClaimPtrInput `pulumi:"devices"`
}

func (ResourceClaimSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSpec)(nil)).Elem()
}

func (i ResourceClaimSpecArgs) ToResourceClaimSpecOutput() ResourceClaimSpecOutput {
	return i.ToResourceClaimSpecOutputWithContext(context.Background())
}

func (i ResourceClaimSpecArgs) ToResourceClaimSpecOutputWithContext(ctx context.Context) ResourceClaimSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSpecOutput)
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecOutput struct{ *pulumi.OutputState }

func (ResourceClaimSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSpec)(nil)).Elem()
}

func (o ResourceClaimSpecOutput) ToResourceClaimSpecOutput() ResourceClaimSpecOutput {
	return o
}

func (o ResourceClaimSpecOutput) ToResourceClaimSpecOutputWithContext(ctx context.Context) ResourceClaimSpecOutput {
	return o
}

// Devices defines how to request devices.
func (o ResourceClaimSpecOutput) Devices() DeviceClaimPtrOutput {
	return o.ApplyT(func(v ResourceClaimSpec) *DeviceClaim { return v.Devices }).(DeviceClaimPtrOutput)
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecPatch struct {
	// Devices defines how to request devices.
	Devices *DeviceClaimPatch `pulumi:"devices"`
}

// ResourceClaimSpecPatchInput is an input type that accepts ResourceClaimSpecPatchArgs and ResourceClaimSpecPatchOutput values.
// You can construct a concrete instance of `ResourceClaimSpecPatchInput` via:
//
//	ResourceClaimSpecPatchArgs{...}
type ResourceClaimSpecPatchInput interface {
	pulumi.Input

	ToResourceClaimSpecPatchOutput() ResourceClaimSpecPatchOutput
	ToResourceClaimSpecPatchOutputWithContext(context.Context) ResourceClaimSpecPatchOutput
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecPatchArgs struct {
	// Devices defines how to request devices.
	Devices DeviceClaimPatchPtrInput `pulumi:"devices"`
}

func (ResourceClaimSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSpecPatch)(nil)).Elem()
}

func (i ResourceClaimSpecPatchArgs) ToResourceClaimSpecPatchOutput() ResourceClaimSpecPatchOutput {
	return i.ToResourceClaimSpecPatchOutputWithContext(context.Background())
}

func (i ResourceClaimSpecPatchArgs) ToResourceClaimSpecPatchOutputWithContext(ctx context.Context) ResourceClaimSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSpecPatchOutput)
}

func (i ResourceClaimSpecPatchArgs) ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput {
	return i.ToResourceClaimSpecPatchPtrOutputWithContext(context.Background())
}

func (i ResourceClaimSpecPatchArgs) ToResourceClaimSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSpecPatchOutput).ToResourceClaimSpecPatchPtrOutputWithContext(ctx)
}

// ResourceClaimSpecPatchPtrInput is an input type that accepts ResourceClaimSpecPatchArgs, ResourceClaimSpecPatchPtr and ResourceClaimSpecPatchPtrOutput values.
// You can construct a concrete instance of `ResourceClaimSpecPatchPtrInput` via:
//
//	        ResourceClaimSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ResourceClaimSpecPatchPtrInput interface {
	pulumi.Input

	ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput
	ToResourceClaimSpecPatchPtrOutputWithContext(context.Context) ResourceClaimSpecPatchPtrOutput
}

type resourceClaimSpecPatchPtrType ResourceClaimSpecPatchArgs

func ResourceClaimSpecPatchPtr(v *ResourceClaimSpecPatchArgs) ResourceClaimSpecPatchPtrInput {
	return (*resourceClaimSpecPatchPtrType)(v)
}

func (*resourceClaimSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimSpecPatch)(nil)).Elem()
}

func (i *resourceClaimSpecPatchPtrType) ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput {
	return i.ToResourceClaimSpecPatchPtrOutputWithContext(context.Background())
}

func (i *resourceClaimSpecPatchPtrType) ToResourceClaimSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSpecPatchPtrOutput)
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecPatchOutput struct{ *pulumi.OutputState }

func (ResourceClaimSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSpecPatch)(nil)).Elem()
}

func (o ResourceClaimSpecPatchOutput) ToResourceClaimSpecPatchOutput() ResourceClaimSpecPatchOutput {
	return o
}

func (o ResourceClaimSpecPatchOutput) ToResourceClaimSpecPatchOutputWithContext(ctx context.Context) ResourceClaimSpecPatchOutput {
	return o
}

func (o ResourceClaimSpecPatchOutput) ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput {
	return o.ToResourceClaimSpecPatchPtrOutputWithContext(context.Background())
}

func (o ResourceClaimSpecPatchOutput) ToResourceClaimSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceClaimSpecPatch) *ResourceClaimSpecPatch {
		return &v
	}).(ResourceClaimSpecPatchPtrOutput)
}

// Devices defines how to request devices.
func (o ResourceClaimSpecPatchOutput) Devices() DeviceClaimPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimSpecPatch) *DeviceClaimPatch { return v.Devices }).(DeviceClaimPatchPtrOutput)
}

type ResourceClaimSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourceClaimSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimSpecPatch)(nil)).Elem()
}

func (o ResourceClaimSpecPatchPtrOutput) ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput {
	return o
}

func (o ResourceClaimSpecPatchPtrOutput) ToResourceClaimSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimSpecPatchPtrOutput {
	return o
}

func (o ResourceClaimSpecPatchPtrOutput) Elem() ResourceClaimSpecPatchOutput {
	return o.ApplyT(func(v *ResourceClaimSpecPatch) ResourceClaimSpecPatch {
		if v != nil {
			return *v
		}
		var ret ResourceClaimSpecPatch
		return ret
	}).(ResourceClaimSpecPatchOutput)
}

// Devices defines how to request devices.
func (o ResourceClaimSpecPatchPtrOutput) Devices() DeviceClaimPatchPtrOutput {
	return o.ApplyT(func(v *ResourceClaimSpecPatch) *DeviceClaimPatch {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(DeviceClaimPatchPtrOutput)
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatus struct {
	// Allocation is set once the claim has been allocated successfully.
	Allocation *AllocationResult `pulumi:"allocation"`
	// Devices contains the status of each device allocated for this claim, as reported by the driver. This can include driver-specific information. Entries are owned by their respective drivers.
	Devices []AllocatedDeviceStatus `pulumi:"devices"`
	// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
	//
	// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
	//
	// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
	//
	// There can be at most 256 such reservations. This may get increased in the future, but not reduced.
	ReservedFor []ResourceClaimConsumerReference `pulumi:"reservedFor"`
}

// ResourceClaimStatusInput is an input type that accepts ResourceClaimStatusArgs and ResourceClaimStatusOutput values.
// You can construct a concrete instance of `ResourceClaimStatusInput` via:
//
//	ResourceClaimStatusArgs{...}
type ResourceClaimStatusInput interface {
	pulumi.Input

	ToResourceClaimStatusOutput() ResourceClaimStatusOutput
	ToResourceClaimStatusOutputWithContext(context.Context) ResourceClaimStatusOutput
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusArgs struct {
	// Allocation is set once the claim has been allocated successfully.
	Allocation AllocationResultPtrInput `pulumi:"allocation"`
	// Devices contains the status of each device allocated for this claim, as reported by the driver. This can include driver-specific information. Entries are owned by their respective drivers.
	Devices AllocatedDeviceStatusArrayInput `pulumi:"devices"`
	// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
	//
	// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
	//
	// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
	//
	// There can be at most 256 such reservations. This may get increased in the future, but not reduced.
	ReservedFor ResourceClaimConsumerReferenceArrayInput `pulumi:"reservedFor"`
}

func (ResourceClaimStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimStatus)(nil)).Elem()
}

func (i ResourceClaimStatusArgs) ToResourceClaimStatusOutput() ResourceClaimStatusOutput {
	return i.ToResourceClaimStatusOutputWithContext(context.Background())
}

func (i ResourceClaimStatusArgs) ToResourceClaimStatusOutputWithContext(ctx context.Context) ResourceClaimStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusOutput)
}

func (i ResourceClaimStatusArgs) ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput {
	return i.ToResourceClaimStatusPtrOutputWithContext(context.Background())
}

func (i ResourceClaimStatusArgs) ToResourceClaimStatusPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusOutput).ToResourceClaimStatusPtrOutputWithContext(ctx)
}

// ResourceClaimStatusPtrInput is an input type that accepts ResourceClaimStatusArgs, ResourceClaimStatusPtr and ResourceClaimStatusPtrOutput values.
// You can construct a concrete instance of `ResourceClaimStatusPtrInput` via:
//
//	        ResourceClaimStatusArgs{...}
//
//	or:
//
//	        nil
type ResourceClaimStatusPtrInput interface {
	pulumi.Input

	ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput
	ToResourceClaimStatusPtrOutputWithContext(context.Context) ResourceClaimStatusPtrOutput
}

type resourceClaimStatusPtrType ResourceClaimStatusArgs

func ResourceClaimStatusPtr(v *ResourceClaimStatusArgs) ResourceClaimStatusPtrInput {
	return (*resourceClaimStatusPtrType)(v)
}

func (*resourceClaimStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimStatus)(nil)).Elem()
}

func (i *resourceClaimStatusPtrType) ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput {
	return i.ToResourceClaimStatusPtrOutputWithContext(context.Background())
}

func (i *resourceClaimStatusPtrType) ToResourceClaimStatusPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusPtrOutput)
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusOutput struct{ *pulumi.OutputState }

func (ResourceClaimStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimStatus)(nil)).Elem()
}

func (o ResourceClaimStatusOutput) ToResourceClaimStatusOutput() ResourceClaimStatusOutput {
	return o
}

func (o ResourceClaimStatusOutput) ToResourceClaimStatusOutputWithContext(ctx context.Context) ResourceClaimStatusOutput {
	return o
}

func (o ResourceClaimStatusOutput) ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput {
	return o.ToResourceClaimStatusPtrOutputWithContext(context.Background())
}

func (o ResourceClaimStatusOutput) ToResourceClaimStatusPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceClaimStatus) *ResourceClaimStatus {
		return &v
	}).(ResourceClaimStatusPtrOutput)
}

// Allocation is set once the claim has been allocated successfully.
func (o ResourceClaimStatusOutput) Allocation() AllocationResultPtrOutput {
	return o.ApplyT(func(v ResourceClaimStatus) *AllocationResult { return v.Allocation }).(AllocationResultPtrOutput)
}

// Devices contains the status of each device allocated for this claim, as reported by the driver. This can include driver-specific information. Entries are owned by their respective drivers.
func (o ResourceClaimStatusOutput) Devices() AllocatedDeviceStatusArrayOutput {
	return o.ApplyT(func(v ResourceClaimStatus) []AllocatedDeviceStatus { return v.Devices }).(AllocatedDeviceStatusArrayOutput)
}

// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
//
// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
//
// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
//
// There can be at most 256 such reservations. This may get increased in the future, but not reduced.
func (o ResourceClaimStatusOutput) ReservedFor() ResourceClaimConsumerReferenceArrayOutput {
	return o.ApplyT(func(v ResourceClaimStatus) []ResourceClaimConsumerReference { return v.ReservedFor }).(ResourceClaimConsumerReferenceArrayOutput)
}

type ResourceClaimStatusPtrOutput struct{ *pulumi.OutputState }

func (ResourceClaimStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimStatus)(nil)).Elem()
}

func (o ResourceClaimStatusPtrOutput) ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput {
	return o
}

func (o ResourceClaimStatusPtrOutput) ToResourceClaimStatusPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPtrOutput {
	return o
}

func (o ResourceClaimStatusPtrOutput) Elem() ResourceClaimStatusOutput {
	return o.ApplyT(func(v *ResourceClaimStatus) ResourceClaimStatus {
		if v != nil {
			return *v
		}
		var ret ResourceClaimStatus
		return ret
	}).(ResourceClaimStatusOutput)
}

// Allocation is set once the claim has been allocated successfully.
func (o ResourceClaimStatusPtrOutput) Allocation() AllocationResultPtrOutput {
	return o.ApplyT(func(v *ResourceClaimStatus) *AllocationResult {
		if v == nil {
			return nil
		}
		return v.Allocation
	}).(AllocationResultPtrOutput)
}

// Devices contains the status of each device allocated for this claim, as reported by the driver. This can include driver-specific information. Entries are owned by their respective drivers.
func (o ResourceClaimStatusPtrOutput) Devices() AllocatedDeviceStatusArrayOutput {
	return o.ApplyT(func(v *ResourceClaimStatus) []AllocatedDeviceStatus {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(AllocatedDeviceStatusArrayOutput)
}

// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
//
// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
//
// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
//
// There can be at most 256 such reservations. This may get increased in the future, but not reduced.
func (o ResourceClaimStatusPtrOutput) ReservedFor() ResourceClaimConsumerReferenceArrayOutput {
	return o.ApplyT(func(v *ResourceClaimStatus) []ResourceClaimConsumerReference {
		if v == nil {
			return nil
		}
		return v.ReservedFor
	}).(ResourceClaimConsumerReferenceArrayOutput)
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusPatch struct {
	// Allocation is set once the claim has been allocated successfully.
	Allocation *AllocationResultPatch `pulumi:"allocation"`
	// Devices contains the status of each device allocated for this claim, as reported by the driver. This can include driver-specific information. Entries are owned by their respective drivers.
	Devices []AllocatedDeviceStatusPatch `pulumi:"devices"`
	// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
	//
	// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
	//
	// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
	//
	// There can be at most 256 such reservations. This may get increased in the future, but not reduced.
	ReservedFor []ResourceClaimConsumerReferencePatch `pulumi:"reservedFor"`
}

// ResourceClaimStatusPatchInput is an input type that accepts ResourceClaimStatusPatchArgs and ResourceClaimStatusPatchOutput values.
// You can construct a concrete instance of `ResourceClaimStatusPatchInput` via:
//
//	ResourceClaimStatusPatchArgs{...}
type ResourceClaimStatusPatchInput interface {
	pulumi.Input

	ToResourceClaimStatusPatchOutput() ResourceClaimStatusPatchOutput
	ToResourceClaimStatusPatchOutputWithContext(context.Context) ResourceClaimStatusPatchOutput
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusPatchArgs struct {
	// Allocation is set once the claim has been allocated successfully.
	Allocation AllocationResultPatchPtrInput `pulumi:"allocation"`
	// Devices contains the status of each device allocated for this claim, as reported by the driver. This can include driver-specific information. Entries are owned by their respective drivers.
	Devices AllocatedDeviceStatusPatchArrayInput `pulumi:"devices"`
	// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
	//
	// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
	//
	// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
	//
	// There can be at most 256 such reservations. This may get increased in the future, but not reduced.
	ReservedFor ResourceClaimConsumerReferencePatchArrayInput `pulumi:"reservedFor"`
}

func (ResourceClaimStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimStatusPatch)(nil)).Elem()
}

func (i ResourceClaimStatusPatchArgs) ToResourceClaimStatusPatchOutput() ResourceClaimStatusPatchOutput {
	return i.ToResourceClaimStatusPatchOutputWithContext(context.Background())
}

func (i ResourceClaimStatusPatchArgs) ToResourceClaimStatusPatchOutputWithContext(ctx context.Context) ResourceClaimStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusPatchOutput)
}

func (i ResourceClaimStatusPatchArgs) ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput {
	return i.ToResourceClaimStatusPatchPtrOutputWithContext(context.Background())
}

func (i ResourceClaimStatusPatchArgs) ToResourceClaimStatusPatchPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusPatchOutput).ToResourceClaimStatusPatchPtrOutputWithContext(ctx)
}

// ResourceClaimStatusPatchPtrInput is an input type that accepts ResourceClaimStatusPatchArgs, ResourceClaimStatusPatchPtr and ResourceClaimStatusPatchPtrOutput values.
// You can construct a concrete instance of `ResourceClaimStatusPatchPtrInput` via:
//
//	        ResourceClaimStatusPatchArgs{...}
//
//	or:
//
//	        nil
type ResourceClaimStatusPatchPtrInput interface {
	pulumi.Input

	ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput
	ToResourceClaimStatusPatchPtrOutputWithContext(context.Context) ResourceClaimStatusPatchPtrOutput
}

type resourceClaimStatusPatchPtrType ResourceClaimStatusPatchArgs

func ResourceClaimStatusPatchPtr(v *ResourceClaimStatusPatchArgs) ResourceClaimStatusPatchPtrInput {
	return (*resourceClaimStatusPatchPtrType)(v)
}

func (*resourceClaimStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimStatusPatch)(nil)).Elem()
}

func (i *resourceClaimStatusPatchPtrType) ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput {
	return i.ToResourceClaimStatusPatchPtrOutputWithContext(context.Background())
}

func (i *resourceClaimStatusPatchPtrType) ToResourceClaimStatusPatchPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusPatchPtrOutput)
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusPatchOutput struct{ *pulumi.OutputState }

func (ResourceClaimStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimStatusPatch)(nil)).Elem()
}

func (o ResourceClaimStatusPatchOutput) ToResourceClaimStatusPatchOutput() ResourceClaimStatusPatchOutput {
	return o
}

func (o ResourceClaimStatusPatchOutput) ToResourceClaimStatusPatchOutputWithContext(ctx context.Context) ResourceClaimStatusPatchOutput {
	return o
}

func (o ResourceClaimStatusPatchOutput) ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput {
	return o.ToResourceClaimStatusPatchPtrOutputWithContext(context.Background())
}

func (o ResourceClaimStatusPatchOutput) ToResourceClaimStatusPatchPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceClaimStatusPatch) *ResourceClaimStatusPatch {
		return &v
	}).(ResourceClaimStatusPatchPtrOutput)
}

// Allocation is set once the claim has been allocated successfully.
func (o ResourceClaimStatusPatchOutput) Allocation() AllocationResultPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimStatusPatch) *AllocationResultPatch { return v.Allocation }).(AllocationResultPatchPtrOutput)
}

// Devices contains the status of each device allocated for this claim, as reported by the driver. This can include driver-specific information. Entries are owned by their respective drivers.
func (o ResourceClaimStatusPatchOutput) Devices() AllocatedDeviceStatusPatchArrayOutput {
	return o.ApplyT(func(v ResourceClaimStatusPatch) []AllocatedDeviceStatusPatch { return v.Devices }).(AllocatedDeviceStatusPatchArrayOutput)
}

// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
//
// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
//
// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
//
// There can be at most 256 such reservations. This may get increased in the future, but not reduced.
func (o ResourceClaimStatusPatchOutput) ReservedFor() ResourceClaimConsumerReferencePatchArrayOutput {
	return o.ApplyT(func(v ResourceClaimStatusPatch) []ResourceClaimConsumerReferencePatch { return v.ReservedFor }).(ResourceClaimConsumerReferencePatchArrayOutput)
}

type ResourceClaimStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourceClaimStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimStatusPatch)(nil)).Elem()
}

func (o ResourceClaimStatusPatchPtrOutput) ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput {
	return o
}

func (o ResourceClaimStatusPatchPtrOutput) ToResourceClaimStatusPatchPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPatchPtrOutput {
	return o
}

func (o ResourceClaimStatusPatchPtrOutput) Elem() ResourceClaimStatusPatchOutput {
	return o.ApplyT(func(v *ResourceClaimStatusPatch) ResourceClaimStatusPatch {
		if v != nil {
			return *v
		}
		var ret ResourceClaimStatusPatch
		return ret
	}).(ResourceClaimStatusPatchOutput)
}

// Allocation is set once the claim has been allocated successfully.
func (o ResourceClaimStatusPatchPtrOutput) Allocation() AllocationResultPatchPtrOutput {
	return o.ApplyT(func(v *ResourceClaimStatusPatch) *AllocationResultPatch {
		if v == nil {
			return nil
		}
		return v.Allocation
	}).(AllocationResultPatchPtrOutput)
}

// Devices contains the status of each device allocated for this claim, as reported by the driver. This can include driver-specific information. Entries are owned by their respective drivers.
func (o ResourceClaimStatusPatchPtrOutput) Devices() AllocatedDeviceStatusPatchArrayOutput {
	return o.ApplyT(func(v *ResourceClaimStatusPatch) []AllocatedDeviceStatusPatch {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(AllocatedDeviceStatusPatchArrayOutput)
}

// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
//
// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
//
// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
//
// There can be at most 256 such reservations. This may get increased in the future, but not reduced.
func (o ResourceClaimStatusPatchPtrOutput) ReservedFor() ResourceClaimConsumerReferencePatchArrayOutput {
	return o.ApplyT(func(v *ResourceClaimStatusPatch) []ResourceClaimConsumerReferencePatch {
		if v == nil {
			return nil
		}
		return v.ReservedFor
	}).(ResourceClaimConsumerReferencePatchArrayOutput)
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplateType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Describes the ResourceClaim that is to be generated.
	//
	// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
	Spec ResourceClaimTemplateSpec `pulumi:"spec"`
}

// ResourceClaimTemplateTypeInput is an input type that accepts ResourceClaimTemplateTypeArgs and ResourceClaimTemplateTypeOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateTypeInput` via:
//
//	ResourceClaimTemplateTypeArgs{...}
type ResourceClaimTemplateTypeInput interface {
	pulumi.Input

	ToResourceClaimTemplateTypeOutput() ResourceClaimTemplateTypeOutput
	ToResourceClaimTemplateTypeOutputWithContext(context.Context) ResourceClaimTemplateTypeOutput
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplateTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Describes the ResourceClaim that is to be generated.
	//
	// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
	Spec ResourceClaimTemplateSpecInput `pulumi:"spec"`
}

func (ResourceClaimTemplateTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateType)(nil)).Elem()
}

func (i ResourceClaimTemplateTypeArgs) ToResourceClaimTemplateTypeOutput() ResourceClaimTemplateTypeOutput {
	return i.ToResourceClaimTemplateTypeOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateTypeArgs) ToResourceClaimTemplateTypeOutputWithContext(ctx context.Context) ResourceClaimTemplateTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateTypeOutput)
}

// ResourceClaimTemplateTypeArrayInput is an input type that accepts ResourceClaimTemplateTypeArray and ResourceClaimTemplateTypeArrayOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateTypeArrayInput` via:
//
//	ResourceClaimTemplateTypeArray{ ResourceClaimTemplateTypeArgs{...} }
type ResourceClaimTemplateTypeArrayInput interface {
	pulumi.Input

	ToResourceClaimTemplateTypeArrayOutput() ResourceClaimTemplateTypeArrayOutput
	ToResourceClaimTemplateTypeArrayOutputWithContext(context.Context) ResourceClaimTemplateTypeArrayOutput
}

type ResourceClaimTemplateTypeArray []ResourceClaimTemplateTypeInput

func (ResourceClaimTemplateTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimTemplateType)(nil)).Elem()
}

func (i ResourceClaimTemplateTypeArray) ToResourceClaimTemplateTypeArrayOutput() ResourceClaimTemplateTypeArrayOutput {
	return i.ToResourceClaimTemplateTypeArrayOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateTypeArray) ToResourceClaimTemplateTypeArrayOutputWithContext(ctx context.Context) ResourceClaimTemplateTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateTypeArrayOutput)
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplateTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateType)(nil)).Elem()
}

func (o ResourceClaimTemplateTypeOutput) ToResourceClaimTemplateTypeOutput() ResourceClaimTemplateTypeOutput {
	return o
}

func (o ResourceClaimTemplateTypeOutput) ToResourceClaimTemplateTypeOutputWithContext(ctx context.Context) ResourceClaimTemplateTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimTemplateTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimTemplateTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceClaimTemplateTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Describes the ResourceClaim that is to be generated.
//
// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
func (o ResourceClaimTemplateTypeOutput) Spec() ResourceClaimTemplateSpecOutput {
	return o.ApplyT(func(v ResourceClaimTemplateType) ResourceClaimTemplateSpec { return v.Spec }).(ResourceClaimTemplateSpecOutput)
}

type ResourceClaimTemplateTypeArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimTemplateType)(nil)).Elem()
}

func (o ResourceClaimTemplateTypeArrayOutput) ToResourceClaimTemplateTypeArrayOutput() ResourceClaimTemplateTypeArrayOutput {
	return o
}

func (o ResourceClaimTemplateTypeArrayOutput) ToResourceClaimTemplateTypeArrayOutputWithContext(ctx context.Context) ResourceClaimTemplateTypeArrayOutput {
	return o
}

func (o ResourceClaimTemplateTypeArrayOutput) Index(i pulumi.IntInput) ResourceClaimTemplateTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimTemplateType {
		return vs[0].([]ResourceClaimTemplateType)[vs[1].(int)]
	}).(ResourceClaimTemplateTypeOutput)
}

// ResourceClaimTemplateList is a collection of claim templates.
type ResourceClaimTemplateListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of resource claim templates.
	Items []ResourceClaimTemplateType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ResourceClaimTemplateListTypeInput is an input type that accepts ResourceClaimTemplateListTypeArgs and ResourceClaimTemplateListTypeOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateListTypeInput` via:
//
//	ResourceClaimTemplateListTypeArgs{...}
type ResourceClaimTemplateListTypeInput interface {
	pulumi.Input

	ToResourceClaimTemplateListTypeOutput() ResourceClaimTemplateListTypeOutput
	ToResourceClaimTemplateListTypeOutputWithContext(context.Context) ResourceClaimTemplateListTypeOutput
}

// ResourceClaimTemplateList is a collection of claim templates.
type ResourceClaimTemplateListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of resource claim templates.
	Items ResourceClaimTemplateTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ResourceClaimTemplateListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateListType)(nil)).Elem()
}

func (i ResourceClaimTemplateListTypeArgs) ToResourceClaimTemplateListTypeOutput() ResourceClaimTemplateListTypeOutput {
	return i.ToResourceClaimTemplateListTypeOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateListTypeArgs) ToResourceClaimTemplateListTypeOutputWithContext(ctx context.Context) ResourceClaimTemplateListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateListTypeOutput)
}

// ResourceClaimTemplateList is a collection of claim templates.
type ResourceClaimTemplateListTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateListType)(nil)).Elem()
}

func (o ResourceClaimTemplateListTypeOutput) ToResourceClaimTemplateListTypeOutput() ResourceClaimTemplateListTypeOutput {
	return o
}

func (o ResourceClaimTemplateListTypeOutput) ToResourceClaimTemplateListTypeOutputWithContext(ctx context.Context) ResourceClaimTemplateListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimTemplateListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of resource claim templates.
func (o ResourceClaimTemplateListTypeOutput) Items() ResourceClaimTemplateTypeArrayOutput {
	return o.ApplyT(func(v ResourceClaimTemplateListType) []ResourceClaimTemplateType { return v.Items }).(ResourceClaimTemplateTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimTemplateListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o ResourceClaimTemplateListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplatePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Describes the ResourceClaim that is to be generated.
	//
	// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
	Spec *ResourceClaimTemplateSpecPatch `pulumi:"spec"`
}

// ResourceClaimTemplatePatchTypeInput is an input type that accepts ResourceClaimTemplatePatchTypeArgs and ResourceClaimTemplatePatchTypeOutput values.
// You can construct a concrete instance of `ResourceClaimTemplatePatchTypeInput` via:
//
//	ResourceClaimTemplatePatchTypeArgs{...}
type ResourceClaimTemplatePatchTypeInput interface {
	pulumi.Input

	ToResourceClaimTemplatePatchTypeOutput() ResourceClaimTemplatePatchTypeOutput
	ToResourceClaimTemplatePatchTypeOutputWithContext(context.Context) ResourceClaimTemplatePatchTypeOutput
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplatePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Describes the ResourceClaim that is to be generated.
	//
	// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
	Spec ResourceClaimTemplateSpecPatchPtrInput `pulumi:"spec"`
}

func (ResourceClaimTemplatePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplatePatchType)(nil)).Elem()
}

func (i ResourceClaimTemplatePatchTypeArgs) ToResourceClaimTemplatePatchTypeOutput() ResourceClaimTemplatePatchTypeOutput {
	return i.ToResourceClaimTemplatePatchTypeOutputWithContext(context.Background())
}

func (i ResourceClaimTemplatePatchTypeArgs) ToResourceClaimTemplatePatchTypeOutputWithContext(ctx context.Context) ResourceClaimTemplatePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplatePatchTypeOutput)
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplatePatchTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplatePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplatePatchType)(nil)).Elem()
}

func (o ResourceClaimTemplatePatchTypeOutput) ToResourceClaimTemplatePatchTypeOutput() ResourceClaimTemplatePatchTypeOutput {
	return o
}

func (o ResourceClaimTemplatePatchTypeOutput) ToResourceClaimTemplatePatchTypeOutputWithContext(ctx context.Context) ResourceClaimTemplatePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimTemplatePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplatePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimTemplatePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplatePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceClaimTemplatePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplatePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Describes the ResourceClaim that is to be generated.
//
// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
func (o ResourceClaimTemplatePatchTypeOutput) Spec() ResourceClaimTemplateSpecPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplatePatchType) *ResourceClaimTemplateSpecPatch { return v.Spec }).(ResourceClaimTemplateSpecPatchPtrOutput)
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpec struct {
	// ObjectMeta may contain labels and annotations that will be copied into the ResourceClaim when creating it. No other fields are allowed and will be rejected during validation.
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
	Spec ResourceClaimSpec `pulumi:"spec"`
}

// ResourceClaimTemplateSpecInput is an input type that accepts ResourceClaimTemplateSpecArgs and ResourceClaimTemplateSpecOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateSpecInput` via:
//
//	ResourceClaimTemplateSpecArgs{...}
type ResourceClaimTemplateSpecInput interface {
	pulumi.Input

	ToResourceClaimTemplateSpecOutput() ResourceClaimTemplateSpecOutput
	ToResourceClaimTemplateSpecOutputWithContext(context.Context) ResourceClaimTemplateSpecOutput
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecArgs struct {
	// ObjectMeta may contain labels and annotations that will be copied into the ResourceClaim when creating it. No other fields are allowed and will be rejected during validation.
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
	Spec ResourceClaimSpecInput `pulumi:"spec"`
}

func (ResourceClaimTemplateSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateSpec)(nil)).Elem()
}

func (i ResourceClaimTemplateSpecArgs) ToResourceClaimTemplateSpecOutput() ResourceClaimTemplateSpecOutput {
	return i.ToResourceClaimTemplateSpecOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateSpecArgs) ToResourceClaimTemplateSpecOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateSpecOutput)
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateSpec)(nil)).Elem()
}

func (o ResourceClaimTemplateSpecOutput) ToResourceClaimTemplateSpecOutput() ResourceClaimTemplateSpecOutput {
	return o
}

func (o ResourceClaimTemplateSpecOutput) ToResourceClaimTemplateSpecOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecOutput {
	return o
}

// ObjectMeta may contain labels and annotations that will be copied into the ResourceClaim when creating it. No other fields are allowed and will be rejected during validation.
func (o ResourceClaimTemplateSpecOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateSpec) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
func (o ResourceClaimTemplateSpecOutput) Spec() ResourceClaimSpecOutput {
	return o.ApplyT(func(v ResourceClaimTemplateSpec) ResourceClaimSpec { return v.Spec }).(ResourceClaimSpecOutput)
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecPatch struct {
	// ObjectMeta may contain labels and annotations that will be copied into the ResourceClaim when creating it. No other fields are allowed and will be rejected during validation.
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
	Spec *ResourceClaimSpecPatch `pulumi:"spec"`
}

// ResourceClaimTemplateSpecPatchInput is an input type that accepts ResourceClaimTemplateSpecPatchArgs and ResourceClaimTemplateSpecPatchOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateSpecPatchInput` via:
//
//	ResourceClaimTemplateSpecPatchArgs{...}
type ResourceClaimTemplateSpecPatchInput interface {
	pulumi.Input

	ToResourceClaimTemplateSpecPatchOutput() ResourceClaimTemplateSpecPatchOutput
	ToResourceClaimTemplateSpecPatchOutputWithContext(context.Context) ResourceClaimTemplateSpecPatchOutput
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecPatchArgs struct {
	// ObjectMeta may contain labels and annotations that will be copied into the ResourceClaim when creating it. No other fields are allowed and will be rejected during validation.
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
	Spec ResourceClaimSpecPatchPtrInput `pulumi:"spec"`
}

func (ResourceClaimTemplateSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateSpecPatch)(nil)).Elem()
}

func (i ResourceClaimTemplateSpecPatchArgs) ToResourceClaimTemplateSpecPatchOutput() ResourceClaimTemplateSpecPatchOutput {
	return i.ToResourceClaimTemplateSpecPatchOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateSpecPatchArgs) ToResourceClaimTemplateSpecPatchOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateSpecPatchOutput)
}

func (i ResourceClaimTemplateSpecPatchArgs) ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput {
	return i.ToResourceClaimTemplateSpecPatchPtrOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateSpecPatchArgs) ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateSpecPatchOutput).ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx)
}

// ResourceClaimTemplateSpecPatchPtrInput is an input type that accepts ResourceClaimTemplateSpecPatchArgs, ResourceClaimTemplateSpecPatchPtr and ResourceClaimTemplateSpecPatchPtrOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateSpecPatchPtrInput` via:
//
//	        ResourceClaimTemplateSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ResourceClaimTemplateSpecPatchPtrInput interface {
	pulumi.Input

	ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput
	ToResourceClaimTemplateSpecPatchPtrOutputWithContext(context.Context) ResourceClaimTemplateSpecPatchPtrOutput
}

type resourceClaimTemplateSpecPatchPtrType ResourceClaimTemplateSpecPatchArgs

func ResourceClaimTemplateSpecPatchPtr(v *ResourceClaimTemplateSpecPatchArgs) ResourceClaimTemplateSpecPatchPtrInput {
	return (*resourceClaimTemplateSpecPatchPtrType)(v)
}

func (*resourceClaimTemplateSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimTemplateSpecPatch)(nil)).Elem()
}

func (i *resourceClaimTemplateSpecPatchPtrType) ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput {
	return i.ToResourceClaimTemplateSpecPatchPtrOutputWithContext(context.Background())
}

func (i *resourceClaimTemplateSpecPatchPtrType) ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateSpecPatchPtrOutput)
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecPatchOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateSpecPatch)(nil)).Elem()
}

func (o ResourceClaimTemplateSpecPatchOutput) ToResourceClaimTemplateSpecPatchOutput() ResourceClaimTemplateSpecPatchOutput {
	return o
}

func (o ResourceClaimTemplateSpecPatchOutput) ToResourceClaimTemplateSpecPatchOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchOutput {
	return o
}

func (o ResourceClaimTemplateSpecPatchOutput) ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput {
	return o.ToResourceClaimTemplateSpecPatchPtrOutputWithContext(context.Background())
}

func (o ResourceClaimTemplateSpecPatchOutput) ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceClaimTemplateSpecPatch) *ResourceClaimTemplateSpecPatch {
		return &v
	}).(ResourceClaimTemplateSpecPatchPtrOutput)
}

// ObjectMeta may contain labels and annotations that will be copied into the ResourceClaim when creating it. No other fields are allowed and will be rejected during validation.
func (o ResourceClaimTemplateSpecPatchOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateSpecPatch) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
func (o ResourceClaimTemplateSpecPatchOutput) Spec() ResourceClaimSpecPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateSpecPatch) *ResourceClaimSpecPatch { return v.Spec }).(ResourceClaimSpecPatchPtrOutput)
}

type ResourceClaimTemplateSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimTemplateSpecPatch)(nil)).Elem()
}

func (o ResourceClaimTemplateSpecPatchPtrOutput) ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput {
	return o
}

func (o ResourceClaimTemplateSpecPatchPtrOutput) ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchPtrOutput {
	return o
}

func (o ResourceClaimTemplateSpecPatchPtrOutput) Elem() ResourceClaimTemplateSpecPatchOutput {
	return o.ApplyT(func(v *ResourceClaimTemplateSpecPatch) ResourceClaimTemplateSpecPatch {
		if v != nil {
			return *v
		}
		var ret ResourceClaimTemplateSpecPatch
		return ret
	}).(ResourceClaimTemplateSpecPatchOutput)
}

// ObjectMeta may contain labels and annotations that will be copied into the ResourceClaim when creating it. No other fields are allowed and will be rejected during validation.
func (o ResourceClaimTemplateSpecPatchPtrOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v *ResourceClaimTemplateSpecPatch) *metav1.ObjectMetaPatch {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
func (o ResourceClaimTemplateSpecPatchPtrOutput) Spec() ResourceClaimSpecPatchPtrOutput {
	return o.ApplyT(func(v *ResourceClaimTemplateSpecPatch) *ResourceClaimSpecPatch {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ResourceClaimSpecPatchPtrOutput)
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePool struct {
	// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
	//
	// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
	Generation int `pulumi:"generation"`
	// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
	//
	// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
	Name string `pulumi:"name"`
	// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
	//
	// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
	ResourceSliceCount int `pulumi:"resourceSliceCount"`
}

// ResourcePoolInput is an input type that accepts ResourcePoolArgs and ResourcePoolOutput values.
// You can construct a concrete instance of `ResourcePoolInput` via:
//
//	ResourcePoolArgs{...}
type ResourcePoolInput interface {
	pulumi.Input

	ToResourcePoolOutput() ResourcePoolOutput
	ToResourcePoolOutputWithContext(context.Context) ResourcePoolOutput
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolArgs struct {
	// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
	//
	// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
	Generation pulumi.IntInput `pulumi:"generation"`
	// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
	//
	// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
	Name pulumi.StringInput `pulumi:"name"`
	// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
	//
	// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
	ResourceSliceCount pulumi.IntInput `pulumi:"resourceSliceCount"`
}

func (ResourcePoolArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePool)(nil)).Elem()
}

func (i ResourcePoolArgs) ToResourcePoolOutput() ResourcePoolOutput {
	return i.ToResourcePoolOutputWithContext(context.Background())
}

func (i ResourcePoolArgs) ToResourcePoolOutputWithContext(ctx context.Context) ResourcePoolOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePoolOutput)
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolOutput struct{ *pulumi.OutputState }

func (ResourcePoolOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePool)(nil)).Elem()
}

func (o ResourcePoolOutput) ToResourcePoolOutput() ResourcePoolOutput {
	return o
}

func (o ResourcePoolOutput) ToResourcePoolOutputWithContext(ctx context.Context) ResourcePoolOutput {
	return o
}

// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
//
// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
func (o ResourcePoolOutput) Generation() pulumi.IntOutput {
	return o.ApplyT(func(v ResourcePool) int { return v.Generation }).(pulumi.IntOutput)
}

// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
//
// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
func (o ResourcePoolOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ResourcePool) string { return v.Name }).(pulumi.StringOutput)
}

// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
//
// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
func (o ResourcePoolOutput) ResourceSliceCount() pulumi.IntOutput {
	return o.ApplyT(func(v ResourcePool) int { return v.ResourceSliceCount }).(pulumi.IntOutput)
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolPatch struct {
	// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
	//
	// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
	Generation *int `pulumi:"generation"`
	// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
	//
	// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
	Name *string `pulumi:"name"`
	// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
	//
	// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
	ResourceSliceCount *int `pulumi:"resourceSliceCount"`
}

// ResourcePoolPatchInput is an input type that accepts ResourcePoolPatchArgs and ResourcePoolPatchOutput values.
// You can construct a concrete instance of `ResourcePoolPatchInput` via:
//
//	ResourcePoolPatchArgs{...}
type ResourcePoolPatchInput interface {
	pulumi.Input

	ToResourcePoolPatchOutput() ResourcePoolPatchOutput
	ToResourcePoolPatchOutputWithContext(context.Context) ResourcePoolPatchOutput
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolPatchArgs struct {
	// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
	//
	// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
	Generation pulumi.IntPtrInput `pulumi:"generation"`
	// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
	//
	// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
	//
	// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
	ResourceSliceCount pulumi.IntPtrInput `pulumi:"resourceSliceCount"`
}

func (ResourcePoolPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePoolPatch)(nil)).Elem()
}

func (i ResourcePoolPatchArgs) ToResourcePoolPatchOutput() ResourcePoolPatchOutput {
	return i.ToResourcePoolPatchOutputWithContext(context.Background())
}

func (i ResourcePoolPatchArgs) ToResourcePoolPatchOutputWithContext(ctx context.Context) ResourcePoolPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePoolPatchOutput)
}

func (i ResourcePoolPatchArgs) ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput {
	return i.ToResourcePoolPatchPtrOutputWithContext(context.Background())
}

func (i ResourcePoolPatchArgs) ToResourcePoolPatchPtrOutputWithContext(ctx context.Context) ResourcePoolPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePoolPatchOutput).ToResourcePoolPatchPtrOutputWithContext(ctx)
}

// ResourcePoolPatchPtrInput is an input type that accepts ResourcePoolPatchArgs, ResourcePoolPatchPtr and ResourcePoolPatchPtrOutput values.
// You can construct a concrete instance of `ResourcePoolPatchPtrInput` via:
//
//	        ResourcePoolPatchArgs{...}
//
//	or:
//
//	        nil
type ResourcePoolPatchPtrInput interface {
	pulumi.Input

	ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput
	ToResourcePoolPatchPtrOutputWithContext(context.Context) ResourcePoolPatchPtrOutput
}

type resourcePoolPatchPtrType ResourcePoolPatchArgs

func ResourcePoolPatchPtr(v *ResourcePoolPatchArgs) ResourcePoolPatchPtrInput {
	return (*resourcePoolPatchPtrType)(v)
}

func (*resourcePoolPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourcePoolPatch)(nil)).Elem()
}

func (i *resourcePoolPatchPtrType) ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput {
	return i.ToResourcePoolPatchPtrOutputWithContext(context.Background())
}

func (i *resourcePoolPatchPtrType) ToResourcePoolPatchPtrOutputWithContext(ctx context.Context) ResourcePoolPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePoolPatchPtrOutput)
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolPatchOutput struct{ *pulumi.OutputState }

func (ResourcePoolPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePoolPatch)(nil)).Elem()
}

func (o ResourcePoolPatchOutput) ToResourcePoolPatchOutput() ResourcePoolPatchOutput {
	return o
}

func (o ResourcePoolPatchOutput) ToResourcePoolPatchOutputWithContext(ctx context.Context) ResourcePoolPatchOutput {
	return o
}

func (o ResourcePoolPatchOutput) ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput {
	return o.ToResourcePoolPatchPtrOutputWithContext(context.Background())
}

func (o ResourcePoolPatchOutput) ToResourcePoolPatchPtrOutputWithContext(ctx context.Context) ResourcePoolPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourcePoolPatch) *ResourcePoolPatch {
		return &v
	}).(ResourcePoolPatchPtrOutput)
}

// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
//
// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
func (o ResourcePoolPatchOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ResourcePoolPatch) *int { return v.Generation }).(pulumi.IntPtrOutput)
}

// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
//
// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
func (o ResourcePoolPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourcePoolPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
//
// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
func (o ResourcePoolPatchOutput) ResourceSliceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ResourcePoolPatch) *int { return v.ResourceSliceCount }).(pulumi.IntPtrOutput)
}

type ResourcePoolPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourcePoolPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourcePoolPatch)(nil)).Elem()
}

func (o ResourcePoolPatchPtrOutput) ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput {
	return o
}

func (o ResourcePoolPatchPtrOutput) ToResourcePoolPatchPtrOutputWithContext(ctx context.Context) ResourcePoolPatchPtrOutput {
	return o
}

func (o ResourcePoolPatchPtrOutput) Elem() ResourcePoolPatchOutput {
	return o.ApplyT(func(v *ResourcePoolPatch) ResourcePoolPatch {
		if v != nil {
			return *v
		}
		var ret ResourcePoolPatch
		return ret
	}).(ResourcePoolPatchOutput)
}

// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
//
// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
func (o ResourcePoolPatchPtrOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ResourcePoolPatch) *int {
		if v == nil {
			return nil
		}
		return v.Generation
	}).(pulumi.IntPtrOutput)
}

// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
//
// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
func (o ResourcePoolPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourcePoolPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
//
// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
func (o ResourcePoolPatchPtrOutput) ResourceSliceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ResourcePoolPatch) *int {
		if v == nil {
			return nil
		}
		return v.ResourceSliceCount
	}).(pulumi.IntPtrOutput)
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSliceType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Contains the information published by the driver.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec ResourceSliceSpec `pulumi:"spec"`
}

// ResourceSliceTypeInput is an input type that accepts ResourceSliceTypeArgs and ResourceSliceTypeOutput values.
// You can construct a concrete instance of `ResourceSliceTypeInput` via:
//
//	ResourceSliceTypeArgs{...}
type ResourceSliceTypeInput interface {
	pulumi.Input

	ToResourceSliceTypeOutput() ResourceSliceTypeOutput
	ToResourceSliceTypeOutputWithContext(context.Context) ResourceSliceTypeOutput
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSliceTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Contains the information published by the driver.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec ResourceSliceSpecInput `pulumi:"spec"`
}

func (ResourceSliceTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceType)(nil)).Elem()
}

func (i ResourceSliceTypeArgs) ToResourceSliceTypeOutput() ResourceSliceTypeOutput {
	return i.ToResourceSliceTypeOutputWithContext(context.Background())
}

func (i ResourceSliceTypeArgs) ToResourceSliceTypeOutputWithContext(ctx context.Context) ResourceSliceTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceTypeOutput)
}

// ResourceSliceTypeArrayInput is an input type that accepts ResourceSliceTypeArray and ResourceSliceTypeArrayOutput values.
// You can construct a concrete instance of `ResourceSliceTypeArrayInput` via:
//
//	ResourceSliceTypeArray{ ResourceSliceTypeArgs{...} }
type ResourceSliceTypeArrayInput interface {
	pulumi.Input

	ToResourceSliceTypeArrayOutput() ResourceSliceTypeArrayOutput
	ToResourceSliceTypeArrayOutputWithContext(context.Context) ResourceSliceTypeArrayOutput
}

type ResourceSliceTypeArray []ResourceSliceTypeInput

func (ResourceSliceTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceSliceType)(nil)).Elem()
}

func (i ResourceSliceTypeArray) ToResourceSliceTypeArrayOutput() ResourceSliceTypeArrayOutput {
	return i.ToResourceSliceTypeArrayOutputWithContext(context.Background())
}

func (i ResourceSliceTypeArray) ToResourceSliceTypeArrayOutputWithContext(ctx context.Context) ResourceSliceTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceTypeArrayOutput)
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSliceTypeOutput struct{ *pulumi.OutputState }

func (ResourceSliceTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceType)(nil)).Elem()
}

func (o ResourceSliceTypeOutput) ToResourceSliceTypeOutput() ResourceSliceTypeOutput {
	return o
}

func (o ResourceSliceTypeOutput) ToResourceSliceTypeOutputWithContext(ctx context.Context) ResourceSliceTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceSliceTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceSliceTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceSliceTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ResourceSliceType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Contains the information published by the driver.
//
// Changing the spec automatically increments the metadata.generation number.
func (o ResourceSliceTypeOutput) Spec() ResourceSliceSpecOutput {
	return o.ApplyT(func(v ResourceSliceType) ResourceSliceSpec { return v.Spec }).(ResourceSliceSpecOutput)
}

type ResourceSliceTypeArrayOutput struct{ *pulumi.OutputState }

func (ResourceSliceTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceSliceType)(nil)).Elem()
}

func (o ResourceSliceTypeArrayOutput) ToResourceSliceTypeArrayOutput() ResourceSliceTypeArrayOutput {
	return o
}

func (o ResourceSliceTypeArrayOutput) ToResourceSliceTypeArrayOutputWithContext(ctx context.Context) ResourceSliceTypeArrayOutput {
	return o
}

func (o ResourceSliceTypeArrayOutput) Index(i pulumi.IntInput) ResourceSliceTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceSliceType {
		return vs[0].([]ResourceSliceType)[vs[1].(int)]
	}).(ResourceSliceTypeOutput)
}

// ResourceSliceList is a collection of ResourceSlices.
type ResourceSliceListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of resource ResourceSlices.
	Items []ResourceSliceType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ResourceSliceListTypeInput is an input type that accepts ResourceSliceListTypeArgs and ResourceSliceListTypeOutput values.
// You can construct a concrete instance of `ResourceSliceListTypeInput` via:
//
//	ResourceSliceListTypeArgs{...}
type ResourceSliceListTypeInput interface {
	pulumi.Input

	ToResourceSliceListTypeOutput() ResourceSliceListTypeOutput
	ToResourceSliceListTypeOutputWithContext(context.Context) ResourceSliceListTypeOutput
}

// ResourceSliceList is a collection of ResourceSlices.
type ResourceSliceListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of resource ResourceSlices.
	Items ResourceSliceTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ResourceSliceListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceListType)(nil)).Elem()
}

func (i ResourceSliceListTypeArgs) ToResourceSliceListTypeOutput() ResourceSliceListTypeOutput {
	return i.ToResourceSliceListTypeOutputWithContext(context.Background())
}

func (i ResourceSliceListTypeArgs) ToResourceSliceListTypeOutputWithContext(ctx context.Context) ResourceSliceListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceListTypeOutput)
}

// ResourceSliceList is a collection of ResourceSlices.
type ResourceSliceListTypeOutput struct{ *pulumi.OutputState }

func (ResourceSliceListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceListType)(nil)).Elem()
}

func (o ResourceSliceListTypeOutput) ToResourceSliceListTypeOutput() ResourceSliceListTypeOutput {
	return o
}

func (o ResourceSliceListTypeOutput) ToResourceSliceListTypeOutputWithContext(ctx context.Context) ResourceSliceListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceSliceListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of resource ResourceSlices.
func (o ResourceSliceListTypeOutput) Items() ResourceSliceTypeArrayOutput {
	return o.ApplyT(func(v ResourceSliceListType) []ResourceSliceType { return v.Items }).(ResourceSliceTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceSliceListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o ResourceSliceListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ResourceSliceListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSlicePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Contains the information published by the driver.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec *ResourceSliceSpecPatch `pulumi:"spec"`
}

// ResourceSlicePatchTypeInput is an input type that accepts ResourceSlicePatchTypeArgs and ResourceSlicePatchTypeOutput values.
// You can construct a concrete instance of `ResourceSlicePatchTypeInput` via:
//
//	ResourceSlicePatchTypeArgs{...}
type ResourceSlicePatchTypeInput interface {
	pulumi.Input

	ToResourceSlicePatchTypeOutput() ResourceSlicePatchTypeOutput
	ToResourceSlicePatchTypeOutputWithContext(context.Context) ResourceSlicePatchTypeOutput
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSlicePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Contains the information published by the driver.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec ResourceSliceSpecPatchPtrInput `pulumi:"spec"`
}

func (ResourceSlicePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSlicePatchType)(nil)).Elem()
}

func (i ResourceSlicePatchTypeArgs) ToResourceSlicePatchTypeOutput() ResourceSlicePatchTypeOutput {
	return i.ToResourceSlicePatchTypeOutputWithContext(context.Background())
}

func (i ResourceSlicePatchTypeArgs) ToResourceSlicePatchTypeOutputWithContext(ctx context.Context) ResourceSlicePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSlicePatchTypeOutput)
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSlicePatchTypeOutput struct{ *pulumi.OutputState }

func (ResourceSlicePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSlicePatchType)(nil)).Elem()
}

func (o ResourceSlicePatchTypeOutput) ToResourceSlicePatchTypeOutput() ResourceSlicePatchTypeOutput {
	return o
}

func (o ResourceSlicePatchTypeOutput) ToResourceSlicePatchTypeOutputWithContext(ctx context.Context) ResourceSlicePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceSlicePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSlicePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceSlicePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSlicePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceSlicePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ResourceSlicePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Contains the information published by the driver.
//
// Changing the spec automatically increments the metadata.generation number.
func (o ResourceSlicePatchTypeOutput) Spec() ResourceSliceSpecPatchPtrOutput {
	return o.ApplyT(func(v ResourceSlicePatchType) *ResourceSliceSpecPatch { return v.Spec }).(ResourceSliceSpecPatchPtrOutput)
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpec struct {
	// AllNodes indicates that all nodes have access to the resources in the pool.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	AllNodes *bool `pulumi:"allNodes"`
	// Devices lists some or all of the devices in this pool.
	//
	// Must not have more than 128 entries.
	Devices []Device `pulumi:"devices"`
	// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
	Driver string `pulumi:"driver"`
	// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
	//
	// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set. This field is immutable.
	NodeName *string `pulumi:"nodeName"`
	// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
	//
	// Must use exactly one term.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	NodeSelector *corev1.NodeSelector `pulumi:"nodeSelector"`
	// PerDeviceNodeSelection defines whether the access from nodes to resources in the pool is set on the ResourceSlice level or on each device. If it is set to true, every device defined the ResourceSlice must specify this individually.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	PerDeviceNodeSelection *bool `pulumi:"perDeviceNodeSelection"`
	// Pool describes the pool that this ResourceSlice belongs to.
	Pool ResourcePool `pulumi:"pool"`
	// SharedCounters defines a list of counter sets, each of which has a name and a list of counters available.
	//
	// The names of the SharedCounters must be unique in the ResourceSlice.
	//
	// The maximum number of SharedCounters is 32.
	SharedCounters []CounterSet `pulumi:"sharedCounters"`
}

// ResourceSliceSpecInput is an input type that accepts ResourceSliceSpecArgs and ResourceSliceSpecOutput values.
// You can construct a concrete instance of `ResourceSliceSpecInput` via:
//
//	ResourceSliceSpecArgs{...}
type ResourceSliceSpecInput interface {
	pulumi.Input

	ToResourceSliceSpecOutput() ResourceSliceSpecOutput
	ToResourceSliceSpecOutputWithContext(context.Context) ResourceSliceSpecOutput
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecArgs struct {
	// AllNodes indicates that all nodes have access to the resources in the pool.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	AllNodes pulumi.BoolPtrInput `pulumi:"allNodes"`
	// Devices lists some or all of the devices in this pool.
	//
	// Must not have more than 128 entries.
	Devices DeviceArrayInput `pulumi:"devices"`
	// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
	Driver pulumi.StringInput `pulumi:"driver"`
	// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
	//
	// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set. This field is immutable.
	NodeName pulumi.StringPtrInput `pulumi:"nodeName"`
	// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
	//
	// Must use exactly one term.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	NodeSelector corev1.NodeSelectorPtrInput `pulumi:"nodeSelector"`
	// PerDeviceNodeSelection defines whether the access from nodes to resources in the pool is set on the ResourceSlice level or on each device. If it is set to true, every device defined the ResourceSlice must specify this individually.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	PerDeviceNodeSelection pulumi.BoolPtrInput `pulumi:"perDeviceNodeSelection"`
	// Pool describes the pool that this ResourceSlice belongs to.
	Pool ResourcePoolInput `pulumi:"pool"`
	// SharedCounters defines a list of counter sets, each of which has a name and a list of counters available.
	//
	// The names of the SharedCounters must be unique in the ResourceSlice.
	//
	// The maximum number of SharedCounters is 32.
	SharedCounters CounterSetArrayInput `pulumi:"sharedCounters"`
}

func (ResourceSliceSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceSpec)(nil)).Elem()
}

func (i ResourceSliceSpecArgs) ToResourceSliceSpecOutput() ResourceSliceSpecOutput {
	return i.ToResourceSliceSpecOutputWithContext(context.Background())
}

func (i ResourceSliceSpecArgs) ToResourceSliceSpecOutputWithContext(ctx context.Context) ResourceSliceSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceSpecOutput)
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecOutput struct{ *pulumi.OutputState }

func (ResourceSliceSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceSpec)(nil)).Elem()
}

func (o ResourceSliceSpecOutput) ToResourceSliceSpecOutput() ResourceSliceSpecOutput {
	return o
}

func (o ResourceSliceSpecOutput) ToResourceSliceSpecOutputWithContext(ctx context.Context) ResourceSliceSpecOutput {
	return o
}

// AllNodes indicates that all nodes have access to the resources in the pool.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
func (o ResourceSliceSpecOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpec) *bool { return v.AllNodes }).(pulumi.BoolPtrOutput)
}

// Devices lists some or all of the devices in this pool.
//
// Must not have more than 128 entries.
func (o ResourceSliceSpecOutput) Devices() DeviceArrayOutput {
	return o.ApplyT(func(v ResourceSliceSpec) []Device { return v.Devices }).(DeviceArrayOutput)
}

// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
func (o ResourceSliceSpecOutput) Driver() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceSliceSpec) string { return v.Driver }).(pulumi.StringOutput)
}

// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
//
// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set. This field is immutable.
func (o ResourceSliceSpecOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpec) *string { return v.NodeName }).(pulumi.StringPtrOutput)
}

// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
//
// Must use exactly one term.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
func (o ResourceSliceSpecOutput) NodeSelector() corev1.NodeSelectorPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpec) *corev1.NodeSelector { return v.NodeSelector }).(corev1.NodeSelectorPtrOutput)
}

// PerDeviceNodeSelection defines whether the access from nodes to resources in the pool is set on the ResourceSlice level or on each device. If it is set to true, every device defined the ResourceSlice must specify this individually.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
func (o ResourceSliceSpecOutput) PerDeviceNodeSelection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpec) *bool { return v.PerDeviceNodeSelection }).(pulumi.BoolPtrOutput)
}

// Pool describes the pool that this ResourceSlice belongs to.
func (o ResourceSliceSpecOutput) Pool() ResourcePoolOutput {
	return o.ApplyT(func(v ResourceSliceSpec) ResourcePool { return v.Pool }).(ResourcePoolOutput)
}

// SharedCounters defines a list of counter sets, each of which has a name and a list of counters available.
//
// The names of the SharedCounters must be unique in the ResourceSlice.
//
// The maximum number of SharedCounters is 32.
func (o ResourceSliceSpecOutput) SharedCounters() CounterSetArrayOutput {
	return o.ApplyT(func(v ResourceSliceSpec) []CounterSet { return v.SharedCounters }).(CounterSetArrayOutput)
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecPatch struct {
	// AllNodes indicates that all nodes have access to the resources in the pool.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	AllNodes *bool `pulumi:"allNodes"`
	// Devices lists some or all of the devices in this pool.
	//
	// Must not have more than 128 entries.
	Devices []DevicePatch `pulumi:"devices"`
	// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
	Driver *string `pulumi:"driver"`
	// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
	//
	// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set. This field is immutable.
	NodeName *string `pulumi:"nodeName"`
	// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
	//
	// Must use exactly one term.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	NodeSelector *corev1.NodeSelectorPatch `pulumi:"nodeSelector"`
	// PerDeviceNodeSelection defines whether the access from nodes to resources in the pool is set on the ResourceSlice level or on each device. If it is set to true, every device defined the ResourceSlice must specify this individually.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	PerDeviceNodeSelection *bool `pulumi:"perDeviceNodeSelection"`
	// Pool describes the pool that this ResourceSlice belongs to.
	Pool *ResourcePoolPatch `pulumi:"pool"`
	// SharedCounters defines a list of counter sets, each of which has a name and a list of counters available.
	//
	// The names of the SharedCounters must be unique in the ResourceSlice.
	//
	// The maximum number of SharedCounters is 32.
	SharedCounters []CounterSetPatch `pulumi:"sharedCounters"`
}

// ResourceSliceSpecPatchInput is an input type that accepts ResourceSliceSpecPatchArgs and ResourceSliceSpecPatchOutput values.
// You can construct a concrete instance of `ResourceSliceSpecPatchInput` via:
//
//	ResourceSliceSpecPatchArgs{...}
type ResourceSliceSpecPatchInput interface {
	pulumi.Input

	ToResourceSliceSpecPatchOutput() ResourceSliceSpecPatchOutput
	ToResourceSliceSpecPatchOutputWithContext(context.Context) ResourceSliceSpecPatchOutput
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecPatchArgs struct {
	// AllNodes indicates that all nodes have access to the resources in the pool.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	AllNodes pulumi.BoolPtrInput `pulumi:"allNodes"`
	// Devices lists some or all of the devices in this pool.
	//
	// Must not have more than 128 entries.
	Devices DevicePatchArrayInput `pulumi:"devices"`
	// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
	Driver pulumi.StringPtrInput `pulumi:"driver"`
	// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
	//
	// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set. This field is immutable.
	NodeName pulumi.StringPtrInput `pulumi:"nodeName"`
	// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
	//
	// Must use exactly one term.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	NodeSelector corev1.NodeSelectorPatchPtrInput `pulumi:"nodeSelector"`
	// PerDeviceNodeSelection defines whether the access from nodes to resources in the pool is set on the ResourceSlice level or on each device. If it is set to true, every device defined the ResourceSlice must specify this individually.
	//
	// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
	PerDeviceNodeSelection pulumi.BoolPtrInput `pulumi:"perDeviceNodeSelection"`
	// Pool describes the pool that this ResourceSlice belongs to.
	Pool ResourcePoolPatchPtrInput `pulumi:"pool"`
	// SharedCounters defines a list of counter sets, each of which has a name and a list of counters available.
	//
	// The names of the SharedCounters must be unique in the ResourceSlice.
	//
	// The maximum number of SharedCounters is 32.
	SharedCounters CounterSetPatchArrayInput `pulumi:"sharedCounters"`
}

func (ResourceSliceSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceSpecPatch)(nil)).Elem()
}

func (i ResourceSliceSpecPatchArgs) ToResourceSliceSpecPatchOutput() ResourceSliceSpecPatchOutput {
	return i.ToResourceSliceSpecPatchOutputWithContext(context.Background())
}

func (i ResourceSliceSpecPatchArgs) ToResourceSliceSpecPatchOutputWithContext(ctx context.Context) ResourceSliceSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceSpecPatchOutput)
}

func (i ResourceSliceSpecPatchArgs) ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput {
	return i.ToResourceSliceSpecPatchPtrOutputWithContext(context.Background())
}

func (i ResourceSliceSpecPatchArgs) ToResourceSliceSpecPatchPtrOutputWithContext(ctx context.Context) ResourceSliceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceSpecPatchOutput).ToResourceSliceSpecPatchPtrOutputWithContext(ctx)
}

// ResourceSliceSpecPatchPtrInput is an input type that accepts ResourceSliceSpecPatchArgs, ResourceSliceSpecPatchPtr and ResourceSliceSpecPatchPtrOutput values.
// You can construct a concrete instance of `ResourceSliceSpecPatchPtrInput` via:
//
//	        ResourceSliceSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ResourceSliceSpecPatchPtrInput interface {
	pulumi.Input

	ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput
	ToResourceSliceSpecPatchPtrOutputWithContext(context.Context) ResourceSliceSpecPatchPtrOutput
}

type resourceSliceSpecPatchPtrType ResourceSliceSpecPatchArgs

func ResourceSliceSpecPatchPtr(v *ResourceSliceSpecPatchArgs) ResourceSliceSpecPatchPtrInput {
	return (*resourceSliceSpecPatchPtrType)(v)
}

func (*resourceSliceSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceSliceSpecPatch)(nil)).Elem()
}

func (i *resourceSliceSpecPatchPtrType) ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput {
	return i.ToResourceSliceSpecPatchPtrOutputWithContext(context.Background())
}

func (i *resourceSliceSpecPatchPtrType) ToResourceSliceSpecPatchPtrOutputWithContext(ctx context.Context) ResourceSliceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceSpecPatchPtrOutput)
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecPatchOutput struct{ *pulumi.OutputState }

func (ResourceSliceSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceSpecPatch)(nil)).Elem()
}

func (o ResourceSliceSpecPatchOutput) ToResourceSliceSpecPatchOutput() ResourceSliceSpecPatchOutput {
	return o
}

func (o ResourceSliceSpecPatchOutput) ToResourceSliceSpecPatchOutputWithContext(ctx context.Context) ResourceSliceSpecPatchOutput {
	return o
}

func (o ResourceSliceSpecPatchOutput) ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput {
	return o.ToResourceSliceSpecPatchPtrOutputWithContext(context.Background())
}

func (o ResourceSliceSpecPatchOutput) ToResourceSliceSpecPatchPtrOutputWithContext(ctx context.Context) ResourceSliceSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceSliceSpecPatch) *ResourceSliceSpecPatch {
		return &v
	}).(ResourceSliceSpecPatchPtrOutput)
}

// AllNodes indicates that all nodes have access to the resources in the pool.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
func (o ResourceSliceSpecPatchOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *bool { return v.AllNodes }).(pulumi.BoolPtrOutput)
}

// Devices lists some or all of the devices in this pool.
//
// Must not have more than 128 entries.
func (o ResourceSliceSpecPatchOutput) Devices() DevicePatchArrayOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) []DevicePatch { return v.Devices }).(DevicePatchArrayOutput)
}

// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
func (o ResourceSliceSpecPatchOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *string { return v.Driver }).(pulumi.StringPtrOutput)
}

// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
//
// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set. This field is immutable.
func (o ResourceSliceSpecPatchOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *string { return v.NodeName }).(pulumi.StringPtrOutput)
}

// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
//
// Must use exactly one term.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
func (o ResourceSliceSpecPatchOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *corev1.NodeSelectorPatch { return v.NodeSelector }).(corev1.NodeSelectorPatchPtrOutput)
}

// PerDeviceNodeSelection defines whether the access from nodes to resources in the pool is set on the ResourceSlice level or on each device. If it is set to true, every device defined the ResourceSlice must specify this individually.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
func (o ResourceSliceSpecPatchOutput) PerDeviceNodeSelection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *bool { return v.PerDeviceNodeSelection }).(pulumi.BoolPtrOutput)
}

// Pool describes the pool that this ResourceSlice belongs to.
func (o ResourceSliceSpecPatchOutput) Pool() ResourcePoolPatchPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *ResourcePoolPatch { return v.Pool }).(ResourcePoolPatchPtrOutput)
}

// SharedCounters defines a list of counter sets, each of which has a name and a list of counters available.
//
// The names of the SharedCounters must be unique in the ResourceSlice.
//
// The maximum number of SharedCounters is 32.
func (o ResourceSliceSpecPatchOutput) SharedCounters() CounterSetPatchArrayOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) []CounterSetPatch { return v.SharedCounters }).(CounterSetPatchArrayOutput)
}

type ResourceSliceSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourceSliceSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceSliceSpecPatch)(nil)).Elem()
}

func (o ResourceSliceSpecPatchPtrOutput) ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput {
	return o
}

func (o ResourceSliceSpecPatchPtrOutput) ToResourceSliceSpecPatchPtrOutputWithContext(ctx context.Context) ResourceSliceSpecPatchPtrOutput {
	return o
}

func (o ResourceSliceSpecPatchPtrOutput) Elem() ResourceSliceSpecPatchOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) ResourceSliceSpecPatch {
		if v != nil {
			return *v
		}
		var ret ResourceSliceSpecPatch
		return ret
	}).(ResourceSliceSpecPatchOutput)
}

// AllNodes indicates that all nodes have access to the resources in the pool.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
func (o ResourceSliceSpecPatchPtrOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.AllNodes
	}).(pulumi.BoolPtrOutput)
}

// Devices lists some or all of the devices in this pool.
//
// Must not have more than 128 entries.
func (o ResourceSliceSpecPatchPtrOutput) Devices() DevicePatchArrayOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) []DevicePatch {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(DevicePatchArrayOutput)
}

// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
func (o ResourceSliceSpecPatchPtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Driver
	}).(pulumi.StringPtrOutput)
}

// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
//
// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set. This field is immutable.
func (o ResourceSliceSpecPatchPtrOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.NodeName
	}).(pulumi.StringPtrOutput)
}

// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
//
// Must use exactly one term.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
func (o ResourceSliceSpecPatchPtrOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *corev1.NodeSelectorPatch {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(corev1.NodeSelectorPatchPtrOutput)
}

// PerDeviceNodeSelection defines whether the access from nodes to resources in the pool is set on the ResourceSlice level or on each device. If it is set to true, every device defined the ResourceSlice must specify this individually.
//
// Exactly one of NodeName, NodeSelector, AllNodes, and PerDeviceNodeSelection must be set.
func (o ResourceSliceSpecPatchPtrOutput) PerDeviceNodeSelection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.PerDeviceNodeSelection
	}).(pulumi.BoolPtrOutput)
}

// Pool describes the pool that this ResourceSlice belongs to.
func (o ResourceSliceSpecPatchPtrOutput) Pool() ResourcePoolPatchPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *ResourcePoolPatch {
		if v == nil {
			return nil
		}
		return v.Pool
	}).(ResourcePoolPatchPtrOutput)
}

// SharedCounters defines a list of counter sets, each of which has a name and a list of counters available.
//
// The names of the SharedCounters must be unique in the ResourceSlice.
//
// The maximum number of SharedCounters is 32.
func (o ResourceSliceSpecPatchPtrOutput) SharedCounters() CounterSetPatchArrayOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) []CounterSetPatch {
		if v == nil {
			return nil
		}
		return v.SharedCounters
	}).(CounterSetPatchArrayOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AllocatedDeviceStatusInput)(nil)).Elem(), AllocatedDeviceStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocatedDeviceStatusArrayInput)(nil)).Elem(), AllocatedDeviceStatusArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocatedDeviceStatusPatchInput)(nil)).Elem(), AllocatedDeviceStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocatedDeviceStatusPatchArrayInput)(nil)).Elem(), AllocatedDeviceStatusPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationResultInput)(nil)).Elem(), AllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationResultPtrInput)(nil)).Elem(), AllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationResultPatchInput)(nil)).Elem(), AllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationResultPatchPtrInput)(nil)).Elem(), AllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicDeviceInput)(nil)).Elem(), BasicDeviceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicDevicePtrInput)(nil)).Elem(), BasicDeviceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicDevicePatchInput)(nil)).Elem(), BasicDevicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicDevicePatchPtrInput)(nil)).Elem(), BasicDevicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CELDeviceSelectorInput)(nil)).Elem(), CELDeviceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CELDeviceSelectorPtrInput)(nil)).Elem(), CELDeviceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CELDeviceSelectorPatchInput)(nil)).Elem(), CELDeviceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CELDeviceSelectorPatchPtrInput)(nil)).Elem(), CELDeviceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CounterInput)(nil)).Elem(), CounterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CounterMapInput)(nil)).Elem(), CounterMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*CounterPatchInput)(nil)).Elem(), CounterPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CounterSetInput)(nil)).Elem(), CounterSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CounterSetArrayInput)(nil)).Elem(), CounterSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CounterSetPatchInput)(nil)).Elem(), CounterSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CounterSetPatchArrayInput)(nil)).Elem(), CounterSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceInput)(nil)).Elem(), DeviceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceArrayInput)(nil)).Elem(), DeviceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationConfigurationInput)(nil)).Elem(), DeviceAllocationConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationConfigurationArrayInput)(nil)).Elem(), DeviceAllocationConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationConfigurationPatchInput)(nil)).Elem(), DeviceAllocationConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationConfigurationPatchArrayInput)(nil)).Elem(), DeviceAllocationConfigurationPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationResultInput)(nil)).Elem(), DeviceAllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationResultPtrInput)(nil)).Elem(), DeviceAllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationResultPatchInput)(nil)).Elem(), DeviceAllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationResultPatchPtrInput)(nil)).Elem(), DeviceAllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAttributeInput)(nil)).Elem(), DeviceAttributeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAttributeMapInput)(nil)).Elem(), DeviceAttributeMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAttributePatchInput)(nil)).Elem(), DeviceAttributePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceCapacityInput)(nil)).Elem(), DeviceCapacityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceCapacityMapInput)(nil)).Elem(), DeviceCapacityMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceCapacityPatchInput)(nil)).Elem(), DeviceCapacityPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimInput)(nil)).Elem(), DeviceClaimArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimPtrInput)(nil)).Elem(), DeviceClaimArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimConfigurationInput)(nil)).Elem(), DeviceClaimConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimConfigurationArrayInput)(nil)).Elem(), DeviceClaimConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimConfigurationPatchInput)(nil)).Elem(), DeviceClaimConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimConfigurationPatchArrayInput)(nil)).Elem(), DeviceClaimConfigurationPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimPatchInput)(nil)).Elem(), DeviceClaimPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimPatchPtrInput)(nil)).Elem(), DeviceClaimPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassTypeInput)(nil)).Elem(), DeviceClassTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassTypeArrayInput)(nil)).Elem(), DeviceClassTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassConfigurationInput)(nil)).Elem(), DeviceClassConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassConfigurationArrayInput)(nil)).Elem(), DeviceClassConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassConfigurationPatchInput)(nil)).Elem(), DeviceClassConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassConfigurationPatchArrayInput)(nil)).Elem(), DeviceClassConfigurationPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassListTypeInput)(nil)).Elem(), DeviceClassListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassPatchTypeInput)(nil)).Elem(), DeviceClassPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassSpecInput)(nil)).Elem(), DeviceClassSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassSpecPatchInput)(nil)).Elem(), DeviceClassSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassSpecPatchPtrInput)(nil)).Elem(), DeviceClassSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceConstraintInput)(nil)).Elem(), DeviceConstraintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceConstraintArrayInput)(nil)).Elem(), DeviceConstraintArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceConstraintPatchInput)(nil)).Elem(), DeviceConstraintPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceConstraintPatchArrayInput)(nil)).Elem(), DeviceConstraintPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceCounterConsumptionInput)(nil)).Elem(), DeviceCounterConsumptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceCounterConsumptionArrayInput)(nil)).Elem(), DeviceCounterConsumptionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceCounterConsumptionPatchInput)(nil)).Elem(), DeviceCounterConsumptionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceCounterConsumptionPatchArrayInput)(nil)).Elem(), DeviceCounterConsumptionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DevicePatchInput)(nil)).Elem(), DevicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DevicePatchArrayInput)(nil)).Elem(), DevicePatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestInput)(nil)).Elem(), DeviceRequestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestArrayInput)(nil)).Elem(), DeviceRequestArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestAllocationResultInput)(nil)).Elem(), DeviceRequestAllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestAllocationResultArrayInput)(nil)).Elem(), DeviceRequestAllocationResultArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestAllocationResultPatchInput)(nil)).Elem(), DeviceRequestAllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestAllocationResultPatchArrayInput)(nil)).Elem(), DeviceRequestAllocationResultPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestPatchInput)(nil)).Elem(), DeviceRequestPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestPatchArrayInput)(nil)).Elem(), DeviceRequestPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSelectorInput)(nil)).Elem(), DeviceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSelectorArrayInput)(nil)).Elem(), DeviceSelectorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSelectorPatchInput)(nil)).Elem(), DeviceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSelectorPatchArrayInput)(nil)).Elem(), DeviceSelectorPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSubRequestInput)(nil)).Elem(), DeviceSubRequestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSubRequestArrayInput)(nil)).Elem(), DeviceSubRequestArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSubRequestPatchInput)(nil)).Elem(), DeviceSubRequestPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSubRequestPatchArrayInput)(nil)).Elem(), DeviceSubRequestPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintInput)(nil)).Elem(), DeviceTaintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintArrayInput)(nil)).Elem(), DeviceTaintArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintPatchInput)(nil)).Elem(), DeviceTaintPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintPatchArrayInput)(nil)).Elem(), DeviceTaintPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTolerationInput)(nil)).Elem(), DeviceTolerationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTolerationArrayInput)(nil)).Elem(), DeviceTolerationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTolerationPatchInput)(nil)).Elem(), DeviceTolerationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTolerationPatchArrayInput)(nil)).Elem(), DeviceTolerationPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDeviceDataInput)(nil)).Elem(), NetworkDeviceDataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDeviceDataPtrInput)(nil)).Elem(), NetworkDeviceDataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDeviceDataPatchInput)(nil)).Elem(), NetworkDeviceDataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDeviceDataPatchPtrInput)(nil)).Elem(), NetworkDeviceDataPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpaqueDeviceConfigurationInput)(nil)).Elem(), OpaqueDeviceConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpaqueDeviceConfigurationPtrInput)(nil)).Elem(), OpaqueDeviceConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpaqueDeviceConfigurationPatchInput)(nil)).Elem(), OpaqueDeviceConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpaqueDeviceConfigurationPatchPtrInput)(nil)).Elem(), OpaqueDeviceConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTypeInput)(nil)).Elem(), ResourceClaimTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTypeArrayInput)(nil)).Elem(), ResourceClaimTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimConsumerReferenceInput)(nil)).Elem(), ResourceClaimConsumerReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimConsumerReferenceArrayInput)(nil)).Elem(), ResourceClaimConsumerReferenceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimConsumerReferencePatchInput)(nil)).Elem(), ResourceClaimConsumerReferencePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimConsumerReferencePatchArrayInput)(nil)).Elem(), ResourceClaimConsumerReferencePatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimListTypeInput)(nil)).Elem(), ResourceClaimListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimPatchTypeInput)(nil)).Elem(), ResourceClaimPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSpecInput)(nil)).Elem(), ResourceClaimSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSpecPatchInput)(nil)).Elem(), ResourceClaimSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSpecPatchPtrInput)(nil)).Elem(), ResourceClaimSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimStatusInput)(nil)).Elem(), ResourceClaimStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimStatusPtrInput)(nil)).Elem(), ResourceClaimStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimStatusPatchInput)(nil)).Elem(), ResourceClaimStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimStatusPatchPtrInput)(nil)).Elem(), ResourceClaimStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateTypeInput)(nil)).Elem(), ResourceClaimTemplateTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateTypeArrayInput)(nil)).Elem(), ResourceClaimTemplateTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateListTypeInput)(nil)).Elem(), ResourceClaimTemplateListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplatePatchTypeInput)(nil)).Elem(), ResourceClaimTemplatePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateSpecInput)(nil)).Elem(), ResourceClaimTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateSpecPatchInput)(nil)).Elem(), ResourceClaimTemplateSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateSpecPatchPtrInput)(nil)).Elem(), ResourceClaimTemplateSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePoolInput)(nil)).Elem(), ResourcePoolArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePoolPatchInput)(nil)).Elem(), ResourcePoolPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePoolPatchPtrInput)(nil)).Elem(), ResourcePoolPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceTypeInput)(nil)).Elem(), ResourceSliceTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceTypeArrayInput)(nil)).Elem(), ResourceSliceTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceListTypeInput)(nil)).Elem(), ResourceSliceListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSlicePatchTypeInput)(nil)).Elem(), ResourceSlicePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceSpecInput)(nil)).Elem(), ResourceSliceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceSpecPatchInput)(nil)).Elem(), ResourceSliceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceSpecPatchPtrInput)(nil)).Elem(), ResourceSliceSpecPatchArgs{})
	pulumi.RegisterOutputType(AllocatedDeviceStatusOutput{})
	pulumi.RegisterOutputType(AllocatedDeviceStatusArrayOutput{})
	pulumi.RegisterOutputType(AllocatedDeviceStatusPatchOutput{})
	pulumi.RegisterOutputType(AllocatedDeviceStatusPatchArrayOutput{})
	pulumi.RegisterOutputType(AllocationResultOutput{})
	pulumi.RegisterOutputType(AllocationResultPtrOutput{})
	pulumi.RegisterOutputType(AllocationResultPatchOutput{})
	pulumi.RegisterOutputType(AllocationResultPatchPtrOutput{})
	pulumi.RegisterOutputType(BasicDeviceOutput{})
	pulumi.RegisterOutputType(BasicDevicePtrOutput{})
	pulumi.RegisterOutputType(BasicDevicePatchOutput{})
	pulumi.RegisterOutputType(BasicDevicePatchPtrOutput{})
	pulumi.RegisterOutputType(CELDeviceSelectorOutput{})
	pulumi.RegisterOutputType(CELDeviceSelectorPtrOutput{})
	pulumi.RegisterOutputType(CELDeviceSelectorPatchOutput{})
	pulumi.RegisterOutputType(CELDeviceSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(CounterOutput{})
	pulumi.RegisterOutputType(CounterMapOutput{})
	pulumi.RegisterOutputType(CounterPatchOutput{})
	pulumi.RegisterOutputType(CounterSetOutput{})
	pulumi.RegisterOutputType(CounterSetArrayOutput{})
	pulumi.RegisterOutputType(CounterSetPatchOutput{})
	pulumi.RegisterOutputType(CounterSetPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceOutput{})
	pulumi.RegisterOutputType(DeviceArrayOutput{})
	pulumi.RegisterOutputType(DeviceAllocationConfigurationOutput{})
	pulumi.RegisterOutputType(DeviceAllocationConfigurationArrayOutput{})
	pulumi.RegisterOutputType(DeviceAllocationConfigurationPatchOutput{})
	pulumi.RegisterOutputType(DeviceAllocationConfigurationPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceAllocationResultOutput{})
	pulumi.RegisterOutputType(DeviceAllocationResultPtrOutput{})
	pulumi.RegisterOutputType(DeviceAllocationResultPatchOutput{})
	pulumi.RegisterOutputType(DeviceAllocationResultPatchPtrOutput{})
	pulumi.RegisterOutputType(DeviceAttributeOutput{})
	pulumi.RegisterOutputType(DeviceAttributeMapOutput{})
	pulumi.RegisterOutputType(DeviceAttributePatchOutput{})
	pulumi.RegisterOutputType(DeviceCapacityOutput{})
	pulumi.RegisterOutputType(DeviceCapacityMapOutput{})
	pulumi.RegisterOutputType(DeviceCapacityPatchOutput{})
	pulumi.RegisterOutputType(DeviceClaimOutput{})
	pulumi.RegisterOutputType(DeviceClaimPtrOutput{})
	pulumi.RegisterOutputType(DeviceClaimConfigurationOutput{})
	pulumi.RegisterOutputType(DeviceClaimConfigurationArrayOutput{})
	pulumi.RegisterOutputType(DeviceClaimConfigurationPatchOutput{})
	pulumi.RegisterOutputType(DeviceClaimConfigurationPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceClaimPatchOutput{})
	pulumi.RegisterOutputType(DeviceClaimPatchPtrOutput{})
	pulumi.RegisterOutputType(DeviceClassTypeOutput{})
	pulumi.RegisterOutputType(DeviceClassTypeArrayOutput{})
	pulumi.RegisterOutputType(DeviceClassConfigurationOutput{})
	pulumi.RegisterOutputType(DeviceClassConfigurationArrayOutput{})
	pulumi.RegisterOutputType(DeviceClassConfigurationPatchOutput{})
	pulumi.RegisterOutputType(DeviceClassConfigurationPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceClassListTypeOutput{})
	pulumi.RegisterOutputType(DeviceClassPatchTypeOutput{})
	pulumi.RegisterOutputType(DeviceClassSpecOutput{})
	pulumi.RegisterOutputType(DeviceClassSpecPatchOutput{})
	pulumi.RegisterOutputType(DeviceClassSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(DeviceConstraintOutput{})
	pulumi.RegisterOutputType(DeviceConstraintArrayOutput{})
	pulumi.RegisterOutputType(DeviceConstraintPatchOutput{})
	pulumi.RegisterOutputType(DeviceConstraintPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceCounterConsumptionOutput{})
	pulumi.RegisterOutputType(DeviceCounterConsumptionArrayOutput{})
	pulumi.RegisterOutputType(DeviceCounterConsumptionPatchOutput{})
	pulumi.RegisterOutputType(DeviceCounterConsumptionPatchArrayOutput{})
	pulumi.RegisterOutputType(DevicePatchOutput{})
	pulumi.RegisterOutputType(DevicePatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceRequestOutput{})
	pulumi.RegisterOutputType(DeviceRequestArrayOutput{})
	pulumi.RegisterOutputType(DeviceRequestAllocationResultOutput{})
	pulumi.RegisterOutputType(DeviceRequestAllocationResultArrayOutput{})
	pulumi.RegisterOutputType(DeviceRequestAllocationResultPatchOutput{})
	pulumi.RegisterOutputType(DeviceRequestAllocationResultPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceRequestPatchOutput{})
	pulumi.RegisterOutputType(DeviceRequestPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceSelectorOutput{})
	pulumi.RegisterOutputType(DeviceSelectorArrayOutput{})
	pulumi.RegisterOutputType(DeviceSelectorPatchOutput{})
	pulumi.RegisterOutputType(DeviceSelectorPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceSubRequestOutput{})
	pulumi.RegisterOutputType(DeviceSubRequestArrayOutput{})
	pulumi.RegisterOutputType(DeviceSubRequestPatchOutput{})
	pulumi.RegisterOutputType(DeviceSubRequestPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceTaintOutput{})
	pulumi.RegisterOutputType(DeviceTaintArrayOutput{})
	pulumi.RegisterOutputType(DeviceTaintPatchOutput{})
	pulumi.RegisterOutputType(DeviceTaintPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceTolerationOutput{})
	pulumi.RegisterOutputType(DeviceTolerationArrayOutput{})
	pulumi.RegisterOutputType(DeviceTolerationPatchOutput{})
	pulumi.RegisterOutputType(DeviceTolerationPatchArrayOutput{})
	pulumi.RegisterOutputType(NetworkDeviceDataOutput{})
	pulumi.RegisterOutputType(NetworkDeviceDataPtrOutput{})
	pulumi.RegisterOutputType(NetworkDeviceDataPatchOutput{})
	pulumi.RegisterOutputType(NetworkDeviceDataPatchPtrOutput{})
	pulumi.RegisterOutputType(OpaqueDeviceConfigurationOutput{})
	pulumi.RegisterOutputType(OpaqueDeviceConfigurationPtrOutput{})
	pulumi.RegisterOutputType(OpaqueDeviceConfigurationPatchOutput{})
	pulumi.RegisterOutputType(OpaqueDeviceConfigurationPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourceClaimTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimTypeArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimConsumerReferenceOutput{})
	pulumi.RegisterOutputType(ResourceClaimConsumerReferenceArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimConsumerReferencePatchOutput{})
	pulumi.RegisterOutputType(ResourceClaimConsumerReferencePatchArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimListTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimPatchTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimSpecOutput{})
	pulumi.RegisterOutputType(ResourceClaimSpecPatchOutput{})
	pulumi.RegisterOutputType(ResourceClaimSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourceClaimStatusOutput{})
	pulumi.RegisterOutputType(ResourceClaimStatusPtrOutput{})
	pulumi.RegisterOutputType(ResourceClaimStatusPatchOutput{})
	pulumi.RegisterOutputType(ResourceClaimStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateTypeArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateListTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplatePatchTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateSpecOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateSpecPatchOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourcePoolOutput{})
	pulumi.RegisterOutputType(ResourcePoolPatchOutput{})
	pulumi.RegisterOutputType(ResourcePoolPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourceSliceTypeOutput{})
	pulumi.RegisterOutputType(ResourceSliceTypeArrayOutput{})
	pulumi.RegisterOutputType(ResourceSliceListTypeOutput{})
	pulumi.RegisterOutputType(ResourceSlicePatchTypeOutput{})
	pulumi.RegisterOutputType(ResourceSliceSpecOutput{})
	pulumi.RegisterOutputType(ResourceSliceSpecPatchOutput{})
	pulumi.RegisterOutputType(ResourceSliceSpecPatchPtrOutput{})
}
