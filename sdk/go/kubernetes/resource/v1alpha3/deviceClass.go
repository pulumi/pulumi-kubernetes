// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha3

import (
	"context"
	"reflect"

	"errors"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClass struct {
	pulumi.CustomResourceState

	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringOutput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringOutput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaOutput `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceClassSpecOutput `pulumi:"spec"`
}

// NewDeviceClass registers a new resource with the given unique name, arguments, and options.
func NewDeviceClass(ctx *pulumi.Context,
	name string, args *DeviceClassArgs, opts ...pulumi.ResourceOption) (*DeviceClass, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Spec == nil {
		return nil, errors.New("invalid value for required argument 'Spec'")
	}
	args.ApiVersion = pulumi.StringPtr("resource.k8s.io/v1alpha3")
	args.Kind = pulumi.StringPtr("DeviceClass")
	opts = utilities.PkgResourceDefaultOpts(opts)
	var resource DeviceClass
	err := ctx.RegisterResource("kubernetes:resource.k8s.io/v1alpha3:DeviceClass", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDeviceClass gets an existing DeviceClass resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDeviceClass(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DeviceClassState, opts ...pulumi.ResourceOption) (*DeviceClass, error) {
	var resource DeviceClass
	err := ctx.ReadResource("kubernetes:resource.k8s.io/v1alpha3:DeviceClass", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DeviceClass resources.
type deviceClassState struct {
}

type DeviceClassState struct {
}

func (DeviceClassState) ElementType() reflect.Type {
	return reflect.TypeOf((*deviceClassState)(nil)).Elem()
}

type deviceClassArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceClassSpec `pulumi:"spec"`
}

// The set of arguments for constructing a DeviceClass resource.
type DeviceClassArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceClassSpecInput
}

func (DeviceClassArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*deviceClassArgs)(nil)).Elem()
}

type DeviceClassInput interface {
	pulumi.Input

	ToDeviceClassOutput() DeviceClassOutput
	ToDeviceClassOutputWithContext(ctx context.Context) DeviceClassOutput
}

func (*DeviceClass) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClass)(nil)).Elem()
}

func (i *DeviceClass) ToDeviceClassOutput() DeviceClassOutput {
	return i.ToDeviceClassOutputWithContext(context.Background())
}

func (i *DeviceClass) ToDeviceClassOutputWithContext(ctx context.Context) DeviceClassOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassOutput)
}

// DeviceClassArrayInput is an input type that accepts DeviceClassArray and DeviceClassArrayOutput values.
// You can construct a concrete instance of `DeviceClassArrayInput` via:
//
//	DeviceClassArray{ DeviceClassArgs{...} }
type DeviceClassArrayInput interface {
	pulumi.Input

	ToDeviceClassArrayOutput() DeviceClassArrayOutput
	ToDeviceClassArrayOutputWithContext(context.Context) DeviceClassArrayOutput
}

type DeviceClassArray []DeviceClassInput

func (DeviceClassArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DeviceClass)(nil)).Elem()
}

func (i DeviceClassArray) ToDeviceClassArrayOutput() DeviceClassArrayOutput {
	return i.ToDeviceClassArrayOutputWithContext(context.Background())
}

func (i DeviceClassArray) ToDeviceClassArrayOutputWithContext(ctx context.Context) DeviceClassArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassArrayOutput)
}

// DeviceClassMapInput is an input type that accepts DeviceClassMap and DeviceClassMapOutput values.
// You can construct a concrete instance of `DeviceClassMapInput` via:
//
//	DeviceClassMap{ "key": DeviceClassArgs{...} }
type DeviceClassMapInput interface {
	pulumi.Input

	ToDeviceClassMapOutput() DeviceClassMapOutput
	ToDeviceClassMapOutputWithContext(context.Context) DeviceClassMapOutput
}

type DeviceClassMap map[string]DeviceClassInput

func (DeviceClassMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DeviceClass)(nil)).Elem()
}

func (i DeviceClassMap) ToDeviceClassMapOutput() DeviceClassMapOutput {
	return i.ToDeviceClassMapOutputWithContext(context.Background())
}

func (i DeviceClassMap) ToDeviceClassMapOutputWithContext(ctx context.Context) DeviceClassMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassMapOutput)
}

type DeviceClassOutput struct{ *pulumi.OutputState }

func (DeviceClassOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClass)(nil)).Elem()
}

func (o DeviceClassOutput) ToDeviceClassOutput() DeviceClassOutput {
	return o
}

func (o DeviceClassOutput) ToDeviceClassOutputWithContext(ctx context.Context) DeviceClassOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceClassOutput) ApiVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *DeviceClass) pulumi.StringOutput { return v.ApiVersion }).(pulumi.StringOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceClassOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v *DeviceClass) pulumi.StringOutput { return v.Kind }).(pulumi.StringOutput)
}

// Standard object metadata
func (o DeviceClassOutput) Metadata() metav1.ObjectMetaOutput {
	return o.ApplyT(func(v *DeviceClass) metav1.ObjectMetaOutput { return v.Metadata }).(metav1.ObjectMetaOutput)
}

// Spec defines what can be allocated and how to configure it.
//
// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
//
// Changing the spec automatically increments the metadata.generation number.
func (o DeviceClassOutput) Spec() DeviceClassSpecOutput {
	return o.ApplyT(func(v *DeviceClass) DeviceClassSpecOutput { return v.Spec }).(DeviceClassSpecOutput)
}

type DeviceClassArrayOutput struct{ *pulumi.OutputState }

func (DeviceClassArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DeviceClass)(nil)).Elem()
}

func (o DeviceClassArrayOutput) ToDeviceClassArrayOutput() DeviceClassArrayOutput {
	return o
}

func (o DeviceClassArrayOutput) ToDeviceClassArrayOutputWithContext(ctx context.Context) DeviceClassArrayOutput {
	return o
}

func (o DeviceClassArrayOutput) Index(i pulumi.IntInput) DeviceClassOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DeviceClass {
		return vs[0].([]*DeviceClass)[vs[1].(int)]
	}).(DeviceClassOutput)
}

type DeviceClassMapOutput struct{ *pulumi.OutputState }

func (DeviceClassMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DeviceClass)(nil)).Elem()
}

func (o DeviceClassMapOutput) ToDeviceClassMapOutput() DeviceClassMapOutput {
	return o
}

func (o DeviceClassMapOutput) ToDeviceClassMapOutputWithContext(ctx context.Context) DeviceClassMapOutput {
	return o
}

func (o DeviceClassMapOutput) MapIndex(k pulumi.StringInput) DeviceClassOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DeviceClass {
		return vs[0].(map[string]*DeviceClass)[vs[1].(string)]
	}).(DeviceClassOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassInput)(nil)).Elem(), &DeviceClass{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassArrayInput)(nil)).Elem(), DeviceClassArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassMapInput)(nil)).Elem(), DeviceClassMap{})
	pulumi.RegisterOutputType(DeviceClassOutput{})
	pulumi.RegisterOutputType(DeviceClassArrayOutput{})
	pulumi.RegisterOutputType(DeviceClassMapOutput{})
}
