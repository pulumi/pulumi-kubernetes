// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha3

import (
	"context"
	"reflect"

	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/core/v1"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// AllocationResult contains attributes of an allocated resource.
type AllocationResult struct {
	// Controller is the name of the DRA driver which handled the allocation. That driver is also responsible for deallocating the claim. It is empty when the claim can be deallocated without involving a driver.
	//
	// A driver may allocate devices provided by other drivers, so this driver name here can be different from the driver names listed for the results.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	Controller *string `pulumi:"controller"`
	// Devices is the result of allocating devices.
	Devices *DeviceAllocationResult `pulumi:"devices"`
	// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
	NodeSelector *corev1.NodeSelector `pulumi:"nodeSelector"`
}

// AllocationResultInput is an input type that accepts AllocationResultArgs and AllocationResultOutput values.
// You can construct a concrete instance of `AllocationResultInput` via:
//
//	AllocationResultArgs{...}
type AllocationResultInput interface {
	pulumi.Input

	ToAllocationResultOutput() AllocationResultOutput
	ToAllocationResultOutputWithContext(context.Context) AllocationResultOutput
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultArgs struct {
	// Controller is the name of the DRA driver which handled the allocation. That driver is also responsible for deallocating the claim. It is empty when the claim can be deallocated without involving a driver.
	//
	// A driver may allocate devices provided by other drivers, so this driver name here can be different from the driver names listed for the results.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	Controller pulumi.StringPtrInput `pulumi:"controller"`
	// Devices is the result of allocating devices.
	Devices DeviceAllocationResultPtrInput `pulumi:"devices"`
	// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
	NodeSelector corev1.NodeSelectorPtrInput `pulumi:"nodeSelector"`
}

func (AllocationResultArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationResult)(nil)).Elem()
}

func (i AllocationResultArgs) ToAllocationResultOutput() AllocationResultOutput {
	return i.ToAllocationResultOutputWithContext(context.Background())
}

func (i AllocationResultArgs) ToAllocationResultOutputWithContext(ctx context.Context) AllocationResultOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultOutput)
}

func (i AllocationResultArgs) ToAllocationResultPtrOutput() AllocationResultPtrOutput {
	return i.ToAllocationResultPtrOutputWithContext(context.Background())
}

func (i AllocationResultArgs) ToAllocationResultPtrOutputWithContext(ctx context.Context) AllocationResultPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultOutput).ToAllocationResultPtrOutputWithContext(ctx)
}

// AllocationResultPtrInput is an input type that accepts AllocationResultArgs, AllocationResultPtr and AllocationResultPtrOutput values.
// You can construct a concrete instance of `AllocationResultPtrInput` via:
//
//	        AllocationResultArgs{...}
//
//	or:
//
//	        nil
type AllocationResultPtrInput interface {
	pulumi.Input

	ToAllocationResultPtrOutput() AllocationResultPtrOutput
	ToAllocationResultPtrOutputWithContext(context.Context) AllocationResultPtrOutput
}

type allocationResultPtrType AllocationResultArgs

func AllocationResultPtr(v *AllocationResultArgs) AllocationResultPtrInput {
	return (*allocationResultPtrType)(v)
}

func (*allocationResultPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationResult)(nil)).Elem()
}

func (i *allocationResultPtrType) ToAllocationResultPtrOutput() AllocationResultPtrOutput {
	return i.ToAllocationResultPtrOutputWithContext(context.Background())
}

func (i *allocationResultPtrType) ToAllocationResultPtrOutputWithContext(ctx context.Context) AllocationResultPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultPtrOutput)
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultOutput struct{ *pulumi.OutputState }

func (AllocationResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationResult)(nil)).Elem()
}

func (o AllocationResultOutput) ToAllocationResultOutput() AllocationResultOutput {
	return o
}

func (o AllocationResultOutput) ToAllocationResultOutputWithContext(ctx context.Context) AllocationResultOutput {
	return o
}

func (o AllocationResultOutput) ToAllocationResultPtrOutput() AllocationResultPtrOutput {
	return o.ToAllocationResultPtrOutputWithContext(context.Background())
}

func (o AllocationResultOutput) ToAllocationResultPtrOutputWithContext(ctx context.Context) AllocationResultPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AllocationResult) *AllocationResult {
		return &v
	}).(AllocationResultPtrOutput)
}

// Controller is the name of the DRA driver which handled the allocation. That driver is also responsible for deallocating the claim. It is empty when the claim can be deallocated without involving a driver.
//
// A driver may allocate devices provided by other drivers, so this driver name here can be different from the driver names listed for the results.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o AllocationResultOutput) Controller() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AllocationResult) *string { return v.Controller }).(pulumi.StringPtrOutput)
}

// Devices is the result of allocating devices.
func (o AllocationResultOutput) Devices() DeviceAllocationResultPtrOutput {
	return o.ApplyT(func(v AllocationResult) *DeviceAllocationResult { return v.Devices }).(DeviceAllocationResultPtrOutput)
}

// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
func (o AllocationResultOutput) NodeSelector() corev1.NodeSelectorPtrOutput {
	return o.ApplyT(func(v AllocationResult) *corev1.NodeSelector { return v.NodeSelector }).(corev1.NodeSelectorPtrOutput)
}

type AllocationResultPtrOutput struct{ *pulumi.OutputState }

func (AllocationResultPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationResult)(nil)).Elem()
}

func (o AllocationResultPtrOutput) ToAllocationResultPtrOutput() AllocationResultPtrOutput {
	return o
}

func (o AllocationResultPtrOutput) ToAllocationResultPtrOutputWithContext(ctx context.Context) AllocationResultPtrOutput {
	return o
}

func (o AllocationResultPtrOutput) Elem() AllocationResultOutput {
	return o.ApplyT(func(v *AllocationResult) AllocationResult {
		if v != nil {
			return *v
		}
		var ret AllocationResult
		return ret
	}).(AllocationResultOutput)
}

// Controller is the name of the DRA driver which handled the allocation. That driver is also responsible for deallocating the claim. It is empty when the claim can be deallocated without involving a driver.
//
// A driver may allocate devices provided by other drivers, so this driver name here can be different from the driver names listed for the results.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o AllocationResultPtrOutput) Controller() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AllocationResult) *string {
		if v == nil {
			return nil
		}
		return v.Controller
	}).(pulumi.StringPtrOutput)
}

// Devices is the result of allocating devices.
func (o AllocationResultPtrOutput) Devices() DeviceAllocationResultPtrOutput {
	return o.ApplyT(func(v *AllocationResult) *DeviceAllocationResult {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(DeviceAllocationResultPtrOutput)
}

// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
func (o AllocationResultPtrOutput) NodeSelector() corev1.NodeSelectorPtrOutput {
	return o.ApplyT(func(v *AllocationResult) *corev1.NodeSelector {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(corev1.NodeSelectorPtrOutput)
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultPatch struct {
	// Controller is the name of the DRA driver which handled the allocation. That driver is also responsible for deallocating the claim. It is empty when the claim can be deallocated without involving a driver.
	//
	// A driver may allocate devices provided by other drivers, so this driver name here can be different from the driver names listed for the results.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	Controller *string `pulumi:"controller"`
	// Devices is the result of allocating devices.
	Devices *DeviceAllocationResultPatch `pulumi:"devices"`
	// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
	NodeSelector *corev1.NodeSelectorPatch `pulumi:"nodeSelector"`
}

// AllocationResultPatchInput is an input type that accepts AllocationResultPatchArgs and AllocationResultPatchOutput values.
// You can construct a concrete instance of `AllocationResultPatchInput` via:
//
//	AllocationResultPatchArgs{...}
type AllocationResultPatchInput interface {
	pulumi.Input

	ToAllocationResultPatchOutput() AllocationResultPatchOutput
	ToAllocationResultPatchOutputWithContext(context.Context) AllocationResultPatchOutput
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultPatchArgs struct {
	// Controller is the name of the DRA driver which handled the allocation. That driver is also responsible for deallocating the claim. It is empty when the claim can be deallocated without involving a driver.
	//
	// A driver may allocate devices provided by other drivers, so this driver name here can be different from the driver names listed for the results.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	Controller pulumi.StringPtrInput `pulumi:"controller"`
	// Devices is the result of allocating devices.
	Devices DeviceAllocationResultPatchPtrInput `pulumi:"devices"`
	// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
	NodeSelector corev1.NodeSelectorPatchPtrInput `pulumi:"nodeSelector"`
}

func (AllocationResultPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationResultPatch)(nil)).Elem()
}

func (i AllocationResultPatchArgs) ToAllocationResultPatchOutput() AllocationResultPatchOutput {
	return i.ToAllocationResultPatchOutputWithContext(context.Background())
}

func (i AllocationResultPatchArgs) ToAllocationResultPatchOutputWithContext(ctx context.Context) AllocationResultPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultPatchOutput)
}

func (i AllocationResultPatchArgs) ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput {
	return i.ToAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (i AllocationResultPatchArgs) ToAllocationResultPatchPtrOutputWithContext(ctx context.Context) AllocationResultPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultPatchOutput).ToAllocationResultPatchPtrOutputWithContext(ctx)
}

// AllocationResultPatchPtrInput is an input type that accepts AllocationResultPatchArgs, AllocationResultPatchPtr and AllocationResultPatchPtrOutput values.
// You can construct a concrete instance of `AllocationResultPatchPtrInput` via:
//
//	        AllocationResultPatchArgs{...}
//
//	or:
//
//	        nil
type AllocationResultPatchPtrInput interface {
	pulumi.Input

	ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput
	ToAllocationResultPatchPtrOutputWithContext(context.Context) AllocationResultPatchPtrOutput
}

type allocationResultPatchPtrType AllocationResultPatchArgs

func AllocationResultPatchPtr(v *AllocationResultPatchArgs) AllocationResultPatchPtrInput {
	return (*allocationResultPatchPtrType)(v)
}

func (*allocationResultPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationResultPatch)(nil)).Elem()
}

func (i *allocationResultPatchPtrType) ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput {
	return i.ToAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (i *allocationResultPatchPtrType) ToAllocationResultPatchPtrOutputWithContext(ctx context.Context) AllocationResultPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationResultPatchPtrOutput)
}

// AllocationResult contains attributes of an allocated resource.
type AllocationResultPatchOutput struct{ *pulumi.OutputState }

func (AllocationResultPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationResultPatch)(nil)).Elem()
}

func (o AllocationResultPatchOutput) ToAllocationResultPatchOutput() AllocationResultPatchOutput {
	return o
}

func (o AllocationResultPatchOutput) ToAllocationResultPatchOutputWithContext(ctx context.Context) AllocationResultPatchOutput {
	return o
}

func (o AllocationResultPatchOutput) ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput {
	return o.ToAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (o AllocationResultPatchOutput) ToAllocationResultPatchPtrOutputWithContext(ctx context.Context) AllocationResultPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AllocationResultPatch) *AllocationResultPatch {
		return &v
	}).(AllocationResultPatchPtrOutput)
}

// Controller is the name of the DRA driver which handled the allocation. That driver is also responsible for deallocating the claim. It is empty when the claim can be deallocated without involving a driver.
//
// A driver may allocate devices provided by other drivers, so this driver name here can be different from the driver names listed for the results.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o AllocationResultPatchOutput) Controller() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AllocationResultPatch) *string { return v.Controller }).(pulumi.StringPtrOutput)
}

// Devices is the result of allocating devices.
func (o AllocationResultPatchOutput) Devices() DeviceAllocationResultPatchPtrOutput {
	return o.ApplyT(func(v AllocationResultPatch) *DeviceAllocationResultPatch { return v.Devices }).(DeviceAllocationResultPatchPtrOutput)
}

// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
func (o AllocationResultPatchOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v AllocationResultPatch) *corev1.NodeSelectorPatch { return v.NodeSelector }).(corev1.NodeSelectorPatchPtrOutput)
}

type AllocationResultPatchPtrOutput struct{ *pulumi.OutputState }

func (AllocationResultPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationResultPatch)(nil)).Elem()
}

func (o AllocationResultPatchPtrOutput) ToAllocationResultPatchPtrOutput() AllocationResultPatchPtrOutput {
	return o
}

func (o AllocationResultPatchPtrOutput) ToAllocationResultPatchPtrOutputWithContext(ctx context.Context) AllocationResultPatchPtrOutput {
	return o
}

func (o AllocationResultPatchPtrOutput) Elem() AllocationResultPatchOutput {
	return o.ApplyT(func(v *AllocationResultPatch) AllocationResultPatch {
		if v != nil {
			return *v
		}
		var ret AllocationResultPatch
		return ret
	}).(AllocationResultPatchOutput)
}

// Controller is the name of the DRA driver which handled the allocation. That driver is also responsible for deallocating the claim. It is empty when the claim can be deallocated without involving a driver.
//
// A driver may allocate devices provided by other drivers, so this driver name here can be different from the driver names listed for the results.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o AllocationResultPatchPtrOutput) Controller() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AllocationResultPatch) *string {
		if v == nil {
			return nil
		}
		return v.Controller
	}).(pulumi.StringPtrOutput)
}

// Devices is the result of allocating devices.
func (o AllocationResultPatchPtrOutput) Devices() DeviceAllocationResultPatchPtrOutput {
	return o.ApplyT(func(v *AllocationResultPatch) *DeviceAllocationResultPatch {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(DeviceAllocationResultPatchPtrOutput)
}

// NodeSelector defines where the allocated resources are available. If unset, they are available everywhere.
func (o AllocationResultPatchPtrOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v *AllocationResultPatch) *corev1.NodeSelectorPatch {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(corev1.NodeSelectorPatchPtrOutput)
}

// BasicDevice defines one device instance.
type BasicDevice struct {
	// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Attributes map[string]DeviceAttribute `pulumi:"attributes"`
	// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Capacity map[string]string `pulumi:"capacity"`
}

// BasicDeviceInput is an input type that accepts BasicDeviceArgs and BasicDeviceOutput values.
// You can construct a concrete instance of `BasicDeviceInput` via:
//
//	BasicDeviceArgs{...}
type BasicDeviceInput interface {
	pulumi.Input

	ToBasicDeviceOutput() BasicDeviceOutput
	ToBasicDeviceOutputWithContext(context.Context) BasicDeviceOutput
}

// BasicDevice defines one device instance.
type BasicDeviceArgs struct {
	// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Attributes DeviceAttributeMapInput `pulumi:"attributes"`
	// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Capacity pulumi.StringMapInput `pulumi:"capacity"`
}

func (BasicDeviceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicDevice)(nil)).Elem()
}

func (i BasicDeviceArgs) ToBasicDeviceOutput() BasicDeviceOutput {
	return i.ToBasicDeviceOutputWithContext(context.Background())
}

func (i BasicDeviceArgs) ToBasicDeviceOutputWithContext(ctx context.Context) BasicDeviceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDeviceOutput)
}

func (i BasicDeviceArgs) ToBasicDevicePtrOutput() BasicDevicePtrOutput {
	return i.ToBasicDevicePtrOutputWithContext(context.Background())
}

func (i BasicDeviceArgs) ToBasicDevicePtrOutputWithContext(ctx context.Context) BasicDevicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDeviceOutput).ToBasicDevicePtrOutputWithContext(ctx)
}

// BasicDevicePtrInput is an input type that accepts BasicDeviceArgs, BasicDevicePtr and BasicDevicePtrOutput values.
// You can construct a concrete instance of `BasicDevicePtrInput` via:
//
//	        BasicDeviceArgs{...}
//
//	or:
//
//	        nil
type BasicDevicePtrInput interface {
	pulumi.Input

	ToBasicDevicePtrOutput() BasicDevicePtrOutput
	ToBasicDevicePtrOutputWithContext(context.Context) BasicDevicePtrOutput
}

type basicDevicePtrType BasicDeviceArgs

func BasicDevicePtr(v *BasicDeviceArgs) BasicDevicePtrInput {
	return (*basicDevicePtrType)(v)
}

func (*basicDevicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicDevice)(nil)).Elem()
}

func (i *basicDevicePtrType) ToBasicDevicePtrOutput() BasicDevicePtrOutput {
	return i.ToBasicDevicePtrOutputWithContext(context.Background())
}

func (i *basicDevicePtrType) ToBasicDevicePtrOutputWithContext(ctx context.Context) BasicDevicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDevicePtrOutput)
}

// BasicDevice defines one device instance.
type BasicDeviceOutput struct{ *pulumi.OutputState }

func (BasicDeviceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicDevice)(nil)).Elem()
}

func (o BasicDeviceOutput) ToBasicDeviceOutput() BasicDeviceOutput {
	return o
}

func (o BasicDeviceOutput) ToBasicDeviceOutputWithContext(ctx context.Context) BasicDeviceOutput {
	return o
}

func (o BasicDeviceOutput) ToBasicDevicePtrOutput() BasicDevicePtrOutput {
	return o.ToBasicDevicePtrOutputWithContext(context.Background())
}

func (o BasicDeviceOutput) ToBasicDevicePtrOutputWithContext(ctx context.Context) BasicDevicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicDevice) *BasicDevice {
		return &v
	}).(BasicDevicePtrOutput)
}

// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDeviceOutput) Attributes() DeviceAttributeMapOutput {
	return o.ApplyT(func(v BasicDevice) map[string]DeviceAttribute { return v.Attributes }).(DeviceAttributeMapOutput)
}

// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDeviceOutput) Capacity() pulumi.StringMapOutput {
	return o.ApplyT(func(v BasicDevice) map[string]string { return v.Capacity }).(pulumi.StringMapOutput)
}

type BasicDevicePtrOutput struct{ *pulumi.OutputState }

func (BasicDevicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicDevice)(nil)).Elem()
}

func (o BasicDevicePtrOutput) ToBasicDevicePtrOutput() BasicDevicePtrOutput {
	return o
}

func (o BasicDevicePtrOutput) ToBasicDevicePtrOutputWithContext(ctx context.Context) BasicDevicePtrOutput {
	return o
}

func (o BasicDevicePtrOutput) Elem() BasicDeviceOutput {
	return o.ApplyT(func(v *BasicDevice) BasicDevice {
		if v != nil {
			return *v
		}
		var ret BasicDevice
		return ret
	}).(BasicDeviceOutput)
}

// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePtrOutput) Attributes() DeviceAttributeMapOutput {
	return o.ApplyT(func(v *BasicDevice) map[string]DeviceAttribute {
		if v == nil {
			return nil
		}
		return v.Attributes
	}).(DeviceAttributeMapOutput)
}

// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePtrOutput) Capacity() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BasicDevice) map[string]string {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(pulumi.StringMapOutput)
}

// BasicDevice defines one device instance.
type BasicDevicePatch struct {
	// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Attributes map[string]DeviceAttribute `pulumi:"attributes"`
	// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Capacity map[string]string `pulumi:"capacity"`
}

// BasicDevicePatchInput is an input type that accepts BasicDevicePatchArgs and BasicDevicePatchOutput values.
// You can construct a concrete instance of `BasicDevicePatchInput` via:
//
//	BasicDevicePatchArgs{...}
type BasicDevicePatchInput interface {
	pulumi.Input

	ToBasicDevicePatchOutput() BasicDevicePatchOutput
	ToBasicDevicePatchOutputWithContext(context.Context) BasicDevicePatchOutput
}

// BasicDevice defines one device instance.
type BasicDevicePatchArgs struct {
	// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Attributes DeviceAttributeMapInput `pulumi:"attributes"`
	// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
	//
	// The maximum number of attributes and capacities combined is 32.
	Capacity pulumi.StringMapInput `pulumi:"capacity"`
}

func (BasicDevicePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicDevicePatch)(nil)).Elem()
}

func (i BasicDevicePatchArgs) ToBasicDevicePatchOutput() BasicDevicePatchOutput {
	return i.ToBasicDevicePatchOutputWithContext(context.Background())
}

func (i BasicDevicePatchArgs) ToBasicDevicePatchOutputWithContext(ctx context.Context) BasicDevicePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDevicePatchOutput)
}

func (i BasicDevicePatchArgs) ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput {
	return i.ToBasicDevicePatchPtrOutputWithContext(context.Background())
}

func (i BasicDevicePatchArgs) ToBasicDevicePatchPtrOutputWithContext(ctx context.Context) BasicDevicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDevicePatchOutput).ToBasicDevicePatchPtrOutputWithContext(ctx)
}

// BasicDevicePatchPtrInput is an input type that accepts BasicDevicePatchArgs, BasicDevicePatchPtr and BasicDevicePatchPtrOutput values.
// You can construct a concrete instance of `BasicDevicePatchPtrInput` via:
//
//	        BasicDevicePatchArgs{...}
//
//	or:
//
//	        nil
type BasicDevicePatchPtrInput interface {
	pulumi.Input

	ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput
	ToBasicDevicePatchPtrOutputWithContext(context.Context) BasicDevicePatchPtrOutput
}

type basicDevicePatchPtrType BasicDevicePatchArgs

func BasicDevicePatchPtr(v *BasicDevicePatchArgs) BasicDevicePatchPtrInput {
	return (*basicDevicePatchPtrType)(v)
}

func (*basicDevicePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicDevicePatch)(nil)).Elem()
}

func (i *basicDevicePatchPtrType) ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput {
	return i.ToBasicDevicePatchPtrOutputWithContext(context.Background())
}

func (i *basicDevicePatchPtrType) ToBasicDevicePatchPtrOutputWithContext(ctx context.Context) BasicDevicePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicDevicePatchPtrOutput)
}

// BasicDevice defines one device instance.
type BasicDevicePatchOutput struct{ *pulumi.OutputState }

func (BasicDevicePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicDevicePatch)(nil)).Elem()
}

func (o BasicDevicePatchOutput) ToBasicDevicePatchOutput() BasicDevicePatchOutput {
	return o
}

func (o BasicDevicePatchOutput) ToBasicDevicePatchOutputWithContext(ctx context.Context) BasicDevicePatchOutput {
	return o
}

func (o BasicDevicePatchOutput) ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput {
	return o.ToBasicDevicePatchPtrOutputWithContext(context.Background())
}

func (o BasicDevicePatchOutput) ToBasicDevicePatchPtrOutputWithContext(ctx context.Context) BasicDevicePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicDevicePatch) *BasicDevicePatch {
		return &v
	}).(BasicDevicePatchPtrOutput)
}

// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePatchOutput) Attributes() DeviceAttributeMapOutput {
	return o.ApplyT(func(v BasicDevicePatch) map[string]DeviceAttribute { return v.Attributes }).(DeviceAttributeMapOutput)
}

// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePatchOutput) Capacity() pulumi.StringMapOutput {
	return o.ApplyT(func(v BasicDevicePatch) map[string]string { return v.Capacity }).(pulumi.StringMapOutput)
}

type BasicDevicePatchPtrOutput struct{ *pulumi.OutputState }

func (BasicDevicePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicDevicePatch)(nil)).Elem()
}

func (o BasicDevicePatchPtrOutput) ToBasicDevicePatchPtrOutput() BasicDevicePatchPtrOutput {
	return o
}

func (o BasicDevicePatchPtrOutput) ToBasicDevicePatchPtrOutputWithContext(ctx context.Context) BasicDevicePatchPtrOutput {
	return o
}

func (o BasicDevicePatchPtrOutput) Elem() BasicDevicePatchOutput {
	return o.ApplyT(func(v *BasicDevicePatch) BasicDevicePatch {
		if v != nil {
			return *v
		}
		var ret BasicDevicePatch
		return ret
	}).(BasicDevicePatchOutput)
}

// Attributes defines the set of attributes for this device. The name of each attribute must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePatchPtrOutput) Attributes() DeviceAttributeMapOutput {
	return o.ApplyT(func(v *BasicDevicePatch) map[string]DeviceAttribute {
		if v == nil {
			return nil
		}
		return v.Attributes
	}).(DeviceAttributeMapOutput)
}

// Capacity defines the set of capacities for this device. The name of each capacity must be unique in that set.
//
// The maximum number of attributes and capacities combined is 32.
func (o BasicDevicePatchPtrOutput) Capacity() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BasicDevicePatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(pulumi.StringMapOutput)
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelector struct {
	// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
	//
	// The expression's input is an object named "device", which carries the following properties:
	//  - driver (string): the name of the driver which defines this device.
	//  - attributes (map[string]object): the device's attributes, grouped by prefix
	//    (e.g. device.attributes["dra.example.com"] evaluates to an object with all
	//    of the attributes which were prefixed by "dra.example.com".
	//  - capacity (map[string]object): the device's capacities, grouped by prefix.
	//
	// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
	//
	//     device.driver
	//     device.attributes["dra.example.com"].model
	//     device.attributes["ext.example.com"].family
	//     device.capacity["dra.example.com"].modules
	//
	// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
	//
	// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
	//
	// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
	//
	// A robust expression should check for the existence of attributes before referencing them.
	//
	// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
	//
	//     cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
	//
	// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
	Expression string `pulumi:"expression"`
}

// CELDeviceSelectorInput is an input type that accepts CELDeviceSelectorArgs and CELDeviceSelectorOutput values.
// You can construct a concrete instance of `CELDeviceSelectorInput` via:
//
//	CELDeviceSelectorArgs{...}
type CELDeviceSelectorInput interface {
	pulumi.Input

	ToCELDeviceSelectorOutput() CELDeviceSelectorOutput
	ToCELDeviceSelectorOutputWithContext(context.Context) CELDeviceSelectorOutput
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorArgs struct {
	// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
	//
	// The expression's input is an object named "device", which carries the following properties:
	//  - driver (string): the name of the driver which defines this device.
	//  - attributes (map[string]object): the device's attributes, grouped by prefix
	//    (e.g. device.attributes["dra.example.com"] evaluates to an object with all
	//    of the attributes which were prefixed by "dra.example.com".
	//  - capacity (map[string]object): the device's capacities, grouped by prefix.
	//
	// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
	//
	//     device.driver
	//     device.attributes["dra.example.com"].model
	//     device.attributes["ext.example.com"].family
	//     device.capacity["dra.example.com"].modules
	//
	// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
	//
	// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
	//
	// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
	//
	// A robust expression should check for the existence of attributes before referencing them.
	//
	// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
	//
	//     cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
	//
	// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
	Expression pulumi.StringInput `pulumi:"expression"`
}

func (CELDeviceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CELDeviceSelector)(nil)).Elem()
}

func (i CELDeviceSelectorArgs) ToCELDeviceSelectorOutput() CELDeviceSelectorOutput {
	return i.ToCELDeviceSelectorOutputWithContext(context.Background())
}

func (i CELDeviceSelectorArgs) ToCELDeviceSelectorOutputWithContext(ctx context.Context) CELDeviceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorOutput)
}

func (i CELDeviceSelectorArgs) ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput {
	return i.ToCELDeviceSelectorPtrOutputWithContext(context.Background())
}

func (i CELDeviceSelectorArgs) ToCELDeviceSelectorPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorOutput).ToCELDeviceSelectorPtrOutputWithContext(ctx)
}

// CELDeviceSelectorPtrInput is an input type that accepts CELDeviceSelectorArgs, CELDeviceSelectorPtr and CELDeviceSelectorPtrOutput values.
// You can construct a concrete instance of `CELDeviceSelectorPtrInput` via:
//
//	        CELDeviceSelectorArgs{...}
//
//	or:
//
//	        nil
type CELDeviceSelectorPtrInput interface {
	pulumi.Input

	ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput
	ToCELDeviceSelectorPtrOutputWithContext(context.Context) CELDeviceSelectorPtrOutput
}

type celdeviceSelectorPtrType CELDeviceSelectorArgs

func CELDeviceSelectorPtr(v *CELDeviceSelectorArgs) CELDeviceSelectorPtrInput {
	return (*celdeviceSelectorPtrType)(v)
}

func (*celdeviceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CELDeviceSelector)(nil)).Elem()
}

func (i *celdeviceSelectorPtrType) ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput {
	return i.ToCELDeviceSelectorPtrOutputWithContext(context.Background())
}

func (i *celdeviceSelectorPtrType) ToCELDeviceSelectorPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorPtrOutput)
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorOutput struct{ *pulumi.OutputState }

func (CELDeviceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CELDeviceSelector)(nil)).Elem()
}

func (o CELDeviceSelectorOutput) ToCELDeviceSelectorOutput() CELDeviceSelectorOutput {
	return o
}

func (o CELDeviceSelectorOutput) ToCELDeviceSelectorOutputWithContext(ctx context.Context) CELDeviceSelectorOutput {
	return o
}

func (o CELDeviceSelectorOutput) ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput {
	return o.ToCELDeviceSelectorPtrOutputWithContext(context.Background())
}

func (o CELDeviceSelectorOutput) ToCELDeviceSelectorPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CELDeviceSelector) *CELDeviceSelector {
		return &v
	}).(CELDeviceSelectorPtrOutput)
}

// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
//
// The expression's input is an object named "device", which carries the following properties:
//   - driver (string): the name of the driver which defines this device.
//   - attributes (map[string]object): the device's attributes, grouped by prefix
//     (e.g. device.attributes["dra.example.com"] evaluates to an object with all
//     of the attributes which were prefixed by "dra.example.com".
//   - capacity (map[string]object): the device's capacities, grouped by prefix.
//
// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
//
//	device.driver
//	device.attributes["dra.example.com"].model
//	device.attributes["ext.example.com"].family
//	device.capacity["dra.example.com"].modules
//
// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
//
// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
//
// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
//
// A robust expression should check for the existence of attributes before referencing them.
//
// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
//
//	cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
//
// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
func (o CELDeviceSelectorOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v CELDeviceSelector) string { return v.Expression }).(pulumi.StringOutput)
}

type CELDeviceSelectorPtrOutput struct{ *pulumi.OutputState }

func (CELDeviceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CELDeviceSelector)(nil)).Elem()
}

func (o CELDeviceSelectorPtrOutput) ToCELDeviceSelectorPtrOutput() CELDeviceSelectorPtrOutput {
	return o
}

func (o CELDeviceSelectorPtrOutput) ToCELDeviceSelectorPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPtrOutput {
	return o
}

func (o CELDeviceSelectorPtrOutput) Elem() CELDeviceSelectorOutput {
	return o.ApplyT(func(v *CELDeviceSelector) CELDeviceSelector {
		if v != nil {
			return *v
		}
		var ret CELDeviceSelector
		return ret
	}).(CELDeviceSelectorOutput)
}

// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
//
// The expression's input is an object named "device", which carries the following properties:
//   - driver (string): the name of the driver which defines this device.
//   - attributes (map[string]object): the device's attributes, grouped by prefix
//     (e.g. device.attributes["dra.example.com"] evaluates to an object with all
//     of the attributes which were prefixed by "dra.example.com".
//   - capacity (map[string]object): the device's capacities, grouped by prefix.
//
// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
//
//	device.driver
//	device.attributes["dra.example.com"].model
//	device.attributes["ext.example.com"].family
//	device.capacity["dra.example.com"].modules
//
// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
//
// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
//
// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
//
// A robust expression should check for the existence of attributes before referencing them.
//
// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
//
//	cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
//
// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
func (o CELDeviceSelectorPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CELDeviceSelector) *string {
		if v == nil {
			return nil
		}
		return &v.Expression
	}).(pulumi.StringPtrOutput)
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorPatch struct {
	// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
	//
	// The expression's input is an object named "device", which carries the following properties:
	//  - driver (string): the name of the driver which defines this device.
	//  - attributes (map[string]object): the device's attributes, grouped by prefix
	//    (e.g. device.attributes["dra.example.com"] evaluates to an object with all
	//    of the attributes which were prefixed by "dra.example.com".
	//  - capacity (map[string]object): the device's capacities, grouped by prefix.
	//
	// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
	//
	//     device.driver
	//     device.attributes["dra.example.com"].model
	//     device.attributes["ext.example.com"].family
	//     device.capacity["dra.example.com"].modules
	//
	// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
	//
	// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
	//
	// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
	//
	// A robust expression should check for the existence of attributes before referencing them.
	//
	// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
	//
	//     cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
	//
	// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
	Expression *string `pulumi:"expression"`
}

// CELDeviceSelectorPatchInput is an input type that accepts CELDeviceSelectorPatchArgs and CELDeviceSelectorPatchOutput values.
// You can construct a concrete instance of `CELDeviceSelectorPatchInput` via:
//
//	CELDeviceSelectorPatchArgs{...}
type CELDeviceSelectorPatchInput interface {
	pulumi.Input

	ToCELDeviceSelectorPatchOutput() CELDeviceSelectorPatchOutput
	ToCELDeviceSelectorPatchOutputWithContext(context.Context) CELDeviceSelectorPatchOutput
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorPatchArgs struct {
	// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
	//
	// The expression's input is an object named "device", which carries the following properties:
	//  - driver (string): the name of the driver which defines this device.
	//  - attributes (map[string]object): the device's attributes, grouped by prefix
	//    (e.g. device.attributes["dra.example.com"] evaluates to an object with all
	//    of the attributes which were prefixed by "dra.example.com".
	//  - capacity (map[string]object): the device's capacities, grouped by prefix.
	//
	// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
	//
	//     device.driver
	//     device.attributes["dra.example.com"].model
	//     device.attributes["ext.example.com"].family
	//     device.capacity["dra.example.com"].modules
	//
	// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
	//
	// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
	//
	// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
	//
	// A robust expression should check for the existence of attributes before referencing them.
	//
	// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
	//
	//     cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
	//
	// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
}

func (CELDeviceSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CELDeviceSelectorPatch)(nil)).Elem()
}

func (i CELDeviceSelectorPatchArgs) ToCELDeviceSelectorPatchOutput() CELDeviceSelectorPatchOutput {
	return i.ToCELDeviceSelectorPatchOutputWithContext(context.Background())
}

func (i CELDeviceSelectorPatchArgs) ToCELDeviceSelectorPatchOutputWithContext(ctx context.Context) CELDeviceSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorPatchOutput)
}

func (i CELDeviceSelectorPatchArgs) ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput {
	return i.ToCELDeviceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i CELDeviceSelectorPatchArgs) ToCELDeviceSelectorPatchPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorPatchOutput).ToCELDeviceSelectorPatchPtrOutputWithContext(ctx)
}

// CELDeviceSelectorPatchPtrInput is an input type that accepts CELDeviceSelectorPatchArgs, CELDeviceSelectorPatchPtr and CELDeviceSelectorPatchPtrOutput values.
// You can construct a concrete instance of `CELDeviceSelectorPatchPtrInput` via:
//
//	        CELDeviceSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type CELDeviceSelectorPatchPtrInput interface {
	pulumi.Input

	ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput
	ToCELDeviceSelectorPatchPtrOutputWithContext(context.Context) CELDeviceSelectorPatchPtrOutput
}

type celdeviceSelectorPatchPtrType CELDeviceSelectorPatchArgs

func CELDeviceSelectorPatchPtr(v *CELDeviceSelectorPatchArgs) CELDeviceSelectorPatchPtrInput {
	return (*celdeviceSelectorPatchPtrType)(v)
}

func (*celdeviceSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CELDeviceSelectorPatch)(nil)).Elem()
}

func (i *celdeviceSelectorPatchPtrType) ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput {
	return i.ToCELDeviceSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *celdeviceSelectorPatchPtrType) ToCELDeviceSelectorPatchPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CELDeviceSelectorPatchPtrOutput)
}

// CELDeviceSelector contains a CEL expression for selecting a device.
type CELDeviceSelectorPatchOutput struct{ *pulumi.OutputState }

func (CELDeviceSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CELDeviceSelectorPatch)(nil)).Elem()
}

func (o CELDeviceSelectorPatchOutput) ToCELDeviceSelectorPatchOutput() CELDeviceSelectorPatchOutput {
	return o
}

func (o CELDeviceSelectorPatchOutput) ToCELDeviceSelectorPatchOutputWithContext(ctx context.Context) CELDeviceSelectorPatchOutput {
	return o
}

func (o CELDeviceSelectorPatchOutput) ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput {
	return o.ToCELDeviceSelectorPatchPtrOutputWithContext(context.Background())
}

func (o CELDeviceSelectorPatchOutput) ToCELDeviceSelectorPatchPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CELDeviceSelectorPatch) *CELDeviceSelectorPatch {
		return &v
	}).(CELDeviceSelectorPatchPtrOutput)
}

// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
//
// The expression's input is an object named "device", which carries the following properties:
//   - driver (string): the name of the driver which defines this device.
//   - attributes (map[string]object): the device's attributes, grouped by prefix
//     (e.g. device.attributes["dra.example.com"] evaluates to an object with all
//     of the attributes which were prefixed by "dra.example.com".
//   - capacity (map[string]object): the device's capacities, grouped by prefix.
//
// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
//
//	device.driver
//	device.attributes["dra.example.com"].model
//	device.attributes["ext.example.com"].family
//	device.capacity["dra.example.com"].modules
//
// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
//
// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
//
// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
//
// A robust expression should check for the existence of attributes before referencing them.
//
// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
//
//	cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
//
// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
func (o CELDeviceSelectorPatchOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CELDeviceSelectorPatch) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

type CELDeviceSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (CELDeviceSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CELDeviceSelectorPatch)(nil)).Elem()
}

func (o CELDeviceSelectorPatchPtrOutput) ToCELDeviceSelectorPatchPtrOutput() CELDeviceSelectorPatchPtrOutput {
	return o
}

func (o CELDeviceSelectorPatchPtrOutput) ToCELDeviceSelectorPatchPtrOutputWithContext(ctx context.Context) CELDeviceSelectorPatchPtrOutput {
	return o
}

func (o CELDeviceSelectorPatchPtrOutput) Elem() CELDeviceSelectorPatchOutput {
	return o.ApplyT(func(v *CELDeviceSelectorPatch) CELDeviceSelectorPatch {
		if v != nil {
			return *v
		}
		var ret CELDeviceSelectorPatch
		return ret
	}).(CELDeviceSelectorPatchOutput)
}

// Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.
//
// The expression's input is an object named "device", which carries the following properties:
//   - driver (string): the name of the driver which defines this device.
//   - attributes (map[string]object): the device's attributes, grouped by prefix
//     (e.g. device.attributes["dra.example.com"] evaluates to an object with all
//     of the attributes which were prefixed by "dra.example.com".
//   - capacity (map[string]object): the device's capacities, grouped by prefix.
//
// Example: Consider a device with driver="dra.example.com", which exposes two attributes named "model" and "ext.example.com/family" and which exposes one capacity named "modules". This input to this expression would have the following fields:
//
//	device.driver
//	device.attributes["dra.example.com"].model
//	device.attributes["ext.example.com"].family
//	device.capacity["dra.example.com"].modules
//
// The device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.
//
// The value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.
//
// If an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.
//
// A robust expression should check for the existence of attributes before referencing them.
//
// For ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:
//
//	cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
//
// The length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.
func (o CELDeviceSelectorPatchPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CELDeviceSelectorPatch) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type Device struct {
	// Basic defines one device instance.
	Basic *BasicDevice `pulumi:"basic"`
	// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
	Name string `pulumi:"name"`
}

// DeviceInput is an input type that accepts DeviceArgs and DeviceOutput values.
// You can construct a concrete instance of `DeviceInput` via:
//
//	DeviceArgs{...}
type DeviceInput interface {
	pulumi.Input

	ToDeviceOutput() DeviceOutput
	ToDeviceOutputWithContext(context.Context) DeviceOutput
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DeviceArgs struct {
	// Basic defines one device instance.
	Basic BasicDevicePtrInput `pulumi:"basic"`
	// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
	Name pulumi.StringInput `pulumi:"name"`
}

func (DeviceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Device)(nil)).Elem()
}

func (i DeviceArgs) ToDeviceOutput() DeviceOutput {
	return i.ToDeviceOutputWithContext(context.Background())
}

func (i DeviceArgs) ToDeviceOutputWithContext(ctx context.Context) DeviceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceOutput)
}

// DeviceArrayInput is an input type that accepts DeviceArray and DeviceArrayOutput values.
// You can construct a concrete instance of `DeviceArrayInput` via:
//
//	DeviceArray{ DeviceArgs{...} }
type DeviceArrayInput interface {
	pulumi.Input

	ToDeviceArrayOutput() DeviceArrayOutput
	ToDeviceArrayOutputWithContext(context.Context) DeviceArrayOutput
}

type DeviceArray []DeviceInput

func (DeviceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Device)(nil)).Elem()
}

func (i DeviceArray) ToDeviceArrayOutput() DeviceArrayOutput {
	return i.ToDeviceArrayOutputWithContext(context.Background())
}

func (i DeviceArray) ToDeviceArrayOutputWithContext(ctx context.Context) DeviceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceArrayOutput)
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DeviceOutput struct{ *pulumi.OutputState }

func (DeviceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Device)(nil)).Elem()
}

func (o DeviceOutput) ToDeviceOutput() DeviceOutput {
	return o
}

func (o DeviceOutput) ToDeviceOutputWithContext(ctx context.Context) DeviceOutput {
	return o
}

// Basic defines one device instance.
func (o DeviceOutput) Basic() BasicDevicePtrOutput {
	return o.ApplyT(func(v Device) *BasicDevice { return v.Basic }).(BasicDevicePtrOutput)
}

// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
func (o DeviceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Device) string { return v.Name }).(pulumi.StringOutput)
}

type DeviceArrayOutput struct{ *pulumi.OutputState }

func (DeviceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Device)(nil)).Elem()
}

func (o DeviceArrayOutput) ToDeviceArrayOutput() DeviceArrayOutput {
	return o
}

func (o DeviceArrayOutput) ToDeviceArrayOutputWithContext(ctx context.Context) DeviceArrayOutput {
	return o
}

func (o DeviceArrayOutput) Index(i pulumi.IntInput) DeviceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Device {
		return vs[0].([]Device)[vs[1].(int)]
	}).(DeviceOutput)
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfiguration struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfiguration `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
	Requests []string `pulumi:"requests"`
	// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
	Source string `pulumi:"source"`
}

// DeviceAllocationConfigurationInput is an input type that accepts DeviceAllocationConfigurationArgs and DeviceAllocationConfigurationOutput values.
// You can construct a concrete instance of `DeviceAllocationConfigurationInput` via:
//
//	DeviceAllocationConfigurationArgs{...}
type DeviceAllocationConfigurationInput interface {
	pulumi.Input

	ToDeviceAllocationConfigurationOutput() DeviceAllocationConfigurationOutput
	ToDeviceAllocationConfigurationOutputWithContext(context.Context) DeviceAllocationConfigurationOutput
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPtrInput `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
	// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
	Source pulumi.StringInput `pulumi:"source"`
}

func (DeviceAllocationConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationConfiguration)(nil)).Elem()
}

func (i DeviceAllocationConfigurationArgs) ToDeviceAllocationConfigurationOutput() DeviceAllocationConfigurationOutput {
	return i.ToDeviceAllocationConfigurationOutputWithContext(context.Background())
}

func (i DeviceAllocationConfigurationArgs) ToDeviceAllocationConfigurationOutputWithContext(ctx context.Context) DeviceAllocationConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationConfigurationOutput)
}

// DeviceAllocationConfigurationArrayInput is an input type that accepts DeviceAllocationConfigurationArray and DeviceAllocationConfigurationArrayOutput values.
// You can construct a concrete instance of `DeviceAllocationConfigurationArrayInput` via:
//
//	DeviceAllocationConfigurationArray{ DeviceAllocationConfigurationArgs{...} }
type DeviceAllocationConfigurationArrayInput interface {
	pulumi.Input

	ToDeviceAllocationConfigurationArrayOutput() DeviceAllocationConfigurationArrayOutput
	ToDeviceAllocationConfigurationArrayOutputWithContext(context.Context) DeviceAllocationConfigurationArrayOutput
}

type DeviceAllocationConfigurationArray []DeviceAllocationConfigurationInput

func (DeviceAllocationConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceAllocationConfiguration)(nil)).Elem()
}

func (i DeviceAllocationConfigurationArray) ToDeviceAllocationConfigurationArrayOutput() DeviceAllocationConfigurationArrayOutput {
	return i.ToDeviceAllocationConfigurationArrayOutputWithContext(context.Background())
}

func (i DeviceAllocationConfigurationArray) ToDeviceAllocationConfigurationArrayOutputWithContext(ctx context.Context) DeviceAllocationConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationConfigurationArrayOutput)
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationOutput struct{ *pulumi.OutputState }

func (DeviceAllocationConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationConfiguration)(nil)).Elem()
}

func (o DeviceAllocationConfigurationOutput) ToDeviceAllocationConfigurationOutput() DeviceAllocationConfigurationOutput {
	return o
}

func (o DeviceAllocationConfigurationOutput) ToDeviceAllocationConfigurationOutputWithContext(ctx context.Context) DeviceAllocationConfigurationOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceAllocationConfigurationOutput) Opaque() OpaqueDeviceConfigurationPtrOutput {
	return o.ApplyT(func(v DeviceAllocationConfiguration) *OpaqueDeviceConfiguration { return v.Opaque }).(OpaqueDeviceConfigurationPtrOutput)
}

// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
func (o DeviceAllocationConfigurationOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceAllocationConfiguration) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
func (o DeviceAllocationConfigurationOutput) Source() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceAllocationConfiguration) string { return v.Source }).(pulumi.StringOutput)
}

type DeviceAllocationConfigurationArrayOutput struct{ *pulumi.OutputState }

func (DeviceAllocationConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceAllocationConfiguration)(nil)).Elem()
}

func (o DeviceAllocationConfigurationArrayOutput) ToDeviceAllocationConfigurationArrayOutput() DeviceAllocationConfigurationArrayOutput {
	return o
}

func (o DeviceAllocationConfigurationArrayOutput) ToDeviceAllocationConfigurationArrayOutputWithContext(ctx context.Context) DeviceAllocationConfigurationArrayOutput {
	return o
}

func (o DeviceAllocationConfigurationArrayOutput) Index(i pulumi.IntInput) DeviceAllocationConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceAllocationConfiguration {
		return vs[0].([]DeviceAllocationConfiguration)[vs[1].(int)]
	}).(DeviceAllocationConfigurationOutput)
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationPatch struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfigurationPatch `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
	Requests []string `pulumi:"requests"`
	// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
	Source *string `pulumi:"source"`
}

// DeviceAllocationConfigurationPatchInput is an input type that accepts DeviceAllocationConfigurationPatchArgs and DeviceAllocationConfigurationPatchOutput values.
// You can construct a concrete instance of `DeviceAllocationConfigurationPatchInput` via:
//
//	DeviceAllocationConfigurationPatchArgs{...}
type DeviceAllocationConfigurationPatchInput interface {
	pulumi.Input

	ToDeviceAllocationConfigurationPatchOutput() DeviceAllocationConfigurationPatchOutput
	ToDeviceAllocationConfigurationPatchOutputWithContext(context.Context) DeviceAllocationConfigurationPatchOutput
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationPatchArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPatchPtrInput `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
	// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
	Source pulumi.StringPtrInput `pulumi:"source"`
}

func (DeviceAllocationConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationConfigurationPatch)(nil)).Elem()
}

func (i DeviceAllocationConfigurationPatchArgs) ToDeviceAllocationConfigurationPatchOutput() DeviceAllocationConfigurationPatchOutput {
	return i.ToDeviceAllocationConfigurationPatchOutputWithContext(context.Background())
}

func (i DeviceAllocationConfigurationPatchArgs) ToDeviceAllocationConfigurationPatchOutputWithContext(ctx context.Context) DeviceAllocationConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationConfigurationPatchOutput)
}

// DeviceAllocationConfigurationPatchArrayInput is an input type that accepts DeviceAllocationConfigurationPatchArray and DeviceAllocationConfigurationPatchArrayOutput values.
// You can construct a concrete instance of `DeviceAllocationConfigurationPatchArrayInput` via:
//
//	DeviceAllocationConfigurationPatchArray{ DeviceAllocationConfigurationPatchArgs{...} }
type DeviceAllocationConfigurationPatchArrayInput interface {
	pulumi.Input

	ToDeviceAllocationConfigurationPatchArrayOutput() DeviceAllocationConfigurationPatchArrayOutput
	ToDeviceAllocationConfigurationPatchArrayOutputWithContext(context.Context) DeviceAllocationConfigurationPatchArrayOutput
}

type DeviceAllocationConfigurationPatchArray []DeviceAllocationConfigurationPatchInput

func (DeviceAllocationConfigurationPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceAllocationConfigurationPatch)(nil)).Elem()
}

func (i DeviceAllocationConfigurationPatchArray) ToDeviceAllocationConfigurationPatchArrayOutput() DeviceAllocationConfigurationPatchArrayOutput {
	return i.ToDeviceAllocationConfigurationPatchArrayOutputWithContext(context.Background())
}

func (i DeviceAllocationConfigurationPatchArray) ToDeviceAllocationConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceAllocationConfigurationPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationConfigurationPatchArrayOutput)
}

// DeviceAllocationConfiguration gets embedded in an AllocationResult.
type DeviceAllocationConfigurationPatchOutput struct{ *pulumi.OutputState }

func (DeviceAllocationConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationConfigurationPatch)(nil)).Elem()
}

func (o DeviceAllocationConfigurationPatchOutput) ToDeviceAllocationConfigurationPatchOutput() DeviceAllocationConfigurationPatchOutput {
	return o
}

func (o DeviceAllocationConfigurationPatchOutput) ToDeviceAllocationConfigurationPatchOutputWithContext(ctx context.Context) DeviceAllocationConfigurationPatchOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceAllocationConfigurationPatchOutput) Opaque() OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ApplyT(func(v DeviceAllocationConfigurationPatch) *OpaqueDeviceConfigurationPatch { return v.Opaque }).(OpaqueDeviceConfigurationPatchPtrOutput)
}

// Requests lists the names of requests where the configuration applies. If empty, its applies to all requests.
func (o DeviceAllocationConfigurationPatchOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceAllocationConfigurationPatch) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

// Source records whether the configuration comes from a class and thus is not something that a normal user would have been able to set or from a claim.
func (o DeviceAllocationConfigurationPatchOutput) Source() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAllocationConfigurationPatch) *string { return v.Source }).(pulumi.StringPtrOutput)
}

type DeviceAllocationConfigurationPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceAllocationConfigurationPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceAllocationConfigurationPatch)(nil)).Elem()
}

func (o DeviceAllocationConfigurationPatchArrayOutput) ToDeviceAllocationConfigurationPatchArrayOutput() DeviceAllocationConfigurationPatchArrayOutput {
	return o
}

func (o DeviceAllocationConfigurationPatchArrayOutput) ToDeviceAllocationConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceAllocationConfigurationPatchArrayOutput {
	return o
}

func (o DeviceAllocationConfigurationPatchArrayOutput) Index(i pulumi.IntInput) DeviceAllocationConfigurationPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceAllocationConfigurationPatch {
		return vs[0].([]DeviceAllocationConfigurationPatch)[vs[1].(int)]
	}).(DeviceAllocationConfigurationPatchOutput)
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResult struct {
	// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
	//
	// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
	Config []DeviceAllocationConfiguration `pulumi:"config"`
	// Results lists all allocated devices.
	Results []DeviceRequestAllocationResult `pulumi:"results"`
}

// DeviceAllocationResultInput is an input type that accepts DeviceAllocationResultArgs and DeviceAllocationResultOutput values.
// You can construct a concrete instance of `DeviceAllocationResultInput` via:
//
//	DeviceAllocationResultArgs{...}
type DeviceAllocationResultInput interface {
	pulumi.Input

	ToDeviceAllocationResultOutput() DeviceAllocationResultOutput
	ToDeviceAllocationResultOutputWithContext(context.Context) DeviceAllocationResultOutput
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultArgs struct {
	// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
	//
	// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
	Config DeviceAllocationConfigurationArrayInput `pulumi:"config"`
	// Results lists all allocated devices.
	Results DeviceRequestAllocationResultArrayInput `pulumi:"results"`
}

func (DeviceAllocationResultArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationResult)(nil)).Elem()
}

func (i DeviceAllocationResultArgs) ToDeviceAllocationResultOutput() DeviceAllocationResultOutput {
	return i.ToDeviceAllocationResultOutputWithContext(context.Background())
}

func (i DeviceAllocationResultArgs) ToDeviceAllocationResultOutputWithContext(ctx context.Context) DeviceAllocationResultOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultOutput)
}

func (i DeviceAllocationResultArgs) ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput {
	return i.ToDeviceAllocationResultPtrOutputWithContext(context.Background())
}

func (i DeviceAllocationResultArgs) ToDeviceAllocationResultPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultOutput).ToDeviceAllocationResultPtrOutputWithContext(ctx)
}

// DeviceAllocationResultPtrInput is an input type that accepts DeviceAllocationResultArgs, DeviceAllocationResultPtr and DeviceAllocationResultPtrOutput values.
// You can construct a concrete instance of `DeviceAllocationResultPtrInput` via:
//
//	        DeviceAllocationResultArgs{...}
//
//	or:
//
//	        nil
type DeviceAllocationResultPtrInput interface {
	pulumi.Input

	ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput
	ToDeviceAllocationResultPtrOutputWithContext(context.Context) DeviceAllocationResultPtrOutput
}

type deviceAllocationResultPtrType DeviceAllocationResultArgs

func DeviceAllocationResultPtr(v *DeviceAllocationResultArgs) DeviceAllocationResultPtrInput {
	return (*deviceAllocationResultPtrType)(v)
}

func (*deviceAllocationResultPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceAllocationResult)(nil)).Elem()
}

func (i *deviceAllocationResultPtrType) ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput {
	return i.ToDeviceAllocationResultPtrOutputWithContext(context.Background())
}

func (i *deviceAllocationResultPtrType) ToDeviceAllocationResultPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultPtrOutput)
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultOutput struct{ *pulumi.OutputState }

func (DeviceAllocationResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationResult)(nil)).Elem()
}

func (o DeviceAllocationResultOutput) ToDeviceAllocationResultOutput() DeviceAllocationResultOutput {
	return o
}

func (o DeviceAllocationResultOutput) ToDeviceAllocationResultOutputWithContext(ctx context.Context) DeviceAllocationResultOutput {
	return o
}

func (o DeviceAllocationResultOutput) ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput {
	return o.ToDeviceAllocationResultPtrOutputWithContext(context.Background())
}

func (o DeviceAllocationResultOutput) ToDeviceAllocationResultPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceAllocationResult) *DeviceAllocationResult {
		return &v
	}).(DeviceAllocationResultPtrOutput)
}

// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
//
// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
func (o DeviceAllocationResultOutput) Config() DeviceAllocationConfigurationArrayOutput {
	return o.ApplyT(func(v DeviceAllocationResult) []DeviceAllocationConfiguration { return v.Config }).(DeviceAllocationConfigurationArrayOutput)
}

// Results lists all allocated devices.
func (o DeviceAllocationResultOutput) Results() DeviceRequestAllocationResultArrayOutput {
	return o.ApplyT(func(v DeviceAllocationResult) []DeviceRequestAllocationResult { return v.Results }).(DeviceRequestAllocationResultArrayOutput)
}

type DeviceAllocationResultPtrOutput struct{ *pulumi.OutputState }

func (DeviceAllocationResultPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceAllocationResult)(nil)).Elem()
}

func (o DeviceAllocationResultPtrOutput) ToDeviceAllocationResultPtrOutput() DeviceAllocationResultPtrOutput {
	return o
}

func (o DeviceAllocationResultPtrOutput) ToDeviceAllocationResultPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPtrOutput {
	return o
}

func (o DeviceAllocationResultPtrOutput) Elem() DeviceAllocationResultOutput {
	return o.ApplyT(func(v *DeviceAllocationResult) DeviceAllocationResult {
		if v != nil {
			return *v
		}
		var ret DeviceAllocationResult
		return ret
	}).(DeviceAllocationResultOutput)
}

// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
//
// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
func (o DeviceAllocationResultPtrOutput) Config() DeviceAllocationConfigurationArrayOutput {
	return o.ApplyT(func(v *DeviceAllocationResult) []DeviceAllocationConfiguration {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceAllocationConfigurationArrayOutput)
}

// Results lists all allocated devices.
func (o DeviceAllocationResultPtrOutput) Results() DeviceRequestAllocationResultArrayOutput {
	return o.ApplyT(func(v *DeviceAllocationResult) []DeviceRequestAllocationResult {
		if v == nil {
			return nil
		}
		return v.Results
	}).(DeviceRequestAllocationResultArrayOutput)
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultPatch struct {
	// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
	//
	// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
	Config []DeviceAllocationConfigurationPatch `pulumi:"config"`
	// Results lists all allocated devices.
	Results []DeviceRequestAllocationResultPatch `pulumi:"results"`
}

// DeviceAllocationResultPatchInput is an input type that accepts DeviceAllocationResultPatchArgs and DeviceAllocationResultPatchOutput values.
// You can construct a concrete instance of `DeviceAllocationResultPatchInput` via:
//
//	DeviceAllocationResultPatchArgs{...}
type DeviceAllocationResultPatchInput interface {
	pulumi.Input

	ToDeviceAllocationResultPatchOutput() DeviceAllocationResultPatchOutput
	ToDeviceAllocationResultPatchOutputWithContext(context.Context) DeviceAllocationResultPatchOutput
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultPatchArgs struct {
	// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
	//
	// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
	Config DeviceAllocationConfigurationPatchArrayInput `pulumi:"config"`
	// Results lists all allocated devices.
	Results DeviceRequestAllocationResultPatchArrayInput `pulumi:"results"`
}

func (DeviceAllocationResultPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationResultPatch)(nil)).Elem()
}

func (i DeviceAllocationResultPatchArgs) ToDeviceAllocationResultPatchOutput() DeviceAllocationResultPatchOutput {
	return i.ToDeviceAllocationResultPatchOutputWithContext(context.Background())
}

func (i DeviceAllocationResultPatchArgs) ToDeviceAllocationResultPatchOutputWithContext(ctx context.Context) DeviceAllocationResultPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultPatchOutput)
}

func (i DeviceAllocationResultPatchArgs) ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput {
	return i.ToDeviceAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (i DeviceAllocationResultPatchArgs) ToDeviceAllocationResultPatchPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultPatchOutput).ToDeviceAllocationResultPatchPtrOutputWithContext(ctx)
}

// DeviceAllocationResultPatchPtrInput is an input type that accepts DeviceAllocationResultPatchArgs, DeviceAllocationResultPatchPtr and DeviceAllocationResultPatchPtrOutput values.
// You can construct a concrete instance of `DeviceAllocationResultPatchPtrInput` via:
//
//	        DeviceAllocationResultPatchArgs{...}
//
//	or:
//
//	        nil
type DeviceAllocationResultPatchPtrInput interface {
	pulumi.Input

	ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput
	ToDeviceAllocationResultPatchPtrOutputWithContext(context.Context) DeviceAllocationResultPatchPtrOutput
}

type deviceAllocationResultPatchPtrType DeviceAllocationResultPatchArgs

func DeviceAllocationResultPatchPtr(v *DeviceAllocationResultPatchArgs) DeviceAllocationResultPatchPtrInput {
	return (*deviceAllocationResultPatchPtrType)(v)
}

func (*deviceAllocationResultPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceAllocationResultPatch)(nil)).Elem()
}

func (i *deviceAllocationResultPatchPtrType) ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput {
	return i.ToDeviceAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (i *deviceAllocationResultPatchPtrType) ToDeviceAllocationResultPatchPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAllocationResultPatchPtrOutput)
}

// DeviceAllocationResult is the result of allocating devices.
type DeviceAllocationResultPatchOutput struct{ *pulumi.OutputState }

func (DeviceAllocationResultPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAllocationResultPatch)(nil)).Elem()
}

func (o DeviceAllocationResultPatchOutput) ToDeviceAllocationResultPatchOutput() DeviceAllocationResultPatchOutput {
	return o
}

func (o DeviceAllocationResultPatchOutput) ToDeviceAllocationResultPatchOutputWithContext(ctx context.Context) DeviceAllocationResultPatchOutput {
	return o
}

func (o DeviceAllocationResultPatchOutput) ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput {
	return o.ToDeviceAllocationResultPatchPtrOutputWithContext(context.Background())
}

func (o DeviceAllocationResultPatchOutput) ToDeviceAllocationResultPatchPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceAllocationResultPatch) *DeviceAllocationResultPatch {
		return &v
	}).(DeviceAllocationResultPatchPtrOutput)
}

// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
//
// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
func (o DeviceAllocationResultPatchOutput) Config() DeviceAllocationConfigurationPatchArrayOutput {
	return o.ApplyT(func(v DeviceAllocationResultPatch) []DeviceAllocationConfigurationPatch { return v.Config }).(DeviceAllocationConfigurationPatchArrayOutput)
}

// Results lists all allocated devices.
func (o DeviceAllocationResultPatchOutput) Results() DeviceRequestAllocationResultPatchArrayOutput {
	return o.ApplyT(func(v DeviceAllocationResultPatch) []DeviceRequestAllocationResultPatch { return v.Results }).(DeviceRequestAllocationResultPatchArrayOutput)
}

type DeviceAllocationResultPatchPtrOutput struct{ *pulumi.OutputState }

func (DeviceAllocationResultPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceAllocationResultPatch)(nil)).Elem()
}

func (o DeviceAllocationResultPatchPtrOutput) ToDeviceAllocationResultPatchPtrOutput() DeviceAllocationResultPatchPtrOutput {
	return o
}

func (o DeviceAllocationResultPatchPtrOutput) ToDeviceAllocationResultPatchPtrOutputWithContext(ctx context.Context) DeviceAllocationResultPatchPtrOutput {
	return o
}

func (o DeviceAllocationResultPatchPtrOutput) Elem() DeviceAllocationResultPatchOutput {
	return o.ApplyT(func(v *DeviceAllocationResultPatch) DeviceAllocationResultPatch {
		if v != nil {
			return *v
		}
		var ret DeviceAllocationResultPatch
		return ret
	}).(DeviceAllocationResultPatchOutput)
}

// This field is a combination of all the claim and class configuration parameters. Drivers can distinguish between those based on a flag.
//
// This includes configuration parameters for drivers which have no allocated devices in the result because it is up to the drivers which configuration parameters they support. They can silently ignore unknown configuration parameters.
func (o DeviceAllocationResultPatchPtrOutput) Config() DeviceAllocationConfigurationPatchArrayOutput {
	return o.ApplyT(func(v *DeviceAllocationResultPatch) []DeviceAllocationConfigurationPatch {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceAllocationConfigurationPatchArrayOutput)
}

// Results lists all allocated devices.
func (o DeviceAllocationResultPatchPtrOutput) Results() DeviceRequestAllocationResultPatchArrayOutput {
	return o.ApplyT(func(v *DeviceAllocationResultPatch) []DeviceRequestAllocationResultPatch {
		if v == nil {
			return nil
		}
		return v.Results
	}).(DeviceRequestAllocationResultPatchArrayOutput)
}

// DeviceAttribute must have exactly one field set.
type DeviceAttribute struct {
	// BoolValue is a true/false value.
	Bool *bool `pulumi:"bool"`
	// IntValue is a number.
	Int *int `pulumi:"int"`
	// StringValue is a string. Must not be longer than 64 characters.
	String *string `pulumi:"string"`
	// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
	Version *string `pulumi:"version"`
}

// DeviceAttributeInput is an input type that accepts DeviceAttributeArgs and DeviceAttributeOutput values.
// You can construct a concrete instance of `DeviceAttributeInput` via:
//
//	DeviceAttributeArgs{...}
type DeviceAttributeInput interface {
	pulumi.Input

	ToDeviceAttributeOutput() DeviceAttributeOutput
	ToDeviceAttributeOutputWithContext(context.Context) DeviceAttributeOutput
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributeArgs struct {
	// BoolValue is a true/false value.
	Bool pulumi.BoolPtrInput `pulumi:"bool"`
	// IntValue is a number.
	Int pulumi.IntPtrInput `pulumi:"int"`
	// StringValue is a string. Must not be longer than 64 characters.
	String pulumi.StringPtrInput `pulumi:"string"`
	// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (DeviceAttributeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAttribute)(nil)).Elem()
}

func (i DeviceAttributeArgs) ToDeviceAttributeOutput() DeviceAttributeOutput {
	return i.ToDeviceAttributeOutputWithContext(context.Background())
}

func (i DeviceAttributeArgs) ToDeviceAttributeOutputWithContext(ctx context.Context) DeviceAttributeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAttributeOutput)
}

// DeviceAttributeMapInput is an input type that accepts DeviceAttributeMap and DeviceAttributeMapOutput values.
// You can construct a concrete instance of `DeviceAttributeMapInput` via:
//
//	DeviceAttributeMap{ "key": DeviceAttributeArgs{...} }
type DeviceAttributeMapInput interface {
	pulumi.Input

	ToDeviceAttributeMapOutput() DeviceAttributeMapOutput
	ToDeviceAttributeMapOutputWithContext(context.Context) DeviceAttributeMapOutput
}

type DeviceAttributeMap map[string]DeviceAttributeInput

func (DeviceAttributeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]DeviceAttribute)(nil)).Elem()
}

func (i DeviceAttributeMap) ToDeviceAttributeMapOutput() DeviceAttributeMapOutput {
	return i.ToDeviceAttributeMapOutputWithContext(context.Background())
}

func (i DeviceAttributeMap) ToDeviceAttributeMapOutputWithContext(ctx context.Context) DeviceAttributeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAttributeMapOutput)
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributeOutput struct{ *pulumi.OutputState }

func (DeviceAttributeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAttribute)(nil)).Elem()
}

func (o DeviceAttributeOutput) ToDeviceAttributeOutput() DeviceAttributeOutput {
	return o
}

func (o DeviceAttributeOutput) ToDeviceAttributeOutputWithContext(ctx context.Context) DeviceAttributeOutput {
	return o
}

// BoolValue is a true/false value.
func (o DeviceAttributeOutput) Bool() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceAttribute) *bool { return v.Bool }).(pulumi.BoolPtrOutput)
}

// IntValue is a number.
func (o DeviceAttributeOutput) Int() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceAttribute) *int { return v.Int }).(pulumi.IntPtrOutput)
}

// StringValue is a string. Must not be longer than 64 characters.
func (o DeviceAttributeOutput) String() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAttribute) *string { return v.String }).(pulumi.StringPtrOutput)
}

// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
func (o DeviceAttributeOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAttribute) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type DeviceAttributeMapOutput struct{ *pulumi.OutputState }

func (DeviceAttributeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]DeviceAttribute)(nil)).Elem()
}

func (o DeviceAttributeMapOutput) ToDeviceAttributeMapOutput() DeviceAttributeMapOutput {
	return o
}

func (o DeviceAttributeMapOutput) ToDeviceAttributeMapOutputWithContext(ctx context.Context) DeviceAttributeMapOutput {
	return o
}

func (o DeviceAttributeMapOutput) MapIndex(k pulumi.StringInput) DeviceAttributeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) DeviceAttribute {
		return vs[0].(map[string]DeviceAttribute)[vs[1].(string)]
	}).(DeviceAttributeOutput)
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributePatch struct {
	// BoolValue is a true/false value.
	Bool *bool `pulumi:"bool"`
	// IntValue is a number.
	Int *int `pulumi:"int"`
	// StringValue is a string. Must not be longer than 64 characters.
	String *string `pulumi:"string"`
	// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
	Version *string `pulumi:"version"`
}

// DeviceAttributePatchInput is an input type that accepts DeviceAttributePatchArgs and DeviceAttributePatchOutput values.
// You can construct a concrete instance of `DeviceAttributePatchInput` via:
//
//	DeviceAttributePatchArgs{...}
type DeviceAttributePatchInput interface {
	pulumi.Input

	ToDeviceAttributePatchOutput() DeviceAttributePatchOutput
	ToDeviceAttributePatchOutputWithContext(context.Context) DeviceAttributePatchOutput
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributePatchArgs struct {
	// BoolValue is a true/false value.
	Bool pulumi.BoolPtrInput `pulumi:"bool"`
	// IntValue is a number.
	Int pulumi.IntPtrInput `pulumi:"int"`
	// StringValue is a string. Must not be longer than 64 characters.
	String pulumi.StringPtrInput `pulumi:"string"`
	// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (DeviceAttributePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAttributePatch)(nil)).Elem()
}

func (i DeviceAttributePatchArgs) ToDeviceAttributePatchOutput() DeviceAttributePatchOutput {
	return i.ToDeviceAttributePatchOutputWithContext(context.Background())
}

func (i DeviceAttributePatchArgs) ToDeviceAttributePatchOutputWithContext(ctx context.Context) DeviceAttributePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAttributePatchOutput)
}

// DeviceAttribute must have exactly one field set.
type DeviceAttributePatchOutput struct{ *pulumi.OutputState }

func (DeviceAttributePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAttributePatch)(nil)).Elem()
}

func (o DeviceAttributePatchOutput) ToDeviceAttributePatchOutput() DeviceAttributePatchOutput {
	return o
}

func (o DeviceAttributePatchOutput) ToDeviceAttributePatchOutputWithContext(ctx context.Context) DeviceAttributePatchOutput {
	return o
}

// BoolValue is a true/false value.
func (o DeviceAttributePatchOutput) Bool() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceAttributePatch) *bool { return v.Bool }).(pulumi.BoolPtrOutput)
}

// IntValue is a number.
func (o DeviceAttributePatchOutput) Int() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceAttributePatch) *int { return v.Int }).(pulumi.IntPtrOutput)
}

// StringValue is a string. Must not be longer than 64 characters.
func (o DeviceAttributePatchOutput) String() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAttributePatch) *string { return v.String }).(pulumi.StringPtrOutput)
}

// VersionValue is a semantic version according to semver.org spec 2.0.0. Must not be longer than 64 characters.
func (o DeviceAttributePatchOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceAttributePatch) *string { return v.Version }).(pulumi.StringPtrOutput)
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaim struct {
	// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
	Config []DeviceClaimConfiguration `pulumi:"config"`
	// These constraints must be satisfied by the set of devices that get allocated for the claim.
	Constraints []DeviceConstraint `pulumi:"constraints"`
	// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
	Requests []DeviceRequest `pulumi:"requests"`
}

// DeviceClaimInput is an input type that accepts DeviceClaimArgs and DeviceClaimOutput values.
// You can construct a concrete instance of `DeviceClaimInput` via:
//
//	DeviceClaimArgs{...}
type DeviceClaimInput interface {
	pulumi.Input

	ToDeviceClaimOutput() DeviceClaimOutput
	ToDeviceClaimOutputWithContext(context.Context) DeviceClaimOutput
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimArgs struct {
	// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
	Config DeviceClaimConfigurationArrayInput `pulumi:"config"`
	// These constraints must be satisfied by the set of devices that get allocated for the claim.
	Constraints DeviceConstraintArrayInput `pulumi:"constraints"`
	// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
	Requests DeviceRequestArrayInput `pulumi:"requests"`
}

func (DeviceClaimArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaim)(nil)).Elem()
}

func (i DeviceClaimArgs) ToDeviceClaimOutput() DeviceClaimOutput {
	return i.ToDeviceClaimOutputWithContext(context.Background())
}

func (i DeviceClaimArgs) ToDeviceClaimOutputWithContext(ctx context.Context) DeviceClaimOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimOutput)
}

func (i DeviceClaimArgs) ToDeviceClaimPtrOutput() DeviceClaimPtrOutput {
	return i.ToDeviceClaimPtrOutputWithContext(context.Background())
}

func (i DeviceClaimArgs) ToDeviceClaimPtrOutputWithContext(ctx context.Context) DeviceClaimPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimOutput).ToDeviceClaimPtrOutputWithContext(ctx)
}

// DeviceClaimPtrInput is an input type that accepts DeviceClaimArgs, DeviceClaimPtr and DeviceClaimPtrOutput values.
// You can construct a concrete instance of `DeviceClaimPtrInput` via:
//
//	        DeviceClaimArgs{...}
//
//	or:
//
//	        nil
type DeviceClaimPtrInput interface {
	pulumi.Input

	ToDeviceClaimPtrOutput() DeviceClaimPtrOutput
	ToDeviceClaimPtrOutputWithContext(context.Context) DeviceClaimPtrOutput
}

type deviceClaimPtrType DeviceClaimArgs

func DeviceClaimPtr(v *DeviceClaimArgs) DeviceClaimPtrInput {
	return (*deviceClaimPtrType)(v)
}

func (*deviceClaimPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClaim)(nil)).Elem()
}

func (i *deviceClaimPtrType) ToDeviceClaimPtrOutput() DeviceClaimPtrOutput {
	return i.ToDeviceClaimPtrOutputWithContext(context.Background())
}

func (i *deviceClaimPtrType) ToDeviceClaimPtrOutputWithContext(ctx context.Context) DeviceClaimPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimPtrOutput)
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimOutput struct{ *pulumi.OutputState }

func (DeviceClaimOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaim)(nil)).Elem()
}

func (o DeviceClaimOutput) ToDeviceClaimOutput() DeviceClaimOutput {
	return o
}

func (o DeviceClaimOutput) ToDeviceClaimOutputWithContext(ctx context.Context) DeviceClaimOutput {
	return o
}

func (o DeviceClaimOutput) ToDeviceClaimPtrOutput() DeviceClaimPtrOutput {
	return o.ToDeviceClaimPtrOutputWithContext(context.Background())
}

func (o DeviceClaimOutput) ToDeviceClaimPtrOutputWithContext(ctx context.Context) DeviceClaimPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceClaim) *DeviceClaim {
		return &v
	}).(DeviceClaimPtrOutput)
}

// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
func (o DeviceClaimOutput) Config() DeviceClaimConfigurationArrayOutput {
	return o.ApplyT(func(v DeviceClaim) []DeviceClaimConfiguration { return v.Config }).(DeviceClaimConfigurationArrayOutput)
}

// These constraints must be satisfied by the set of devices that get allocated for the claim.
func (o DeviceClaimOutput) Constraints() DeviceConstraintArrayOutput {
	return o.ApplyT(func(v DeviceClaim) []DeviceConstraint { return v.Constraints }).(DeviceConstraintArrayOutput)
}

// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
func (o DeviceClaimOutput) Requests() DeviceRequestArrayOutput {
	return o.ApplyT(func(v DeviceClaim) []DeviceRequest { return v.Requests }).(DeviceRequestArrayOutput)
}

type DeviceClaimPtrOutput struct{ *pulumi.OutputState }

func (DeviceClaimPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClaim)(nil)).Elem()
}

func (o DeviceClaimPtrOutput) ToDeviceClaimPtrOutput() DeviceClaimPtrOutput {
	return o
}

func (o DeviceClaimPtrOutput) ToDeviceClaimPtrOutputWithContext(ctx context.Context) DeviceClaimPtrOutput {
	return o
}

func (o DeviceClaimPtrOutput) Elem() DeviceClaimOutput {
	return o.ApplyT(func(v *DeviceClaim) DeviceClaim {
		if v != nil {
			return *v
		}
		var ret DeviceClaim
		return ret
	}).(DeviceClaimOutput)
}

// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
func (o DeviceClaimPtrOutput) Config() DeviceClaimConfigurationArrayOutput {
	return o.ApplyT(func(v *DeviceClaim) []DeviceClaimConfiguration {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceClaimConfigurationArrayOutput)
}

// These constraints must be satisfied by the set of devices that get allocated for the claim.
func (o DeviceClaimPtrOutput) Constraints() DeviceConstraintArrayOutput {
	return o.ApplyT(func(v *DeviceClaim) []DeviceConstraint {
		if v == nil {
			return nil
		}
		return v.Constraints
	}).(DeviceConstraintArrayOutput)
}

// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
func (o DeviceClaimPtrOutput) Requests() DeviceRequestArrayOutput {
	return o.ApplyT(func(v *DeviceClaim) []DeviceRequest {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(DeviceRequestArrayOutput)
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfiguration struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfiguration `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
	Requests []string `pulumi:"requests"`
}

// DeviceClaimConfigurationInput is an input type that accepts DeviceClaimConfigurationArgs and DeviceClaimConfigurationOutput values.
// You can construct a concrete instance of `DeviceClaimConfigurationInput` via:
//
//	DeviceClaimConfigurationArgs{...}
type DeviceClaimConfigurationInput interface {
	pulumi.Input

	ToDeviceClaimConfigurationOutput() DeviceClaimConfigurationOutput
	ToDeviceClaimConfigurationOutputWithContext(context.Context) DeviceClaimConfigurationOutput
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPtrInput `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
}

func (DeviceClaimConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimConfiguration)(nil)).Elem()
}

func (i DeviceClaimConfigurationArgs) ToDeviceClaimConfigurationOutput() DeviceClaimConfigurationOutput {
	return i.ToDeviceClaimConfigurationOutputWithContext(context.Background())
}

func (i DeviceClaimConfigurationArgs) ToDeviceClaimConfigurationOutputWithContext(ctx context.Context) DeviceClaimConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimConfigurationOutput)
}

// DeviceClaimConfigurationArrayInput is an input type that accepts DeviceClaimConfigurationArray and DeviceClaimConfigurationArrayOutput values.
// You can construct a concrete instance of `DeviceClaimConfigurationArrayInput` via:
//
//	DeviceClaimConfigurationArray{ DeviceClaimConfigurationArgs{...} }
type DeviceClaimConfigurationArrayInput interface {
	pulumi.Input

	ToDeviceClaimConfigurationArrayOutput() DeviceClaimConfigurationArrayOutput
	ToDeviceClaimConfigurationArrayOutputWithContext(context.Context) DeviceClaimConfigurationArrayOutput
}

type DeviceClaimConfigurationArray []DeviceClaimConfigurationInput

func (DeviceClaimConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClaimConfiguration)(nil)).Elem()
}

func (i DeviceClaimConfigurationArray) ToDeviceClaimConfigurationArrayOutput() DeviceClaimConfigurationArrayOutput {
	return i.ToDeviceClaimConfigurationArrayOutputWithContext(context.Background())
}

func (i DeviceClaimConfigurationArray) ToDeviceClaimConfigurationArrayOutputWithContext(ctx context.Context) DeviceClaimConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimConfigurationArrayOutput)
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationOutput struct{ *pulumi.OutputState }

func (DeviceClaimConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimConfiguration)(nil)).Elem()
}

func (o DeviceClaimConfigurationOutput) ToDeviceClaimConfigurationOutput() DeviceClaimConfigurationOutput {
	return o
}

func (o DeviceClaimConfigurationOutput) ToDeviceClaimConfigurationOutputWithContext(ctx context.Context) DeviceClaimConfigurationOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceClaimConfigurationOutput) Opaque() OpaqueDeviceConfigurationPtrOutput {
	return o.ApplyT(func(v DeviceClaimConfiguration) *OpaqueDeviceConfiguration { return v.Opaque }).(OpaqueDeviceConfigurationPtrOutput)
}

// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
func (o DeviceClaimConfigurationOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceClaimConfiguration) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

type DeviceClaimConfigurationArrayOutput struct{ *pulumi.OutputState }

func (DeviceClaimConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClaimConfiguration)(nil)).Elem()
}

func (o DeviceClaimConfigurationArrayOutput) ToDeviceClaimConfigurationArrayOutput() DeviceClaimConfigurationArrayOutput {
	return o
}

func (o DeviceClaimConfigurationArrayOutput) ToDeviceClaimConfigurationArrayOutputWithContext(ctx context.Context) DeviceClaimConfigurationArrayOutput {
	return o
}

func (o DeviceClaimConfigurationArrayOutput) Index(i pulumi.IntInput) DeviceClaimConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClaimConfiguration {
		return vs[0].([]DeviceClaimConfiguration)[vs[1].(int)]
	}).(DeviceClaimConfigurationOutput)
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationPatch struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfigurationPatch `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
	Requests []string `pulumi:"requests"`
}

// DeviceClaimConfigurationPatchInput is an input type that accepts DeviceClaimConfigurationPatchArgs and DeviceClaimConfigurationPatchOutput values.
// You can construct a concrete instance of `DeviceClaimConfigurationPatchInput` via:
//
//	DeviceClaimConfigurationPatchArgs{...}
type DeviceClaimConfigurationPatchInput interface {
	pulumi.Input

	ToDeviceClaimConfigurationPatchOutput() DeviceClaimConfigurationPatchOutput
	ToDeviceClaimConfigurationPatchOutputWithContext(context.Context) DeviceClaimConfigurationPatchOutput
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationPatchArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPatchPtrInput `pulumi:"opaque"`
	// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
}

func (DeviceClaimConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimConfigurationPatch)(nil)).Elem()
}

func (i DeviceClaimConfigurationPatchArgs) ToDeviceClaimConfigurationPatchOutput() DeviceClaimConfigurationPatchOutput {
	return i.ToDeviceClaimConfigurationPatchOutputWithContext(context.Background())
}

func (i DeviceClaimConfigurationPatchArgs) ToDeviceClaimConfigurationPatchOutputWithContext(ctx context.Context) DeviceClaimConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimConfigurationPatchOutput)
}

// DeviceClaimConfigurationPatchArrayInput is an input type that accepts DeviceClaimConfigurationPatchArray and DeviceClaimConfigurationPatchArrayOutput values.
// You can construct a concrete instance of `DeviceClaimConfigurationPatchArrayInput` via:
//
//	DeviceClaimConfigurationPatchArray{ DeviceClaimConfigurationPatchArgs{...} }
type DeviceClaimConfigurationPatchArrayInput interface {
	pulumi.Input

	ToDeviceClaimConfigurationPatchArrayOutput() DeviceClaimConfigurationPatchArrayOutput
	ToDeviceClaimConfigurationPatchArrayOutputWithContext(context.Context) DeviceClaimConfigurationPatchArrayOutput
}

type DeviceClaimConfigurationPatchArray []DeviceClaimConfigurationPatchInput

func (DeviceClaimConfigurationPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClaimConfigurationPatch)(nil)).Elem()
}

func (i DeviceClaimConfigurationPatchArray) ToDeviceClaimConfigurationPatchArrayOutput() DeviceClaimConfigurationPatchArrayOutput {
	return i.ToDeviceClaimConfigurationPatchArrayOutputWithContext(context.Background())
}

func (i DeviceClaimConfigurationPatchArray) ToDeviceClaimConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceClaimConfigurationPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimConfigurationPatchArrayOutput)
}

// DeviceClaimConfiguration is used for configuration parameters in DeviceClaim.
type DeviceClaimConfigurationPatchOutput struct{ *pulumi.OutputState }

func (DeviceClaimConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimConfigurationPatch)(nil)).Elem()
}

func (o DeviceClaimConfigurationPatchOutput) ToDeviceClaimConfigurationPatchOutput() DeviceClaimConfigurationPatchOutput {
	return o
}

func (o DeviceClaimConfigurationPatchOutput) ToDeviceClaimConfigurationPatchOutputWithContext(ctx context.Context) DeviceClaimConfigurationPatchOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceClaimConfigurationPatchOutput) Opaque() OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ApplyT(func(v DeviceClaimConfigurationPatch) *OpaqueDeviceConfigurationPatch { return v.Opaque }).(OpaqueDeviceConfigurationPatchPtrOutput)
}

// Requests lists the names of requests where the configuration applies. If empty, it applies to all requests.
func (o DeviceClaimConfigurationPatchOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceClaimConfigurationPatch) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

type DeviceClaimConfigurationPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceClaimConfigurationPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClaimConfigurationPatch)(nil)).Elem()
}

func (o DeviceClaimConfigurationPatchArrayOutput) ToDeviceClaimConfigurationPatchArrayOutput() DeviceClaimConfigurationPatchArrayOutput {
	return o
}

func (o DeviceClaimConfigurationPatchArrayOutput) ToDeviceClaimConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceClaimConfigurationPatchArrayOutput {
	return o
}

func (o DeviceClaimConfigurationPatchArrayOutput) Index(i pulumi.IntInput) DeviceClaimConfigurationPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClaimConfigurationPatch {
		return vs[0].([]DeviceClaimConfigurationPatch)[vs[1].(int)]
	}).(DeviceClaimConfigurationPatchOutput)
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimPatch struct {
	// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
	Config []DeviceClaimConfigurationPatch `pulumi:"config"`
	// These constraints must be satisfied by the set of devices that get allocated for the claim.
	Constraints []DeviceConstraintPatch `pulumi:"constraints"`
	// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
	Requests []DeviceRequestPatch `pulumi:"requests"`
}

// DeviceClaimPatchInput is an input type that accepts DeviceClaimPatchArgs and DeviceClaimPatchOutput values.
// You can construct a concrete instance of `DeviceClaimPatchInput` via:
//
//	DeviceClaimPatchArgs{...}
type DeviceClaimPatchInput interface {
	pulumi.Input

	ToDeviceClaimPatchOutput() DeviceClaimPatchOutput
	ToDeviceClaimPatchOutputWithContext(context.Context) DeviceClaimPatchOutput
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimPatchArgs struct {
	// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
	Config DeviceClaimConfigurationPatchArrayInput `pulumi:"config"`
	// These constraints must be satisfied by the set of devices that get allocated for the claim.
	Constraints DeviceConstraintPatchArrayInput `pulumi:"constraints"`
	// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
	Requests DeviceRequestPatchArrayInput `pulumi:"requests"`
}

func (DeviceClaimPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimPatch)(nil)).Elem()
}

func (i DeviceClaimPatchArgs) ToDeviceClaimPatchOutput() DeviceClaimPatchOutput {
	return i.ToDeviceClaimPatchOutputWithContext(context.Background())
}

func (i DeviceClaimPatchArgs) ToDeviceClaimPatchOutputWithContext(ctx context.Context) DeviceClaimPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimPatchOutput)
}

func (i DeviceClaimPatchArgs) ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput {
	return i.ToDeviceClaimPatchPtrOutputWithContext(context.Background())
}

func (i DeviceClaimPatchArgs) ToDeviceClaimPatchPtrOutputWithContext(ctx context.Context) DeviceClaimPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimPatchOutput).ToDeviceClaimPatchPtrOutputWithContext(ctx)
}

// DeviceClaimPatchPtrInput is an input type that accepts DeviceClaimPatchArgs, DeviceClaimPatchPtr and DeviceClaimPatchPtrOutput values.
// You can construct a concrete instance of `DeviceClaimPatchPtrInput` via:
//
//	        DeviceClaimPatchArgs{...}
//
//	or:
//
//	        nil
type DeviceClaimPatchPtrInput interface {
	pulumi.Input

	ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput
	ToDeviceClaimPatchPtrOutputWithContext(context.Context) DeviceClaimPatchPtrOutput
}

type deviceClaimPatchPtrType DeviceClaimPatchArgs

func DeviceClaimPatchPtr(v *DeviceClaimPatchArgs) DeviceClaimPatchPtrInput {
	return (*deviceClaimPatchPtrType)(v)
}

func (*deviceClaimPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClaimPatch)(nil)).Elem()
}

func (i *deviceClaimPatchPtrType) ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput {
	return i.ToDeviceClaimPatchPtrOutputWithContext(context.Background())
}

func (i *deviceClaimPatchPtrType) ToDeviceClaimPatchPtrOutputWithContext(ctx context.Context) DeviceClaimPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClaimPatchPtrOutput)
}

// DeviceClaim defines how to request devices with a ResourceClaim.
type DeviceClaimPatchOutput struct{ *pulumi.OutputState }

func (DeviceClaimPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClaimPatch)(nil)).Elem()
}

func (o DeviceClaimPatchOutput) ToDeviceClaimPatchOutput() DeviceClaimPatchOutput {
	return o
}

func (o DeviceClaimPatchOutput) ToDeviceClaimPatchOutputWithContext(ctx context.Context) DeviceClaimPatchOutput {
	return o
}

func (o DeviceClaimPatchOutput) ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput {
	return o.ToDeviceClaimPatchPtrOutputWithContext(context.Background())
}

func (o DeviceClaimPatchOutput) ToDeviceClaimPatchPtrOutputWithContext(ctx context.Context) DeviceClaimPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceClaimPatch) *DeviceClaimPatch {
		return &v
	}).(DeviceClaimPatchPtrOutput)
}

// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
func (o DeviceClaimPatchOutput) Config() DeviceClaimConfigurationPatchArrayOutput {
	return o.ApplyT(func(v DeviceClaimPatch) []DeviceClaimConfigurationPatch { return v.Config }).(DeviceClaimConfigurationPatchArrayOutput)
}

// These constraints must be satisfied by the set of devices that get allocated for the claim.
func (o DeviceClaimPatchOutput) Constraints() DeviceConstraintPatchArrayOutput {
	return o.ApplyT(func(v DeviceClaimPatch) []DeviceConstraintPatch { return v.Constraints }).(DeviceConstraintPatchArrayOutput)
}

// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
func (o DeviceClaimPatchOutput) Requests() DeviceRequestPatchArrayOutput {
	return o.ApplyT(func(v DeviceClaimPatch) []DeviceRequestPatch { return v.Requests }).(DeviceRequestPatchArrayOutput)
}

type DeviceClaimPatchPtrOutput struct{ *pulumi.OutputState }

func (DeviceClaimPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClaimPatch)(nil)).Elem()
}

func (o DeviceClaimPatchPtrOutput) ToDeviceClaimPatchPtrOutput() DeviceClaimPatchPtrOutput {
	return o
}

func (o DeviceClaimPatchPtrOutput) ToDeviceClaimPatchPtrOutputWithContext(ctx context.Context) DeviceClaimPatchPtrOutput {
	return o
}

func (o DeviceClaimPatchPtrOutput) Elem() DeviceClaimPatchOutput {
	return o.ApplyT(func(v *DeviceClaimPatch) DeviceClaimPatch {
		if v != nil {
			return *v
		}
		var ret DeviceClaimPatch
		return ret
	}).(DeviceClaimPatchOutput)
}

// This field holds configuration for multiple potential drivers which could satisfy requests in this claim. It is ignored while allocating the claim.
func (o DeviceClaimPatchPtrOutput) Config() DeviceClaimConfigurationPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClaimPatch) []DeviceClaimConfigurationPatch {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceClaimConfigurationPatchArrayOutput)
}

// These constraints must be satisfied by the set of devices that get allocated for the claim.
func (o DeviceClaimPatchPtrOutput) Constraints() DeviceConstraintPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClaimPatch) []DeviceConstraintPatch {
		if v == nil {
			return nil
		}
		return v.Constraints
	}).(DeviceConstraintPatchArrayOutput)
}

// Requests represent individual requests for distinct devices which must all be satisfied. If empty, nothing needs to be allocated.
func (o DeviceClaimPatchPtrOutput) Requests() DeviceRequestPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClaimPatch) []DeviceRequestPatch {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(DeviceRequestPatchArrayOutput)
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceClassSpec `pulumi:"spec"`
}

// DeviceClassTypeInput is an input type that accepts DeviceClassTypeArgs and DeviceClassTypeOutput values.
// You can construct a concrete instance of `DeviceClassTypeInput` via:
//
//	DeviceClassTypeArgs{...}
type DeviceClassTypeInput interface {
	pulumi.Input

	ToDeviceClassTypeOutput() DeviceClassTypeOutput
	ToDeviceClassTypeOutputWithContext(context.Context) DeviceClassTypeOutput
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceClassSpecInput `pulumi:"spec"`
}

func (DeviceClassTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassType)(nil)).Elem()
}

func (i DeviceClassTypeArgs) ToDeviceClassTypeOutput() DeviceClassTypeOutput {
	return i.ToDeviceClassTypeOutputWithContext(context.Background())
}

func (i DeviceClassTypeArgs) ToDeviceClassTypeOutputWithContext(ctx context.Context) DeviceClassTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassTypeOutput)
}

// DeviceClassTypeArrayInput is an input type that accepts DeviceClassTypeArray and DeviceClassTypeArrayOutput values.
// You can construct a concrete instance of `DeviceClassTypeArrayInput` via:
//
//	DeviceClassTypeArray{ DeviceClassTypeArgs{...} }
type DeviceClassTypeArrayInput interface {
	pulumi.Input

	ToDeviceClassTypeArrayOutput() DeviceClassTypeArrayOutput
	ToDeviceClassTypeArrayOutputWithContext(context.Context) DeviceClassTypeArrayOutput
}

type DeviceClassTypeArray []DeviceClassTypeInput

func (DeviceClassTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassType)(nil)).Elem()
}

func (i DeviceClassTypeArray) ToDeviceClassTypeArrayOutput() DeviceClassTypeArrayOutput {
	return i.ToDeviceClassTypeArrayOutputWithContext(context.Background())
}

func (i DeviceClassTypeArray) ToDeviceClassTypeArrayOutputWithContext(ctx context.Context) DeviceClassTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassTypeArrayOutput)
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassTypeOutput struct{ *pulumi.OutputState }

func (DeviceClassTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassType)(nil)).Elem()
}

func (o DeviceClassTypeOutput) ToDeviceClassTypeOutput() DeviceClassTypeOutput {
	return o
}

func (o DeviceClassTypeOutput) ToDeviceClassTypeOutputWithContext(ctx context.Context) DeviceClassTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceClassTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceClassTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o DeviceClassTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v DeviceClassType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec defines what can be allocated and how to configure it.
//
// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
//
// Changing the spec automatically increments the metadata.generation number.
func (o DeviceClassTypeOutput) Spec() DeviceClassSpecOutput {
	return o.ApplyT(func(v DeviceClassType) DeviceClassSpec { return v.Spec }).(DeviceClassSpecOutput)
}

type DeviceClassTypeArrayOutput struct{ *pulumi.OutputState }

func (DeviceClassTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassType)(nil)).Elem()
}

func (o DeviceClassTypeArrayOutput) ToDeviceClassTypeArrayOutput() DeviceClassTypeArrayOutput {
	return o
}

func (o DeviceClassTypeArrayOutput) ToDeviceClassTypeArrayOutputWithContext(ctx context.Context) DeviceClassTypeArrayOutput {
	return o
}

func (o DeviceClassTypeArrayOutput) Index(i pulumi.IntInput) DeviceClassTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClassType {
		return vs[0].([]DeviceClassType)[vs[1].(int)]
	}).(DeviceClassTypeOutput)
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfiguration struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfiguration `pulumi:"opaque"`
}

// DeviceClassConfigurationInput is an input type that accepts DeviceClassConfigurationArgs and DeviceClassConfigurationOutput values.
// You can construct a concrete instance of `DeviceClassConfigurationInput` via:
//
//	DeviceClassConfigurationArgs{...}
type DeviceClassConfigurationInput interface {
	pulumi.Input

	ToDeviceClassConfigurationOutput() DeviceClassConfigurationOutput
	ToDeviceClassConfigurationOutputWithContext(context.Context) DeviceClassConfigurationOutput
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPtrInput `pulumi:"opaque"`
}

func (DeviceClassConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassConfiguration)(nil)).Elem()
}

func (i DeviceClassConfigurationArgs) ToDeviceClassConfigurationOutput() DeviceClassConfigurationOutput {
	return i.ToDeviceClassConfigurationOutputWithContext(context.Background())
}

func (i DeviceClassConfigurationArgs) ToDeviceClassConfigurationOutputWithContext(ctx context.Context) DeviceClassConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassConfigurationOutput)
}

// DeviceClassConfigurationArrayInput is an input type that accepts DeviceClassConfigurationArray and DeviceClassConfigurationArrayOutput values.
// You can construct a concrete instance of `DeviceClassConfigurationArrayInput` via:
//
//	DeviceClassConfigurationArray{ DeviceClassConfigurationArgs{...} }
type DeviceClassConfigurationArrayInput interface {
	pulumi.Input

	ToDeviceClassConfigurationArrayOutput() DeviceClassConfigurationArrayOutput
	ToDeviceClassConfigurationArrayOutputWithContext(context.Context) DeviceClassConfigurationArrayOutput
}

type DeviceClassConfigurationArray []DeviceClassConfigurationInput

func (DeviceClassConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassConfiguration)(nil)).Elem()
}

func (i DeviceClassConfigurationArray) ToDeviceClassConfigurationArrayOutput() DeviceClassConfigurationArrayOutput {
	return i.ToDeviceClassConfigurationArrayOutputWithContext(context.Background())
}

func (i DeviceClassConfigurationArray) ToDeviceClassConfigurationArrayOutputWithContext(ctx context.Context) DeviceClassConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassConfigurationArrayOutput)
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationOutput struct{ *pulumi.OutputState }

func (DeviceClassConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassConfiguration)(nil)).Elem()
}

func (o DeviceClassConfigurationOutput) ToDeviceClassConfigurationOutput() DeviceClassConfigurationOutput {
	return o
}

func (o DeviceClassConfigurationOutput) ToDeviceClassConfigurationOutputWithContext(ctx context.Context) DeviceClassConfigurationOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceClassConfigurationOutput) Opaque() OpaqueDeviceConfigurationPtrOutput {
	return o.ApplyT(func(v DeviceClassConfiguration) *OpaqueDeviceConfiguration { return v.Opaque }).(OpaqueDeviceConfigurationPtrOutput)
}

type DeviceClassConfigurationArrayOutput struct{ *pulumi.OutputState }

func (DeviceClassConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassConfiguration)(nil)).Elem()
}

func (o DeviceClassConfigurationArrayOutput) ToDeviceClassConfigurationArrayOutput() DeviceClassConfigurationArrayOutput {
	return o
}

func (o DeviceClassConfigurationArrayOutput) ToDeviceClassConfigurationArrayOutputWithContext(ctx context.Context) DeviceClassConfigurationArrayOutput {
	return o
}

func (o DeviceClassConfigurationArrayOutput) Index(i pulumi.IntInput) DeviceClassConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClassConfiguration {
		return vs[0].([]DeviceClassConfiguration)[vs[1].(int)]
	}).(DeviceClassConfigurationOutput)
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationPatch struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque *OpaqueDeviceConfigurationPatch `pulumi:"opaque"`
}

// DeviceClassConfigurationPatchInput is an input type that accepts DeviceClassConfigurationPatchArgs and DeviceClassConfigurationPatchOutput values.
// You can construct a concrete instance of `DeviceClassConfigurationPatchInput` via:
//
//	DeviceClassConfigurationPatchArgs{...}
type DeviceClassConfigurationPatchInput interface {
	pulumi.Input

	ToDeviceClassConfigurationPatchOutput() DeviceClassConfigurationPatchOutput
	ToDeviceClassConfigurationPatchOutputWithContext(context.Context) DeviceClassConfigurationPatchOutput
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationPatchArgs struct {
	// Opaque provides driver-specific configuration parameters.
	Opaque OpaqueDeviceConfigurationPatchPtrInput `pulumi:"opaque"`
}

func (DeviceClassConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassConfigurationPatch)(nil)).Elem()
}

func (i DeviceClassConfigurationPatchArgs) ToDeviceClassConfigurationPatchOutput() DeviceClassConfigurationPatchOutput {
	return i.ToDeviceClassConfigurationPatchOutputWithContext(context.Background())
}

func (i DeviceClassConfigurationPatchArgs) ToDeviceClassConfigurationPatchOutputWithContext(ctx context.Context) DeviceClassConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassConfigurationPatchOutput)
}

// DeviceClassConfigurationPatchArrayInput is an input type that accepts DeviceClassConfigurationPatchArray and DeviceClassConfigurationPatchArrayOutput values.
// You can construct a concrete instance of `DeviceClassConfigurationPatchArrayInput` via:
//
//	DeviceClassConfigurationPatchArray{ DeviceClassConfigurationPatchArgs{...} }
type DeviceClassConfigurationPatchArrayInput interface {
	pulumi.Input

	ToDeviceClassConfigurationPatchArrayOutput() DeviceClassConfigurationPatchArrayOutput
	ToDeviceClassConfigurationPatchArrayOutputWithContext(context.Context) DeviceClassConfigurationPatchArrayOutput
}

type DeviceClassConfigurationPatchArray []DeviceClassConfigurationPatchInput

func (DeviceClassConfigurationPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassConfigurationPatch)(nil)).Elem()
}

func (i DeviceClassConfigurationPatchArray) ToDeviceClassConfigurationPatchArrayOutput() DeviceClassConfigurationPatchArrayOutput {
	return i.ToDeviceClassConfigurationPatchArrayOutputWithContext(context.Background())
}

func (i DeviceClassConfigurationPatchArray) ToDeviceClassConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceClassConfigurationPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassConfigurationPatchArrayOutput)
}

// DeviceClassConfiguration is used in DeviceClass.
type DeviceClassConfigurationPatchOutput struct{ *pulumi.OutputState }

func (DeviceClassConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassConfigurationPatch)(nil)).Elem()
}

func (o DeviceClassConfigurationPatchOutput) ToDeviceClassConfigurationPatchOutput() DeviceClassConfigurationPatchOutput {
	return o
}

func (o DeviceClassConfigurationPatchOutput) ToDeviceClassConfigurationPatchOutputWithContext(ctx context.Context) DeviceClassConfigurationPatchOutput {
	return o
}

// Opaque provides driver-specific configuration parameters.
func (o DeviceClassConfigurationPatchOutput) Opaque() OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ApplyT(func(v DeviceClassConfigurationPatch) *OpaqueDeviceConfigurationPatch { return v.Opaque }).(OpaqueDeviceConfigurationPatchPtrOutput)
}

type DeviceClassConfigurationPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceClassConfigurationPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceClassConfigurationPatch)(nil)).Elem()
}

func (o DeviceClassConfigurationPatchArrayOutput) ToDeviceClassConfigurationPatchArrayOutput() DeviceClassConfigurationPatchArrayOutput {
	return o
}

func (o DeviceClassConfigurationPatchArrayOutput) ToDeviceClassConfigurationPatchArrayOutputWithContext(ctx context.Context) DeviceClassConfigurationPatchArrayOutput {
	return o
}

func (o DeviceClassConfigurationPatchArrayOutput) Index(i pulumi.IntInput) DeviceClassConfigurationPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceClassConfigurationPatch {
		return vs[0].([]DeviceClassConfigurationPatch)[vs[1].(int)]
	}).(DeviceClassConfigurationPatchOutput)
}

// DeviceClassList is a collection of classes.
type DeviceClassListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of resource classes.
	Items []DeviceClassType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// DeviceClassListTypeInput is an input type that accepts DeviceClassListTypeArgs and DeviceClassListTypeOutput values.
// You can construct a concrete instance of `DeviceClassListTypeInput` via:
//
//	DeviceClassListTypeArgs{...}
type DeviceClassListTypeInput interface {
	pulumi.Input

	ToDeviceClassListTypeOutput() DeviceClassListTypeOutput
	ToDeviceClassListTypeOutputWithContext(context.Context) DeviceClassListTypeOutput
}

// DeviceClassList is a collection of classes.
type DeviceClassListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of resource classes.
	Items DeviceClassTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (DeviceClassListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassListType)(nil)).Elem()
}

func (i DeviceClassListTypeArgs) ToDeviceClassListTypeOutput() DeviceClassListTypeOutput {
	return i.ToDeviceClassListTypeOutputWithContext(context.Background())
}

func (i DeviceClassListTypeArgs) ToDeviceClassListTypeOutputWithContext(ctx context.Context) DeviceClassListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassListTypeOutput)
}

// DeviceClassList is a collection of classes.
type DeviceClassListTypeOutput struct{ *pulumi.OutputState }

func (DeviceClassListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassListType)(nil)).Elem()
}

func (o DeviceClassListTypeOutput) ToDeviceClassListTypeOutput() DeviceClassListTypeOutput {
	return o
}

func (o DeviceClassListTypeOutput) ToDeviceClassListTypeOutputWithContext(ctx context.Context) DeviceClassListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceClassListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of resource classes.
func (o DeviceClassListTypeOutput) Items() DeviceClassTypeArrayOutput {
	return o.ApplyT(func(v DeviceClassListType) []DeviceClassType { return v.Items }).(DeviceClassTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceClassListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o DeviceClassListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v DeviceClassListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec *DeviceClassSpecPatch `pulumi:"spec"`
}

// DeviceClassPatchTypeInput is an input type that accepts DeviceClassPatchTypeArgs and DeviceClassPatchTypeOutput values.
// You can construct a concrete instance of `DeviceClassPatchTypeInput` via:
//
//	DeviceClassPatchTypeArgs{...}
type DeviceClassPatchTypeInput interface {
	pulumi.Input

	ToDeviceClassPatchTypeOutput() DeviceClassPatchTypeOutput
	ToDeviceClassPatchTypeOutputWithContext(context.Context) DeviceClassPatchTypeOutput
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Spec defines what can be allocated and how to configure it.
	//
	// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceClassSpecPatchPtrInput `pulumi:"spec"`
}

func (DeviceClassPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassPatchType)(nil)).Elem()
}

func (i DeviceClassPatchTypeArgs) ToDeviceClassPatchTypeOutput() DeviceClassPatchTypeOutput {
	return i.ToDeviceClassPatchTypeOutputWithContext(context.Background())
}

func (i DeviceClassPatchTypeArgs) ToDeviceClassPatchTypeOutputWithContext(ctx context.Context) DeviceClassPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassPatchTypeOutput)
}

// DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type DeviceClassPatchTypeOutput struct{ *pulumi.OutputState }

func (DeviceClassPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassPatchType)(nil)).Elem()
}

func (o DeviceClassPatchTypeOutput) ToDeviceClassPatchTypeOutput() DeviceClassPatchTypeOutput {
	return o
}

func (o DeviceClassPatchTypeOutput) ToDeviceClassPatchTypeOutputWithContext(ctx context.Context) DeviceClassPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceClassPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceClassPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceClassPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o DeviceClassPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v DeviceClassPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec defines what can be allocated and how to configure it.
//
// This is mutable. Consumers have to be prepared for classes changing at any time, either because they get updated or replaced. Claim allocations are done once based on whatever was set in classes at the time of allocation.
//
// Changing the spec automatically increments the metadata.generation number.
func (o DeviceClassPatchTypeOutput) Spec() DeviceClassSpecPatchPtrOutput {
	return o.ApplyT(func(v DeviceClassPatchType) *DeviceClassSpecPatch { return v.Spec }).(DeviceClassSpecPatchPtrOutput)
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpec struct {
	// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
	//
	// They are passed to the driver, but are not considered while allocating the claim.
	Config []DeviceClassConfiguration `pulumi:"config"`
	// Each selector must be satisfied by a device which is claimed via this class.
	Selectors []DeviceSelector `pulumi:"selectors"`
	// Only nodes matching the selector will be considered by the scheduler when trying to find a Node that fits a Pod when that Pod uses a claim that has not been allocated yet *and* that claim gets allocated through a control plane controller. It is ignored when the claim does not use a control plane controller for allocation.
	//
	// Setting this field is optional. If unset, all Nodes are candidates.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	SuitableNodes *corev1.NodeSelector `pulumi:"suitableNodes"`
}

// DeviceClassSpecInput is an input type that accepts DeviceClassSpecArgs and DeviceClassSpecOutput values.
// You can construct a concrete instance of `DeviceClassSpecInput` via:
//
//	DeviceClassSpecArgs{...}
type DeviceClassSpecInput interface {
	pulumi.Input

	ToDeviceClassSpecOutput() DeviceClassSpecOutput
	ToDeviceClassSpecOutputWithContext(context.Context) DeviceClassSpecOutput
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecArgs struct {
	// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
	//
	// They are passed to the driver, but are not considered while allocating the claim.
	Config DeviceClassConfigurationArrayInput `pulumi:"config"`
	// Each selector must be satisfied by a device which is claimed via this class.
	Selectors DeviceSelectorArrayInput `pulumi:"selectors"`
	// Only nodes matching the selector will be considered by the scheduler when trying to find a Node that fits a Pod when that Pod uses a claim that has not been allocated yet *and* that claim gets allocated through a control plane controller. It is ignored when the claim does not use a control plane controller for allocation.
	//
	// Setting this field is optional. If unset, all Nodes are candidates.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	SuitableNodes corev1.NodeSelectorPtrInput `pulumi:"suitableNodes"`
}

func (DeviceClassSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassSpec)(nil)).Elem()
}

func (i DeviceClassSpecArgs) ToDeviceClassSpecOutput() DeviceClassSpecOutput {
	return i.ToDeviceClassSpecOutputWithContext(context.Background())
}

func (i DeviceClassSpecArgs) ToDeviceClassSpecOutputWithContext(ctx context.Context) DeviceClassSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassSpecOutput)
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecOutput struct{ *pulumi.OutputState }

func (DeviceClassSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassSpec)(nil)).Elem()
}

func (o DeviceClassSpecOutput) ToDeviceClassSpecOutput() DeviceClassSpecOutput {
	return o
}

func (o DeviceClassSpecOutput) ToDeviceClassSpecOutputWithContext(ctx context.Context) DeviceClassSpecOutput {
	return o
}

// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
//
// They are passed to the driver, but are not considered while allocating the claim.
func (o DeviceClassSpecOutput) Config() DeviceClassConfigurationArrayOutput {
	return o.ApplyT(func(v DeviceClassSpec) []DeviceClassConfiguration { return v.Config }).(DeviceClassConfigurationArrayOutput)
}

// Each selector must be satisfied by a device which is claimed via this class.
func (o DeviceClassSpecOutput) Selectors() DeviceSelectorArrayOutput {
	return o.ApplyT(func(v DeviceClassSpec) []DeviceSelector { return v.Selectors }).(DeviceSelectorArrayOutput)
}

// Only nodes matching the selector will be considered by the scheduler when trying to find a Node that fits a Pod when that Pod uses a claim that has not been allocated yet *and* that claim gets allocated through a control plane controller. It is ignored when the claim does not use a control plane controller for allocation.
//
// Setting this field is optional. If unset, all Nodes are candidates.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o DeviceClassSpecOutput) SuitableNodes() corev1.NodeSelectorPtrOutput {
	return o.ApplyT(func(v DeviceClassSpec) *corev1.NodeSelector { return v.SuitableNodes }).(corev1.NodeSelectorPtrOutput)
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecPatch struct {
	// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
	//
	// They are passed to the driver, but are not considered while allocating the claim.
	Config []DeviceClassConfigurationPatch `pulumi:"config"`
	// Each selector must be satisfied by a device which is claimed via this class.
	Selectors []DeviceSelectorPatch `pulumi:"selectors"`
	// Only nodes matching the selector will be considered by the scheduler when trying to find a Node that fits a Pod when that Pod uses a claim that has not been allocated yet *and* that claim gets allocated through a control plane controller. It is ignored when the claim does not use a control plane controller for allocation.
	//
	// Setting this field is optional. If unset, all Nodes are candidates.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	SuitableNodes *corev1.NodeSelectorPatch `pulumi:"suitableNodes"`
}

// DeviceClassSpecPatchInput is an input type that accepts DeviceClassSpecPatchArgs and DeviceClassSpecPatchOutput values.
// You can construct a concrete instance of `DeviceClassSpecPatchInput` via:
//
//	DeviceClassSpecPatchArgs{...}
type DeviceClassSpecPatchInput interface {
	pulumi.Input

	ToDeviceClassSpecPatchOutput() DeviceClassSpecPatchOutput
	ToDeviceClassSpecPatchOutputWithContext(context.Context) DeviceClassSpecPatchOutput
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecPatchArgs struct {
	// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
	//
	// They are passed to the driver, but are not considered while allocating the claim.
	Config DeviceClassConfigurationPatchArrayInput `pulumi:"config"`
	// Each selector must be satisfied by a device which is claimed via this class.
	Selectors DeviceSelectorPatchArrayInput `pulumi:"selectors"`
	// Only nodes matching the selector will be considered by the scheduler when trying to find a Node that fits a Pod when that Pod uses a claim that has not been allocated yet *and* that claim gets allocated through a control plane controller. It is ignored when the claim does not use a control plane controller for allocation.
	//
	// Setting this field is optional. If unset, all Nodes are candidates.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	SuitableNodes corev1.NodeSelectorPatchPtrInput `pulumi:"suitableNodes"`
}

func (DeviceClassSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassSpecPatch)(nil)).Elem()
}

func (i DeviceClassSpecPatchArgs) ToDeviceClassSpecPatchOutput() DeviceClassSpecPatchOutput {
	return i.ToDeviceClassSpecPatchOutputWithContext(context.Background())
}

func (i DeviceClassSpecPatchArgs) ToDeviceClassSpecPatchOutputWithContext(ctx context.Context) DeviceClassSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassSpecPatchOutput)
}

func (i DeviceClassSpecPatchArgs) ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput {
	return i.ToDeviceClassSpecPatchPtrOutputWithContext(context.Background())
}

func (i DeviceClassSpecPatchArgs) ToDeviceClassSpecPatchPtrOutputWithContext(ctx context.Context) DeviceClassSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassSpecPatchOutput).ToDeviceClassSpecPatchPtrOutputWithContext(ctx)
}

// DeviceClassSpecPatchPtrInput is an input type that accepts DeviceClassSpecPatchArgs, DeviceClassSpecPatchPtr and DeviceClassSpecPatchPtrOutput values.
// You can construct a concrete instance of `DeviceClassSpecPatchPtrInput` via:
//
//	        DeviceClassSpecPatchArgs{...}
//
//	or:
//
//	        nil
type DeviceClassSpecPatchPtrInput interface {
	pulumi.Input

	ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput
	ToDeviceClassSpecPatchPtrOutputWithContext(context.Context) DeviceClassSpecPatchPtrOutput
}

type deviceClassSpecPatchPtrType DeviceClassSpecPatchArgs

func DeviceClassSpecPatchPtr(v *DeviceClassSpecPatchArgs) DeviceClassSpecPatchPtrInput {
	return (*deviceClassSpecPatchPtrType)(v)
}

func (*deviceClassSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClassSpecPatch)(nil)).Elem()
}

func (i *deviceClassSpecPatchPtrType) ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput {
	return i.ToDeviceClassSpecPatchPtrOutputWithContext(context.Background())
}

func (i *deviceClassSpecPatchPtrType) ToDeviceClassSpecPatchPtrOutputWithContext(ctx context.Context) DeviceClassSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceClassSpecPatchPtrOutput)
}

// DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it.
type DeviceClassSpecPatchOutput struct{ *pulumi.OutputState }

func (DeviceClassSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceClassSpecPatch)(nil)).Elem()
}

func (o DeviceClassSpecPatchOutput) ToDeviceClassSpecPatchOutput() DeviceClassSpecPatchOutput {
	return o
}

func (o DeviceClassSpecPatchOutput) ToDeviceClassSpecPatchOutputWithContext(ctx context.Context) DeviceClassSpecPatchOutput {
	return o
}

func (o DeviceClassSpecPatchOutput) ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput {
	return o.ToDeviceClassSpecPatchPtrOutputWithContext(context.Background())
}

func (o DeviceClassSpecPatchOutput) ToDeviceClassSpecPatchPtrOutputWithContext(ctx context.Context) DeviceClassSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceClassSpecPatch) *DeviceClassSpecPatch {
		return &v
	}).(DeviceClassSpecPatchPtrOutput)
}

// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
//
// They are passed to the driver, but are not considered while allocating the claim.
func (o DeviceClassSpecPatchOutput) Config() DeviceClassConfigurationPatchArrayOutput {
	return o.ApplyT(func(v DeviceClassSpecPatch) []DeviceClassConfigurationPatch { return v.Config }).(DeviceClassConfigurationPatchArrayOutput)
}

// Each selector must be satisfied by a device which is claimed via this class.
func (o DeviceClassSpecPatchOutput) Selectors() DeviceSelectorPatchArrayOutput {
	return o.ApplyT(func(v DeviceClassSpecPatch) []DeviceSelectorPatch { return v.Selectors }).(DeviceSelectorPatchArrayOutput)
}

// Only nodes matching the selector will be considered by the scheduler when trying to find a Node that fits a Pod when that Pod uses a claim that has not been allocated yet *and* that claim gets allocated through a control plane controller. It is ignored when the claim does not use a control plane controller for allocation.
//
// Setting this field is optional. If unset, all Nodes are candidates.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o DeviceClassSpecPatchOutput) SuitableNodes() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v DeviceClassSpecPatch) *corev1.NodeSelectorPatch { return v.SuitableNodes }).(corev1.NodeSelectorPatchPtrOutput)
}

type DeviceClassSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (DeviceClassSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceClassSpecPatch)(nil)).Elem()
}

func (o DeviceClassSpecPatchPtrOutput) ToDeviceClassSpecPatchPtrOutput() DeviceClassSpecPatchPtrOutput {
	return o
}

func (o DeviceClassSpecPatchPtrOutput) ToDeviceClassSpecPatchPtrOutputWithContext(ctx context.Context) DeviceClassSpecPatchPtrOutput {
	return o
}

func (o DeviceClassSpecPatchPtrOutput) Elem() DeviceClassSpecPatchOutput {
	return o.ApplyT(func(v *DeviceClassSpecPatch) DeviceClassSpecPatch {
		if v != nil {
			return *v
		}
		var ret DeviceClassSpecPatch
		return ret
	}).(DeviceClassSpecPatchOutput)
}

// Config defines configuration parameters that apply to each device that is claimed via this class. Some classses may potentially be satisfied by multiple drivers, so each instance of a vendor configuration applies to exactly one driver.
//
// They are passed to the driver, but are not considered while allocating the claim.
func (o DeviceClassSpecPatchPtrOutput) Config() DeviceClassConfigurationPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClassSpecPatch) []DeviceClassConfigurationPatch {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeviceClassConfigurationPatchArrayOutput)
}

// Each selector must be satisfied by a device which is claimed via this class.
func (o DeviceClassSpecPatchPtrOutput) Selectors() DeviceSelectorPatchArrayOutput {
	return o.ApplyT(func(v *DeviceClassSpecPatch) []DeviceSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selectors
	}).(DeviceSelectorPatchArrayOutput)
}

// Only nodes matching the selector will be considered by the scheduler when trying to find a Node that fits a Pod when that Pod uses a claim that has not been allocated yet *and* that claim gets allocated through a control plane controller. It is ignored when the claim does not use a control plane controller for allocation.
//
// Setting this field is optional. If unset, all Nodes are candidates.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o DeviceClassSpecPatchPtrOutput) SuitableNodes() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v *DeviceClassSpecPatch) *corev1.NodeSelectorPatch {
		if v == nil {
			return nil
		}
		return v.SuitableNodes
	}).(corev1.NodeSelectorPatchPtrOutput)
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraint struct {
	// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
	//
	// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
	//
	// Must include the domain qualifier.
	MatchAttribute *string `pulumi:"matchAttribute"`
	// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
	Requests []string `pulumi:"requests"`
}

// DeviceConstraintInput is an input type that accepts DeviceConstraintArgs and DeviceConstraintOutput values.
// You can construct a concrete instance of `DeviceConstraintInput` via:
//
//	DeviceConstraintArgs{...}
type DeviceConstraintInput interface {
	pulumi.Input

	ToDeviceConstraintOutput() DeviceConstraintOutput
	ToDeviceConstraintOutputWithContext(context.Context) DeviceConstraintOutput
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintArgs struct {
	// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
	//
	// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
	//
	// Must include the domain qualifier.
	MatchAttribute pulumi.StringPtrInput `pulumi:"matchAttribute"`
	// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
}

func (DeviceConstraintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceConstraint)(nil)).Elem()
}

func (i DeviceConstraintArgs) ToDeviceConstraintOutput() DeviceConstraintOutput {
	return i.ToDeviceConstraintOutputWithContext(context.Background())
}

func (i DeviceConstraintArgs) ToDeviceConstraintOutputWithContext(ctx context.Context) DeviceConstraintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceConstraintOutput)
}

// DeviceConstraintArrayInput is an input type that accepts DeviceConstraintArray and DeviceConstraintArrayOutput values.
// You can construct a concrete instance of `DeviceConstraintArrayInput` via:
//
//	DeviceConstraintArray{ DeviceConstraintArgs{...} }
type DeviceConstraintArrayInput interface {
	pulumi.Input

	ToDeviceConstraintArrayOutput() DeviceConstraintArrayOutput
	ToDeviceConstraintArrayOutputWithContext(context.Context) DeviceConstraintArrayOutput
}

type DeviceConstraintArray []DeviceConstraintInput

func (DeviceConstraintArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceConstraint)(nil)).Elem()
}

func (i DeviceConstraintArray) ToDeviceConstraintArrayOutput() DeviceConstraintArrayOutput {
	return i.ToDeviceConstraintArrayOutputWithContext(context.Background())
}

func (i DeviceConstraintArray) ToDeviceConstraintArrayOutputWithContext(ctx context.Context) DeviceConstraintArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceConstraintArrayOutput)
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintOutput struct{ *pulumi.OutputState }

func (DeviceConstraintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceConstraint)(nil)).Elem()
}

func (o DeviceConstraintOutput) ToDeviceConstraintOutput() DeviceConstraintOutput {
	return o
}

func (o DeviceConstraintOutput) ToDeviceConstraintOutputWithContext(ctx context.Context) DeviceConstraintOutput {
	return o
}

// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
//
// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
//
// Must include the domain qualifier.
func (o DeviceConstraintOutput) MatchAttribute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceConstraint) *string { return v.MatchAttribute }).(pulumi.StringPtrOutput)
}

// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
func (o DeviceConstraintOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceConstraint) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

type DeviceConstraintArrayOutput struct{ *pulumi.OutputState }

func (DeviceConstraintArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceConstraint)(nil)).Elem()
}

func (o DeviceConstraintArrayOutput) ToDeviceConstraintArrayOutput() DeviceConstraintArrayOutput {
	return o
}

func (o DeviceConstraintArrayOutput) ToDeviceConstraintArrayOutputWithContext(ctx context.Context) DeviceConstraintArrayOutput {
	return o
}

func (o DeviceConstraintArrayOutput) Index(i pulumi.IntInput) DeviceConstraintOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceConstraint {
		return vs[0].([]DeviceConstraint)[vs[1].(int)]
	}).(DeviceConstraintOutput)
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintPatch struct {
	// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
	//
	// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
	//
	// Must include the domain qualifier.
	MatchAttribute *string `pulumi:"matchAttribute"`
	// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
	Requests []string `pulumi:"requests"`
}

// DeviceConstraintPatchInput is an input type that accepts DeviceConstraintPatchArgs and DeviceConstraintPatchOutput values.
// You can construct a concrete instance of `DeviceConstraintPatchInput` via:
//
//	DeviceConstraintPatchArgs{...}
type DeviceConstraintPatchInput interface {
	pulumi.Input

	ToDeviceConstraintPatchOutput() DeviceConstraintPatchOutput
	ToDeviceConstraintPatchOutputWithContext(context.Context) DeviceConstraintPatchOutput
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintPatchArgs struct {
	// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
	//
	// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
	//
	// Must include the domain qualifier.
	MatchAttribute pulumi.StringPtrInput `pulumi:"matchAttribute"`
	// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
	Requests pulumi.StringArrayInput `pulumi:"requests"`
}

func (DeviceConstraintPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceConstraintPatch)(nil)).Elem()
}

func (i DeviceConstraintPatchArgs) ToDeviceConstraintPatchOutput() DeviceConstraintPatchOutput {
	return i.ToDeviceConstraintPatchOutputWithContext(context.Background())
}

func (i DeviceConstraintPatchArgs) ToDeviceConstraintPatchOutputWithContext(ctx context.Context) DeviceConstraintPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceConstraintPatchOutput)
}

// DeviceConstraintPatchArrayInput is an input type that accepts DeviceConstraintPatchArray and DeviceConstraintPatchArrayOutput values.
// You can construct a concrete instance of `DeviceConstraintPatchArrayInput` via:
//
//	DeviceConstraintPatchArray{ DeviceConstraintPatchArgs{...} }
type DeviceConstraintPatchArrayInput interface {
	pulumi.Input

	ToDeviceConstraintPatchArrayOutput() DeviceConstraintPatchArrayOutput
	ToDeviceConstraintPatchArrayOutputWithContext(context.Context) DeviceConstraintPatchArrayOutput
}

type DeviceConstraintPatchArray []DeviceConstraintPatchInput

func (DeviceConstraintPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceConstraintPatch)(nil)).Elem()
}

func (i DeviceConstraintPatchArray) ToDeviceConstraintPatchArrayOutput() DeviceConstraintPatchArrayOutput {
	return i.ToDeviceConstraintPatchArrayOutputWithContext(context.Background())
}

func (i DeviceConstraintPatchArray) ToDeviceConstraintPatchArrayOutputWithContext(ctx context.Context) DeviceConstraintPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceConstraintPatchArrayOutput)
}

// DeviceConstraint must have exactly one field set besides Requests.
type DeviceConstraintPatchOutput struct{ *pulumi.OutputState }

func (DeviceConstraintPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceConstraintPatch)(nil)).Elem()
}

func (o DeviceConstraintPatchOutput) ToDeviceConstraintPatchOutput() DeviceConstraintPatchOutput {
	return o
}

func (o DeviceConstraintPatchOutput) ToDeviceConstraintPatchOutputWithContext(ctx context.Context) DeviceConstraintPatchOutput {
	return o
}

// MatchAttribute requires that all devices in question have this attribute and that its type and value are the same across those devices.
//
// For example, if you specified "dra.example.com/numa" (a hypothetical example!), then only devices in the same NUMA node will be chosen. A device which does not have that attribute will not be chosen. All devices should use a value of the same type for this attribute because that is part of its specification, but if one device doesn't, then it also will not be chosen.
//
// Must include the domain qualifier.
func (o DeviceConstraintPatchOutput) MatchAttribute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceConstraintPatch) *string { return v.MatchAttribute }).(pulumi.StringPtrOutput)
}

// Requests is a list of the one or more requests in this claim which must co-satisfy this constraint. If a request is fulfilled by multiple devices, then all of the devices must satisfy the constraint. If this is not specified, this constraint applies to all requests in this claim.
func (o DeviceConstraintPatchOutput) Requests() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeviceConstraintPatch) []string { return v.Requests }).(pulumi.StringArrayOutput)
}

type DeviceConstraintPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceConstraintPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceConstraintPatch)(nil)).Elem()
}

func (o DeviceConstraintPatchArrayOutput) ToDeviceConstraintPatchArrayOutput() DeviceConstraintPatchArrayOutput {
	return o
}

func (o DeviceConstraintPatchArrayOutput) ToDeviceConstraintPatchArrayOutputWithContext(ctx context.Context) DeviceConstraintPatchArrayOutput {
	return o
}

func (o DeviceConstraintPatchArrayOutput) Index(i pulumi.IntInput) DeviceConstraintPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceConstraintPatch {
		return vs[0].([]DeviceConstraintPatch)[vs[1].(int)]
	}).(DeviceConstraintPatchOutput)
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DevicePatch struct {
	// Basic defines one device instance.
	Basic *BasicDevicePatch `pulumi:"basic"`
	// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
	Name *string `pulumi:"name"`
}

// DevicePatchInput is an input type that accepts DevicePatchArgs and DevicePatchOutput values.
// You can construct a concrete instance of `DevicePatchInput` via:
//
//	DevicePatchArgs{...}
type DevicePatchInput interface {
	pulumi.Input

	ToDevicePatchOutput() DevicePatchOutput
	ToDevicePatchOutputWithContext(context.Context) DevicePatchOutput
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DevicePatchArgs struct {
	// Basic defines one device instance.
	Basic BasicDevicePatchPtrInput `pulumi:"basic"`
	// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (DevicePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePatch)(nil)).Elem()
}

func (i DevicePatchArgs) ToDevicePatchOutput() DevicePatchOutput {
	return i.ToDevicePatchOutputWithContext(context.Background())
}

func (i DevicePatchArgs) ToDevicePatchOutputWithContext(ctx context.Context) DevicePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePatchOutput)
}

// DevicePatchArrayInput is an input type that accepts DevicePatchArray and DevicePatchArrayOutput values.
// You can construct a concrete instance of `DevicePatchArrayInput` via:
//
//	DevicePatchArray{ DevicePatchArgs{...} }
type DevicePatchArrayInput interface {
	pulumi.Input

	ToDevicePatchArrayOutput() DevicePatchArrayOutput
	ToDevicePatchArrayOutputWithContext(context.Context) DevicePatchArrayOutput
}

type DevicePatchArray []DevicePatchInput

func (DevicePatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DevicePatch)(nil)).Elem()
}

func (i DevicePatchArray) ToDevicePatchArrayOutput() DevicePatchArrayOutput {
	return i.ToDevicePatchArrayOutputWithContext(context.Background())
}

func (i DevicePatchArray) ToDevicePatchArrayOutputWithContext(ctx context.Context) DevicePatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePatchArrayOutput)
}

// Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set.
type DevicePatchOutput struct{ *pulumi.OutputState }

func (DevicePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePatch)(nil)).Elem()
}

func (o DevicePatchOutput) ToDevicePatchOutput() DevicePatchOutput {
	return o
}

func (o DevicePatchOutput) ToDevicePatchOutputWithContext(ctx context.Context) DevicePatchOutput {
	return o
}

// Basic defines one device instance.
func (o DevicePatchOutput) Basic() BasicDevicePatchPtrOutput {
	return o.ApplyT(func(v DevicePatch) *BasicDevicePatch { return v.Basic }).(BasicDevicePatchPtrOutput)
}

// Name is unique identifier among all devices managed by the driver in the pool. It must be a DNS label.
func (o DevicePatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DevicePatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type DevicePatchArrayOutput struct{ *pulumi.OutputState }

func (DevicePatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DevicePatch)(nil)).Elem()
}

func (o DevicePatchArrayOutput) ToDevicePatchArrayOutput() DevicePatchArrayOutput {
	return o
}

func (o DevicePatchArrayOutput) ToDevicePatchArrayOutputWithContext(ctx context.Context) DevicePatchArrayOutput {
	return o
}

func (o DevicePatchArrayOutput) Index(i pulumi.IntInput) DevicePatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DevicePatch {
		return vs[0].([]DevicePatch)[vs[1].(int)]
	}).(DevicePatchOutput)
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// A DeviceClassName is currently required. Clients must check that it is indeed set. It's absence indicates that something changed in a way that is not supported by the client yet, in which case it must refuse to handle the request.
type DeviceRequest struct {
	// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
	AdminAccess *bool `pulumi:"adminAccess"`
	// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This request is for all of the matching devices in a pool.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AlloctionMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode *string `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	Count *int `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
	//
	// A class is required. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName string `pulumi:"deviceClassName"`
	// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
	//
	// Must be a DNS label.
	Name string `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
	Selectors []DeviceSelector `pulumi:"selectors"`
}

// DeviceRequestInput is an input type that accepts DeviceRequestArgs and DeviceRequestOutput values.
// You can construct a concrete instance of `DeviceRequestInput` via:
//
//	DeviceRequestArgs{...}
type DeviceRequestInput interface {
	pulumi.Input

	ToDeviceRequestOutput() DeviceRequestOutput
	ToDeviceRequestOutputWithContext(context.Context) DeviceRequestOutput
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// A DeviceClassName is currently required. Clients must check that it is indeed set. It's absence indicates that something changed in a way that is not supported by the client yet, in which case it must refuse to handle the request.
type DeviceRequestArgs struct {
	// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
	AdminAccess pulumi.BoolPtrInput `pulumi:"adminAccess"`
	// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This request is for all of the matching devices in a pool.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AlloctionMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode pulumi.StringPtrInput `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
	//
	// A class is required. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName pulumi.StringInput `pulumi:"deviceClassName"`
	// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
	//
	// Must be a DNS label.
	Name pulumi.StringInput `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
	Selectors DeviceSelectorArrayInput `pulumi:"selectors"`
}

func (DeviceRequestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequest)(nil)).Elem()
}

func (i DeviceRequestArgs) ToDeviceRequestOutput() DeviceRequestOutput {
	return i.ToDeviceRequestOutputWithContext(context.Background())
}

func (i DeviceRequestArgs) ToDeviceRequestOutputWithContext(ctx context.Context) DeviceRequestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestOutput)
}

// DeviceRequestArrayInput is an input type that accepts DeviceRequestArray and DeviceRequestArrayOutput values.
// You can construct a concrete instance of `DeviceRequestArrayInput` via:
//
//	DeviceRequestArray{ DeviceRequestArgs{...} }
type DeviceRequestArrayInput interface {
	pulumi.Input

	ToDeviceRequestArrayOutput() DeviceRequestArrayOutput
	ToDeviceRequestArrayOutputWithContext(context.Context) DeviceRequestArrayOutput
}

type DeviceRequestArray []DeviceRequestInput

func (DeviceRequestArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequest)(nil)).Elem()
}

func (i DeviceRequestArray) ToDeviceRequestArrayOutput() DeviceRequestArrayOutput {
	return i.ToDeviceRequestArrayOutputWithContext(context.Background())
}

func (i DeviceRequestArray) ToDeviceRequestArrayOutputWithContext(ctx context.Context) DeviceRequestArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestArrayOutput)
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// A DeviceClassName is currently required. Clients must check that it is indeed set. It's absence indicates that something changed in a way that is not supported by the client yet, in which case it must refuse to handle the request.
type DeviceRequestOutput struct{ *pulumi.OutputState }

func (DeviceRequestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequest)(nil)).Elem()
}

func (o DeviceRequestOutput) ToDeviceRequestOutput() DeviceRequestOutput {
	return o
}

func (o DeviceRequestOutput) ToDeviceRequestOutputWithContext(ctx context.Context) DeviceRequestOutput {
	return o
}

// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
func (o DeviceRequestOutput) AdminAccess() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceRequest) *bool { return v.AdminAccess }).(pulumi.BoolPtrOutput)
}

// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
//
// - ExactCount: This request is for a specific number of devices.
// This is the default. The exact number is provided in the
// count field.
//
// - All: This request is for all of the matching devices in a pool.
// Allocation will fail if some devices are already allocated,
// unless adminAccess is requested.
//
// If AlloctionMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
//
// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
func (o DeviceRequestOutput) AllocationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequest) *string { return v.AllocationMode }).(pulumi.StringPtrOutput)
}

// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
func (o DeviceRequestOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceRequest) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
//
// A class is required. Which classes are available depends on the cluster.
//
// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
func (o DeviceRequestOutput) DeviceClassName() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequest) string { return v.DeviceClassName }).(pulumi.StringOutput)
}

// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
//
// Must be a DNS label.
func (o DeviceRequestOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequest) string { return v.Name }).(pulumi.StringOutput)
}

// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
func (o DeviceRequestOutput) Selectors() DeviceSelectorArrayOutput {
	return o.ApplyT(func(v DeviceRequest) []DeviceSelector { return v.Selectors }).(DeviceSelectorArrayOutput)
}

type DeviceRequestArrayOutput struct{ *pulumi.OutputState }

func (DeviceRequestArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequest)(nil)).Elem()
}

func (o DeviceRequestArrayOutput) ToDeviceRequestArrayOutput() DeviceRequestArrayOutput {
	return o
}

func (o DeviceRequestArrayOutput) ToDeviceRequestArrayOutputWithContext(ctx context.Context) DeviceRequestArrayOutput {
	return o
}

func (o DeviceRequestArrayOutput) Index(i pulumi.IntInput) DeviceRequestOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceRequest {
		return vs[0].([]DeviceRequest)[vs[1].(int)]
	}).(DeviceRequestOutput)
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResult struct {
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device string `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver string `pulumi:"driver"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool string `pulumi:"pool"`
	// Request is the name of the request in the claim which caused this device to be allocated. Multiple devices may have been allocated per request.
	Request string `pulumi:"request"`
}

// DeviceRequestAllocationResultInput is an input type that accepts DeviceRequestAllocationResultArgs and DeviceRequestAllocationResultOutput values.
// You can construct a concrete instance of `DeviceRequestAllocationResultInput` via:
//
//	DeviceRequestAllocationResultArgs{...}
type DeviceRequestAllocationResultInput interface {
	pulumi.Input

	ToDeviceRequestAllocationResultOutput() DeviceRequestAllocationResultOutput
	ToDeviceRequestAllocationResultOutputWithContext(context.Context) DeviceRequestAllocationResultOutput
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultArgs struct {
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device pulumi.StringInput `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringInput `pulumi:"driver"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool pulumi.StringInput `pulumi:"pool"`
	// Request is the name of the request in the claim which caused this device to be allocated. Multiple devices may have been allocated per request.
	Request pulumi.StringInput `pulumi:"request"`
}

func (DeviceRequestAllocationResultArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestAllocationResult)(nil)).Elem()
}

func (i DeviceRequestAllocationResultArgs) ToDeviceRequestAllocationResultOutput() DeviceRequestAllocationResultOutput {
	return i.ToDeviceRequestAllocationResultOutputWithContext(context.Background())
}

func (i DeviceRequestAllocationResultArgs) ToDeviceRequestAllocationResultOutputWithContext(ctx context.Context) DeviceRequestAllocationResultOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestAllocationResultOutput)
}

// DeviceRequestAllocationResultArrayInput is an input type that accepts DeviceRequestAllocationResultArray and DeviceRequestAllocationResultArrayOutput values.
// You can construct a concrete instance of `DeviceRequestAllocationResultArrayInput` via:
//
//	DeviceRequestAllocationResultArray{ DeviceRequestAllocationResultArgs{...} }
type DeviceRequestAllocationResultArrayInput interface {
	pulumi.Input

	ToDeviceRequestAllocationResultArrayOutput() DeviceRequestAllocationResultArrayOutput
	ToDeviceRequestAllocationResultArrayOutputWithContext(context.Context) DeviceRequestAllocationResultArrayOutput
}

type DeviceRequestAllocationResultArray []DeviceRequestAllocationResultInput

func (DeviceRequestAllocationResultArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestAllocationResult)(nil)).Elem()
}

func (i DeviceRequestAllocationResultArray) ToDeviceRequestAllocationResultArrayOutput() DeviceRequestAllocationResultArrayOutput {
	return i.ToDeviceRequestAllocationResultArrayOutputWithContext(context.Background())
}

func (i DeviceRequestAllocationResultArray) ToDeviceRequestAllocationResultArrayOutputWithContext(ctx context.Context) DeviceRequestAllocationResultArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestAllocationResultArrayOutput)
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultOutput struct{ *pulumi.OutputState }

func (DeviceRequestAllocationResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestAllocationResult)(nil)).Elem()
}

func (o DeviceRequestAllocationResultOutput) ToDeviceRequestAllocationResultOutput() DeviceRequestAllocationResultOutput {
	return o
}

func (o DeviceRequestAllocationResultOutput) ToDeviceRequestAllocationResultOutputWithContext(ctx context.Context) DeviceRequestAllocationResultOutput {
	return o
}

// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
func (o DeviceRequestAllocationResultOutput) Device() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) string { return v.Device }).(pulumi.StringOutput)
}

// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o DeviceRequestAllocationResultOutput) Driver() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) string { return v.Driver }).(pulumi.StringOutput)
}

// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
//
// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
func (o DeviceRequestAllocationResultOutput) Pool() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) string { return v.Pool }).(pulumi.StringOutput)
}

// Request is the name of the request in the claim which caused this device to be allocated. Multiple devices may have been allocated per request.
func (o DeviceRequestAllocationResultOutput) Request() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResult) string { return v.Request }).(pulumi.StringOutput)
}

type DeviceRequestAllocationResultArrayOutput struct{ *pulumi.OutputState }

func (DeviceRequestAllocationResultArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestAllocationResult)(nil)).Elem()
}

func (o DeviceRequestAllocationResultArrayOutput) ToDeviceRequestAllocationResultArrayOutput() DeviceRequestAllocationResultArrayOutput {
	return o
}

func (o DeviceRequestAllocationResultArrayOutput) ToDeviceRequestAllocationResultArrayOutputWithContext(ctx context.Context) DeviceRequestAllocationResultArrayOutput {
	return o
}

func (o DeviceRequestAllocationResultArrayOutput) Index(i pulumi.IntInput) DeviceRequestAllocationResultOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceRequestAllocationResult {
		return vs[0].([]DeviceRequestAllocationResult)[vs[1].(int)]
	}).(DeviceRequestAllocationResultOutput)
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultPatch struct {
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device *string `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver *string `pulumi:"driver"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool *string `pulumi:"pool"`
	// Request is the name of the request in the claim which caused this device to be allocated. Multiple devices may have been allocated per request.
	Request *string `pulumi:"request"`
}

// DeviceRequestAllocationResultPatchInput is an input type that accepts DeviceRequestAllocationResultPatchArgs and DeviceRequestAllocationResultPatchOutput values.
// You can construct a concrete instance of `DeviceRequestAllocationResultPatchInput` via:
//
//	DeviceRequestAllocationResultPatchArgs{...}
type DeviceRequestAllocationResultPatchInput interface {
	pulumi.Input

	ToDeviceRequestAllocationResultPatchOutput() DeviceRequestAllocationResultPatchOutput
	ToDeviceRequestAllocationResultPatchOutputWithContext(context.Context) DeviceRequestAllocationResultPatchOutput
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultPatchArgs struct {
	// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
	Device pulumi.StringPtrInput `pulumi:"device"`
	// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringPtrInput `pulumi:"driver"`
	// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
	//
	// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
	Pool pulumi.StringPtrInput `pulumi:"pool"`
	// Request is the name of the request in the claim which caused this device to be allocated. Multiple devices may have been allocated per request.
	Request pulumi.StringPtrInput `pulumi:"request"`
}

func (DeviceRequestAllocationResultPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestAllocationResultPatch)(nil)).Elem()
}

func (i DeviceRequestAllocationResultPatchArgs) ToDeviceRequestAllocationResultPatchOutput() DeviceRequestAllocationResultPatchOutput {
	return i.ToDeviceRequestAllocationResultPatchOutputWithContext(context.Background())
}

func (i DeviceRequestAllocationResultPatchArgs) ToDeviceRequestAllocationResultPatchOutputWithContext(ctx context.Context) DeviceRequestAllocationResultPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestAllocationResultPatchOutput)
}

// DeviceRequestAllocationResultPatchArrayInput is an input type that accepts DeviceRequestAllocationResultPatchArray and DeviceRequestAllocationResultPatchArrayOutput values.
// You can construct a concrete instance of `DeviceRequestAllocationResultPatchArrayInput` via:
//
//	DeviceRequestAllocationResultPatchArray{ DeviceRequestAllocationResultPatchArgs{...} }
type DeviceRequestAllocationResultPatchArrayInput interface {
	pulumi.Input

	ToDeviceRequestAllocationResultPatchArrayOutput() DeviceRequestAllocationResultPatchArrayOutput
	ToDeviceRequestAllocationResultPatchArrayOutputWithContext(context.Context) DeviceRequestAllocationResultPatchArrayOutput
}

type DeviceRequestAllocationResultPatchArray []DeviceRequestAllocationResultPatchInput

func (DeviceRequestAllocationResultPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestAllocationResultPatch)(nil)).Elem()
}

func (i DeviceRequestAllocationResultPatchArray) ToDeviceRequestAllocationResultPatchArrayOutput() DeviceRequestAllocationResultPatchArrayOutput {
	return i.ToDeviceRequestAllocationResultPatchArrayOutputWithContext(context.Background())
}

func (i DeviceRequestAllocationResultPatchArray) ToDeviceRequestAllocationResultPatchArrayOutputWithContext(ctx context.Context) DeviceRequestAllocationResultPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestAllocationResultPatchArrayOutput)
}

// DeviceRequestAllocationResult contains the allocation result for one request.
type DeviceRequestAllocationResultPatchOutput struct{ *pulumi.OutputState }

func (DeviceRequestAllocationResultPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestAllocationResultPatch)(nil)).Elem()
}

func (o DeviceRequestAllocationResultPatchOutput) ToDeviceRequestAllocationResultPatchOutput() DeviceRequestAllocationResultPatchOutput {
	return o
}

func (o DeviceRequestAllocationResultPatchOutput) ToDeviceRequestAllocationResultPatchOutputWithContext(ctx context.Context) DeviceRequestAllocationResultPatchOutput {
	return o
}

// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
func (o DeviceRequestAllocationResultPatchOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) *string { return v.Device }).(pulumi.StringPtrOutput)
}

// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o DeviceRequestAllocationResultPatchOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) *string { return v.Driver }).(pulumi.StringPtrOutput)
}

// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
//
// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
func (o DeviceRequestAllocationResultPatchOutput) Pool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) *string { return v.Pool }).(pulumi.StringPtrOutput)
}

// Request is the name of the request in the claim which caused this device to be allocated. Multiple devices may have been allocated per request.
func (o DeviceRequestAllocationResultPatchOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestAllocationResultPatch) *string { return v.Request }).(pulumi.StringPtrOutput)
}

type DeviceRequestAllocationResultPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceRequestAllocationResultPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestAllocationResultPatch)(nil)).Elem()
}

func (o DeviceRequestAllocationResultPatchArrayOutput) ToDeviceRequestAllocationResultPatchArrayOutput() DeviceRequestAllocationResultPatchArrayOutput {
	return o
}

func (o DeviceRequestAllocationResultPatchArrayOutput) ToDeviceRequestAllocationResultPatchArrayOutputWithContext(ctx context.Context) DeviceRequestAllocationResultPatchArrayOutput {
	return o
}

func (o DeviceRequestAllocationResultPatchArrayOutput) Index(i pulumi.IntInput) DeviceRequestAllocationResultPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceRequestAllocationResultPatch {
		return vs[0].([]DeviceRequestAllocationResultPatch)[vs[1].(int)]
	}).(DeviceRequestAllocationResultPatchOutput)
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// A DeviceClassName is currently required. Clients must check that it is indeed set. It's absence indicates that something changed in a way that is not supported by the client yet, in which case it must refuse to handle the request.
type DeviceRequestPatch struct {
	// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
	AdminAccess *bool `pulumi:"adminAccess"`
	// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This request is for all of the matching devices in a pool.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AlloctionMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode *string `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	Count *int `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
	//
	// A class is required. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName *string `pulumi:"deviceClassName"`
	// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
	//
	// Must be a DNS label.
	Name *string `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
	Selectors []DeviceSelectorPatch `pulumi:"selectors"`
}

// DeviceRequestPatchInput is an input type that accepts DeviceRequestPatchArgs and DeviceRequestPatchOutput values.
// You can construct a concrete instance of `DeviceRequestPatchInput` via:
//
//	DeviceRequestPatchArgs{...}
type DeviceRequestPatchInput interface {
	pulumi.Input

	ToDeviceRequestPatchOutput() DeviceRequestPatchOutput
	ToDeviceRequestPatchOutputWithContext(context.Context) DeviceRequestPatchOutput
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// A DeviceClassName is currently required. Clients must check that it is indeed set. It's absence indicates that something changed in a way that is not supported by the client yet, in which case it must refuse to handle the request.
type DeviceRequestPatchArgs struct {
	// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
	AdminAccess pulumi.BoolPtrInput `pulumi:"adminAccess"`
	// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
	//
	// - ExactCount: This request is for a specific number of devices.
	// This is the default. The exact number is provided in the
	// count field.
	//
	// - All: This request is for all of the matching devices in a pool.
	// Allocation will fail if some devices are already allocated,
	// unless adminAccess is requested.
	//
	// If AlloctionMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
	//
	// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
	AllocationMode pulumi.StringPtrInput `pulumi:"allocationMode"`
	// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
	//
	// A class is required. Which classes are available depends on the cluster.
	//
	// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
	DeviceClassName pulumi.StringPtrInput `pulumi:"deviceClassName"`
	// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
	//
	// Must be a DNS label.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
	Selectors DeviceSelectorPatchArrayInput `pulumi:"selectors"`
}

func (DeviceRequestPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestPatch)(nil)).Elem()
}

func (i DeviceRequestPatchArgs) ToDeviceRequestPatchOutput() DeviceRequestPatchOutput {
	return i.ToDeviceRequestPatchOutputWithContext(context.Background())
}

func (i DeviceRequestPatchArgs) ToDeviceRequestPatchOutputWithContext(ctx context.Context) DeviceRequestPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestPatchOutput)
}

// DeviceRequestPatchArrayInput is an input type that accepts DeviceRequestPatchArray and DeviceRequestPatchArrayOutput values.
// You can construct a concrete instance of `DeviceRequestPatchArrayInput` via:
//
//	DeviceRequestPatchArray{ DeviceRequestPatchArgs{...} }
type DeviceRequestPatchArrayInput interface {
	pulumi.Input

	ToDeviceRequestPatchArrayOutput() DeviceRequestPatchArrayOutput
	ToDeviceRequestPatchArrayOutputWithContext(context.Context) DeviceRequestPatchArrayOutput
}

type DeviceRequestPatchArray []DeviceRequestPatchInput

func (DeviceRequestPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestPatch)(nil)).Elem()
}

func (i DeviceRequestPatchArray) ToDeviceRequestPatchArrayOutput() DeviceRequestPatchArrayOutput {
	return i.ToDeviceRequestPatchArrayOutputWithContext(context.Background())
}

func (i DeviceRequestPatchArray) ToDeviceRequestPatchArrayOutputWithContext(ctx context.Context) DeviceRequestPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceRequestPatchArrayOutput)
}

// DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices.
//
// A DeviceClassName is currently required. Clients must check that it is indeed set. It's absence indicates that something changed in a way that is not supported by the client yet, in which case it must refuse to handle the request.
type DeviceRequestPatchOutput struct{ *pulumi.OutputState }

func (DeviceRequestPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceRequestPatch)(nil)).Elem()
}

func (o DeviceRequestPatchOutput) ToDeviceRequestPatchOutput() DeviceRequestPatchOutput {
	return o
}

func (o DeviceRequestPatchOutput) ToDeviceRequestPatchOutputWithContext(ctx context.Context) DeviceRequestPatchOutput {
	return o
}

// AdminAccess indicates that this is a claim for administrative access to the device(s). Claims with AdminAccess are expected to be used for monitoring or other management services for a device.  They ignore all ordinary claims to the device with respect to access modes and any resource allocations.
func (o DeviceRequestPatchOutput) AdminAccess() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *bool { return v.AdminAccess }).(pulumi.BoolPtrOutput)
}

// AllocationMode and its related fields define how devices are allocated to satisfy this request. Supported values are:
//
// - ExactCount: This request is for a specific number of devices.
// This is the default. The exact number is provided in the
// count field.
//
// - All: This request is for all of the matching devices in a pool.
// Allocation will fail if some devices are already allocated,
// unless adminAccess is requested.
//
// If AlloctionMode is not specified, the default mode is ExactCount. If the mode is ExactCount and count is not specified, the default count is one. Any other requests must specify this field.
//
// More modes may get added in the future. Clients must refuse to handle requests with unknown modes.
func (o DeviceRequestPatchOutput) AllocationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *string { return v.AllocationMode }).(pulumi.StringPtrOutput)
}

// Count is used only when the count mode is "ExactCount". Must be greater than zero. If AllocationMode is ExactCount and this field is not specified, the default is one.
func (o DeviceRequestPatchOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// DeviceClassName references a specific DeviceClass, which can define additional configuration and selectors to be inherited by this request.
//
// A class is required. Which classes are available depends on the cluster.
//
// Administrators may use this to restrict which devices may get requested by only installing classes with selectors for permitted devices. If users are free to request anything without restrictions, then administrators can create an empty DeviceClass for users to reference.
func (o DeviceRequestPatchOutput) DeviceClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *string { return v.DeviceClassName }).(pulumi.StringPtrOutput)
}

// Name can be used to reference this request in a pod.spec.containers[].resources.claims entry and in a constraint of the claim.
//
// Must be a DNS label.
func (o DeviceRequestPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceRequestPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Selectors define criteria which must be satisfied by a specific device in order for that device to be considered for this request. All selectors must be satisfied for a device to be considered.
func (o DeviceRequestPatchOutput) Selectors() DeviceSelectorPatchArrayOutput {
	return o.ApplyT(func(v DeviceRequestPatch) []DeviceSelectorPatch { return v.Selectors }).(DeviceSelectorPatchArrayOutput)
}

type DeviceRequestPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceRequestPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceRequestPatch)(nil)).Elem()
}

func (o DeviceRequestPatchArrayOutput) ToDeviceRequestPatchArrayOutput() DeviceRequestPatchArrayOutput {
	return o
}

func (o DeviceRequestPatchArrayOutput) ToDeviceRequestPatchArrayOutputWithContext(ctx context.Context) DeviceRequestPatchArrayOutput {
	return o
}

func (o DeviceRequestPatchArrayOutput) Index(i pulumi.IntInput) DeviceRequestPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceRequestPatch {
		return vs[0].([]DeviceRequestPatch)[vs[1].(int)]
	}).(DeviceRequestPatchOutput)
}

// DeviceSelector must have exactly one field set.
type DeviceSelector struct {
	// CEL contains a CEL expression for selecting a device.
	Cel *CELDeviceSelector `pulumi:"cel"`
}

// DeviceSelectorInput is an input type that accepts DeviceSelectorArgs and DeviceSelectorOutput values.
// You can construct a concrete instance of `DeviceSelectorInput` via:
//
//	DeviceSelectorArgs{...}
type DeviceSelectorInput interface {
	pulumi.Input

	ToDeviceSelectorOutput() DeviceSelectorOutput
	ToDeviceSelectorOutputWithContext(context.Context) DeviceSelectorOutput
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorArgs struct {
	// CEL contains a CEL expression for selecting a device.
	Cel CELDeviceSelectorPtrInput `pulumi:"cel"`
}

func (DeviceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSelector)(nil)).Elem()
}

func (i DeviceSelectorArgs) ToDeviceSelectorOutput() DeviceSelectorOutput {
	return i.ToDeviceSelectorOutputWithContext(context.Background())
}

func (i DeviceSelectorArgs) ToDeviceSelectorOutputWithContext(ctx context.Context) DeviceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSelectorOutput)
}

// DeviceSelectorArrayInput is an input type that accepts DeviceSelectorArray and DeviceSelectorArrayOutput values.
// You can construct a concrete instance of `DeviceSelectorArrayInput` via:
//
//	DeviceSelectorArray{ DeviceSelectorArgs{...} }
type DeviceSelectorArrayInput interface {
	pulumi.Input

	ToDeviceSelectorArrayOutput() DeviceSelectorArrayOutput
	ToDeviceSelectorArrayOutputWithContext(context.Context) DeviceSelectorArrayOutput
}

type DeviceSelectorArray []DeviceSelectorInput

func (DeviceSelectorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSelector)(nil)).Elem()
}

func (i DeviceSelectorArray) ToDeviceSelectorArrayOutput() DeviceSelectorArrayOutput {
	return i.ToDeviceSelectorArrayOutputWithContext(context.Background())
}

func (i DeviceSelectorArray) ToDeviceSelectorArrayOutputWithContext(ctx context.Context) DeviceSelectorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSelectorArrayOutput)
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorOutput struct{ *pulumi.OutputState }

func (DeviceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSelector)(nil)).Elem()
}

func (o DeviceSelectorOutput) ToDeviceSelectorOutput() DeviceSelectorOutput {
	return o
}

func (o DeviceSelectorOutput) ToDeviceSelectorOutputWithContext(ctx context.Context) DeviceSelectorOutput {
	return o
}

// CEL contains a CEL expression for selecting a device.
func (o DeviceSelectorOutput) Cel() CELDeviceSelectorPtrOutput {
	return o.ApplyT(func(v DeviceSelector) *CELDeviceSelector { return v.Cel }).(CELDeviceSelectorPtrOutput)
}

type DeviceSelectorArrayOutput struct{ *pulumi.OutputState }

func (DeviceSelectorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSelector)(nil)).Elem()
}

func (o DeviceSelectorArrayOutput) ToDeviceSelectorArrayOutput() DeviceSelectorArrayOutput {
	return o
}

func (o DeviceSelectorArrayOutput) ToDeviceSelectorArrayOutputWithContext(ctx context.Context) DeviceSelectorArrayOutput {
	return o
}

func (o DeviceSelectorArrayOutput) Index(i pulumi.IntInput) DeviceSelectorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceSelector {
		return vs[0].([]DeviceSelector)[vs[1].(int)]
	}).(DeviceSelectorOutput)
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorPatch struct {
	// CEL contains a CEL expression for selecting a device.
	Cel *CELDeviceSelectorPatch `pulumi:"cel"`
}

// DeviceSelectorPatchInput is an input type that accepts DeviceSelectorPatchArgs and DeviceSelectorPatchOutput values.
// You can construct a concrete instance of `DeviceSelectorPatchInput` via:
//
//	DeviceSelectorPatchArgs{...}
type DeviceSelectorPatchInput interface {
	pulumi.Input

	ToDeviceSelectorPatchOutput() DeviceSelectorPatchOutput
	ToDeviceSelectorPatchOutputWithContext(context.Context) DeviceSelectorPatchOutput
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorPatchArgs struct {
	// CEL contains a CEL expression for selecting a device.
	Cel CELDeviceSelectorPatchPtrInput `pulumi:"cel"`
}

func (DeviceSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSelectorPatch)(nil)).Elem()
}

func (i DeviceSelectorPatchArgs) ToDeviceSelectorPatchOutput() DeviceSelectorPatchOutput {
	return i.ToDeviceSelectorPatchOutputWithContext(context.Background())
}

func (i DeviceSelectorPatchArgs) ToDeviceSelectorPatchOutputWithContext(ctx context.Context) DeviceSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSelectorPatchOutput)
}

// DeviceSelectorPatchArrayInput is an input type that accepts DeviceSelectorPatchArray and DeviceSelectorPatchArrayOutput values.
// You can construct a concrete instance of `DeviceSelectorPatchArrayInput` via:
//
//	DeviceSelectorPatchArray{ DeviceSelectorPatchArgs{...} }
type DeviceSelectorPatchArrayInput interface {
	pulumi.Input

	ToDeviceSelectorPatchArrayOutput() DeviceSelectorPatchArrayOutput
	ToDeviceSelectorPatchArrayOutputWithContext(context.Context) DeviceSelectorPatchArrayOutput
}

type DeviceSelectorPatchArray []DeviceSelectorPatchInput

func (DeviceSelectorPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSelectorPatch)(nil)).Elem()
}

func (i DeviceSelectorPatchArray) ToDeviceSelectorPatchArrayOutput() DeviceSelectorPatchArrayOutput {
	return i.ToDeviceSelectorPatchArrayOutputWithContext(context.Background())
}

func (i DeviceSelectorPatchArray) ToDeviceSelectorPatchArrayOutputWithContext(ctx context.Context) DeviceSelectorPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceSelectorPatchArrayOutput)
}

// DeviceSelector must have exactly one field set.
type DeviceSelectorPatchOutput struct{ *pulumi.OutputState }

func (DeviceSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceSelectorPatch)(nil)).Elem()
}

func (o DeviceSelectorPatchOutput) ToDeviceSelectorPatchOutput() DeviceSelectorPatchOutput {
	return o
}

func (o DeviceSelectorPatchOutput) ToDeviceSelectorPatchOutputWithContext(ctx context.Context) DeviceSelectorPatchOutput {
	return o
}

// CEL contains a CEL expression for selecting a device.
func (o DeviceSelectorPatchOutput) Cel() CELDeviceSelectorPatchPtrOutput {
	return o.ApplyT(func(v DeviceSelectorPatch) *CELDeviceSelectorPatch { return v.Cel }).(CELDeviceSelectorPatchPtrOutput)
}

type DeviceSelectorPatchArrayOutput struct{ *pulumi.OutputState }

func (DeviceSelectorPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceSelectorPatch)(nil)).Elem()
}

func (o DeviceSelectorPatchArrayOutput) ToDeviceSelectorPatchArrayOutput() DeviceSelectorPatchArrayOutput {
	return o
}

func (o DeviceSelectorPatchArrayOutput) ToDeviceSelectorPatchArrayOutputWithContext(ctx context.Context) DeviceSelectorPatchArrayOutput {
	return o
}

func (o DeviceSelectorPatchArrayOutput) Index(i pulumi.IntInput) DeviceSelectorPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceSelectorPatch {
		return vs[0].([]DeviceSelectorPatch)[vs[1].(int)]
	}).(DeviceSelectorPatchOutput)
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaint struct {
	// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
	Effect string `pulumi:"effect"`
	// The taint key to be applied to a device. Must be a label name.
	Key string `pulumi:"key"`
	// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
	TimeAdded *string `pulumi:"timeAdded"`
	// The taint value corresponding to the taint key. Must be a label value.
	Value *string `pulumi:"value"`
}

// DeviceTaintInput is an input type that accepts DeviceTaintArgs and DeviceTaintOutput values.
// You can construct a concrete instance of `DeviceTaintInput` via:
//
//	DeviceTaintArgs{...}
type DeviceTaintInput interface {
	pulumi.Input

	ToDeviceTaintOutput() DeviceTaintOutput
	ToDeviceTaintOutputWithContext(context.Context) DeviceTaintOutput
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintArgs struct {
	// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
	Effect pulumi.StringInput `pulumi:"effect"`
	// The taint key to be applied to a device. Must be a label name.
	Key pulumi.StringInput `pulumi:"key"`
	// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
	TimeAdded pulumi.StringPtrInput `pulumi:"timeAdded"`
	// The taint value corresponding to the taint key. Must be a label value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (DeviceTaintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaint)(nil)).Elem()
}

func (i DeviceTaintArgs) ToDeviceTaintOutput() DeviceTaintOutput {
	return i.ToDeviceTaintOutputWithContext(context.Background())
}

func (i DeviceTaintArgs) ToDeviceTaintOutputWithContext(ctx context.Context) DeviceTaintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintOutput)
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintOutput struct{ *pulumi.OutputState }

func (DeviceTaintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaint)(nil)).Elem()
}

func (o DeviceTaintOutput) ToDeviceTaintOutput() DeviceTaintOutput {
	return o
}

func (o DeviceTaintOutput) ToDeviceTaintOutputWithContext(ctx context.Context) DeviceTaintOutput {
	return o
}

// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
func (o DeviceTaintOutput) Effect() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceTaint) string { return v.Effect }).(pulumi.StringOutput)
}

// The taint key to be applied to a device. Must be a label name.
func (o DeviceTaintOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v DeviceTaint) string { return v.Key }).(pulumi.StringOutput)
}

// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
func (o DeviceTaintOutput) TimeAdded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaint) *string { return v.TimeAdded }).(pulumi.StringPtrOutput)
}

// The taint value corresponding to the taint key. Must be a label value.
func (o DeviceTaintOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaint) *string { return v.Value }).(pulumi.StringPtrOutput)
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintPatch struct {
	// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
	Effect *string `pulumi:"effect"`
	// The taint key to be applied to a device. Must be a label name.
	Key *string `pulumi:"key"`
	// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
	TimeAdded *string `pulumi:"timeAdded"`
	// The taint value corresponding to the taint key. Must be a label value.
	Value *string `pulumi:"value"`
}

// DeviceTaintPatchInput is an input type that accepts DeviceTaintPatchArgs and DeviceTaintPatchOutput values.
// You can construct a concrete instance of `DeviceTaintPatchInput` via:
//
//	DeviceTaintPatchArgs{...}
type DeviceTaintPatchInput interface {
	pulumi.Input

	ToDeviceTaintPatchOutput() DeviceTaintPatchOutput
	ToDeviceTaintPatchOutputWithContext(context.Context) DeviceTaintPatchOutput
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintPatchArgs struct {
	// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// The taint key to be applied to a device. Must be a label name.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
	TimeAdded pulumi.StringPtrInput `pulumi:"timeAdded"`
	// The taint value corresponding to the taint key. Must be a label value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (DeviceTaintPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintPatch)(nil)).Elem()
}

func (i DeviceTaintPatchArgs) ToDeviceTaintPatchOutput() DeviceTaintPatchOutput {
	return i.ToDeviceTaintPatchOutputWithContext(context.Background())
}

func (i DeviceTaintPatchArgs) ToDeviceTaintPatchOutputWithContext(ctx context.Context) DeviceTaintPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintPatchOutput)
}

func (i DeviceTaintPatchArgs) ToDeviceTaintPatchPtrOutput() DeviceTaintPatchPtrOutput {
	return i.ToDeviceTaintPatchPtrOutputWithContext(context.Background())
}

func (i DeviceTaintPatchArgs) ToDeviceTaintPatchPtrOutputWithContext(ctx context.Context) DeviceTaintPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintPatchOutput).ToDeviceTaintPatchPtrOutputWithContext(ctx)
}

// DeviceTaintPatchPtrInput is an input type that accepts DeviceTaintPatchArgs, DeviceTaintPatchPtr and DeviceTaintPatchPtrOutput values.
// You can construct a concrete instance of `DeviceTaintPatchPtrInput` via:
//
//	        DeviceTaintPatchArgs{...}
//
//	or:
//
//	        nil
type DeviceTaintPatchPtrInput interface {
	pulumi.Input

	ToDeviceTaintPatchPtrOutput() DeviceTaintPatchPtrOutput
	ToDeviceTaintPatchPtrOutputWithContext(context.Context) DeviceTaintPatchPtrOutput
}

type deviceTaintPatchPtrType DeviceTaintPatchArgs

func DeviceTaintPatchPtr(v *DeviceTaintPatchArgs) DeviceTaintPatchPtrInput {
	return (*deviceTaintPatchPtrType)(v)
}

func (*deviceTaintPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceTaintPatch)(nil)).Elem()
}

func (i *deviceTaintPatchPtrType) ToDeviceTaintPatchPtrOutput() DeviceTaintPatchPtrOutput {
	return i.ToDeviceTaintPatchPtrOutputWithContext(context.Background())
}

func (i *deviceTaintPatchPtrType) ToDeviceTaintPatchPtrOutputWithContext(ctx context.Context) DeviceTaintPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintPatchPtrOutput)
}

// The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim.
type DeviceTaintPatchOutput struct{ *pulumi.OutputState }

func (DeviceTaintPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintPatch)(nil)).Elem()
}

func (o DeviceTaintPatchOutput) ToDeviceTaintPatchOutput() DeviceTaintPatchOutput {
	return o
}

func (o DeviceTaintPatchOutput) ToDeviceTaintPatchOutputWithContext(ctx context.Context) DeviceTaintPatchOutput {
	return o
}

func (o DeviceTaintPatchOutput) ToDeviceTaintPatchPtrOutput() DeviceTaintPatchPtrOutput {
	return o.ToDeviceTaintPatchPtrOutputWithContext(context.Background())
}

func (o DeviceTaintPatchOutput) ToDeviceTaintPatchPtrOutputWithContext(ctx context.Context) DeviceTaintPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceTaintPatch) *DeviceTaintPatch {
		return &v
	}).(DeviceTaintPatchPtrOutput)
}

// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
func (o DeviceTaintPatchOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintPatch) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// The taint key to be applied to a device. Must be a label name.
func (o DeviceTaintPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
func (o DeviceTaintPatchOutput) TimeAdded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintPatch) *string { return v.TimeAdded }).(pulumi.StringPtrOutput)
}

// The taint value corresponding to the taint key. Must be a label value.
func (o DeviceTaintPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type DeviceTaintPatchPtrOutput struct{ *pulumi.OutputState }

func (DeviceTaintPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceTaintPatch)(nil)).Elem()
}

func (o DeviceTaintPatchPtrOutput) ToDeviceTaintPatchPtrOutput() DeviceTaintPatchPtrOutput {
	return o
}

func (o DeviceTaintPatchPtrOutput) ToDeviceTaintPatchPtrOutputWithContext(ctx context.Context) DeviceTaintPatchPtrOutput {
	return o
}

func (o DeviceTaintPatchPtrOutput) Elem() DeviceTaintPatchOutput {
	return o.ApplyT(func(v *DeviceTaintPatch) DeviceTaintPatch {
		if v != nil {
			return *v
		}
		var ret DeviceTaintPatch
		return ret
	}).(DeviceTaintPatchOutput)
}

// The effect of the taint on claims that do not tolerate the taint and through such claims on the pods using them. Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for nodes is not valid here.
func (o DeviceTaintPatchPtrOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintPatch) *string {
		if v == nil {
			return nil
		}
		return v.Effect
	}).(pulumi.StringPtrOutput)
}

// The taint key to be applied to a device. Must be a label name.
func (o DeviceTaintPatchPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintPatch) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// TimeAdded represents the time at which the taint was added. Added automatically during create or update if not set.
func (o DeviceTaintPatchPtrOutput) TimeAdded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintPatch) *string {
		if v == nil {
			return nil
		}
		return v.TimeAdded
	}).(pulumi.StringPtrOutput)
}

// The taint value corresponding to the taint key. Must be a label value.
func (o DeviceTaintPatchPtrOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintPatch) *string {
		if v == nil {
			return nil
		}
		return v.Value
	}).(pulumi.StringPtrOutput)
}

// DeviceTaintRule adds one taint to all devices which match the selector. This has the same effect as if the taint was specified directly in the ResourceSlice by the DRA driver.
type DeviceTaintRuleType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec specifies the selector and one taint.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceTaintRuleSpec `pulumi:"spec"`
}

// DeviceTaintRuleTypeInput is an input type that accepts DeviceTaintRuleTypeArgs and DeviceTaintRuleTypeOutput values.
// You can construct a concrete instance of `DeviceTaintRuleTypeInput` via:
//
//	DeviceTaintRuleTypeArgs{...}
type DeviceTaintRuleTypeInput interface {
	pulumi.Input

	ToDeviceTaintRuleTypeOutput() DeviceTaintRuleTypeOutput
	ToDeviceTaintRuleTypeOutputWithContext(context.Context) DeviceTaintRuleTypeOutput
}

// DeviceTaintRule adds one taint to all devices which match the selector. This has the same effect as if the taint was specified directly in the ResourceSlice by the DRA driver.
type DeviceTaintRuleTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec specifies the selector and one taint.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceTaintRuleSpecInput `pulumi:"spec"`
}

func (DeviceTaintRuleTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRuleType)(nil)).Elem()
}

func (i DeviceTaintRuleTypeArgs) ToDeviceTaintRuleTypeOutput() DeviceTaintRuleTypeOutput {
	return i.ToDeviceTaintRuleTypeOutputWithContext(context.Background())
}

func (i DeviceTaintRuleTypeArgs) ToDeviceTaintRuleTypeOutputWithContext(ctx context.Context) DeviceTaintRuleTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintRuleTypeOutput)
}

// DeviceTaintRuleTypeArrayInput is an input type that accepts DeviceTaintRuleTypeArray and DeviceTaintRuleTypeArrayOutput values.
// You can construct a concrete instance of `DeviceTaintRuleTypeArrayInput` via:
//
//	DeviceTaintRuleTypeArray{ DeviceTaintRuleTypeArgs{...} }
type DeviceTaintRuleTypeArrayInput interface {
	pulumi.Input

	ToDeviceTaintRuleTypeArrayOutput() DeviceTaintRuleTypeArrayOutput
	ToDeviceTaintRuleTypeArrayOutputWithContext(context.Context) DeviceTaintRuleTypeArrayOutput
}

type DeviceTaintRuleTypeArray []DeviceTaintRuleTypeInput

func (DeviceTaintRuleTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceTaintRuleType)(nil)).Elem()
}

func (i DeviceTaintRuleTypeArray) ToDeviceTaintRuleTypeArrayOutput() DeviceTaintRuleTypeArrayOutput {
	return i.ToDeviceTaintRuleTypeArrayOutputWithContext(context.Background())
}

func (i DeviceTaintRuleTypeArray) ToDeviceTaintRuleTypeArrayOutputWithContext(ctx context.Context) DeviceTaintRuleTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintRuleTypeArrayOutput)
}

// DeviceTaintRule adds one taint to all devices which match the selector. This has the same effect as if the taint was specified directly in the ResourceSlice by the DRA driver.
type DeviceTaintRuleTypeOutput struct{ *pulumi.OutputState }

func (DeviceTaintRuleTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRuleType)(nil)).Elem()
}

func (o DeviceTaintRuleTypeOutput) ToDeviceTaintRuleTypeOutput() DeviceTaintRuleTypeOutput {
	return o
}

func (o DeviceTaintRuleTypeOutput) ToDeviceTaintRuleTypeOutputWithContext(ctx context.Context) DeviceTaintRuleTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceTaintRuleTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintRuleType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceTaintRuleTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintRuleType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o DeviceTaintRuleTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v DeviceTaintRuleType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec specifies the selector and one taint.
//
// Changing the spec automatically increments the metadata.generation number.
func (o DeviceTaintRuleTypeOutput) Spec() DeviceTaintRuleSpecOutput {
	return o.ApplyT(func(v DeviceTaintRuleType) DeviceTaintRuleSpec { return v.Spec }).(DeviceTaintRuleSpecOutput)
}

type DeviceTaintRuleTypeArrayOutput struct{ *pulumi.OutputState }

func (DeviceTaintRuleTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeviceTaintRuleType)(nil)).Elem()
}

func (o DeviceTaintRuleTypeArrayOutput) ToDeviceTaintRuleTypeArrayOutput() DeviceTaintRuleTypeArrayOutput {
	return o
}

func (o DeviceTaintRuleTypeArrayOutput) ToDeviceTaintRuleTypeArrayOutputWithContext(ctx context.Context) DeviceTaintRuleTypeArrayOutput {
	return o
}

func (o DeviceTaintRuleTypeArrayOutput) Index(i pulumi.IntInput) DeviceTaintRuleTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeviceTaintRuleType {
		return vs[0].([]DeviceTaintRuleType)[vs[1].(int)]
	}).(DeviceTaintRuleTypeOutput)
}

// DeviceTaintRuleList is a collection of DeviceTaintRules.
type DeviceTaintRuleListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of DeviceTaintRules.
	Items []DeviceTaintRuleType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// DeviceTaintRuleListTypeInput is an input type that accepts DeviceTaintRuleListTypeArgs and DeviceTaintRuleListTypeOutput values.
// You can construct a concrete instance of `DeviceTaintRuleListTypeInput` via:
//
//	DeviceTaintRuleListTypeArgs{...}
type DeviceTaintRuleListTypeInput interface {
	pulumi.Input

	ToDeviceTaintRuleListTypeOutput() DeviceTaintRuleListTypeOutput
	ToDeviceTaintRuleListTypeOutputWithContext(context.Context) DeviceTaintRuleListTypeOutput
}

// DeviceTaintRuleList is a collection of DeviceTaintRules.
type DeviceTaintRuleListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of DeviceTaintRules.
	Items DeviceTaintRuleTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (DeviceTaintRuleListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRuleListType)(nil)).Elem()
}

func (i DeviceTaintRuleListTypeArgs) ToDeviceTaintRuleListTypeOutput() DeviceTaintRuleListTypeOutput {
	return i.ToDeviceTaintRuleListTypeOutputWithContext(context.Background())
}

func (i DeviceTaintRuleListTypeArgs) ToDeviceTaintRuleListTypeOutputWithContext(ctx context.Context) DeviceTaintRuleListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintRuleListTypeOutput)
}

// DeviceTaintRuleList is a collection of DeviceTaintRules.
type DeviceTaintRuleListTypeOutput struct{ *pulumi.OutputState }

func (DeviceTaintRuleListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRuleListType)(nil)).Elem()
}

func (o DeviceTaintRuleListTypeOutput) ToDeviceTaintRuleListTypeOutput() DeviceTaintRuleListTypeOutput {
	return o
}

func (o DeviceTaintRuleListTypeOutput) ToDeviceTaintRuleListTypeOutputWithContext(ctx context.Context) DeviceTaintRuleListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceTaintRuleListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintRuleListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of DeviceTaintRules.
func (o DeviceTaintRuleListTypeOutput) Items() DeviceTaintRuleTypeArrayOutput {
	return o.ApplyT(func(v DeviceTaintRuleListType) []DeviceTaintRuleType { return v.Items }).(DeviceTaintRuleTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceTaintRuleListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintRuleListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o DeviceTaintRuleListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v DeviceTaintRuleListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// DeviceTaintRule adds one taint to all devices which match the selector. This has the same effect as if the taint was specified directly in the ResourceSlice by the DRA driver.
type DeviceTaintRulePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Spec specifies the selector and one taint.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec *DeviceTaintRuleSpecPatch `pulumi:"spec"`
}

// DeviceTaintRulePatchTypeInput is an input type that accepts DeviceTaintRulePatchTypeArgs and DeviceTaintRulePatchTypeOutput values.
// You can construct a concrete instance of `DeviceTaintRulePatchTypeInput` via:
//
//	DeviceTaintRulePatchTypeArgs{...}
type DeviceTaintRulePatchTypeInput interface {
	pulumi.Input

	ToDeviceTaintRulePatchTypeOutput() DeviceTaintRulePatchTypeOutput
	ToDeviceTaintRulePatchTypeOutputWithContext(context.Context) DeviceTaintRulePatchTypeOutput
}

// DeviceTaintRule adds one taint to all devices which match the selector. This has the same effect as if the taint was specified directly in the ResourceSlice by the DRA driver.
type DeviceTaintRulePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Spec specifies the selector and one taint.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec DeviceTaintRuleSpecPatchPtrInput `pulumi:"spec"`
}

func (DeviceTaintRulePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRulePatchType)(nil)).Elem()
}

func (i DeviceTaintRulePatchTypeArgs) ToDeviceTaintRulePatchTypeOutput() DeviceTaintRulePatchTypeOutput {
	return i.ToDeviceTaintRulePatchTypeOutputWithContext(context.Background())
}

func (i DeviceTaintRulePatchTypeArgs) ToDeviceTaintRulePatchTypeOutputWithContext(ctx context.Context) DeviceTaintRulePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintRulePatchTypeOutput)
}

// DeviceTaintRule adds one taint to all devices which match the selector. This has the same effect as if the taint was specified directly in the ResourceSlice by the DRA driver.
type DeviceTaintRulePatchTypeOutput struct{ *pulumi.OutputState }

func (DeviceTaintRulePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRulePatchType)(nil)).Elem()
}

func (o DeviceTaintRulePatchTypeOutput) ToDeviceTaintRulePatchTypeOutput() DeviceTaintRulePatchTypeOutput {
	return o
}

func (o DeviceTaintRulePatchTypeOutput) ToDeviceTaintRulePatchTypeOutputWithContext(ctx context.Context) DeviceTaintRulePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeviceTaintRulePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintRulePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeviceTaintRulePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintRulePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o DeviceTaintRulePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v DeviceTaintRulePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec specifies the selector and one taint.
//
// Changing the spec automatically increments the metadata.generation number.
func (o DeviceTaintRulePatchTypeOutput) Spec() DeviceTaintRuleSpecPatchPtrOutput {
	return o.ApplyT(func(v DeviceTaintRulePatchType) *DeviceTaintRuleSpecPatch { return v.Spec }).(DeviceTaintRuleSpecPatchPtrOutput)
}

// DeviceTaintRuleSpec specifies the selector and one taint.
type DeviceTaintRuleSpec struct {
	// DeviceSelector defines which device(s) the taint is applied to. All selector criteria must be satified for a device to match. The empty selector matches all devices. Without a selector, no devices are matches.
	DeviceSelector *DeviceTaintSelector `pulumi:"deviceSelector"`
	// The taint that gets applied to matching devices.
	Taint DeviceTaint `pulumi:"taint"`
}

// DeviceTaintRuleSpecInput is an input type that accepts DeviceTaintRuleSpecArgs and DeviceTaintRuleSpecOutput values.
// You can construct a concrete instance of `DeviceTaintRuleSpecInput` via:
//
//	DeviceTaintRuleSpecArgs{...}
type DeviceTaintRuleSpecInput interface {
	pulumi.Input

	ToDeviceTaintRuleSpecOutput() DeviceTaintRuleSpecOutput
	ToDeviceTaintRuleSpecOutputWithContext(context.Context) DeviceTaintRuleSpecOutput
}

// DeviceTaintRuleSpec specifies the selector and one taint.
type DeviceTaintRuleSpecArgs struct {
	// DeviceSelector defines which device(s) the taint is applied to. All selector criteria must be satified for a device to match. The empty selector matches all devices. Without a selector, no devices are matches.
	DeviceSelector DeviceTaintSelectorPtrInput `pulumi:"deviceSelector"`
	// The taint that gets applied to matching devices.
	Taint DeviceTaintInput `pulumi:"taint"`
}

func (DeviceTaintRuleSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRuleSpec)(nil)).Elem()
}

func (i DeviceTaintRuleSpecArgs) ToDeviceTaintRuleSpecOutput() DeviceTaintRuleSpecOutput {
	return i.ToDeviceTaintRuleSpecOutputWithContext(context.Background())
}

func (i DeviceTaintRuleSpecArgs) ToDeviceTaintRuleSpecOutputWithContext(ctx context.Context) DeviceTaintRuleSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintRuleSpecOutput)
}

// DeviceTaintRuleSpec specifies the selector and one taint.
type DeviceTaintRuleSpecOutput struct{ *pulumi.OutputState }

func (DeviceTaintRuleSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRuleSpec)(nil)).Elem()
}

func (o DeviceTaintRuleSpecOutput) ToDeviceTaintRuleSpecOutput() DeviceTaintRuleSpecOutput {
	return o
}

func (o DeviceTaintRuleSpecOutput) ToDeviceTaintRuleSpecOutputWithContext(ctx context.Context) DeviceTaintRuleSpecOutput {
	return o
}

// DeviceSelector defines which device(s) the taint is applied to. All selector criteria must be satified for a device to match. The empty selector matches all devices. Without a selector, no devices are matches.
func (o DeviceTaintRuleSpecOutput) DeviceSelector() DeviceTaintSelectorPtrOutput {
	return o.ApplyT(func(v DeviceTaintRuleSpec) *DeviceTaintSelector { return v.DeviceSelector }).(DeviceTaintSelectorPtrOutput)
}

// The taint that gets applied to matching devices.
func (o DeviceTaintRuleSpecOutput) Taint() DeviceTaintOutput {
	return o.ApplyT(func(v DeviceTaintRuleSpec) DeviceTaint { return v.Taint }).(DeviceTaintOutput)
}

// DeviceTaintRuleSpec specifies the selector and one taint.
type DeviceTaintRuleSpecPatch struct {
	// DeviceSelector defines which device(s) the taint is applied to. All selector criteria must be satified for a device to match. The empty selector matches all devices. Without a selector, no devices are matches.
	DeviceSelector *DeviceTaintSelectorPatch `pulumi:"deviceSelector"`
	// The taint that gets applied to matching devices.
	Taint *DeviceTaintPatch `pulumi:"taint"`
}

// DeviceTaintRuleSpecPatchInput is an input type that accepts DeviceTaintRuleSpecPatchArgs and DeviceTaintRuleSpecPatchOutput values.
// You can construct a concrete instance of `DeviceTaintRuleSpecPatchInput` via:
//
//	DeviceTaintRuleSpecPatchArgs{...}
type DeviceTaintRuleSpecPatchInput interface {
	pulumi.Input

	ToDeviceTaintRuleSpecPatchOutput() DeviceTaintRuleSpecPatchOutput
	ToDeviceTaintRuleSpecPatchOutputWithContext(context.Context) DeviceTaintRuleSpecPatchOutput
}

// DeviceTaintRuleSpec specifies the selector and one taint.
type DeviceTaintRuleSpecPatchArgs struct {
	// DeviceSelector defines which device(s) the taint is applied to. All selector criteria must be satified for a device to match. The empty selector matches all devices. Without a selector, no devices are matches.
	DeviceSelector DeviceTaintSelectorPatchPtrInput `pulumi:"deviceSelector"`
	// The taint that gets applied to matching devices.
	Taint DeviceTaintPatchPtrInput `pulumi:"taint"`
}

func (DeviceTaintRuleSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRuleSpecPatch)(nil)).Elem()
}

func (i DeviceTaintRuleSpecPatchArgs) ToDeviceTaintRuleSpecPatchOutput() DeviceTaintRuleSpecPatchOutput {
	return i.ToDeviceTaintRuleSpecPatchOutputWithContext(context.Background())
}

func (i DeviceTaintRuleSpecPatchArgs) ToDeviceTaintRuleSpecPatchOutputWithContext(ctx context.Context) DeviceTaintRuleSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintRuleSpecPatchOutput)
}

func (i DeviceTaintRuleSpecPatchArgs) ToDeviceTaintRuleSpecPatchPtrOutput() DeviceTaintRuleSpecPatchPtrOutput {
	return i.ToDeviceTaintRuleSpecPatchPtrOutputWithContext(context.Background())
}

func (i DeviceTaintRuleSpecPatchArgs) ToDeviceTaintRuleSpecPatchPtrOutputWithContext(ctx context.Context) DeviceTaintRuleSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintRuleSpecPatchOutput).ToDeviceTaintRuleSpecPatchPtrOutputWithContext(ctx)
}

// DeviceTaintRuleSpecPatchPtrInput is an input type that accepts DeviceTaintRuleSpecPatchArgs, DeviceTaintRuleSpecPatchPtr and DeviceTaintRuleSpecPatchPtrOutput values.
// You can construct a concrete instance of `DeviceTaintRuleSpecPatchPtrInput` via:
//
//	        DeviceTaintRuleSpecPatchArgs{...}
//
//	or:
//
//	        nil
type DeviceTaintRuleSpecPatchPtrInput interface {
	pulumi.Input

	ToDeviceTaintRuleSpecPatchPtrOutput() DeviceTaintRuleSpecPatchPtrOutput
	ToDeviceTaintRuleSpecPatchPtrOutputWithContext(context.Context) DeviceTaintRuleSpecPatchPtrOutput
}

type deviceTaintRuleSpecPatchPtrType DeviceTaintRuleSpecPatchArgs

func DeviceTaintRuleSpecPatchPtr(v *DeviceTaintRuleSpecPatchArgs) DeviceTaintRuleSpecPatchPtrInput {
	return (*deviceTaintRuleSpecPatchPtrType)(v)
}

func (*deviceTaintRuleSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceTaintRuleSpecPatch)(nil)).Elem()
}

func (i *deviceTaintRuleSpecPatchPtrType) ToDeviceTaintRuleSpecPatchPtrOutput() DeviceTaintRuleSpecPatchPtrOutput {
	return i.ToDeviceTaintRuleSpecPatchPtrOutputWithContext(context.Background())
}

func (i *deviceTaintRuleSpecPatchPtrType) ToDeviceTaintRuleSpecPatchPtrOutputWithContext(ctx context.Context) DeviceTaintRuleSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintRuleSpecPatchPtrOutput)
}

// DeviceTaintRuleSpec specifies the selector and one taint.
type DeviceTaintRuleSpecPatchOutput struct{ *pulumi.OutputState }

func (DeviceTaintRuleSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintRuleSpecPatch)(nil)).Elem()
}

func (o DeviceTaintRuleSpecPatchOutput) ToDeviceTaintRuleSpecPatchOutput() DeviceTaintRuleSpecPatchOutput {
	return o
}

func (o DeviceTaintRuleSpecPatchOutput) ToDeviceTaintRuleSpecPatchOutputWithContext(ctx context.Context) DeviceTaintRuleSpecPatchOutput {
	return o
}

func (o DeviceTaintRuleSpecPatchOutput) ToDeviceTaintRuleSpecPatchPtrOutput() DeviceTaintRuleSpecPatchPtrOutput {
	return o.ToDeviceTaintRuleSpecPatchPtrOutputWithContext(context.Background())
}

func (o DeviceTaintRuleSpecPatchOutput) ToDeviceTaintRuleSpecPatchPtrOutputWithContext(ctx context.Context) DeviceTaintRuleSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceTaintRuleSpecPatch) *DeviceTaintRuleSpecPatch {
		return &v
	}).(DeviceTaintRuleSpecPatchPtrOutput)
}

// DeviceSelector defines which device(s) the taint is applied to. All selector criteria must be satified for a device to match. The empty selector matches all devices. Without a selector, no devices are matches.
func (o DeviceTaintRuleSpecPatchOutput) DeviceSelector() DeviceTaintSelectorPatchPtrOutput {
	return o.ApplyT(func(v DeviceTaintRuleSpecPatch) *DeviceTaintSelectorPatch { return v.DeviceSelector }).(DeviceTaintSelectorPatchPtrOutput)
}

// The taint that gets applied to matching devices.
func (o DeviceTaintRuleSpecPatchOutput) Taint() DeviceTaintPatchPtrOutput {
	return o.ApplyT(func(v DeviceTaintRuleSpecPatch) *DeviceTaintPatch { return v.Taint }).(DeviceTaintPatchPtrOutput)
}

type DeviceTaintRuleSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (DeviceTaintRuleSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceTaintRuleSpecPatch)(nil)).Elem()
}

func (o DeviceTaintRuleSpecPatchPtrOutput) ToDeviceTaintRuleSpecPatchPtrOutput() DeviceTaintRuleSpecPatchPtrOutput {
	return o
}

func (o DeviceTaintRuleSpecPatchPtrOutput) ToDeviceTaintRuleSpecPatchPtrOutputWithContext(ctx context.Context) DeviceTaintRuleSpecPatchPtrOutput {
	return o
}

func (o DeviceTaintRuleSpecPatchPtrOutput) Elem() DeviceTaintRuleSpecPatchOutput {
	return o.ApplyT(func(v *DeviceTaintRuleSpecPatch) DeviceTaintRuleSpecPatch {
		if v != nil {
			return *v
		}
		var ret DeviceTaintRuleSpecPatch
		return ret
	}).(DeviceTaintRuleSpecPatchOutput)
}

// DeviceSelector defines which device(s) the taint is applied to. All selector criteria must be satified for a device to match. The empty selector matches all devices. Without a selector, no devices are matches.
func (o DeviceTaintRuleSpecPatchPtrOutput) DeviceSelector() DeviceTaintSelectorPatchPtrOutput {
	return o.ApplyT(func(v *DeviceTaintRuleSpecPatch) *DeviceTaintSelectorPatch {
		if v == nil {
			return nil
		}
		return v.DeviceSelector
	}).(DeviceTaintSelectorPatchPtrOutput)
}

// The taint that gets applied to matching devices.
func (o DeviceTaintRuleSpecPatchPtrOutput) Taint() DeviceTaintPatchPtrOutput {
	return o.ApplyT(func(v *DeviceTaintRuleSpecPatch) *DeviceTaintPatch {
		if v == nil {
			return nil
		}
		return v.Taint
	}).(DeviceTaintPatchPtrOutput)
}

// DeviceTaintSelector defines which device(s) a DeviceTaintRule applies to. The empty selector matches all devices. Without a selector, no devices are matched.
type DeviceTaintSelector struct {
	// If device is set, only devices with that name are selected. This field corresponds to slice.spec.devices[].name.
	//
	// Setting also driver and pool may be required to avoid ambiguity, but is not required.
	Device *string `pulumi:"device"`
	// If DeviceClassName is set, the selectors defined there must be satisfied by a device to be selected. This field corresponds to class.metadata.name.
	DeviceClassName *string `pulumi:"deviceClassName"`
	// If driver is set, only devices from that driver are selected. This fields corresponds to slice.spec.driver.
	Driver *string `pulumi:"driver"`
	// If pool is set, only devices in that pool are selected.
	//
	// Also setting the driver name may be useful to avoid ambiguity when different drivers use the same pool name, but this is not required because selecting pools from different drivers may also be useful, for example when drivers with node-local devices use the node name as their pool name.
	Pool *string `pulumi:"pool"`
	// Selectors contains the same selection criteria as a ResourceClaim. Currently, CEL expressions are supported. All of these selectors must be satisfied.
	Selectors []DeviceSelector `pulumi:"selectors"`
}

// DeviceTaintSelectorInput is an input type that accepts DeviceTaintSelectorArgs and DeviceTaintSelectorOutput values.
// You can construct a concrete instance of `DeviceTaintSelectorInput` via:
//
//	DeviceTaintSelectorArgs{...}
type DeviceTaintSelectorInput interface {
	pulumi.Input

	ToDeviceTaintSelectorOutput() DeviceTaintSelectorOutput
	ToDeviceTaintSelectorOutputWithContext(context.Context) DeviceTaintSelectorOutput
}

// DeviceTaintSelector defines which device(s) a DeviceTaintRule applies to. The empty selector matches all devices. Without a selector, no devices are matched.
type DeviceTaintSelectorArgs struct {
	// If device is set, only devices with that name are selected. This field corresponds to slice.spec.devices[].name.
	//
	// Setting also driver and pool may be required to avoid ambiguity, but is not required.
	Device pulumi.StringPtrInput `pulumi:"device"`
	// If DeviceClassName is set, the selectors defined there must be satisfied by a device to be selected. This field corresponds to class.metadata.name.
	DeviceClassName pulumi.StringPtrInput `pulumi:"deviceClassName"`
	// If driver is set, only devices from that driver are selected. This fields corresponds to slice.spec.driver.
	Driver pulumi.StringPtrInput `pulumi:"driver"`
	// If pool is set, only devices in that pool are selected.
	//
	// Also setting the driver name may be useful to avoid ambiguity when different drivers use the same pool name, but this is not required because selecting pools from different drivers may also be useful, for example when drivers with node-local devices use the node name as their pool name.
	Pool pulumi.StringPtrInput `pulumi:"pool"`
	// Selectors contains the same selection criteria as a ResourceClaim. Currently, CEL expressions are supported. All of these selectors must be satisfied.
	Selectors DeviceSelectorArrayInput `pulumi:"selectors"`
}

func (DeviceTaintSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintSelector)(nil)).Elem()
}

func (i DeviceTaintSelectorArgs) ToDeviceTaintSelectorOutput() DeviceTaintSelectorOutput {
	return i.ToDeviceTaintSelectorOutputWithContext(context.Background())
}

func (i DeviceTaintSelectorArgs) ToDeviceTaintSelectorOutputWithContext(ctx context.Context) DeviceTaintSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintSelectorOutput)
}

func (i DeviceTaintSelectorArgs) ToDeviceTaintSelectorPtrOutput() DeviceTaintSelectorPtrOutput {
	return i.ToDeviceTaintSelectorPtrOutputWithContext(context.Background())
}

func (i DeviceTaintSelectorArgs) ToDeviceTaintSelectorPtrOutputWithContext(ctx context.Context) DeviceTaintSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintSelectorOutput).ToDeviceTaintSelectorPtrOutputWithContext(ctx)
}

// DeviceTaintSelectorPtrInput is an input type that accepts DeviceTaintSelectorArgs, DeviceTaintSelectorPtr and DeviceTaintSelectorPtrOutput values.
// You can construct a concrete instance of `DeviceTaintSelectorPtrInput` via:
//
//	        DeviceTaintSelectorArgs{...}
//
//	or:
//
//	        nil
type DeviceTaintSelectorPtrInput interface {
	pulumi.Input

	ToDeviceTaintSelectorPtrOutput() DeviceTaintSelectorPtrOutput
	ToDeviceTaintSelectorPtrOutputWithContext(context.Context) DeviceTaintSelectorPtrOutput
}

type deviceTaintSelectorPtrType DeviceTaintSelectorArgs

func DeviceTaintSelectorPtr(v *DeviceTaintSelectorArgs) DeviceTaintSelectorPtrInput {
	return (*deviceTaintSelectorPtrType)(v)
}

func (*deviceTaintSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceTaintSelector)(nil)).Elem()
}

func (i *deviceTaintSelectorPtrType) ToDeviceTaintSelectorPtrOutput() DeviceTaintSelectorPtrOutput {
	return i.ToDeviceTaintSelectorPtrOutputWithContext(context.Background())
}

func (i *deviceTaintSelectorPtrType) ToDeviceTaintSelectorPtrOutputWithContext(ctx context.Context) DeviceTaintSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintSelectorPtrOutput)
}

// DeviceTaintSelector defines which device(s) a DeviceTaintRule applies to. The empty selector matches all devices. Without a selector, no devices are matched.
type DeviceTaintSelectorOutput struct{ *pulumi.OutputState }

func (DeviceTaintSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintSelector)(nil)).Elem()
}

func (o DeviceTaintSelectorOutput) ToDeviceTaintSelectorOutput() DeviceTaintSelectorOutput {
	return o
}

func (o DeviceTaintSelectorOutput) ToDeviceTaintSelectorOutputWithContext(ctx context.Context) DeviceTaintSelectorOutput {
	return o
}

func (o DeviceTaintSelectorOutput) ToDeviceTaintSelectorPtrOutput() DeviceTaintSelectorPtrOutput {
	return o.ToDeviceTaintSelectorPtrOutputWithContext(context.Background())
}

func (o DeviceTaintSelectorOutput) ToDeviceTaintSelectorPtrOutputWithContext(ctx context.Context) DeviceTaintSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceTaintSelector) *DeviceTaintSelector {
		return &v
	}).(DeviceTaintSelectorPtrOutput)
}

// If device is set, only devices with that name are selected. This field corresponds to slice.spec.devices[].name.
//
// Setting also driver and pool may be required to avoid ambiguity, but is not required.
func (o DeviceTaintSelectorOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintSelector) *string { return v.Device }).(pulumi.StringPtrOutput)
}

// If DeviceClassName is set, the selectors defined there must be satisfied by a device to be selected. This field corresponds to class.metadata.name.
func (o DeviceTaintSelectorOutput) DeviceClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintSelector) *string { return v.DeviceClassName }).(pulumi.StringPtrOutput)
}

// If driver is set, only devices from that driver are selected. This fields corresponds to slice.spec.driver.
func (o DeviceTaintSelectorOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintSelector) *string { return v.Driver }).(pulumi.StringPtrOutput)
}

// If pool is set, only devices in that pool are selected.
//
// Also setting the driver name may be useful to avoid ambiguity when different drivers use the same pool name, but this is not required because selecting pools from different drivers may also be useful, for example when drivers with node-local devices use the node name as their pool name.
func (o DeviceTaintSelectorOutput) Pool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintSelector) *string { return v.Pool }).(pulumi.StringPtrOutput)
}

// Selectors contains the same selection criteria as a ResourceClaim. Currently, CEL expressions are supported. All of these selectors must be satisfied.
func (o DeviceTaintSelectorOutput) Selectors() DeviceSelectorArrayOutput {
	return o.ApplyT(func(v DeviceTaintSelector) []DeviceSelector { return v.Selectors }).(DeviceSelectorArrayOutput)
}

type DeviceTaintSelectorPtrOutput struct{ *pulumi.OutputState }

func (DeviceTaintSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceTaintSelector)(nil)).Elem()
}

func (o DeviceTaintSelectorPtrOutput) ToDeviceTaintSelectorPtrOutput() DeviceTaintSelectorPtrOutput {
	return o
}

func (o DeviceTaintSelectorPtrOutput) ToDeviceTaintSelectorPtrOutputWithContext(ctx context.Context) DeviceTaintSelectorPtrOutput {
	return o
}

func (o DeviceTaintSelectorPtrOutput) Elem() DeviceTaintSelectorOutput {
	return o.ApplyT(func(v *DeviceTaintSelector) DeviceTaintSelector {
		if v != nil {
			return *v
		}
		var ret DeviceTaintSelector
		return ret
	}).(DeviceTaintSelectorOutput)
}

// If device is set, only devices with that name are selected. This field corresponds to slice.spec.devices[].name.
//
// Setting also driver and pool may be required to avoid ambiguity, but is not required.
func (o DeviceTaintSelectorPtrOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintSelector) *string {
		if v == nil {
			return nil
		}
		return v.Device
	}).(pulumi.StringPtrOutput)
}

// If DeviceClassName is set, the selectors defined there must be satisfied by a device to be selected. This field corresponds to class.metadata.name.
func (o DeviceTaintSelectorPtrOutput) DeviceClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintSelector) *string {
		if v == nil {
			return nil
		}
		return v.DeviceClassName
	}).(pulumi.StringPtrOutput)
}

// If driver is set, only devices from that driver are selected. This fields corresponds to slice.spec.driver.
func (o DeviceTaintSelectorPtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintSelector) *string {
		if v == nil {
			return nil
		}
		return v.Driver
	}).(pulumi.StringPtrOutput)
}

// If pool is set, only devices in that pool are selected.
//
// Also setting the driver name may be useful to avoid ambiguity when different drivers use the same pool name, but this is not required because selecting pools from different drivers may also be useful, for example when drivers with node-local devices use the node name as their pool name.
func (o DeviceTaintSelectorPtrOutput) Pool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintSelector) *string {
		if v == nil {
			return nil
		}
		return v.Pool
	}).(pulumi.StringPtrOutput)
}

// Selectors contains the same selection criteria as a ResourceClaim. Currently, CEL expressions are supported. All of these selectors must be satisfied.
func (o DeviceTaintSelectorPtrOutput) Selectors() DeviceSelectorArrayOutput {
	return o.ApplyT(func(v *DeviceTaintSelector) []DeviceSelector {
		if v == nil {
			return nil
		}
		return v.Selectors
	}).(DeviceSelectorArrayOutput)
}

// DeviceTaintSelector defines which device(s) a DeviceTaintRule applies to. The empty selector matches all devices. Without a selector, no devices are matched.
type DeviceTaintSelectorPatch struct {
	// If device is set, only devices with that name are selected. This field corresponds to slice.spec.devices[].name.
	//
	// Setting also driver and pool may be required to avoid ambiguity, but is not required.
	Device *string `pulumi:"device"`
	// If DeviceClassName is set, the selectors defined there must be satisfied by a device to be selected. This field corresponds to class.metadata.name.
	DeviceClassName *string `pulumi:"deviceClassName"`
	// If driver is set, only devices from that driver are selected. This fields corresponds to slice.spec.driver.
	Driver *string `pulumi:"driver"`
	// If pool is set, only devices in that pool are selected.
	//
	// Also setting the driver name may be useful to avoid ambiguity when different drivers use the same pool name, but this is not required because selecting pools from different drivers may also be useful, for example when drivers with node-local devices use the node name as their pool name.
	Pool *string `pulumi:"pool"`
	// Selectors contains the same selection criteria as a ResourceClaim. Currently, CEL expressions are supported. All of these selectors must be satisfied.
	Selectors []DeviceSelectorPatch `pulumi:"selectors"`
}

// DeviceTaintSelectorPatchInput is an input type that accepts DeviceTaintSelectorPatchArgs and DeviceTaintSelectorPatchOutput values.
// You can construct a concrete instance of `DeviceTaintSelectorPatchInput` via:
//
//	DeviceTaintSelectorPatchArgs{...}
type DeviceTaintSelectorPatchInput interface {
	pulumi.Input

	ToDeviceTaintSelectorPatchOutput() DeviceTaintSelectorPatchOutput
	ToDeviceTaintSelectorPatchOutputWithContext(context.Context) DeviceTaintSelectorPatchOutput
}

// DeviceTaintSelector defines which device(s) a DeviceTaintRule applies to. The empty selector matches all devices. Without a selector, no devices are matched.
type DeviceTaintSelectorPatchArgs struct {
	// If device is set, only devices with that name are selected. This field corresponds to slice.spec.devices[].name.
	//
	// Setting also driver and pool may be required to avoid ambiguity, but is not required.
	Device pulumi.StringPtrInput `pulumi:"device"`
	// If DeviceClassName is set, the selectors defined there must be satisfied by a device to be selected. This field corresponds to class.metadata.name.
	DeviceClassName pulumi.StringPtrInput `pulumi:"deviceClassName"`
	// If driver is set, only devices from that driver are selected. This fields corresponds to slice.spec.driver.
	Driver pulumi.StringPtrInput `pulumi:"driver"`
	// If pool is set, only devices in that pool are selected.
	//
	// Also setting the driver name may be useful to avoid ambiguity when different drivers use the same pool name, but this is not required because selecting pools from different drivers may also be useful, for example when drivers with node-local devices use the node name as their pool name.
	Pool pulumi.StringPtrInput `pulumi:"pool"`
	// Selectors contains the same selection criteria as a ResourceClaim. Currently, CEL expressions are supported. All of these selectors must be satisfied.
	Selectors DeviceSelectorPatchArrayInput `pulumi:"selectors"`
}

func (DeviceTaintSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintSelectorPatch)(nil)).Elem()
}

func (i DeviceTaintSelectorPatchArgs) ToDeviceTaintSelectorPatchOutput() DeviceTaintSelectorPatchOutput {
	return i.ToDeviceTaintSelectorPatchOutputWithContext(context.Background())
}

func (i DeviceTaintSelectorPatchArgs) ToDeviceTaintSelectorPatchOutputWithContext(ctx context.Context) DeviceTaintSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintSelectorPatchOutput)
}

func (i DeviceTaintSelectorPatchArgs) ToDeviceTaintSelectorPatchPtrOutput() DeviceTaintSelectorPatchPtrOutput {
	return i.ToDeviceTaintSelectorPatchPtrOutputWithContext(context.Background())
}

func (i DeviceTaintSelectorPatchArgs) ToDeviceTaintSelectorPatchPtrOutputWithContext(ctx context.Context) DeviceTaintSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintSelectorPatchOutput).ToDeviceTaintSelectorPatchPtrOutputWithContext(ctx)
}

// DeviceTaintSelectorPatchPtrInput is an input type that accepts DeviceTaintSelectorPatchArgs, DeviceTaintSelectorPatchPtr and DeviceTaintSelectorPatchPtrOutput values.
// You can construct a concrete instance of `DeviceTaintSelectorPatchPtrInput` via:
//
//	        DeviceTaintSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type DeviceTaintSelectorPatchPtrInput interface {
	pulumi.Input

	ToDeviceTaintSelectorPatchPtrOutput() DeviceTaintSelectorPatchPtrOutput
	ToDeviceTaintSelectorPatchPtrOutputWithContext(context.Context) DeviceTaintSelectorPatchPtrOutput
}

type deviceTaintSelectorPatchPtrType DeviceTaintSelectorPatchArgs

func DeviceTaintSelectorPatchPtr(v *DeviceTaintSelectorPatchArgs) DeviceTaintSelectorPatchPtrInput {
	return (*deviceTaintSelectorPatchPtrType)(v)
}

func (*deviceTaintSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceTaintSelectorPatch)(nil)).Elem()
}

func (i *deviceTaintSelectorPatchPtrType) ToDeviceTaintSelectorPatchPtrOutput() DeviceTaintSelectorPatchPtrOutput {
	return i.ToDeviceTaintSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *deviceTaintSelectorPatchPtrType) ToDeviceTaintSelectorPatchPtrOutputWithContext(ctx context.Context) DeviceTaintSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceTaintSelectorPatchPtrOutput)
}

// DeviceTaintSelector defines which device(s) a DeviceTaintRule applies to. The empty selector matches all devices. Without a selector, no devices are matched.
type DeviceTaintSelectorPatchOutput struct{ *pulumi.OutputState }

func (DeviceTaintSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceTaintSelectorPatch)(nil)).Elem()
}

func (o DeviceTaintSelectorPatchOutput) ToDeviceTaintSelectorPatchOutput() DeviceTaintSelectorPatchOutput {
	return o
}

func (o DeviceTaintSelectorPatchOutput) ToDeviceTaintSelectorPatchOutputWithContext(ctx context.Context) DeviceTaintSelectorPatchOutput {
	return o
}

func (o DeviceTaintSelectorPatchOutput) ToDeviceTaintSelectorPatchPtrOutput() DeviceTaintSelectorPatchPtrOutput {
	return o.ToDeviceTaintSelectorPatchPtrOutputWithContext(context.Background())
}

func (o DeviceTaintSelectorPatchOutput) ToDeviceTaintSelectorPatchPtrOutputWithContext(ctx context.Context) DeviceTaintSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeviceTaintSelectorPatch) *DeviceTaintSelectorPatch {
		return &v
	}).(DeviceTaintSelectorPatchPtrOutput)
}

// If device is set, only devices with that name are selected. This field corresponds to slice.spec.devices[].name.
//
// Setting also driver and pool may be required to avoid ambiguity, but is not required.
func (o DeviceTaintSelectorPatchOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintSelectorPatch) *string { return v.Device }).(pulumi.StringPtrOutput)
}

// If DeviceClassName is set, the selectors defined there must be satisfied by a device to be selected. This field corresponds to class.metadata.name.
func (o DeviceTaintSelectorPatchOutput) DeviceClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintSelectorPatch) *string { return v.DeviceClassName }).(pulumi.StringPtrOutput)
}

// If driver is set, only devices from that driver are selected. This fields corresponds to slice.spec.driver.
func (o DeviceTaintSelectorPatchOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintSelectorPatch) *string { return v.Driver }).(pulumi.StringPtrOutput)
}

// If pool is set, only devices in that pool are selected.
//
// Also setting the driver name may be useful to avoid ambiguity when different drivers use the same pool name, but this is not required because selecting pools from different drivers may also be useful, for example when drivers with node-local devices use the node name as their pool name.
func (o DeviceTaintSelectorPatchOutput) Pool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeviceTaintSelectorPatch) *string { return v.Pool }).(pulumi.StringPtrOutput)
}

// Selectors contains the same selection criteria as a ResourceClaim. Currently, CEL expressions are supported. All of these selectors must be satisfied.
func (o DeviceTaintSelectorPatchOutput) Selectors() DeviceSelectorPatchArrayOutput {
	return o.ApplyT(func(v DeviceTaintSelectorPatch) []DeviceSelectorPatch { return v.Selectors }).(DeviceSelectorPatchArrayOutput)
}

type DeviceTaintSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (DeviceTaintSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeviceTaintSelectorPatch)(nil)).Elem()
}

func (o DeviceTaintSelectorPatchPtrOutput) ToDeviceTaintSelectorPatchPtrOutput() DeviceTaintSelectorPatchPtrOutput {
	return o
}

func (o DeviceTaintSelectorPatchPtrOutput) ToDeviceTaintSelectorPatchPtrOutputWithContext(ctx context.Context) DeviceTaintSelectorPatchPtrOutput {
	return o
}

func (o DeviceTaintSelectorPatchPtrOutput) Elem() DeviceTaintSelectorPatchOutput {
	return o.ApplyT(func(v *DeviceTaintSelectorPatch) DeviceTaintSelectorPatch {
		if v != nil {
			return *v
		}
		var ret DeviceTaintSelectorPatch
		return ret
	}).(DeviceTaintSelectorPatchOutput)
}

// If device is set, only devices with that name are selected. This field corresponds to slice.spec.devices[].name.
//
// Setting also driver and pool may be required to avoid ambiguity, but is not required.
func (o DeviceTaintSelectorPatchPtrOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintSelectorPatch) *string {
		if v == nil {
			return nil
		}
		return v.Device
	}).(pulumi.StringPtrOutput)
}

// If DeviceClassName is set, the selectors defined there must be satisfied by a device to be selected. This field corresponds to class.metadata.name.
func (o DeviceTaintSelectorPatchPtrOutput) DeviceClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintSelectorPatch) *string {
		if v == nil {
			return nil
		}
		return v.DeviceClassName
	}).(pulumi.StringPtrOutput)
}

// If driver is set, only devices from that driver are selected. This fields corresponds to slice.spec.driver.
func (o DeviceTaintSelectorPatchPtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintSelectorPatch) *string {
		if v == nil {
			return nil
		}
		return v.Driver
	}).(pulumi.StringPtrOutput)
}

// If pool is set, only devices in that pool are selected.
//
// Also setting the driver name may be useful to avoid ambiguity when different drivers use the same pool name, but this is not required because selecting pools from different drivers may also be useful, for example when drivers with node-local devices use the node name as their pool name.
func (o DeviceTaintSelectorPatchPtrOutput) Pool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeviceTaintSelectorPatch) *string {
		if v == nil {
			return nil
		}
		return v.Pool
	}).(pulumi.StringPtrOutput)
}

// Selectors contains the same selection criteria as a ResourceClaim. Currently, CEL expressions are supported. All of these selectors must be satisfied.
func (o DeviceTaintSelectorPatchPtrOutput) Selectors() DeviceSelectorPatchArrayOutput {
	return o.ApplyT(func(v *DeviceTaintSelectorPatch) []DeviceSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selectors
	}).(DeviceSelectorPatchArrayOutput)
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfiguration struct {
	// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
	//
	// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver string `pulumi:"driver"`
	// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
	Parameters interface{} `pulumi:"parameters"`
}

// OpaqueDeviceConfigurationInput is an input type that accepts OpaqueDeviceConfigurationArgs and OpaqueDeviceConfigurationOutput values.
// You can construct a concrete instance of `OpaqueDeviceConfigurationInput` via:
//
//	OpaqueDeviceConfigurationArgs{...}
type OpaqueDeviceConfigurationInput interface {
	pulumi.Input

	ToOpaqueDeviceConfigurationOutput() OpaqueDeviceConfigurationOutput
	ToOpaqueDeviceConfigurationOutputWithContext(context.Context) OpaqueDeviceConfigurationOutput
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationArgs struct {
	// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
	//
	// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringInput `pulumi:"driver"`
	// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
	Parameters pulumi.Input `pulumi:"parameters"`
}

func (OpaqueDeviceConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpaqueDeviceConfiguration)(nil)).Elem()
}

func (i OpaqueDeviceConfigurationArgs) ToOpaqueDeviceConfigurationOutput() OpaqueDeviceConfigurationOutput {
	return i.ToOpaqueDeviceConfigurationOutputWithContext(context.Background())
}

func (i OpaqueDeviceConfigurationArgs) ToOpaqueDeviceConfigurationOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationOutput)
}

func (i OpaqueDeviceConfigurationArgs) ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput {
	return i.ToOpaqueDeviceConfigurationPtrOutputWithContext(context.Background())
}

func (i OpaqueDeviceConfigurationArgs) ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationOutput).ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx)
}

// OpaqueDeviceConfigurationPtrInput is an input type that accepts OpaqueDeviceConfigurationArgs, OpaqueDeviceConfigurationPtr and OpaqueDeviceConfigurationPtrOutput values.
// You can construct a concrete instance of `OpaqueDeviceConfigurationPtrInput` via:
//
//	        OpaqueDeviceConfigurationArgs{...}
//
//	or:
//
//	        nil
type OpaqueDeviceConfigurationPtrInput interface {
	pulumi.Input

	ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput
	ToOpaqueDeviceConfigurationPtrOutputWithContext(context.Context) OpaqueDeviceConfigurationPtrOutput
}

type opaqueDeviceConfigurationPtrType OpaqueDeviceConfigurationArgs

func OpaqueDeviceConfigurationPtr(v *OpaqueDeviceConfigurationArgs) OpaqueDeviceConfigurationPtrInput {
	return (*opaqueDeviceConfigurationPtrType)(v)
}

func (*opaqueDeviceConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OpaqueDeviceConfiguration)(nil)).Elem()
}

func (i *opaqueDeviceConfigurationPtrType) ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput {
	return i.ToOpaqueDeviceConfigurationPtrOutputWithContext(context.Background())
}

func (i *opaqueDeviceConfigurationPtrType) ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationPtrOutput)
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationOutput struct{ *pulumi.OutputState }

func (OpaqueDeviceConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpaqueDeviceConfiguration)(nil)).Elem()
}

func (o OpaqueDeviceConfigurationOutput) ToOpaqueDeviceConfigurationOutput() OpaqueDeviceConfigurationOutput {
	return o
}

func (o OpaqueDeviceConfigurationOutput) ToOpaqueDeviceConfigurationOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationOutput {
	return o
}

func (o OpaqueDeviceConfigurationOutput) ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput {
	return o.ToOpaqueDeviceConfigurationPtrOutputWithContext(context.Background())
}

func (o OpaqueDeviceConfigurationOutput) ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OpaqueDeviceConfiguration) *OpaqueDeviceConfiguration {
		return &v
	}).(OpaqueDeviceConfigurationPtrOutput)
}

// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
//
// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o OpaqueDeviceConfigurationOutput) Driver() pulumi.StringOutput {
	return o.ApplyT(func(v OpaqueDeviceConfiguration) string { return v.Driver }).(pulumi.StringOutput)
}

// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
func (o OpaqueDeviceConfigurationOutput) Parameters() pulumi.AnyOutput {
	return o.ApplyT(func(v OpaqueDeviceConfiguration) interface{} { return v.Parameters }).(pulumi.AnyOutput)
}

type OpaqueDeviceConfigurationPtrOutput struct{ *pulumi.OutputState }

func (OpaqueDeviceConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OpaqueDeviceConfiguration)(nil)).Elem()
}

func (o OpaqueDeviceConfigurationPtrOutput) ToOpaqueDeviceConfigurationPtrOutput() OpaqueDeviceConfigurationPtrOutput {
	return o
}

func (o OpaqueDeviceConfigurationPtrOutput) ToOpaqueDeviceConfigurationPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPtrOutput {
	return o
}

func (o OpaqueDeviceConfigurationPtrOutput) Elem() OpaqueDeviceConfigurationOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfiguration) OpaqueDeviceConfiguration {
		if v != nil {
			return *v
		}
		var ret OpaqueDeviceConfiguration
		return ret
	}).(OpaqueDeviceConfigurationOutput)
}

// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
//
// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o OpaqueDeviceConfigurationPtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.Driver
	}).(pulumi.StringPtrOutput)
}

// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
func (o OpaqueDeviceConfigurationPtrOutput) Parameters() pulumi.AnyOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfiguration) interface{} {
		if v == nil {
			return nil
		}
		return v.Parameters
	}).(pulumi.AnyOutput)
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationPatch struct {
	// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
	//
	// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver *string `pulumi:"driver"`
	// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
	Parameters interface{} `pulumi:"parameters"`
}

// OpaqueDeviceConfigurationPatchInput is an input type that accepts OpaqueDeviceConfigurationPatchArgs and OpaqueDeviceConfigurationPatchOutput values.
// You can construct a concrete instance of `OpaqueDeviceConfigurationPatchInput` via:
//
//	OpaqueDeviceConfigurationPatchArgs{...}
type OpaqueDeviceConfigurationPatchInput interface {
	pulumi.Input

	ToOpaqueDeviceConfigurationPatchOutput() OpaqueDeviceConfigurationPatchOutput
	ToOpaqueDeviceConfigurationPatchOutputWithContext(context.Context) OpaqueDeviceConfigurationPatchOutput
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationPatchArgs struct {
	// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
	//
	// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	Driver pulumi.StringPtrInput `pulumi:"driver"`
	// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
	Parameters pulumi.Input `pulumi:"parameters"`
}

func (OpaqueDeviceConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpaqueDeviceConfigurationPatch)(nil)).Elem()
}

func (i OpaqueDeviceConfigurationPatchArgs) ToOpaqueDeviceConfigurationPatchOutput() OpaqueDeviceConfigurationPatchOutput {
	return i.ToOpaqueDeviceConfigurationPatchOutputWithContext(context.Background())
}

func (i OpaqueDeviceConfigurationPatchArgs) ToOpaqueDeviceConfigurationPatchOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationPatchOutput)
}

func (i OpaqueDeviceConfigurationPatchArgs) ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput {
	return i.ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i OpaqueDeviceConfigurationPatchArgs) ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationPatchOutput).ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx)
}

// OpaqueDeviceConfigurationPatchPtrInput is an input type that accepts OpaqueDeviceConfigurationPatchArgs, OpaqueDeviceConfigurationPatchPtr and OpaqueDeviceConfigurationPatchPtrOutput values.
// You can construct a concrete instance of `OpaqueDeviceConfigurationPatchPtrInput` via:
//
//	        OpaqueDeviceConfigurationPatchArgs{...}
//
//	or:
//
//	        nil
type OpaqueDeviceConfigurationPatchPtrInput interface {
	pulumi.Input

	ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput
	ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(context.Context) OpaqueDeviceConfigurationPatchPtrOutput
}

type opaqueDeviceConfigurationPatchPtrType OpaqueDeviceConfigurationPatchArgs

func OpaqueDeviceConfigurationPatchPtr(v *OpaqueDeviceConfigurationPatchArgs) OpaqueDeviceConfigurationPatchPtrInput {
	return (*opaqueDeviceConfigurationPatchPtrType)(v)
}

func (*opaqueDeviceConfigurationPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OpaqueDeviceConfigurationPatch)(nil)).Elem()
}

func (i *opaqueDeviceConfigurationPatchPtrType) ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput {
	return i.ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i *opaqueDeviceConfigurationPatchPtrType) ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpaqueDeviceConfigurationPatchPtrOutput)
}

// OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor.
type OpaqueDeviceConfigurationPatchOutput struct{ *pulumi.OutputState }

func (OpaqueDeviceConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpaqueDeviceConfigurationPatch)(nil)).Elem()
}

func (o OpaqueDeviceConfigurationPatchOutput) ToOpaqueDeviceConfigurationPatchOutput() OpaqueDeviceConfigurationPatchOutput {
	return o
}

func (o OpaqueDeviceConfigurationPatchOutput) ToOpaqueDeviceConfigurationPatchOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchOutput {
	return o
}

func (o OpaqueDeviceConfigurationPatchOutput) ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(context.Background())
}

func (o OpaqueDeviceConfigurationPatchOutput) ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OpaqueDeviceConfigurationPatch) *OpaqueDeviceConfigurationPatch {
		return &v
	}).(OpaqueDeviceConfigurationPatchPtrOutput)
}

// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
//
// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o OpaqueDeviceConfigurationPatchOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OpaqueDeviceConfigurationPatch) *string { return v.Driver }).(pulumi.StringPtrOutput)
}

// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
func (o OpaqueDeviceConfigurationPatchOutput) Parameters() pulumi.AnyOutput {
	return o.ApplyT(func(v OpaqueDeviceConfigurationPatch) interface{} { return v.Parameters }).(pulumi.AnyOutput)
}

type OpaqueDeviceConfigurationPatchPtrOutput struct{ *pulumi.OutputState }

func (OpaqueDeviceConfigurationPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OpaqueDeviceConfigurationPatch)(nil)).Elem()
}

func (o OpaqueDeviceConfigurationPatchPtrOutput) ToOpaqueDeviceConfigurationPatchPtrOutput() OpaqueDeviceConfigurationPatchPtrOutput {
	return o
}

func (o OpaqueDeviceConfigurationPatchPtrOutput) ToOpaqueDeviceConfigurationPatchPtrOutputWithContext(ctx context.Context) OpaqueDeviceConfigurationPatchPtrOutput {
	return o
}

func (o OpaqueDeviceConfigurationPatchPtrOutput) Elem() OpaqueDeviceConfigurationPatchOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfigurationPatch) OpaqueDeviceConfigurationPatch {
		if v != nil {
			return *v
		}
		var ret OpaqueDeviceConfigurationPatch
		return ret
	}).(OpaqueDeviceConfigurationPatchOutput)
}

// Driver is used to determine which kubelet plugin needs to be passed these configuration parameters.
//
// An admission policy provided by the driver developer could use this to decide whether it needs to validate them.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
func (o OpaqueDeviceConfigurationPatchPtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfigurationPatch) *string {
		if v == nil {
			return nil
		}
		return v.Driver
	}).(pulumi.StringPtrOutput)
}

// Parameters can contain arbitrary data. It is the responsibility of the driver developer to handle validation and versioning. Typically this includes self-identification and a version ("kind" + "apiVersion" for Kubernetes types), with conversion between different versions.
func (o OpaqueDeviceConfigurationPatchPtrOutput) Parameters() pulumi.AnyOutput {
	return o.ApplyT(func(v *OpaqueDeviceConfigurationPatch) interface{} {
		if v == nil {
			return nil
		}
		return v.Parameters
	}).(pulumi.AnyOutput)
}

// PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation mode.
//
// This is an alpha type and requires enabling the DRAControlPlaneController feature gate.
type PodSchedulingContextType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec describes where resources for the Pod are needed.
	Spec PodSchedulingContextSpec `pulumi:"spec"`
	// Status describes where resources for the Pod can be allocated.
	Status *PodSchedulingContextStatus `pulumi:"status"`
}

// PodSchedulingContextTypeInput is an input type that accepts PodSchedulingContextTypeArgs and PodSchedulingContextTypeOutput values.
// You can construct a concrete instance of `PodSchedulingContextTypeInput` via:
//
//	PodSchedulingContextTypeArgs{...}
type PodSchedulingContextTypeInput interface {
	pulumi.Input

	ToPodSchedulingContextTypeOutput() PodSchedulingContextTypeOutput
	ToPodSchedulingContextTypeOutputWithContext(context.Context) PodSchedulingContextTypeOutput
}

// PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation mode.
//
// This is an alpha type and requires enabling the DRAControlPlaneController feature gate.
type PodSchedulingContextTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec describes where resources for the Pod are needed.
	Spec PodSchedulingContextSpecInput `pulumi:"spec"`
	// Status describes where resources for the Pod can be allocated.
	Status PodSchedulingContextStatusPtrInput `pulumi:"status"`
}

func (PodSchedulingContextTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextType)(nil)).Elem()
}

func (i PodSchedulingContextTypeArgs) ToPodSchedulingContextTypeOutput() PodSchedulingContextTypeOutput {
	return i.ToPodSchedulingContextTypeOutputWithContext(context.Background())
}

func (i PodSchedulingContextTypeArgs) ToPodSchedulingContextTypeOutputWithContext(ctx context.Context) PodSchedulingContextTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextTypeOutput)
}

// PodSchedulingContextTypeArrayInput is an input type that accepts PodSchedulingContextTypeArray and PodSchedulingContextTypeArrayOutput values.
// You can construct a concrete instance of `PodSchedulingContextTypeArrayInput` via:
//
//	PodSchedulingContextTypeArray{ PodSchedulingContextTypeArgs{...} }
type PodSchedulingContextTypeArrayInput interface {
	pulumi.Input

	ToPodSchedulingContextTypeArrayOutput() PodSchedulingContextTypeArrayOutput
	ToPodSchedulingContextTypeArrayOutputWithContext(context.Context) PodSchedulingContextTypeArrayOutput
}

type PodSchedulingContextTypeArray []PodSchedulingContextTypeInput

func (PodSchedulingContextTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PodSchedulingContextType)(nil)).Elem()
}

func (i PodSchedulingContextTypeArray) ToPodSchedulingContextTypeArrayOutput() PodSchedulingContextTypeArrayOutput {
	return i.ToPodSchedulingContextTypeArrayOutputWithContext(context.Background())
}

func (i PodSchedulingContextTypeArray) ToPodSchedulingContextTypeArrayOutputWithContext(ctx context.Context) PodSchedulingContextTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextTypeArrayOutput)
}

// PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation mode.
//
// This is an alpha type and requires enabling the DRAControlPlaneController feature gate.
type PodSchedulingContextTypeOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextType)(nil)).Elem()
}

func (o PodSchedulingContextTypeOutput) ToPodSchedulingContextTypeOutput() PodSchedulingContextTypeOutput {
	return o
}

func (o PodSchedulingContextTypeOutput) ToPodSchedulingContextTypeOutputWithContext(ctx context.Context) PodSchedulingContextTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodSchedulingContextTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodSchedulingContextTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o PodSchedulingContextTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec describes where resources for the Pod are needed.
func (o PodSchedulingContextTypeOutput) Spec() PodSchedulingContextSpecOutput {
	return o.ApplyT(func(v PodSchedulingContextType) PodSchedulingContextSpec { return v.Spec }).(PodSchedulingContextSpecOutput)
}

// Status describes where resources for the Pod can be allocated.
func (o PodSchedulingContextTypeOutput) Status() PodSchedulingContextStatusPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextType) *PodSchedulingContextStatus { return v.Status }).(PodSchedulingContextStatusPtrOutput)
}

type PodSchedulingContextTypeArrayOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PodSchedulingContextType)(nil)).Elem()
}

func (o PodSchedulingContextTypeArrayOutput) ToPodSchedulingContextTypeArrayOutput() PodSchedulingContextTypeArrayOutput {
	return o
}

func (o PodSchedulingContextTypeArrayOutput) ToPodSchedulingContextTypeArrayOutputWithContext(ctx context.Context) PodSchedulingContextTypeArrayOutput {
	return o
}

func (o PodSchedulingContextTypeArrayOutput) Index(i pulumi.IntInput) PodSchedulingContextTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PodSchedulingContextType {
		return vs[0].([]PodSchedulingContextType)[vs[1].(int)]
	}).(PodSchedulingContextTypeOutput)
}

// PodSchedulingContextList is a collection of Pod scheduling objects.
type PodSchedulingContextListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of PodSchedulingContext objects.
	Items []PodSchedulingContextType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// PodSchedulingContextListTypeInput is an input type that accepts PodSchedulingContextListTypeArgs and PodSchedulingContextListTypeOutput values.
// You can construct a concrete instance of `PodSchedulingContextListTypeInput` via:
//
//	PodSchedulingContextListTypeArgs{...}
type PodSchedulingContextListTypeInput interface {
	pulumi.Input

	ToPodSchedulingContextListTypeOutput() PodSchedulingContextListTypeOutput
	ToPodSchedulingContextListTypeOutputWithContext(context.Context) PodSchedulingContextListTypeOutput
}

// PodSchedulingContextList is a collection of Pod scheduling objects.
type PodSchedulingContextListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of PodSchedulingContext objects.
	Items PodSchedulingContextTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (PodSchedulingContextListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextListType)(nil)).Elem()
}

func (i PodSchedulingContextListTypeArgs) ToPodSchedulingContextListTypeOutput() PodSchedulingContextListTypeOutput {
	return i.ToPodSchedulingContextListTypeOutputWithContext(context.Background())
}

func (i PodSchedulingContextListTypeArgs) ToPodSchedulingContextListTypeOutputWithContext(ctx context.Context) PodSchedulingContextListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextListTypeOutput)
}

// PodSchedulingContextList is a collection of Pod scheduling objects.
type PodSchedulingContextListTypeOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextListType)(nil)).Elem()
}

func (o PodSchedulingContextListTypeOutput) ToPodSchedulingContextListTypeOutput() PodSchedulingContextListTypeOutput {
	return o
}

func (o PodSchedulingContextListTypeOutput) ToPodSchedulingContextListTypeOutputWithContext(ctx context.Context) PodSchedulingContextListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodSchedulingContextListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of PodSchedulingContext objects.
func (o PodSchedulingContextListTypeOutput) Items() PodSchedulingContextTypeArrayOutput {
	return o.ApplyT(func(v PodSchedulingContextListType) []PodSchedulingContextType { return v.Items }).(PodSchedulingContextTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodSchedulingContextListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o PodSchedulingContextListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation mode.
//
// This is an alpha type and requires enabling the DRAControlPlaneController feature gate.
type PodSchedulingContextPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Spec describes where resources for the Pod are needed.
	Spec *PodSchedulingContextSpecPatch `pulumi:"spec"`
	// Status describes where resources for the Pod can be allocated.
	Status *PodSchedulingContextStatusPatch `pulumi:"status"`
}

// PodSchedulingContextPatchTypeInput is an input type that accepts PodSchedulingContextPatchTypeArgs and PodSchedulingContextPatchTypeOutput values.
// You can construct a concrete instance of `PodSchedulingContextPatchTypeInput` via:
//
//	PodSchedulingContextPatchTypeArgs{...}
type PodSchedulingContextPatchTypeInput interface {
	pulumi.Input

	ToPodSchedulingContextPatchTypeOutput() PodSchedulingContextPatchTypeOutput
	ToPodSchedulingContextPatchTypeOutputWithContext(context.Context) PodSchedulingContextPatchTypeOutput
}

// PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation mode.
//
// This is an alpha type and requires enabling the DRAControlPlaneController feature gate.
type PodSchedulingContextPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Spec describes where resources for the Pod are needed.
	Spec PodSchedulingContextSpecPatchPtrInput `pulumi:"spec"`
	// Status describes where resources for the Pod can be allocated.
	Status PodSchedulingContextStatusPatchPtrInput `pulumi:"status"`
}

func (PodSchedulingContextPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextPatchType)(nil)).Elem()
}

func (i PodSchedulingContextPatchTypeArgs) ToPodSchedulingContextPatchTypeOutput() PodSchedulingContextPatchTypeOutput {
	return i.ToPodSchedulingContextPatchTypeOutputWithContext(context.Background())
}

func (i PodSchedulingContextPatchTypeArgs) ToPodSchedulingContextPatchTypeOutputWithContext(ctx context.Context) PodSchedulingContextPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextPatchTypeOutput)
}

// PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation mode.
//
// This is an alpha type and requires enabling the DRAControlPlaneController feature gate.
type PodSchedulingContextPatchTypeOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextPatchType)(nil)).Elem()
}

func (o PodSchedulingContextPatchTypeOutput) ToPodSchedulingContextPatchTypeOutput() PodSchedulingContextPatchTypeOutput {
	return o
}

func (o PodSchedulingContextPatchTypeOutput) ToPodSchedulingContextPatchTypeOutputWithContext(ctx context.Context) PodSchedulingContextPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodSchedulingContextPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodSchedulingContextPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o PodSchedulingContextPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec describes where resources for the Pod are needed.
func (o PodSchedulingContextPatchTypeOutput) Spec() PodSchedulingContextSpecPatchPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextPatchType) *PodSchedulingContextSpecPatch { return v.Spec }).(PodSchedulingContextSpecPatchPtrOutput)
}

// Status describes where resources for the Pod can be allocated.
func (o PodSchedulingContextPatchTypeOutput) Status() PodSchedulingContextStatusPatchPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextPatchType) *PodSchedulingContextStatusPatch { return v.Status }).(PodSchedulingContextStatusPatchPtrOutput)
}

// PodSchedulingContextSpec describes where resources for the Pod are needed.
type PodSchedulingContextSpec struct {
	// PotentialNodes lists nodes where the Pod might be able to run.
	//
	// The size of this field is limited to 128. This is large enough for many clusters. Larger clusters may need more attempts to find a node that suits all pending resources. This may get increased in the future, but not reduced.
	PotentialNodes []string `pulumi:"potentialNodes"`
	// SelectedNode is the node for which allocation of ResourceClaims that are referenced by the Pod and that use "WaitForFirstConsumer" allocation is to be attempted.
	SelectedNode *string `pulumi:"selectedNode"`
}

// PodSchedulingContextSpecInput is an input type that accepts PodSchedulingContextSpecArgs and PodSchedulingContextSpecOutput values.
// You can construct a concrete instance of `PodSchedulingContextSpecInput` via:
//
//	PodSchedulingContextSpecArgs{...}
type PodSchedulingContextSpecInput interface {
	pulumi.Input

	ToPodSchedulingContextSpecOutput() PodSchedulingContextSpecOutput
	ToPodSchedulingContextSpecOutputWithContext(context.Context) PodSchedulingContextSpecOutput
}

// PodSchedulingContextSpec describes where resources for the Pod are needed.
type PodSchedulingContextSpecArgs struct {
	// PotentialNodes lists nodes where the Pod might be able to run.
	//
	// The size of this field is limited to 128. This is large enough for many clusters. Larger clusters may need more attempts to find a node that suits all pending resources. This may get increased in the future, but not reduced.
	PotentialNodes pulumi.StringArrayInput `pulumi:"potentialNodes"`
	// SelectedNode is the node for which allocation of ResourceClaims that are referenced by the Pod and that use "WaitForFirstConsumer" allocation is to be attempted.
	SelectedNode pulumi.StringPtrInput `pulumi:"selectedNode"`
}

func (PodSchedulingContextSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextSpec)(nil)).Elem()
}

func (i PodSchedulingContextSpecArgs) ToPodSchedulingContextSpecOutput() PodSchedulingContextSpecOutput {
	return i.ToPodSchedulingContextSpecOutputWithContext(context.Background())
}

func (i PodSchedulingContextSpecArgs) ToPodSchedulingContextSpecOutputWithContext(ctx context.Context) PodSchedulingContextSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextSpecOutput)
}

// PodSchedulingContextSpec describes where resources for the Pod are needed.
type PodSchedulingContextSpecOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextSpec)(nil)).Elem()
}

func (o PodSchedulingContextSpecOutput) ToPodSchedulingContextSpecOutput() PodSchedulingContextSpecOutput {
	return o
}

func (o PodSchedulingContextSpecOutput) ToPodSchedulingContextSpecOutputWithContext(ctx context.Context) PodSchedulingContextSpecOutput {
	return o
}

// PotentialNodes lists nodes where the Pod might be able to run.
//
// The size of this field is limited to 128. This is large enough for many clusters. Larger clusters may need more attempts to find a node that suits all pending resources. This may get increased in the future, but not reduced.
func (o PodSchedulingContextSpecOutput) PotentialNodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PodSchedulingContextSpec) []string { return v.PotentialNodes }).(pulumi.StringArrayOutput)
}

// SelectedNode is the node for which allocation of ResourceClaims that are referenced by the Pod and that use "WaitForFirstConsumer" allocation is to be attempted.
func (o PodSchedulingContextSpecOutput) SelectedNode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextSpec) *string { return v.SelectedNode }).(pulumi.StringPtrOutput)
}

// PodSchedulingContextSpec describes where resources for the Pod are needed.
type PodSchedulingContextSpecPatch struct {
	// PotentialNodes lists nodes where the Pod might be able to run.
	//
	// The size of this field is limited to 128. This is large enough for many clusters. Larger clusters may need more attempts to find a node that suits all pending resources. This may get increased in the future, but not reduced.
	PotentialNodes []string `pulumi:"potentialNodes"`
	// SelectedNode is the node for which allocation of ResourceClaims that are referenced by the Pod and that use "WaitForFirstConsumer" allocation is to be attempted.
	SelectedNode *string `pulumi:"selectedNode"`
}

// PodSchedulingContextSpecPatchInput is an input type that accepts PodSchedulingContextSpecPatchArgs and PodSchedulingContextSpecPatchOutput values.
// You can construct a concrete instance of `PodSchedulingContextSpecPatchInput` via:
//
//	PodSchedulingContextSpecPatchArgs{...}
type PodSchedulingContextSpecPatchInput interface {
	pulumi.Input

	ToPodSchedulingContextSpecPatchOutput() PodSchedulingContextSpecPatchOutput
	ToPodSchedulingContextSpecPatchOutputWithContext(context.Context) PodSchedulingContextSpecPatchOutput
}

// PodSchedulingContextSpec describes where resources for the Pod are needed.
type PodSchedulingContextSpecPatchArgs struct {
	// PotentialNodes lists nodes where the Pod might be able to run.
	//
	// The size of this field is limited to 128. This is large enough for many clusters. Larger clusters may need more attempts to find a node that suits all pending resources. This may get increased in the future, but not reduced.
	PotentialNodes pulumi.StringArrayInput `pulumi:"potentialNodes"`
	// SelectedNode is the node for which allocation of ResourceClaims that are referenced by the Pod and that use "WaitForFirstConsumer" allocation is to be attempted.
	SelectedNode pulumi.StringPtrInput `pulumi:"selectedNode"`
}

func (PodSchedulingContextSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextSpecPatch)(nil)).Elem()
}

func (i PodSchedulingContextSpecPatchArgs) ToPodSchedulingContextSpecPatchOutput() PodSchedulingContextSpecPatchOutput {
	return i.ToPodSchedulingContextSpecPatchOutputWithContext(context.Background())
}

func (i PodSchedulingContextSpecPatchArgs) ToPodSchedulingContextSpecPatchOutputWithContext(ctx context.Context) PodSchedulingContextSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextSpecPatchOutput)
}

func (i PodSchedulingContextSpecPatchArgs) ToPodSchedulingContextSpecPatchPtrOutput() PodSchedulingContextSpecPatchPtrOutput {
	return i.ToPodSchedulingContextSpecPatchPtrOutputWithContext(context.Background())
}

func (i PodSchedulingContextSpecPatchArgs) ToPodSchedulingContextSpecPatchPtrOutputWithContext(ctx context.Context) PodSchedulingContextSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextSpecPatchOutput).ToPodSchedulingContextSpecPatchPtrOutputWithContext(ctx)
}

// PodSchedulingContextSpecPatchPtrInput is an input type that accepts PodSchedulingContextSpecPatchArgs, PodSchedulingContextSpecPatchPtr and PodSchedulingContextSpecPatchPtrOutput values.
// You can construct a concrete instance of `PodSchedulingContextSpecPatchPtrInput` via:
//
//	        PodSchedulingContextSpecPatchArgs{...}
//
//	or:
//
//	        nil
type PodSchedulingContextSpecPatchPtrInput interface {
	pulumi.Input

	ToPodSchedulingContextSpecPatchPtrOutput() PodSchedulingContextSpecPatchPtrOutput
	ToPodSchedulingContextSpecPatchPtrOutputWithContext(context.Context) PodSchedulingContextSpecPatchPtrOutput
}

type podSchedulingContextSpecPatchPtrType PodSchedulingContextSpecPatchArgs

func PodSchedulingContextSpecPatchPtr(v *PodSchedulingContextSpecPatchArgs) PodSchedulingContextSpecPatchPtrInput {
	return (*podSchedulingContextSpecPatchPtrType)(v)
}

func (*podSchedulingContextSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodSchedulingContextSpecPatch)(nil)).Elem()
}

func (i *podSchedulingContextSpecPatchPtrType) ToPodSchedulingContextSpecPatchPtrOutput() PodSchedulingContextSpecPatchPtrOutput {
	return i.ToPodSchedulingContextSpecPatchPtrOutputWithContext(context.Background())
}

func (i *podSchedulingContextSpecPatchPtrType) ToPodSchedulingContextSpecPatchPtrOutputWithContext(ctx context.Context) PodSchedulingContextSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextSpecPatchPtrOutput)
}

// PodSchedulingContextSpec describes where resources for the Pod are needed.
type PodSchedulingContextSpecPatchOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextSpecPatch)(nil)).Elem()
}

func (o PodSchedulingContextSpecPatchOutput) ToPodSchedulingContextSpecPatchOutput() PodSchedulingContextSpecPatchOutput {
	return o
}

func (o PodSchedulingContextSpecPatchOutput) ToPodSchedulingContextSpecPatchOutputWithContext(ctx context.Context) PodSchedulingContextSpecPatchOutput {
	return o
}

func (o PodSchedulingContextSpecPatchOutput) ToPodSchedulingContextSpecPatchPtrOutput() PodSchedulingContextSpecPatchPtrOutput {
	return o.ToPodSchedulingContextSpecPatchPtrOutputWithContext(context.Background())
}

func (o PodSchedulingContextSpecPatchOutput) ToPodSchedulingContextSpecPatchPtrOutputWithContext(ctx context.Context) PodSchedulingContextSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodSchedulingContextSpecPatch) *PodSchedulingContextSpecPatch {
		return &v
	}).(PodSchedulingContextSpecPatchPtrOutput)
}

// PotentialNodes lists nodes where the Pod might be able to run.
//
// The size of this field is limited to 128. This is large enough for many clusters. Larger clusters may need more attempts to find a node that suits all pending resources. This may get increased in the future, but not reduced.
func (o PodSchedulingContextSpecPatchOutput) PotentialNodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PodSchedulingContextSpecPatch) []string { return v.PotentialNodes }).(pulumi.StringArrayOutput)
}

// SelectedNode is the node for which allocation of ResourceClaims that are referenced by the Pod and that use "WaitForFirstConsumer" allocation is to be attempted.
func (o PodSchedulingContextSpecPatchOutput) SelectedNode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodSchedulingContextSpecPatch) *string { return v.SelectedNode }).(pulumi.StringPtrOutput)
}

type PodSchedulingContextSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodSchedulingContextSpecPatch)(nil)).Elem()
}

func (o PodSchedulingContextSpecPatchPtrOutput) ToPodSchedulingContextSpecPatchPtrOutput() PodSchedulingContextSpecPatchPtrOutput {
	return o
}

func (o PodSchedulingContextSpecPatchPtrOutput) ToPodSchedulingContextSpecPatchPtrOutputWithContext(ctx context.Context) PodSchedulingContextSpecPatchPtrOutput {
	return o
}

func (o PodSchedulingContextSpecPatchPtrOutput) Elem() PodSchedulingContextSpecPatchOutput {
	return o.ApplyT(func(v *PodSchedulingContextSpecPatch) PodSchedulingContextSpecPatch {
		if v != nil {
			return *v
		}
		var ret PodSchedulingContextSpecPatch
		return ret
	}).(PodSchedulingContextSpecPatchOutput)
}

// PotentialNodes lists nodes where the Pod might be able to run.
//
// The size of this field is limited to 128. This is large enough for many clusters. Larger clusters may need more attempts to find a node that suits all pending resources. This may get increased in the future, but not reduced.
func (o PodSchedulingContextSpecPatchPtrOutput) PotentialNodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PodSchedulingContextSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.PotentialNodes
	}).(pulumi.StringArrayOutput)
}

// SelectedNode is the node for which allocation of ResourceClaims that are referenced by the Pod and that use "WaitForFirstConsumer" allocation is to be attempted.
func (o PodSchedulingContextSpecPatchPtrOutput) SelectedNode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodSchedulingContextSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.SelectedNode
	}).(pulumi.StringPtrOutput)
}

// PodSchedulingContextStatus describes where resources for the Pod can be allocated.
type PodSchedulingContextStatus struct {
	// ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
	ResourceClaims []ResourceClaimSchedulingStatus `pulumi:"resourceClaims"`
}

// PodSchedulingContextStatusInput is an input type that accepts PodSchedulingContextStatusArgs and PodSchedulingContextStatusOutput values.
// You can construct a concrete instance of `PodSchedulingContextStatusInput` via:
//
//	PodSchedulingContextStatusArgs{...}
type PodSchedulingContextStatusInput interface {
	pulumi.Input

	ToPodSchedulingContextStatusOutput() PodSchedulingContextStatusOutput
	ToPodSchedulingContextStatusOutputWithContext(context.Context) PodSchedulingContextStatusOutput
}

// PodSchedulingContextStatus describes where resources for the Pod can be allocated.
type PodSchedulingContextStatusArgs struct {
	// ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
	ResourceClaims ResourceClaimSchedulingStatusArrayInput `pulumi:"resourceClaims"`
}

func (PodSchedulingContextStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextStatus)(nil)).Elem()
}

func (i PodSchedulingContextStatusArgs) ToPodSchedulingContextStatusOutput() PodSchedulingContextStatusOutput {
	return i.ToPodSchedulingContextStatusOutputWithContext(context.Background())
}

func (i PodSchedulingContextStatusArgs) ToPodSchedulingContextStatusOutputWithContext(ctx context.Context) PodSchedulingContextStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextStatusOutput)
}

func (i PodSchedulingContextStatusArgs) ToPodSchedulingContextStatusPtrOutput() PodSchedulingContextStatusPtrOutput {
	return i.ToPodSchedulingContextStatusPtrOutputWithContext(context.Background())
}

func (i PodSchedulingContextStatusArgs) ToPodSchedulingContextStatusPtrOutputWithContext(ctx context.Context) PodSchedulingContextStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextStatusOutput).ToPodSchedulingContextStatusPtrOutputWithContext(ctx)
}

// PodSchedulingContextStatusPtrInput is an input type that accepts PodSchedulingContextStatusArgs, PodSchedulingContextStatusPtr and PodSchedulingContextStatusPtrOutput values.
// You can construct a concrete instance of `PodSchedulingContextStatusPtrInput` via:
//
//	        PodSchedulingContextStatusArgs{...}
//
//	or:
//
//	        nil
type PodSchedulingContextStatusPtrInput interface {
	pulumi.Input

	ToPodSchedulingContextStatusPtrOutput() PodSchedulingContextStatusPtrOutput
	ToPodSchedulingContextStatusPtrOutputWithContext(context.Context) PodSchedulingContextStatusPtrOutput
}

type podSchedulingContextStatusPtrType PodSchedulingContextStatusArgs

func PodSchedulingContextStatusPtr(v *PodSchedulingContextStatusArgs) PodSchedulingContextStatusPtrInput {
	return (*podSchedulingContextStatusPtrType)(v)
}

func (*podSchedulingContextStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodSchedulingContextStatus)(nil)).Elem()
}

func (i *podSchedulingContextStatusPtrType) ToPodSchedulingContextStatusPtrOutput() PodSchedulingContextStatusPtrOutput {
	return i.ToPodSchedulingContextStatusPtrOutputWithContext(context.Background())
}

func (i *podSchedulingContextStatusPtrType) ToPodSchedulingContextStatusPtrOutputWithContext(ctx context.Context) PodSchedulingContextStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextStatusPtrOutput)
}

// PodSchedulingContextStatus describes where resources for the Pod can be allocated.
type PodSchedulingContextStatusOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextStatus)(nil)).Elem()
}

func (o PodSchedulingContextStatusOutput) ToPodSchedulingContextStatusOutput() PodSchedulingContextStatusOutput {
	return o
}

func (o PodSchedulingContextStatusOutput) ToPodSchedulingContextStatusOutputWithContext(ctx context.Context) PodSchedulingContextStatusOutput {
	return o
}

func (o PodSchedulingContextStatusOutput) ToPodSchedulingContextStatusPtrOutput() PodSchedulingContextStatusPtrOutput {
	return o.ToPodSchedulingContextStatusPtrOutputWithContext(context.Background())
}

func (o PodSchedulingContextStatusOutput) ToPodSchedulingContextStatusPtrOutputWithContext(ctx context.Context) PodSchedulingContextStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodSchedulingContextStatus) *PodSchedulingContextStatus {
		return &v
	}).(PodSchedulingContextStatusPtrOutput)
}

// ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
func (o PodSchedulingContextStatusOutput) ResourceClaims() ResourceClaimSchedulingStatusArrayOutput {
	return o.ApplyT(func(v PodSchedulingContextStatus) []ResourceClaimSchedulingStatus { return v.ResourceClaims }).(ResourceClaimSchedulingStatusArrayOutput)
}

type PodSchedulingContextStatusPtrOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodSchedulingContextStatus)(nil)).Elem()
}

func (o PodSchedulingContextStatusPtrOutput) ToPodSchedulingContextStatusPtrOutput() PodSchedulingContextStatusPtrOutput {
	return o
}

func (o PodSchedulingContextStatusPtrOutput) ToPodSchedulingContextStatusPtrOutputWithContext(ctx context.Context) PodSchedulingContextStatusPtrOutput {
	return o
}

func (o PodSchedulingContextStatusPtrOutput) Elem() PodSchedulingContextStatusOutput {
	return o.ApplyT(func(v *PodSchedulingContextStatus) PodSchedulingContextStatus {
		if v != nil {
			return *v
		}
		var ret PodSchedulingContextStatus
		return ret
	}).(PodSchedulingContextStatusOutput)
}

// ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
func (o PodSchedulingContextStatusPtrOutput) ResourceClaims() ResourceClaimSchedulingStatusArrayOutput {
	return o.ApplyT(func(v *PodSchedulingContextStatus) []ResourceClaimSchedulingStatus {
		if v == nil {
			return nil
		}
		return v.ResourceClaims
	}).(ResourceClaimSchedulingStatusArrayOutput)
}

// PodSchedulingContextStatus describes where resources for the Pod can be allocated.
type PodSchedulingContextStatusPatch struct {
	// ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
	ResourceClaims []ResourceClaimSchedulingStatusPatch `pulumi:"resourceClaims"`
}

// PodSchedulingContextStatusPatchInput is an input type that accepts PodSchedulingContextStatusPatchArgs and PodSchedulingContextStatusPatchOutput values.
// You can construct a concrete instance of `PodSchedulingContextStatusPatchInput` via:
//
//	PodSchedulingContextStatusPatchArgs{...}
type PodSchedulingContextStatusPatchInput interface {
	pulumi.Input

	ToPodSchedulingContextStatusPatchOutput() PodSchedulingContextStatusPatchOutput
	ToPodSchedulingContextStatusPatchOutputWithContext(context.Context) PodSchedulingContextStatusPatchOutput
}

// PodSchedulingContextStatus describes where resources for the Pod can be allocated.
type PodSchedulingContextStatusPatchArgs struct {
	// ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
	ResourceClaims ResourceClaimSchedulingStatusPatchArrayInput `pulumi:"resourceClaims"`
}

func (PodSchedulingContextStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextStatusPatch)(nil)).Elem()
}

func (i PodSchedulingContextStatusPatchArgs) ToPodSchedulingContextStatusPatchOutput() PodSchedulingContextStatusPatchOutput {
	return i.ToPodSchedulingContextStatusPatchOutputWithContext(context.Background())
}

func (i PodSchedulingContextStatusPatchArgs) ToPodSchedulingContextStatusPatchOutputWithContext(ctx context.Context) PodSchedulingContextStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextStatusPatchOutput)
}

func (i PodSchedulingContextStatusPatchArgs) ToPodSchedulingContextStatusPatchPtrOutput() PodSchedulingContextStatusPatchPtrOutput {
	return i.ToPodSchedulingContextStatusPatchPtrOutputWithContext(context.Background())
}

func (i PodSchedulingContextStatusPatchArgs) ToPodSchedulingContextStatusPatchPtrOutputWithContext(ctx context.Context) PodSchedulingContextStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextStatusPatchOutput).ToPodSchedulingContextStatusPatchPtrOutputWithContext(ctx)
}

// PodSchedulingContextStatusPatchPtrInput is an input type that accepts PodSchedulingContextStatusPatchArgs, PodSchedulingContextStatusPatchPtr and PodSchedulingContextStatusPatchPtrOutput values.
// You can construct a concrete instance of `PodSchedulingContextStatusPatchPtrInput` via:
//
//	        PodSchedulingContextStatusPatchArgs{...}
//
//	or:
//
//	        nil
type PodSchedulingContextStatusPatchPtrInput interface {
	pulumi.Input

	ToPodSchedulingContextStatusPatchPtrOutput() PodSchedulingContextStatusPatchPtrOutput
	ToPodSchedulingContextStatusPatchPtrOutputWithContext(context.Context) PodSchedulingContextStatusPatchPtrOutput
}

type podSchedulingContextStatusPatchPtrType PodSchedulingContextStatusPatchArgs

func PodSchedulingContextStatusPatchPtr(v *PodSchedulingContextStatusPatchArgs) PodSchedulingContextStatusPatchPtrInput {
	return (*podSchedulingContextStatusPatchPtrType)(v)
}

func (*podSchedulingContextStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodSchedulingContextStatusPatch)(nil)).Elem()
}

func (i *podSchedulingContextStatusPatchPtrType) ToPodSchedulingContextStatusPatchPtrOutput() PodSchedulingContextStatusPatchPtrOutput {
	return i.ToPodSchedulingContextStatusPatchPtrOutputWithContext(context.Background())
}

func (i *podSchedulingContextStatusPatchPtrType) ToPodSchedulingContextStatusPatchPtrOutputWithContext(ctx context.Context) PodSchedulingContextStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodSchedulingContextStatusPatchPtrOutput)
}

// PodSchedulingContextStatus describes where resources for the Pod can be allocated.
type PodSchedulingContextStatusPatchOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodSchedulingContextStatusPatch)(nil)).Elem()
}

func (o PodSchedulingContextStatusPatchOutput) ToPodSchedulingContextStatusPatchOutput() PodSchedulingContextStatusPatchOutput {
	return o
}

func (o PodSchedulingContextStatusPatchOutput) ToPodSchedulingContextStatusPatchOutputWithContext(ctx context.Context) PodSchedulingContextStatusPatchOutput {
	return o
}

func (o PodSchedulingContextStatusPatchOutput) ToPodSchedulingContextStatusPatchPtrOutput() PodSchedulingContextStatusPatchPtrOutput {
	return o.ToPodSchedulingContextStatusPatchPtrOutputWithContext(context.Background())
}

func (o PodSchedulingContextStatusPatchOutput) ToPodSchedulingContextStatusPatchPtrOutputWithContext(ctx context.Context) PodSchedulingContextStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodSchedulingContextStatusPatch) *PodSchedulingContextStatusPatch {
		return &v
	}).(PodSchedulingContextStatusPatchPtrOutput)
}

// ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
func (o PodSchedulingContextStatusPatchOutput) ResourceClaims() ResourceClaimSchedulingStatusPatchArrayOutput {
	return o.ApplyT(func(v PodSchedulingContextStatusPatch) []ResourceClaimSchedulingStatusPatch { return v.ResourceClaims }).(ResourceClaimSchedulingStatusPatchArrayOutput)
}

type PodSchedulingContextStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (PodSchedulingContextStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodSchedulingContextStatusPatch)(nil)).Elem()
}

func (o PodSchedulingContextStatusPatchPtrOutput) ToPodSchedulingContextStatusPatchPtrOutput() PodSchedulingContextStatusPatchPtrOutput {
	return o
}

func (o PodSchedulingContextStatusPatchPtrOutput) ToPodSchedulingContextStatusPatchPtrOutputWithContext(ctx context.Context) PodSchedulingContextStatusPatchPtrOutput {
	return o
}

func (o PodSchedulingContextStatusPatchPtrOutput) Elem() PodSchedulingContextStatusPatchOutput {
	return o.ApplyT(func(v *PodSchedulingContextStatusPatch) PodSchedulingContextStatusPatch {
		if v != nil {
			return *v
		}
		var ret PodSchedulingContextStatusPatch
		return ret
	}).(PodSchedulingContextStatusPatchOutput)
}

// ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
func (o PodSchedulingContextStatusPatchPtrOutput) ResourceClaims() ResourceClaimSchedulingStatusPatchArrayOutput {
	return o.ApplyT(func(v *PodSchedulingContextStatusPatch) []ResourceClaimSchedulingStatusPatch {
		if v == nil {
			return nil
		}
		return v.ResourceClaims
	}).(ResourceClaimSchedulingStatusPatchArrayOutput)
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec describes what is being requested and how to configure it. The spec is immutable.
	Spec ResourceClaimSpec `pulumi:"spec"`
	// Status describes whether the claim is ready to use and what has been allocated.
	Status *ResourceClaimStatus `pulumi:"status"`
}

// ResourceClaimTypeInput is an input type that accepts ResourceClaimTypeArgs and ResourceClaimTypeOutput values.
// You can construct a concrete instance of `ResourceClaimTypeInput` via:
//
//	ResourceClaimTypeArgs{...}
type ResourceClaimTypeInput interface {
	pulumi.Input

	ToResourceClaimTypeOutput() ResourceClaimTypeOutput
	ToResourceClaimTypeOutputWithContext(context.Context) ResourceClaimTypeOutput
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec describes what is being requested and how to configure it. The spec is immutable.
	Spec ResourceClaimSpecInput `pulumi:"spec"`
	// Status describes whether the claim is ready to use and what has been allocated.
	Status ResourceClaimStatusPtrInput `pulumi:"status"`
}

func (ResourceClaimTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimType)(nil)).Elem()
}

func (i ResourceClaimTypeArgs) ToResourceClaimTypeOutput() ResourceClaimTypeOutput {
	return i.ToResourceClaimTypeOutputWithContext(context.Background())
}

func (i ResourceClaimTypeArgs) ToResourceClaimTypeOutputWithContext(ctx context.Context) ResourceClaimTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTypeOutput)
}

// ResourceClaimTypeArrayInput is an input type that accepts ResourceClaimTypeArray and ResourceClaimTypeArrayOutput values.
// You can construct a concrete instance of `ResourceClaimTypeArrayInput` via:
//
//	ResourceClaimTypeArray{ ResourceClaimTypeArgs{...} }
type ResourceClaimTypeArrayInput interface {
	pulumi.Input

	ToResourceClaimTypeArrayOutput() ResourceClaimTypeArrayOutput
	ToResourceClaimTypeArrayOutputWithContext(context.Context) ResourceClaimTypeArrayOutput
}

type ResourceClaimTypeArray []ResourceClaimTypeInput

func (ResourceClaimTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimType)(nil)).Elem()
}

func (i ResourceClaimTypeArray) ToResourceClaimTypeArrayOutput() ResourceClaimTypeArrayOutput {
	return i.ToResourceClaimTypeArrayOutputWithContext(context.Background())
}

func (i ResourceClaimTypeArray) ToResourceClaimTypeArrayOutputWithContext(ctx context.Context) ResourceClaimTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTypeArrayOutput)
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimType)(nil)).Elem()
}

func (o ResourceClaimTypeOutput) ToResourceClaimTypeOutput() ResourceClaimTypeOutput {
	return o
}

func (o ResourceClaimTypeOutput) ToResourceClaimTypeOutputWithContext(ctx context.Context) ResourceClaimTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceClaimTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec describes what is being requested and how to configure it. The spec is immutable.
func (o ResourceClaimTypeOutput) Spec() ResourceClaimSpecOutput {
	return o.ApplyT(func(v ResourceClaimType) ResourceClaimSpec { return v.Spec }).(ResourceClaimSpecOutput)
}

// Status describes whether the claim is ready to use and what has been allocated.
func (o ResourceClaimTypeOutput) Status() ResourceClaimStatusPtrOutput {
	return o.ApplyT(func(v ResourceClaimType) *ResourceClaimStatus { return v.Status }).(ResourceClaimStatusPtrOutput)
}

type ResourceClaimTypeArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimType)(nil)).Elem()
}

func (o ResourceClaimTypeArrayOutput) ToResourceClaimTypeArrayOutput() ResourceClaimTypeArrayOutput {
	return o
}

func (o ResourceClaimTypeArrayOutput) ToResourceClaimTypeArrayOutputWithContext(ctx context.Context) ResourceClaimTypeArrayOutput {
	return o
}

func (o ResourceClaimTypeArrayOutput) Index(i pulumi.IntInput) ResourceClaimTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimType {
		return vs[0].([]ResourceClaimType)[vs[1].(int)]
	}).(ResourceClaimTypeOutput)
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReference struct {
	// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
	ApiGroup *string `pulumi:"apiGroup"`
	// Name is the name of resource being referenced.
	Name string `pulumi:"name"`
	// Resource is the type of resource being referenced, for example "pods".
	Resource string `pulumi:"resource"`
	// UID identifies exactly one incarnation of the resource.
	Uid string `pulumi:"uid"`
}

// ResourceClaimConsumerReferenceInput is an input type that accepts ResourceClaimConsumerReferenceArgs and ResourceClaimConsumerReferenceOutput values.
// You can construct a concrete instance of `ResourceClaimConsumerReferenceInput` via:
//
//	ResourceClaimConsumerReferenceArgs{...}
type ResourceClaimConsumerReferenceInput interface {
	pulumi.Input

	ToResourceClaimConsumerReferenceOutput() ResourceClaimConsumerReferenceOutput
	ToResourceClaimConsumerReferenceOutputWithContext(context.Context) ResourceClaimConsumerReferenceOutput
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferenceArgs struct {
	// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Name is the name of resource being referenced.
	Name pulumi.StringInput `pulumi:"name"`
	// Resource is the type of resource being referenced, for example "pods".
	Resource pulumi.StringInput `pulumi:"resource"`
	// UID identifies exactly one incarnation of the resource.
	Uid pulumi.StringInput `pulumi:"uid"`
}

func (ResourceClaimConsumerReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimConsumerReference)(nil)).Elem()
}

func (i ResourceClaimConsumerReferenceArgs) ToResourceClaimConsumerReferenceOutput() ResourceClaimConsumerReferenceOutput {
	return i.ToResourceClaimConsumerReferenceOutputWithContext(context.Background())
}

func (i ResourceClaimConsumerReferenceArgs) ToResourceClaimConsumerReferenceOutputWithContext(ctx context.Context) ResourceClaimConsumerReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimConsumerReferenceOutput)
}

// ResourceClaimConsumerReferenceArrayInput is an input type that accepts ResourceClaimConsumerReferenceArray and ResourceClaimConsumerReferenceArrayOutput values.
// You can construct a concrete instance of `ResourceClaimConsumerReferenceArrayInput` via:
//
//	ResourceClaimConsumerReferenceArray{ ResourceClaimConsumerReferenceArgs{...} }
type ResourceClaimConsumerReferenceArrayInput interface {
	pulumi.Input

	ToResourceClaimConsumerReferenceArrayOutput() ResourceClaimConsumerReferenceArrayOutput
	ToResourceClaimConsumerReferenceArrayOutputWithContext(context.Context) ResourceClaimConsumerReferenceArrayOutput
}

type ResourceClaimConsumerReferenceArray []ResourceClaimConsumerReferenceInput

func (ResourceClaimConsumerReferenceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimConsumerReference)(nil)).Elem()
}

func (i ResourceClaimConsumerReferenceArray) ToResourceClaimConsumerReferenceArrayOutput() ResourceClaimConsumerReferenceArrayOutput {
	return i.ToResourceClaimConsumerReferenceArrayOutputWithContext(context.Background())
}

func (i ResourceClaimConsumerReferenceArray) ToResourceClaimConsumerReferenceArrayOutputWithContext(ctx context.Context) ResourceClaimConsumerReferenceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimConsumerReferenceArrayOutput)
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferenceOutput struct{ *pulumi.OutputState }

func (ResourceClaimConsumerReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimConsumerReference)(nil)).Elem()
}

func (o ResourceClaimConsumerReferenceOutput) ToResourceClaimConsumerReferenceOutput() ResourceClaimConsumerReferenceOutput {
	return o
}

func (o ResourceClaimConsumerReferenceOutput) ToResourceClaimConsumerReferenceOutputWithContext(ctx context.Context) ResourceClaimConsumerReferenceOutput {
	return o
}

// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
func (o ResourceClaimConsumerReferenceOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReference) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced.
func (o ResourceClaimConsumerReferenceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReference) string { return v.Name }).(pulumi.StringOutput)
}

// Resource is the type of resource being referenced, for example "pods".
func (o ResourceClaimConsumerReferenceOutput) Resource() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReference) string { return v.Resource }).(pulumi.StringOutput)
}

// UID identifies exactly one incarnation of the resource.
func (o ResourceClaimConsumerReferenceOutput) Uid() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReference) string { return v.Uid }).(pulumi.StringOutput)
}

type ResourceClaimConsumerReferenceArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimConsumerReferenceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimConsumerReference)(nil)).Elem()
}

func (o ResourceClaimConsumerReferenceArrayOutput) ToResourceClaimConsumerReferenceArrayOutput() ResourceClaimConsumerReferenceArrayOutput {
	return o
}

func (o ResourceClaimConsumerReferenceArrayOutput) ToResourceClaimConsumerReferenceArrayOutputWithContext(ctx context.Context) ResourceClaimConsumerReferenceArrayOutput {
	return o
}

func (o ResourceClaimConsumerReferenceArrayOutput) Index(i pulumi.IntInput) ResourceClaimConsumerReferenceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimConsumerReference {
		return vs[0].([]ResourceClaimConsumerReference)[vs[1].(int)]
	}).(ResourceClaimConsumerReferenceOutput)
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferencePatch struct {
	// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
	ApiGroup *string `pulumi:"apiGroup"`
	// Name is the name of resource being referenced.
	Name *string `pulumi:"name"`
	// Resource is the type of resource being referenced, for example "pods".
	Resource *string `pulumi:"resource"`
	// UID identifies exactly one incarnation of the resource.
	Uid *string `pulumi:"uid"`
}

// ResourceClaimConsumerReferencePatchInput is an input type that accepts ResourceClaimConsumerReferencePatchArgs and ResourceClaimConsumerReferencePatchOutput values.
// You can construct a concrete instance of `ResourceClaimConsumerReferencePatchInput` via:
//
//	ResourceClaimConsumerReferencePatchArgs{...}
type ResourceClaimConsumerReferencePatchInput interface {
	pulumi.Input

	ToResourceClaimConsumerReferencePatchOutput() ResourceClaimConsumerReferencePatchOutput
	ToResourceClaimConsumerReferencePatchOutputWithContext(context.Context) ResourceClaimConsumerReferencePatchOutput
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferencePatchArgs struct {
	// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Name is the name of resource being referenced.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Resource is the type of resource being referenced, for example "pods".
	Resource pulumi.StringPtrInput `pulumi:"resource"`
	// UID identifies exactly one incarnation of the resource.
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (ResourceClaimConsumerReferencePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimConsumerReferencePatch)(nil)).Elem()
}

func (i ResourceClaimConsumerReferencePatchArgs) ToResourceClaimConsumerReferencePatchOutput() ResourceClaimConsumerReferencePatchOutput {
	return i.ToResourceClaimConsumerReferencePatchOutputWithContext(context.Background())
}

func (i ResourceClaimConsumerReferencePatchArgs) ToResourceClaimConsumerReferencePatchOutputWithContext(ctx context.Context) ResourceClaimConsumerReferencePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimConsumerReferencePatchOutput)
}

// ResourceClaimConsumerReferencePatchArrayInput is an input type that accepts ResourceClaimConsumerReferencePatchArray and ResourceClaimConsumerReferencePatchArrayOutput values.
// You can construct a concrete instance of `ResourceClaimConsumerReferencePatchArrayInput` via:
//
//	ResourceClaimConsumerReferencePatchArray{ ResourceClaimConsumerReferencePatchArgs{...} }
type ResourceClaimConsumerReferencePatchArrayInput interface {
	pulumi.Input

	ToResourceClaimConsumerReferencePatchArrayOutput() ResourceClaimConsumerReferencePatchArrayOutput
	ToResourceClaimConsumerReferencePatchArrayOutputWithContext(context.Context) ResourceClaimConsumerReferencePatchArrayOutput
}

type ResourceClaimConsumerReferencePatchArray []ResourceClaimConsumerReferencePatchInput

func (ResourceClaimConsumerReferencePatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimConsumerReferencePatch)(nil)).Elem()
}

func (i ResourceClaimConsumerReferencePatchArray) ToResourceClaimConsumerReferencePatchArrayOutput() ResourceClaimConsumerReferencePatchArrayOutput {
	return i.ToResourceClaimConsumerReferencePatchArrayOutputWithContext(context.Background())
}

func (i ResourceClaimConsumerReferencePatchArray) ToResourceClaimConsumerReferencePatchArrayOutputWithContext(ctx context.Context) ResourceClaimConsumerReferencePatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimConsumerReferencePatchArrayOutput)
}

// ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim.
type ResourceClaimConsumerReferencePatchOutput struct{ *pulumi.OutputState }

func (ResourceClaimConsumerReferencePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimConsumerReferencePatch)(nil)).Elem()
}

func (o ResourceClaimConsumerReferencePatchOutput) ToResourceClaimConsumerReferencePatchOutput() ResourceClaimConsumerReferencePatchOutput {
	return o
}

func (o ResourceClaimConsumerReferencePatchOutput) ToResourceClaimConsumerReferencePatchOutputWithContext(ctx context.Context) ResourceClaimConsumerReferencePatchOutput {
	return o
}

// APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
func (o ResourceClaimConsumerReferencePatchOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReferencePatch) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced.
func (o ResourceClaimConsumerReferencePatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReferencePatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Resource is the type of resource being referenced, for example "pods".
func (o ResourceClaimConsumerReferencePatchOutput) Resource() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReferencePatch) *string { return v.Resource }).(pulumi.StringPtrOutput)
}

// UID identifies exactly one incarnation of the resource.
func (o ResourceClaimConsumerReferencePatchOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimConsumerReferencePatch) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type ResourceClaimConsumerReferencePatchArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimConsumerReferencePatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimConsumerReferencePatch)(nil)).Elem()
}

func (o ResourceClaimConsumerReferencePatchArrayOutput) ToResourceClaimConsumerReferencePatchArrayOutput() ResourceClaimConsumerReferencePatchArrayOutput {
	return o
}

func (o ResourceClaimConsumerReferencePatchArrayOutput) ToResourceClaimConsumerReferencePatchArrayOutputWithContext(ctx context.Context) ResourceClaimConsumerReferencePatchArrayOutput {
	return o
}

func (o ResourceClaimConsumerReferencePatchArrayOutput) Index(i pulumi.IntInput) ResourceClaimConsumerReferencePatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimConsumerReferencePatch {
		return vs[0].([]ResourceClaimConsumerReferencePatch)[vs[1].(int)]
	}).(ResourceClaimConsumerReferencePatchOutput)
}

// ResourceClaimList is a collection of claims.
type ResourceClaimListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of resource claims.
	Items []ResourceClaimType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ResourceClaimListTypeInput is an input type that accepts ResourceClaimListTypeArgs and ResourceClaimListTypeOutput values.
// You can construct a concrete instance of `ResourceClaimListTypeInput` via:
//
//	ResourceClaimListTypeArgs{...}
type ResourceClaimListTypeInput interface {
	pulumi.Input

	ToResourceClaimListTypeOutput() ResourceClaimListTypeOutput
	ToResourceClaimListTypeOutputWithContext(context.Context) ResourceClaimListTypeOutput
}

// ResourceClaimList is a collection of claims.
type ResourceClaimListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of resource claims.
	Items ResourceClaimTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ResourceClaimListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimListType)(nil)).Elem()
}

func (i ResourceClaimListTypeArgs) ToResourceClaimListTypeOutput() ResourceClaimListTypeOutput {
	return i.ToResourceClaimListTypeOutputWithContext(context.Background())
}

func (i ResourceClaimListTypeArgs) ToResourceClaimListTypeOutputWithContext(ctx context.Context) ResourceClaimListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimListTypeOutput)
}

// ResourceClaimList is a collection of claims.
type ResourceClaimListTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimListType)(nil)).Elem()
}

func (o ResourceClaimListTypeOutput) ToResourceClaimListTypeOutput() ResourceClaimListTypeOutput {
	return o
}

func (o ResourceClaimListTypeOutput) ToResourceClaimListTypeOutputWithContext(ctx context.Context) ResourceClaimListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of resource claims.
func (o ResourceClaimListTypeOutput) Items() ResourceClaimTypeArrayOutput {
	return o.ApplyT(func(v ResourceClaimListType) []ResourceClaimType { return v.Items }).(ResourceClaimTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o ResourceClaimListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Spec describes what is being requested and how to configure it. The spec is immutable.
	Spec *ResourceClaimSpecPatch `pulumi:"spec"`
	// Status describes whether the claim is ready to use and what has been allocated.
	Status *ResourceClaimStatusPatch `pulumi:"status"`
}

// ResourceClaimPatchTypeInput is an input type that accepts ResourceClaimPatchTypeArgs and ResourceClaimPatchTypeOutput values.
// You can construct a concrete instance of `ResourceClaimPatchTypeInput` via:
//
//	ResourceClaimPatchTypeArgs{...}
type ResourceClaimPatchTypeInput interface {
	pulumi.Input

	ToResourceClaimPatchTypeOutput() ResourceClaimPatchTypeOutput
	ToResourceClaimPatchTypeOutputWithContext(context.Context) ResourceClaimPatchTypeOutput
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Spec describes what is being requested and how to configure it. The spec is immutable.
	Spec ResourceClaimSpecPatchPtrInput `pulumi:"spec"`
	// Status describes whether the claim is ready to use and what has been allocated.
	Status ResourceClaimStatusPatchPtrInput `pulumi:"status"`
}

func (ResourceClaimPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimPatchType)(nil)).Elem()
}

func (i ResourceClaimPatchTypeArgs) ToResourceClaimPatchTypeOutput() ResourceClaimPatchTypeOutput {
	return i.ToResourceClaimPatchTypeOutputWithContext(context.Background())
}

func (i ResourceClaimPatchTypeArgs) ToResourceClaimPatchTypeOutputWithContext(ctx context.Context) ResourceClaimPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimPatchTypeOutput)
}

// ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimPatchTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimPatchType)(nil)).Elem()
}

func (o ResourceClaimPatchTypeOutput) ToResourceClaimPatchTypeOutput() ResourceClaimPatchTypeOutput {
	return o
}

func (o ResourceClaimPatchTypeOutput) ToResourceClaimPatchTypeOutputWithContext(ctx context.Context) ResourceClaimPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceClaimPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec describes what is being requested and how to configure it. The spec is immutable.
func (o ResourceClaimPatchTypeOutput) Spec() ResourceClaimSpecPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *ResourceClaimSpecPatch { return v.Spec }).(ResourceClaimSpecPatchPtrOutput)
}

// Status describes whether the claim is ready to use and what has been allocated.
func (o ResourceClaimPatchTypeOutput) Status() ResourceClaimStatusPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimPatchType) *ResourceClaimStatusPatch { return v.Status }).(ResourceClaimStatusPatchPtrOutput)
}

// ResourceClaimSchedulingStatus contains information about one particular ResourceClaim with "WaitForFirstConsumer" allocation mode.
type ResourceClaimSchedulingStatus struct {
	// Name matches the pod.spec.resourceClaims[*].Name field.
	Name string `pulumi:"name"`
	// UnsuitableNodes lists nodes that the ResourceClaim cannot be allocated for.
	//
	// The size of this field is limited to 128, the same as for PodSchedulingSpec.PotentialNodes. This may get increased in the future, but not reduced.
	UnsuitableNodes []string `pulumi:"unsuitableNodes"`
}

// ResourceClaimSchedulingStatusInput is an input type that accepts ResourceClaimSchedulingStatusArgs and ResourceClaimSchedulingStatusOutput values.
// You can construct a concrete instance of `ResourceClaimSchedulingStatusInput` via:
//
//	ResourceClaimSchedulingStatusArgs{...}
type ResourceClaimSchedulingStatusInput interface {
	pulumi.Input

	ToResourceClaimSchedulingStatusOutput() ResourceClaimSchedulingStatusOutput
	ToResourceClaimSchedulingStatusOutputWithContext(context.Context) ResourceClaimSchedulingStatusOutput
}

// ResourceClaimSchedulingStatus contains information about one particular ResourceClaim with "WaitForFirstConsumer" allocation mode.
type ResourceClaimSchedulingStatusArgs struct {
	// Name matches the pod.spec.resourceClaims[*].Name field.
	Name pulumi.StringInput `pulumi:"name"`
	// UnsuitableNodes lists nodes that the ResourceClaim cannot be allocated for.
	//
	// The size of this field is limited to 128, the same as for PodSchedulingSpec.PotentialNodes. This may get increased in the future, but not reduced.
	UnsuitableNodes pulumi.StringArrayInput `pulumi:"unsuitableNodes"`
}

func (ResourceClaimSchedulingStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSchedulingStatus)(nil)).Elem()
}

func (i ResourceClaimSchedulingStatusArgs) ToResourceClaimSchedulingStatusOutput() ResourceClaimSchedulingStatusOutput {
	return i.ToResourceClaimSchedulingStatusOutputWithContext(context.Background())
}

func (i ResourceClaimSchedulingStatusArgs) ToResourceClaimSchedulingStatusOutputWithContext(ctx context.Context) ResourceClaimSchedulingStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSchedulingStatusOutput)
}

// ResourceClaimSchedulingStatusArrayInput is an input type that accepts ResourceClaimSchedulingStatusArray and ResourceClaimSchedulingStatusArrayOutput values.
// You can construct a concrete instance of `ResourceClaimSchedulingStatusArrayInput` via:
//
//	ResourceClaimSchedulingStatusArray{ ResourceClaimSchedulingStatusArgs{...} }
type ResourceClaimSchedulingStatusArrayInput interface {
	pulumi.Input

	ToResourceClaimSchedulingStatusArrayOutput() ResourceClaimSchedulingStatusArrayOutput
	ToResourceClaimSchedulingStatusArrayOutputWithContext(context.Context) ResourceClaimSchedulingStatusArrayOutput
}

type ResourceClaimSchedulingStatusArray []ResourceClaimSchedulingStatusInput

func (ResourceClaimSchedulingStatusArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimSchedulingStatus)(nil)).Elem()
}

func (i ResourceClaimSchedulingStatusArray) ToResourceClaimSchedulingStatusArrayOutput() ResourceClaimSchedulingStatusArrayOutput {
	return i.ToResourceClaimSchedulingStatusArrayOutputWithContext(context.Background())
}

func (i ResourceClaimSchedulingStatusArray) ToResourceClaimSchedulingStatusArrayOutputWithContext(ctx context.Context) ResourceClaimSchedulingStatusArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSchedulingStatusArrayOutput)
}

// ResourceClaimSchedulingStatus contains information about one particular ResourceClaim with "WaitForFirstConsumer" allocation mode.
type ResourceClaimSchedulingStatusOutput struct{ *pulumi.OutputState }

func (ResourceClaimSchedulingStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSchedulingStatus)(nil)).Elem()
}

func (o ResourceClaimSchedulingStatusOutput) ToResourceClaimSchedulingStatusOutput() ResourceClaimSchedulingStatusOutput {
	return o
}

func (o ResourceClaimSchedulingStatusOutput) ToResourceClaimSchedulingStatusOutputWithContext(ctx context.Context) ResourceClaimSchedulingStatusOutput {
	return o
}

// Name matches the pod.spec.resourceClaims[*].Name field.
func (o ResourceClaimSchedulingStatusOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceClaimSchedulingStatus) string { return v.Name }).(pulumi.StringOutput)
}

// UnsuitableNodes lists nodes that the ResourceClaim cannot be allocated for.
//
// The size of this field is limited to 128, the same as for PodSchedulingSpec.PotentialNodes. This may get increased in the future, but not reduced.
func (o ResourceClaimSchedulingStatusOutput) UnsuitableNodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourceClaimSchedulingStatus) []string { return v.UnsuitableNodes }).(pulumi.StringArrayOutput)
}

type ResourceClaimSchedulingStatusArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimSchedulingStatusArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimSchedulingStatus)(nil)).Elem()
}

func (o ResourceClaimSchedulingStatusArrayOutput) ToResourceClaimSchedulingStatusArrayOutput() ResourceClaimSchedulingStatusArrayOutput {
	return o
}

func (o ResourceClaimSchedulingStatusArrayOutput) ToResourceClaimSchedulingStatusArrayOutputWithContext(ctx context.Context) ResourceClaimSchedulingStatusArrayOutput {
	return o
}

func (o ResourceClaimSchedulingStatusArrayOutput) Index(i pulumi.IntInput) ResourceClaimSchedulingStatusOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimSchedulingStatus {
		return vs[0].([]ResourceClaimSchedulingStatus)[vs[1].(int)]
	}).(ResourceClaimSchedulingStatusOutput)
}

// ResourceClaimSchedulingStatus contains information about one particular ResourceClaim with "WaitForFirstConsumer" allocation mode.
type ResourceClaimSchedulingStatusPatch struct {
	// Name matches the pod.spec.resourceClaims[*].Name field.
	Name *string `pulumi:"name"`
	// UnsuitableNodes lists nodes that the ResourceClaim cannot be allocated for.
	//
	// The size of this field is limited to 128, the same as for PodSchedulingSpec.PotentialNodes. This may get increased in the future, but not reduced.
	UnsuitableNodes []string `pulumi:"unsuitableNodes"`
}

// ResourceClaimSchedulingStatusPatchInput is an input type that accepts ResourceClaimSchedulingStatusPatchArgs and ResourceClaimSchedulingStatusPatchOutput values.
// You can construct a concrete instance of `ResourceClaimSchedulingStatusPatchInput` via:
//
//	ResourceClaimSchedulingStatusPatchArgs{...}
type ResourceClaimSchedulingStatusPatchInput interface {
	pulumi.Input

	ToResourceClaimSchedulingStatusPatchOutput() ResourceClaimSchedulingStatusPatchOutput
	ToResourceClaimSchedulingStatusPatchOutputWithContext(context.Context) ResourceClaimSchedulingStatusPatchOutput
}

// ResourceClaimSchedulingStatus contains information about one particular ResourceClaim with "WaitForFirstConsumer" allocation mode.
type ResourceClaimSchedulingStatusPatchArgs struct {
	// Name matches the pod.spec.resourceClaims[*].Name field.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// UnsuitableNodes lists nodes that the ResourceClaim cannot be allocated for.
	//
	// The size of this field is limited to 128, the same as for PodSchedulingSpec.PotentialNodes. This may get increased in the future, but not reduced.
	UnsuitableNodes pulumi.StringArrayInput `pulumi:"unsuitableNodes"`
}

func (ResourceClaimSchedulingStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSchedulingStatusPatch)(nil)).Elem()
}

func (i ResourceClaimSchedulingStatusPatchArgs) ToResourceClaimSchedulingStatusPatchOutput() ResourceClaimSchedulingStatusPatchOutput {
	return i.ToResourceClaimSchedulingStatusPatchOutputWithContext(context.Background())
}

func (i ResourceClaimSchedulingStatusPatchArgs) ToResourceClaimSchedulingStatusPatchOutputWithContext(ctx context.Context) ResourceClaimSchedulingStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSchedulingStatusPatchOutput)
}

// ResourceClaimSchedulingStatusPatchArrayInput is an input type that accepts ResourceClaimSchedulingStatusPatchArray and ResourceClaimSchedulingStatusPatchArrayOutput values.
// You can construct a concrete instance of `ResourceClaimSchedulingStatusPatchArrayInput` via:
//
//	ResourceClaimSchedulingStatusPatchArray{ ResourceClaimSchedulingStatusPatchArgs{...} }
type ResourceClaimSchedulingStatusPatchArrayInput interface {
	pulumi.Input

	ToResourceClaimSchedulingStatusPatchArrayOutput() ResourceClaimSchedulingStatusPatchArrayOutput
	ToResourceClaimSchedulingStatusPatchArrayOutputWithContext(context.Context) ResourceClaimSchedulingStatusPatchArrayOutput
}

type ResourceClaimSchedulingStatusPatchArray []ResourceClaimSchedulingStatusPatchInput

func (ResourceClaimSchedulingStatusPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimSchedulingStatusPatch)(nil)).Elem()
}

func (i ResourceClaimSchedulingStatusPatchArray) ToResourceClaimSchedulingStatusPatchArrayOutput() ResourceClaimSchedulingStatusPatchArrayOutput {
	return i.ToResourceClaimSchedulingStatusPatchArrayOutputWithContext(context.Background())
}

func (i ResourceClaimSchedulingStatusPatchArray) ToResourceClaimSchedulingStatusPatchArrayOutputWithContext(ctx context.Context) ResourceClaimSchedulingStatusPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSchedulingStatusPatchArrayOutput)
}

// ResourceClaimSchedulingStatus contains information about one particular ResourceClaim with "WaitForFirstConsumer" allocation mode.
type ResourceClaimSchedulingStatusPatchOutput struct{ *pulumi.OutputState }

func (ResourceClaimSchedulingStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSchedulingStatusPatch)(nil)).Elem()
}

func (o ResourceClaimSchedulingStatusPatchOutput) ToResourceClaimSchedulingStatusPatchOutput() ResourceClaimSchedulingStatusPatchOutput {
	return o
}

func (o ResourceClaimSchedulingStatusPatchOutput) ToResourceClaimSchedulingStatusPatchOutputWithContext(ctx context.Context) ResourceClaimSchedulingStatusPatchOutput {
	return o
}

// Name matches the pod.spec.resourceClaims[*].Name field.
func (o ResourceClaimSchedulingStatusPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimSchedulingStatusPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// UnsuitableNodes lists nodes that the ResourceClaim cannot be allocated for.
//
// The size of this field is limited to 128, the same as for PodSchedulingSpec.PotentialNodes. This may get increased in the future, but not reduced.
func (o ResourceClaimSchedulingStatusPatchOutput) UnsuitableNodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourceClaimSchedulingStatusPatch) []string { return v.UnsuitableNodes }).(pulumi.StringArrayOutput)
}

type ResourceClaimSchedulingStatusPatchArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimSchedulingStatusPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimSchedulingStatusPatch)(nil)).Elem()
}

func (o ResourceClaimSchedulingStatusPatchArrayOutput) ToResourceClaimSchedulingStatusPatchArrayOutput() ResourceClaimSchedulingStatusPatchArrayOutput {
	return o
}

func (o ResourceClaimSchedulingStatusPatchArrayOutput) ToResourceClaimSchedulingStatusPatchArrayOutputWithContext(ctx context.Context) ResourceClaimSchedulingStatusPatchArrayOutput {
	return o
}

func (o ResourceClaimSchedulingStatusPatchArrayOutput) Index(i pulumi.IntInput) ResourceClaimSchedulingStatusPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimSchedulingStatusPatch {
		return vs[0].([]ResourceClaimSchedulingStatusPatch)[vs[1].(int)]
	}).(ResourceClaimSchedulingStatusPatchOutput)
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpec struct {
	// Controller is the name of the DRA driver that is meant to handle allocation of this claim. If empty, allocation is handled by the scheduler while scheduling a pod.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	Controller *string `pulumi:"controller"`
	// Devices defines how to request devices.
	Devices *DeviceClaim `pulumi:"devices"`
}

// ResourceClaimSpecInput is an input type that accepts ResourceClaimSpecArgs and ResourceClaimSpecOutput values.
// You can construct a concrete instance of `ResourceClaimSpecInput` via:
//
//	ResourceClaimSpecArgs{...}
type ResourceClaimSpecInput interface {
	pulumi.Input

	ToResourceClaimSpecOutput() ResourceClaimSpecOutput
	ToResourceClaimSpecOutputWithContext(context.Context) ResourceClaimSpecOutput
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecArgs struct {
	// Controller is the name of the DRA driver that is meant to handle allocation of this claim. If empty, allocation is handled by the scheduler while scheduling a pod.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	Controller pulumi.StringPtrInput `pulumi:"controller"`
	// Devices defines how to request devices.
	Devices DeviceClaimPtrInput `pulumi:"devices"`
}

func (ResourceClaimSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSpec)(nil)).Elem()
}

func (i ResourceClaimSpecArgs) ToResourceClaimSpecOutput() ResourceClaimSpecOutput {
	return i.ToResourceClaimSpecOutputWithContext(context.Background())
}

func (i ResourceClaimSpecArgs) ToResourceClaimSpecOutputWithContext(ctx context.Context) ResourceClaimSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSpecOutput)
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecOutput struct{ *pulumi.OutputState }

func (ResourceClaimSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSpec)(nil)).Elem()
}

func (o ResourceClaimSpecOutput) ToResourceClaimSpecOutput() ResourceClaimSpecOutput {
	return o
}

func (o ResourceClaimSpecOutput) ToResourceClaimSpecOutputWithContext(ctx context.Context) ResourceClaimSpecOutput {
	return o
}

// Controller is the name of the DRA driver that is meant to handle allocation of this claim. If empty, allocation is handled by the scheduler while scheduling a pod.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o ResourceClaimSpecOutput) Controller() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimSpec) *string { return v.Controller }).(pulumi.StringPtrOutput)
}

// Devices defines how to request devices.
func (o ResourceClaimSpecOutput) Devices() DeviceClaimPtrOutput {
	return o.ApplyT(func(v ResourceClaimSpec) *DeviceClaim { return v.Devices }).(DeviceClaimPtrOutput)
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecPatch struct {
	// Controller is the name of the DRA driver that is meant to handle allocation of this claim. If empty, allocation is handled by the scheduler while scheduling a pod.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	Controller *string `pulumi:"controller"`
	// Devices defines how to request devices.
	Devices *DeviceClaimPatch `pulumi:"devices"`
}

// ResourceClaimSpecPatchInput is an input type that accepts ResourceClaimSpecPatchArgs and ResourceClaimSpecPatchOutput values.
// You can construct a concrete instance of `ResourceClaimSpecPatchInput` via:
//
//	ResourceClaimSpecPatchArgs{...}
type ResourceClaimSpecPatchInput interface {
	pulumi.Input

	ToResourceClaimSpecPatchOutput() ResourceClaimSpecPatchOutput
	ToResourceClaimSpecPatchOutputWithContext(context.Context) ResourceClaimSpecPatchOutput
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecPatchArgs struct {
	// Controller is the name of the DRA driver that is meant to handle allocation of this claim. If empty, allocation is handled by the scheduler while scheduling a pod.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	Controller pulumi.StringPtrInput `pulumi:"controller"`
	// Devices defines how to request devices.
	Devices DeviceClaimPatchPtrInput `pulumi:"devices"`
}

func (ResourceClaimSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSpecPatch)(nil)).Elem()
}

func (i ResourceClaimSpecPatchArgs) ToResourceClaimSpecPatchOutput() ResourceClaimSpecPatchOutput {
	return i.ToResourceClaimSpecPatchOutputWithContext(context.Background())
}

func (i ResourceClaimSpecPatchArgs) ToResourceClaimSpecPatchOutputWithContext(ctx context.Context) ResourceClaimSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSpecPatchOutput)
}

func (i ResourceClaimSpecPatchArgs) ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput {
	return i.ToResourceClaimSpecPatchPtrOutputWithContext(context.Background())
}

func (i ResourceClaimSpecPatchArgs) ToResourceClaimSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSpecPatchOutput).ToResourceClaimSpecPatchPtrOutputWithContext(ctx)
}

// ResourceClaimSpecPatchPtrInput is an input type that accepts ResourceClaimSpecPatchArgs, ResourceClaimSpecPatchPtr and ResourceClaimSpecPatchPtrOutput values.
// You can construct a concrete instance of `ResourceClaimSpecPatchPtrInput` via:
//
//	        ResourceClaimSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ResourceClaimSpecPatchPtrInput interface {
	pulumi.Input

	ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput
	ToResourceClaimSpecPatchPtrOutputWithContext(context.Context) ResourceClaimSpecPatchPtrOutput
}

type resourceClaimSpecPatchPtrType ResourceClaimSpecPatchArgs

func ResourceClaimSpecPatchPtr(v *ResourceClaimSpecPatchArgs) ResourceClaimSpecPatchPtrInput {
	return (*resourceClaimSpecPatchPtrType)(v)
}

func (*resourceClaimSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimSpecPatch)(nil)).Elem()
}

func (i *resourceClaimSpecPatchPtrType) ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput {
	return i.ToResourceClaimSpecPatchPtrOutputWithContext(context.Background())
}

func (i *resourceClaimSpecPatchPtrType) ToResourceClaimSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimSpecPatchPtrOutput)
}

// ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it.
type ResourceClaimSpecPatchOutput struct{ *pulumi.OutputState }

func (ResourceClaimSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimSpecPatch)(nil)).Elem()
}

func (o ResourceClaimSpecPatchOutput) ToResourceClaimSpecPatchOutput() ResourceClaimSpecPatchOutput {
	return o
}

func (o ResourceClaimSpecPatchOutput) ToResourceClaimSpecPatchOutputWithContext(ctx context.Context) ResourceClaimSpecPatchOutput {
	return o
}

func (o ResourceClaimSpecPatchOutput) ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput {
	return o.ToResourceClaimSpecPatchPtrOutputWithContext(context.Background())
}

func (o ResourceClaimSpecPatchOutput) ToResourceClaimSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceClaimSpecPatch) *ResourceClaimSpecPatch {
		return &v
	}).(ResourceClaimSpecPatchPtrOutput)
}

// Controller is the name of the DRA driver that is meant to handle allocation of this claim. If empty, allocation is handled by the scheduler while scheduling a pod.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o ResourceClaimSpecPatchOutput) Controller() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimSpecPatch) *string { return v.Controller }).(pulumi.StringPtrOutput)
}

// Devices defines how to request devices.
func (o ResourceClaimSpecPatchOutput) Devices() DeviceClaimPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimSpecPatch) *DeviceClaimPatch { return v.Devices }).(DeviceClaimPatchPtrOutput)
}

type ResourceClaimSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourceClaimSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimSpecPatch)(nil)).Elem()
}

func (o ResourceClaimSpecPatchPtrOutput) ToResourceClaimSpecPatchPtrOutput() ResourceClaimSpecPatchPtrOutput {
	return o
}

func (o ResourceClaimSpecPatchPtrOutput) ToResourceClaimSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimSpecPatchPtrOutput {
	return o
}

func (o ResourceClaimSpecPatchPtrOutput) Elem() ResourceClaimSpecPatchOutput {
	return o.ApplyT(func(v *ResourceClaimSpecPatch) ResourceClaimSpecPatch {
		if v != nil {
			return *v
		}
		var ret ResourceClaimSpecPatch
		return ret
	}).(ResourceClaimSpecPatchOutput)
}

// Controller is the name of the DRA driver that is meant to handle allocation of this claim. If empty, allocation is handled by the scheduler while scheduling a pod.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o ResourceClaimSpecPatchPtrOutput) Controller() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceClaimSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Controller
	}).(pulumi.StringPtrOutput)
}

// Devices defines how to request devices.
func (o ResourceClaimSpecPatchPtrOutput) Devices() DeviceClaimPatchPtrOutput {
	return o.ApplyT(func(v *ResourceClaimSpecPatch) *DeviceClaimPatch {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(DeviceClaimPatchPtrOutput)
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatus struct {
	// Allocation is set once the claim has been allocated successfully.
	Allocation *AllocationResult `pulumi:"allocation"`
	// Indicates that a claim is to be deallocated. While this is set, no new consumers may be added to ReservedFor.
	//
	// This is only used if the claim needs to be deallocated by a DRA driver. That driver then must deallocate this claim and reset the field together with clearing the Allocation field.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	DeallocationRequested *bool `pulumi:"deallocationRequested"`
	// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
	//
	// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
	//
	// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
	//
	// There can be at most 32 such reservations. This may get increased in the future, but not reduced.
	ReservedFor []ResourceClaimConsumerReference `pulumi:"reservedFor"`
}

// ResourceClaimStatusInput is an input type that accepts ResourceClaimStatusArgs and ResourceClaimStatusOutput values.
// You can construct a concrete instance of `ResourceClaimStatusInput` via:
//
//	ResourceClaimStatusArgs{...}
type ResourceClaimStatusInput interface {
	pulumi.Input

	ToResourceClaimStatusOutput() ResourceClaimStatusOutput
	ToResourceClaimStatusOutputWithContext(context.Context) ResourceClaimStatusOutput
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusArgs struct {
	// Allocation is set once the claim has been allocated successfully.
	Allocation AllocationResultPtrInput `pulumi:"allocation"`
	// Indicates that a claim is to be deallocated. While this is set, no new consumers may be added to ReservedFor.
	//
	// This is only used if the claim needs to be deallocated by a DRA driver. That driver then must deallocate this claim and reset the field together with clearing the Allocation field.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	DeallocationRequested pulumi.BoolPtrInput `pulumi:"deallocationRequested"`
	// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
	//
	// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
	//
	// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
	//
	// There can be at most 32 such reservations. This may get increased in the future, but not reduced.
	ReservedFor ResourceClaimConsumerReferenceArrayInput `pulumi:"reservedFor"`
}

func (ResourceClaimStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimStatus)(nil)).Elem()
}

func (i ResourceClaimStatusArgs) ToResourceClaimStatusOutput() ResourceClaimStatusOutput {
	return i.ToResourceClaimStatusOutputWithContext(context.Background())
}

func (i ResourceClaimStatusArgs) ToResourceClaimStatusOutputWithContext(ctx context.Context) ResourceClaimStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusOutput)
}

func (i ResourceClaimStatusArgs) ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput {
	return i.ToResourceClaimStatusPtrOutputWithContext(context.Background())
}

func (i ResourceClaimStatusArgs) ToResourceClaimStatusPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusOutput).ToResourceClaimStatusPtrOutputWithContext(ctx)
}

// ResourceClaimStatusPtrInput is an input type that accepts ResourceClaimStatusArgs, ResourceClaimStatusPtr and ResourceClaimStatusPtrOutput values.
// You can construct a concrete instance of `ResourceClaimStatusPtrInput` via:
//
//	        ResourceClaimStatusArgs{...}
//
//	or:
//
//	        nil
type ResourceClaimStatusPtrInput interface {
	pulumi.Input

	ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput
	ToResourceClaimStatusPtrOutputWithContext(context.Context) ResourceClaimStatusPtrOutput
}

type resourceClaimStatusPtrType ResourceClaimStatusArgs

func ResourceClaimStatusPtr(v *ResourceClaimStatusArgs) ResourceClaimStatusPtrInput {
	return (*resourceClaimStatusPtrType)(v)
}

func (*resourceClaimStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimStatus)(nil)).Elem()
}

func (i *resourceClaimStatusPtrType) ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput {
	return i.ToResourceClaimStatusPtrOutputWithContext(context.Background())
}

func (i *resourceClaimStatusPtrType) ToResourceClaimStatusPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusPtrOutput)
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusOutput struct{ *pulumi.OutputState }

func (ResourceClaimStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimStatus)(nil)).Elem()
}

func (o ResourceClaimStatusOutput) ToResourceClaimStatusOutput() ResourceClaimStatusOutput {
	return o
}

func (o ResourceClaimStatusOutput) ToResourceClaimStatusOutputWithContext(ctx context.Context) ResourceClaimStatusOutput {
	return o
}

func (o ResourceClaimStatusOutput) ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput {
	return o.ToResourceClaimStatusPtrOutputWithContext(context.Background())
}

func (o ResourceClaimStatusOutput) ToResourceClaimStatusPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceClaimStatus) *ResourceClaimStatus {
		return &v
	}).(ResourceClaimStatusPtrOutput)
}

// Allocation is set once the claim has been allocated successfully.
func (o ResourceClaimStatusOutput) Allocation() AllocationResultPtrOutput {
	return o.ApplyT(func(v ResourceClaimStatus) *AllocationResult { return v.Allocation }).(AllocationResultPtrOutput)
}

// Indicates that a claim is to be deallocated. While this is set, no new consumers may be added to ReservedFor.
//
// This is only used if the claim needs to be deallocated by a DRA driver. That driver then must deallocate this claim and reset the field together with clearing the Allocation field.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o ResourceClaimStatusOutput) DeallocationRequested() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourceClaimStatus) *bool { return v.DeallocationRequested }).(pulumi.BoolPtrOutput)
}

// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
//
// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
//
// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
//
// There can be at most 32 such reservations. This may get increased in the future, but not reduced.
func (o ResourceClaimStatusOutput) ReservedFor() ResourceClaimConsumerReferenceArrayOutput {
	return o.ApplyT(func(v ResourceClaimStatus) []ResourceClaimConsumerReference { return v.ReservedFor }).(ResourceClaimConsumerReferenceArrayOutput)
}

type ResourceClaimStatusPtrOutput struct{ *pulumi.OutputState }

func (ResourceClaimStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimStatus)(nil)).Elem()
}

func (o ResourceClaimStatusPtrOutput) ToResourceClaimStatusPtrOutput() ResourceClaimStatusPtrOutput {
	return o
}

func (o ResourceClaimStatusPtrOutput) ToResourceClaimStatusPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPtrOutput {
	return o
}

func (o ResourceClaimStatusPtrOutput) Elem() ResourceClaimStatusOutput {
	return o.ApplyT(func(v *ResourceClaimStatus) ResourceClaimStatus {
		if v != nil {
			return *v
		}
		var ret ResourceClaimStatus
		return ret
	}).(ResourceClaimStatusOutput)
}

// Allocation is set once the claim has been allocated successfully.
func (o ResourceClaimStatusPtrOutput) Allocation() AllocationResultPtrOutput {
	return o.ApplyT(func(v *ResourceClaimStatus) *AllocationResult {
		if v == nil {
			return nil
		}
		return v.Allocation
	}).(AllocationResultPtrOutput)
}

// Indicates that a claim is to be deallocated. While this is set, no new consumers may be added to ReservedFor.
//
// This is only used if the claim needs to be deallocated by a DRA driver. That driver then must deallocate this claim and reset the field together with clearing the Allocation field.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o ResourceClaimStatusPtrOutput) DeallocationRequested() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ResourceClaimStatus) *bool {
		if v == nil {
			return nil
		}
		return v.DeallocationRequested
	}).(pulumi.BoolPtrOutput)
}

// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
//
// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
//
// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
//
// There can be at most 32 such reservations. This may get increased in the future, but not reduced.
func (o ResourceClaimStatusPtrOutput) ReservedFor() ResourceClaimConsumerReferenceArrayOutput {
	return o.ApplyT(func(v *ResourceClaimStatus) []ResourceClaimConsumerReference {
		if v == nil {
			return nil
		}
		return v.ReservedFor
	}).(ResourceClaimConsumerReferenceArrayOutput)
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusPatch struct {
	// Allocation is set once the claim has been allocated successfully.
	Allocation *AllocationResultPatch `pulumi:"allocation"`
	// Indicates that a claim is to be deallocated. While this is set, no new consumers may be added to ReservedFor.
	//
	// This is only used if the claim needs to be deallocated by a DRA driver. That driver then must deallocate this claim and reset the field together with clearing the Allocation field.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	DeallocationRequested *bool `pulumi:"deallocationRequested"`
	// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
	//
	// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
	//
	// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
	//
	// There can be at most 32 such reservations. This may get increased in the future, but not reduced.
	ReservedFor []ResourceClaimConsumerReferencePatch `pulumi:"reservedFor"`
}

// ResourceClaimStatusPatchInput is an input type that accepts ResourceClaimStatusPatchArgs and ResourceClaimStatusPatchOutput values.
// You can construct a concrete instance of `ResourceClaimStatusPatchInput` via:
//
//	ResourceClaimStatusPatchArgs{...}
type ResourceClaimStatusPatchInput interface {
	pulumi.Input

	ToResourceClaimStatusPatchOutput() ResourceClaimStatusPatchOutput
	ToResourceClaimStatusPatchOutputWithContext(context.Context) ResourceClaimStatusPatchOutput
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusPatchArgs struct {
	// Allocation is set once the claim has been allocated successfully.
	Allocation AllocationResultPatchPtrInput `pulumi:"allocation"`
	// Indicates that a claim is to be deallocated. While this is set, no new consumers may be added to ReservedFor.
	//
	// This is only used if the claim needs to be deallocated by a DRA driver. That driver then must deallocate this claim and reset the field together with clearing the Allocation field.
	//
	// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
	DeallocationRequested pulumi.BoolPtrInput `pulumi:"deallocationRequested"`
	// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
	//
	// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
	//
	// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
	//
	// There can be at most 32 such reservations. This may get increased in the future, but not reduced.
	ReservedFor ResourceClaimConsumerReferencePatchArrayInput `pulumi:"reservedFor"`
}

func (ResourceClaimStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimStatusPatch)(nil)).Elem()
}

func (i ResourceClaimStatusPatchArgs) ToResourceClaimStatusPatchOutput() ResourceClaimStatusPatchOutput {
	return i.ToResourceClaimStatusPatchOutputWithContext(context.Background())
}

func (i ResourceClaimStatusPatchArgs) ToResourceClaimStatusPatchOutputWithContext(ctx context.Context) ResourceClaimStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusPatchOutput)
}

func (i ResourceClaimStatusPatchArgs) ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput {
	return i.ToResourceClaimStatusPatchPtrOutputWithContext(context.Background())
}

func (i ResourceClaimStatusPatchArgs) ToResourceClaimStatusPatchPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusPatchOutput).ToResourceClaimStatusPatchPtrOutputWithContext(ctx)
}

// ResourceClaimStatusPatchPtrInput is an input type that accepts ResourceClaimStatusPatchArgs, ResourceClaimStatusPatchPtr and ResourceClaimStatusPatchPtrOutput values.
// You can construct a concrete instance of `ResourceClaimStatusPatchPtrInput` via:
//
//	        ResourceClaimStatusPatchArgs{...}
//
//	or:
//
//	        nil
type ResourceClaimStatusPatchPtrInput interface {
	pulumi.Input

	ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput
	ToResourceClaimStatusPatchPtrOutputWithContext(context.Context) ResourceClaimStatusPatchPtrOutput
}

type resourceClaimStatusPatchPtrType ResourceClaimStatusPatchArgs

func ResourceClaimStatusPatchPtr(v *ResourceClaimStatusPatchArgs) ResourceClaimStatusPatchPtrInput {
	return (*resourceClaimStatusPatchPtrType)(v)
}

func (*resourceClaimStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimStatusPatch)(nil)).Elem()
}

func (i *resourceClaimStatusPatchPtrType) ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput {
	return i.ToResourceClaimStatusPatchPtrOutputWithContext(context.Background())
}

func (i *resourceClaimStatusPatchPtrType) ToResourceClaimStatusPatchPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimStatusPatchPtrOutput)
}

// ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was.
type ResourceClaimStatusPatchOutput struct{ *pulumi.OutputState }

func (ResourceClaimStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimStatusPatch)(nil)).Elem()
}

func (o ResourceClaimStatusPatchOutput) ToResourceClaimStatusPatchOutput() ResourceClaimStatusPatchOutput {
	return o
}

func (o ResourceClaimStatusPatchOutput) ToResourceClaimStatusPatchOutputWithContext(ctx context.Context) ResourceClaimStatusPatchOutput {
	return o
}

func (o ResourceClaimStatusPatchOutput) ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput {
	return o.ToResourceClaimStatusPatchPtrOutputWithContext(context.Background())
}

func (o ResourceClaimStatusPatchOutput) ToResourceClaimStatusPatchPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceClaimStatusPatch) *ResourceClaimStatusPatch {
		return &v
	}).(ResourceClaimStatusPatchPtrOutput)
}

// Allocation is set once the claim has been allocated successfully.
func (o ResourceClaimStatusPatchOutput) Allocation() AllocationResultPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimStatusPatch) *AllocationResultPatch { return v.Allocation }).(AllocationResultPatchPtrOutput)
}

// Indicates that a claim is to be deallocated. While this is set, no new consumers may be added to ReservedFor.
//
// This is only used if the claim needs to be deallocated by a DRA driver. That driver then must deallocate this claim and reset the field together with clearing the Allocation field.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o ResourceClaimStatusPatchOutput) DeallocationRequested() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourceClaimStatusPatch) *bool { return v.DeallocationRequested }).(pulumi.BoolPtrOutput)
}

// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
//
// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
//
// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
//
// There can be at most 32 such reservations. This may get increased in the future, but not reduced.
func (o ResourceClaimStatusPatchOutput) ReservedFor() ResourceClaimConsumerReferencePatchArrayOutput {
	return o.ApplyT(func(v ResourceClaimStatusPatch) []ResourceClaimConsumerReferencePatch { return v.ReservedFor }).(ResourceClaimConsumerReferencePatchArrayOutput)
}

type ResourceClaimStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourceClaimStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimStatusPatch)(nil)).Elem()
}

func (o ResourceClaimStatusPatchPtrOutput) ToResourceClaimStatusPatchPtrOutput() ResourceClaimStatusPatchPtrOutput {
	return o
}

func (o ResourceClaimStatusPatchPtrOutput) ToResourceClaimStatusPatchPtrOutputWithContext(ctx context.Context) ResourceClaimStatusPatchPtrOutput {
	return o
}

func (o ResourceClaimStatusPatchPtrOutput) Elem() ResourceClaimStatusPatchOutput {
	return o.ApplyT(func(v *ResourceClaimStatusPatch) ResourceClaimStatusPatch {
		if v != nil {
			return *v
		}
		var ret ResourceClaimStatusPatch
		return ret
	}).(ResourceClaimStatusPatchOutput)
}

// Allocation is set once the claim has been allocated successfully.
func (o ResourceClaimStatusPatchPtrOutput) Allocation() AllocationResultPatchPtrOutput {
	return o.ApplyT(func(v *ResourceClaimStatusPatch) *AllocationResultPatch {
		if v == nil {
			return nil
		}
		return v.Allocation
	}).(AllocationResultPatchPtrOutput)
}

// Indicates that a claim is to be deallocated. While this is set, no new consumers may be added to ReservedFor.
//
// This is only used if the claim needs to be deallocated by a DRA driver. That driver then must deallocate this claim and reset the field together with clearing the Allocation field.
//
// This is an alpha field and requires enabling the DRAControlPlaneController feature gate.
func (o ResourceClaimStatusPatchPtrOutput) DeallocationRequested() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ResourceClaimStatusPatch) *bool {
		if v == nil {
			return nil
		}
		return v.DeallocationRequested
	}).(pulumi.BoolPtrOutput)
}

// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started. A claim that is in use or might be in use because it has been reserved must not get deallocated.
//
// In a cluster with multiple scheduler instances, two pods might get scheduled concurrently by different schedulers. When they reference the same ResourceClaim which already has reached its maximum number of consumers, only one pod can be scheduled.
//
// Both schedulers try to add their pod to the claim.status.reservedFor field, but only the update that reaches the API server first gets stored. The other one fails with an error and the scheduler which issued it knows that it must put the pod back into the queue, waiting for the ResourceClaim to become usable again.
//
// There can be at most 32 such reservations. This may get increased in the future, but not reduced.
func (o ResourceClaimStatusPatchPtrOutput) ReservedFor() ResourceClaimConsumerReferencePatchArrayOutput {
	return o.ApplyT(func(v *ResourceClaimStatusPatch) []ResourceClaimConsumerReferencePatch {
		if v == nil {
			return nil
		}
		return v.ReservedFor
	}).(ResourceClaimConsumerReferencePatchArrayOutput)
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplateType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Describes the ResourceClaim that is to be generated.
	//
	// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
	Spec ResourceClaimTemplateSpec `pulumi:"spec"`
}

// ResourceClaimTemplateTypeInput is an input type that accepts ResourceClaimTemplateTypeArgs and ResourceClaimTemplateTypeOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateTypeInput` via:
//
//	ResourceClaimTemplateTypeArgs{...}
type ResourceClaimTemplateTypeInput interface {
	pulumi.Input

	ToResourceClaimTemplateTypeOutput() ResourceClaimTemplateTypeOutput
	ToResourceClaimTemplateTypeOutputWithContext(context.Context) ResourceClaimTemplateTypeOutput
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplateTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Describes the ResourceClaim that is to be generated.
	//
	// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
	Spec ResourceClaimTemplateSpecInput `pulumi:"spec"`
}

func (ResourceClaimTemplateTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateType)(nil)).Elem()
}

func (i ResourceClaimTemplateTypeArgs) ToResourceClaimTemplateTypeOutput() ResourceClaimTemplateTypeOutput {
	return i.ToResourceClaimTemplateTypeOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateTypeArgs) ToResourceClaimTemplateTypeOutputWithContext(ctx context.Context) ResourceClaimTemplateTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateTypeOutput)
}

// ResourceClaimTemplateTypeArrayInput is an input type that accepts ResourceClaimTemplateTypeArray and ResourceClaimTemplateTypeArrayOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateTypeArrayInput` via:
//
//	ResourceClaimTemplateTypeArray{ ResourceClaimTemplateTypeArgs{...} }
type ResourceClaimTemplateTypeArrayInput interface {
	pulumi.Input

	ToResourceClaimTemplateTypeArrayOutput() ResourceClaimTemplateTypeArrayOutput
	ToResourceClaimTemplateTypeArrayOutputWithContext(context.Context) ResourceClaimTemplateTypeArrayOutput
}

type ResourceClaimTemplateTypeArray []ResourceClaimTemplateTypeInput

func (ResourceClaimTemplateTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimTemplateType)(nil)).Elem()
}

func (i ResourceClaimTemplateTypeArray) ToResourceClaimTemplateTypeArrayOutput() ResourceClaimTemplateTypeArrayOutput {
	return i.ToResourceClaimTemplateTypeArrayOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateTypeArray) ToResourceClaimTemplateTypeArrayOutputWithContext(ctx context.Context) ResourceClaimTemplateTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateTypeArrayOutput)
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplateTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateType)(nil)).Elem()
}

func (o ResourceClaimTemplateTypeOutput) ToResourceClaimTemplateTypeOutput() ResourceClaimTemplateTypeOutput {
	return o
}

func (o ResourceClaimTemplateTypeOutput) ToResourceClaimTemplateTypeOutputWithContext(ctx context.Context) ResourceClaimTemplateTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimTemplateTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimTemplateTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceClaimTemplateTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Describes the ResourceClaim that is to be generated.
//
// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
func (o ResourceClaimTemplateTypeOutput) Spec() ResourceClaimTemplateSpecOutput {
	return o.ApplyT(func(v ResourceClaimTemplateType) ResourceClaimTemplateSpec { return v.Spec }).(ResourceClaimTemplateSpecOutput)
}

type ResourceClaimTemplateTypeArrayOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceClaimTemplateType)(nil)).Elem()
}

func (o ResourceClaimTemplateTypeArrayOutput) ToResourceClaimTemplateTypeArrayOutput() ResourceClaimTemplateTypeArrayOutput {
	return o
}

func (o ResourceClaimTemplateTypeArrayOutput) ToResourceClaimTemplateTypeArrayOutputWithContext(ctx context.Context) ResourceClaimTemplateTypeArrayOutput {
	return o
}

func (o ResourceClaimTemplateTypeArrayOutput) Index(i pulumi.IntInput) ResourceClaimTemplateTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceClaimTemplateType {
		return vs[0].([]ResourceClaimTemplateType)[vs[1].(int)]
	}).(ResourceClaimTemplateTypeOutput)
}

// ResourceClaimTemplateList is a collection of claim templates.
type ResourceClaimTemplateListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of resource claim templates.
	Items []ResourceClaimTemplateType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ResourceClaimTemplateListTypeInput is an input type that accepts ResourceClaimTemplateListTypeArgs and ResourceClaimTemplateListTypeOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateListTypeInput` via:
//
//	ResourceClaimTemplateListTypeArgs{...}
type ResourceClaimTemplateListTypeInput interface {
	pulumi.Input

	ToResourceClaimTemplateListTypeOutput() ResourceClaimTemplateListTypeOutput
	ToResourceClaimTemplateListTypeOutputWithContext(context.Context) ResourceClaimTemplateListTypeOutput
}

// ResourceClaimTemplateList is a collection of claim templates.
type ResourceClaimTemplateListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of resource claim templates.
	Items ResourceClaimTemplateTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ResourceClaimTemplateListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateListType)(nil)).Elem()
}

func (i ResourceClaimTemplateListTypeArgs) ToResourceClaimTemplateListTypeOutput() ResourceClaimTemplateListTypeOutput {
	return i.ToResourceClaimTemplateListTypeOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateListTypeArgs) ToResourceClaimTemplateListTypeOutputWithContext(ctx context.Context) ResourceClaimTemplateListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateListTypeOutput)
}

// ResourceClaimTemplateList is a collection of claim templates.
type ResourceClaimTemplateListTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateListType)(nil)).Elem()
}

func (o ResourceClaimTemplateListTypeOutput) ToResourceClaimTemplateListTypeOutput() ResourceClaimTemplateListTypeOutput {
	return o
}

func (o ResourceClaimTemplateListTypeOutput) ToResourceClaimTemplateListTypeOutputWithContext(ctx context.Context) ResourceClaimTemplateListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimTemplateListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of resource claim templates.
func (o ResourceClaimTemplateListTypeOutput) Items() ResourceClaimTemplateTypeArrayOutput {
	return o.ApplyT(func(v ResourceClaimTemplateListType) []ResourceClaimTemplateType { return v.Items }).(ResourceClaimTemplateTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimTemplateListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o ResourceClaimTemplateListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplatePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Describes the ResourceClaim that is to be generated.
	//
	// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
	Spec *ResourceClaimTemplateSpecPatch `pulumi:"spec"`
}

// ResourceClaimTemplatePatchTypeInput is an input type that accepts ResourceClaimTemplatePatchTypeArgs and ResourceClaimTemplatePatchTypeOutput values.
// You can construct a concrete instance of `ResourceClaimTemplatePatchTypeInput` via:
//
//	ResourceClaimTemplatePatchTypeArgs{...}
type ResourceClaimTemplatePatchTypeInput interface {
	pulumi.Input

	ToResourceClaimTemplatePatchTypeOutput() ResourceClaimTemplatePatchTypeOutput
	ToResourceClaimTemplatePatchTypeOutputWithContext(context.Context) ResourceClaimTemplatePatchTypeOutput
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplatePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Describes the ResourceClaim that is to be generated.
	//
	// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
	Spec ResourceClaimTemplateSpecPatchPtrInput `pulumi:"spec"`
}

func (ResourceClaimTemplatePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplatePatchType)(nil)).Elem()
}

func (i ResourceClaimTemplatePatchTypeArgs) ToResourceClaimTemplatePatchTypeOutput() ResourceClaimTemplatePatchTypeOutput {
	return i.ToResourceClaimTemplatePatchTypeOutputWithContext(context.Background())
}

func (i ResourceClaimTemplatePatchTypeArgs) ToResourceClaimTemplatePatchTypeOutputWithContext(ctx context.Context) ResourceClaimTemplatePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplatePatchTypeOutput)
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceClaimTemplatePatchTypeOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplatePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplatePatchType)(nil)).Elem()
}

func (o ResourceClaimTemplatePatchTypeOutput) ToResourceClaimTemplatePatchTypeOutput() ResourceClaimTemplatePatchTypeOutput {
	return o
}

func (o ResourceClaimTemplatePatchTypeOutput) ToResourceClaimTemplatePatchTypeOutputWithContext(ctx context.Context) ResourceClaimTemplatePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceClaimTemplatePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplatePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceClaimTemplatePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplatePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceClaimTemplatePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplatePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Describes the ResourceClaim that is to be generated.
//
// This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
func (o ResourceClaimTemplatePatchTypeOutput) Spec() ResourceClaimTemplateSpecPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplatePatchType) *ResourceClaimTemplateSpecPatch { return v.Spec }).(ResourceClaimTemplateSpecPatchPtrOutput)
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpec struct {
	// ObjectMeta may contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
	Spec ResourceClaimSpec `pulumi:"spec"`
}

// ResourceClaimTemplateSpecInput is an input type that accepts ResourceClaimTemplateSpecArgs and ResourceClaimTemplateSpecOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateSpecInput` via:
//
//	ResourceClaimTemplateSpecArgs{...}
type ResourceClaimTemplateSpecInput interface {
	pulumi.Input

	ToResourceClaimTemplateSpecOutput() ResourceClaimTemplateSpecOutput
	ToResourceClaimTemplateSpecOutputWithContext(context.Context) ResourceClaimTemplateSpecOutput
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecArgs struct {
	// ObjectMeta may contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
	Spec ResourceClaimSpecInput `pulumi:"spec"`
}

func (ResourceClaimTemplateSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateSpec)(nil)).Elem()
}

func (i ResourceClaimTemplateSpecArgs) ToResourceClaimTemplateSpecOutput() ResourceClaimTemplateSpecOutput {
	return i.ToResourceClaimTemplateSpecOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateSpecArgs) ToResourceClaimTemplateSpecOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateSpecOutput)
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateSpec)(nil)).Elem()
}

func (o ResourceClaimTemplateSpecOutput) ToResourceClaimTemplateSpecOutput() ResourceClaimTemplateSpecOutput {
	return o
}

func (o ResourceClaimTemplateSpecOutput) ToResourceClaimTemplateSpecOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecOutput {
	return o
}

// ObjectMeta may contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
func (o ResourceClaimTemplateSpecOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateSpec) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
func (o ResourceClaimTemplateSpecOutput) Spec() ResourceClaimSpecOutput {
	return o.ApplyT(func(v ResourceClaimTemplateSpec) ResourceClaimSpec { return v.Spec }).(ResourceClaimSpecOutput)
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecPatch struct {
	// ObjectMeta may contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
	Spec *ResourceClaimSpecPatch `pulumi:"spec"`
}

// ResourceClaimTemplateSpecPatchInput is an input type that accepts ResourceClaimTemplateSpecPatchArgs and ResourceClaimTemplateSpecPatchOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateSpecPatchInput` via:
//
//	ResourceClaimTemplateSpecPatchArgs{...}
type ResourceClaimTemplateSpecPatchInput interface {
	pulumi.Input

	ToResourceClaimTemplateSpecPatchOutput() ResourceClaimTemplateSpecPatchOutput
	ToResourceClaimTemplateSpecPatchOutputWithContext(context.Context) ResourceClaimTemplateSpecPatchOutput
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecPatchArgs struct {
	// ObjectMeta may contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
	Spec ResourceClaimSpecPatchPtrInput `pulumi:"spec"`
}

func (ResourceClaimTemplateSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateSpecPatch)(nil)).Elem()
}

func (i ResourceClaimTemplateSpecPatchArgs) ToResourceClaimTemplateSpecPatchOutput() ResourceClaimTemplateSpecPatchOutput {
	return i.ToResourceClaimTemplateSpecPatchOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateSpecPatchArgs) ToResourceClaimTemplateSpecPatchOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateSpecPatchOutput)
}

func (i ResourceClaimTemplateSpecPatchArgs) ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput {
	return i.ToResourceClaimTemplateSpecPatchPtrOutputWithContext(context.Background())
}

func (i ResourceClaimTemplateSpecPatchArgs) ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateSpecPatchOutput).ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx)
}

// ResourceClaimTemplateSpecPatchPtrInput is an input type that accepts ResourceClaimTemplateSpecPatchArgs, ResourceClaimTemplateSpecPatchPtr and ResourceClaimTemplateSpecPatchPtrOutput values.
// You can construct a concrete instance of `ResourceClaimTemplateSpecPatchPtrInput` via:
//
//	        ResourceClaimTemplateSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ResourceClaimTemplateSpecPatchPtrInput interface {
	pulumi.Input

	ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput
	ToResourceClaimTemplateSpecPatchPtrOutputWithContext(context.Context) ResourceClaimTemplateSpecPatchPtrOutput
}

type resourceClaimTemplateSpecPatchPtrType ResourceClaimTemplateSpecPatchArgs

func ResourceClaimTemplateSpecPatchPtr(v *ResourceClaimTemplateSpecPatchArgs) ResourceClaimTemplateSpecPatchPtrInput {
	return (*resourceClaimTemplateSpecPatchPtrType)(v)
}

func (*resourceClaimTemplateSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimTemplateSpecPatch)(nil)).Elem()
}

func (i *resourceClaimTemplateSpecPatchPtrType) ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput {
	return i.ToResourceClaimTemplateSpecPatchPtrOutputWithContext(context.Background())
}

func (i *resourceClaimTemplateSpecPatchPtrType) ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceClaimTemplateSpecPatchPtrOutput)
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
type ResourceClaimTemplateSpecPatchOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceClaimTemplateSpecPatch)(nil)).Elem()
}

func (o ResourceClaimTemplateSpecPatchOutput) ToResourceClaimTemplateSpecPatchOutput() ResourceClaimTemplateSpecPatchOutput {
	return o
}

func (o ResourceClaimTemplateSpecPatchOutput) ToResourceClaimTemplateSpecPatchOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchOutput {
	return o
}

func (o ResourceClaimTemplateSpecPatchOutput) ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput {
	return o.ToResourceClaimTemplateSpecPatchPtrOutputWithContext(context.Background())
}

func (o ResourceClaimTemplateSpecPatchOutput) ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceClaimTemplateSpecPatch) *ResourceClaimTemplateSpecPatch {
		return &v
	}).(ResourceClaimTemplateSpecPatchPtrOutput)
}

// ObjectMeta may contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
func (o ResourceClaimTemplateSpecPatchOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateSpecPatch) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
func (o ResourceClaimTemplateSpecPatchOutput) Spec() ResourceClaimSpecPatchPtrOutput {
	return o.ApplyT(func(v ResourceClaimTemplateSpecPatch) *ResourceClaimSpecPatch { return v.Spec }).(ResourceClaimSpecPatchPtrOutput)
}

type ResourceClaimTemplateSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourceClaimTemplateSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceClaimTemplateSpecPatch)(nil)).Elem()
}

func (o ResourceClaimTemplateSpecPatchPtrOutput) ToResourceClaimTemplateSpecPatchPtrOutput() ResourceClaimTemplateSpecPatchPtrOutput {
	return o
}

func (o ResourceClaimTemplateSpecPatchPtrOutput) ToResourceClaimTemplateSpecPatchPtrOutputWithContext(ctx context.Context) ResourceClaimTemplateSpecPatchPtrOutput {
	return o
}

func (o ResourceClaimTemplateSpecPatchPtrOutput) Elem() ResourceClaimTemplateSpecPatchOutput {
	return o.ApplyT(func(v *ResourceClaimTemplateSpecPatch) ResourceClaimTemplateSpecPatch {
		if v != nil {
			return *v
		}
		var ret ResourceClaimTemplateSpecPatch
		return ret
	}).(ResourceClaimTemplateSpecPatchOutput)
}

// ObjectMeta may contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
func (o ResourceClaimTemplateSpecPatchPtrOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v *ResourceClaimTemplateSpecPatch) *metav1.ObjectMetaPatch {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(metav1.ObjectMetaPatchPtrOutput)
}

// Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
func (o ResourceClaimTemplateSpecPatchPtrOutput) Spec() ResourceClaimSpecPatchPtrOutput {
	return o.ApplyT(func(v *ResourceClaimTemplateSpecPatch) *ResourceClaimSpecPatch {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ResourceClaimSpecPatchPtrOutput)
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePool struct {
	// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
	//
	// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
	Generation int `pulumi:"generation"`
	// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
	//
	// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
	Name string `pulumi:"name"`
	// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
	//
	// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
	ResourceSliceCount int `pulumi:"resourceSliceCount"`
}

// ResourcePoolInput is an input type that accepts ResourcePoolArgs and ResourcePoolOutput values.
// You can construct a concrete instance of `ResourcePoolInput` via:
//
//	ResourcePoolArgs{...}
type ResourcePoolInput interface {
	pulumi.Input

	ToResourcePoolOutput() ResourcePoolOutput
	ToResourcePoolOutputWithContext(context.Context) ResourcePoolOutput
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolArgs struct {
	// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
	//
	// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
	Generation pulumi.IntInput `pulumi:"generation"`
	// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
	//
	// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
	Name pulumi.StringInput `pulumi:"name"`
	// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
	//
	// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
	ResourceSliceCount pulumi.IntInput `pulumi:"resourceSliceCount"`
}

func (ResourcePoolArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePool)(nil)).Elem()
}

func (i ResourcePoolArgs) ToResourcePoolOutput() ResourcePoolOutput {
	return i.ToResourcePoolOutputWithContext(context.Background())
}

func (i ResourcePoolArgs) ToResourcePoolOutputWithContext(ctx context.Context) ResourcePoolOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePoolOutput)
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolOutput struct{ *pulumi.OutputState }

func (ResourcePoolOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePool)(nil)).Elem()
}

func (o ResourcePoolOutput) ToResourcePoolOutput() ResourcePoolOutput {
	return o
}

func (o ResourcePoolOutput) ToResourcePoolOutputWithContext(ctx context.Context) ResourcePoolOutput {
	return o
}

// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
//
// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
func (o ResourcePoolOutput) Generation() pulumi.IntOutput {
	return o.ApplyT(func(v ResourcePool) int { return v.Generation }).(pulumi.IntOutput)
}

// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
//
// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
func (o ResourcePoolOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ResourcePool) string { return v.Name }).(pulumi.StringOutput)
}

// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
//
// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
func (o ResourcePoolOutput) ResourceSliceCount() pulumi.IntOutput {
	return o.ApplyT(func(v ResourcePool) int { return v.ResourceSliceCount }).(pulumi.IntOutput)
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolPatch struct {
	// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
	//
	// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
	Generation *int `pulumi:"generation"`
	// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
	//
	// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
	Name *string `pulumi:"name"`
	// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
	//
	// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
	ResourceSliceCount *int `pulumi:"resourceSliceCount"`
}

// ResourcePoolPatchInput is an input type that accepts ResourcePoolPatchArgs and ResourcePoolPatchOutput values.
// You can construct a concrete instance of `ResourcePoolPatchInput` via:
//
//	ResourcePoolPatchArgs{...}
type ResourcePoolPatchInput interface {
	pulumi.Input

	ToResourcePoolPatchOutput() ResourcePoolPatchOutput
	ToResourcePoolPatchOutputWithContext(context.Context) ResourcePoolPatchOutput
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolPatchArgs struct {
	// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
	//
	// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
	Generation pulumi.IntPtrInput `pulumi:"generation"`
	// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
	//
	// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
	//
	// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
	ResourceSliceCount pulumi.IntPtrInput `pulumi:"resourceSliceCount"`
}

func (ResourcePoolPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePoolPatch)(nil)).Elem()
}

func (i ResourcePoolPatchArgs) ToResourcePoolPatchOutput() ResourcePoolPatchOutput {
	return i.ToResourcePoolPatchOutputWithContext(context.Background())
}

func (i ResourcePoolPatchArgs) ToResourcePoolPatchOutputWithContext(ctx context.Context) ResourcePoolPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePoolPatchOutput)
}

func (i ResourcePoolPatchArgs) ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput {
	return i.ToResourcePoolPatchPtrOutputWithContext(context.Background())
}

func (i ResourcePoolPatchArgs) ToResourcePoolPatchPtrOutputWithContext(ctx context.Context) ResourcePoolPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePoolPatchOutput).ToResourcePoolPatchPtrOutputWithContext(ctx)
}

// ResourcePoolPatchPtrInput is an input type that accepts ResourcePoolPatchArgs, ResourcePoolPatchPtr and ResourcePoolPatchPtrOutput values.
// You can construct a concrete instance of `ResourcePoolPatchPtrInput` via:
//
//	        ResourcePoolPatchArgs{...}
//
//	or:
//
//	        nil
type ResourcePoolPatchPtrInput interface {
	pulumi.Input

	ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput
	ToResourcePoolPatchPtrOutputWithContext(context.Context) ResourcePoolPatchPtrOutput
}

type resourcePoolPatchPtrType ResourcePoolPatchArgs

func ResourcePoolPatchPtr(v *ResourcePoolPatchArgs) ResourcePoolPatchPtrInput {
	return (*resourcePoolPatchPtrType)(v)
}

func (*resourcePoolPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourcePoolPatch)(nil)).Elem()
}

func (i *resourcePoolPatchPtrType) ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput {
	return i.ToResourcePoolPatchPtrOutputWithContext(context.Background())
}

func (i *resourcePoolPatchPtrType) ToResourcePoolPatchPtrOutputWithContext(ctx context.Context) ResourcePoolPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePoolPatchPtrOutput)
}

// ResourcePool describes the pool that ResourceSlices belong to.
type ResourcePoolPatchOutput struct{ *pulumi.OutputState }

func (ResourcePoolPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePoolPatch)(nil)).Elem()
}

func (o ResourcePoolPatchOutput) ToResourcePoolPatchOutput() ResourcePoolPatchOutput {
	return o
}

func (o ResourcePoolPatchOutput) ToResourcePoolPatchOutputWithContext(ctx context.Context) ResourcePoolPatchOutput {
	return o
}

func (o ResourcePoolPatchOutput) ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput {
	return o.ToResourcePoolPatchPtrOutputWithContext(context.Background())
}

func (o ResourcePoolPatchOutput) ToResourcePoolPatchPtrOutputWithContext(ctx context.Context) ResourcePoolPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourcePoolPatch) *ResourcePoolPatch {
		return &v
	}).(ResourcePoolPatchPtrOutput)
}

// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
//
// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
func (o ResourcePoolPatchOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ResourcePoolPatch) *int { return v.Generation }).(pulumi.IntPtrOutput)
}

// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
//
// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
func (o ResourcePoolPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourcePoolPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
//
// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
func (o ResourcePoolPatchOutput) ResourceSliceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ResourcePoolPatch) *int { return v.ResourceSliceCount }).(pulumi.IntPtrOutput)
}

type ResourcePoolPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourcePoolPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourcePoolPatch)(nil)).Elem()
}

func (o ResourcePoolPatchPtrOutput) ToResourcePoolPatchPtrOutput() ResourcePoolPatchPtrOutput {
	return o
}

func (o ResourcePoolPatchPtrOutput) ToResourcePoolPatchPtrOutputWithContext(ctx context.Context) ResourcePoolPatchPtrOutput {
	return o
}

func (o ResourcePoolPatchPtrOutput) Elem() ResourcePoolPatchOutput {
	return o.ApplyT(func(v *ResourcePoolPatch) ResourcePoolPatch {
		if v != nil {
			return *v
		}
		var ret ResourcePoolPatch
		return ret
	}).(ResourcePoolPatchOutput)
}

// Generation tracks the change in a pool over time. Whenever a driver changes something about one or more of the resources in a pool, it must change the generation in all ResourceSlices which are part of that pool. Consumers of ResourceSlices should only consider resources from the pool with the highest generation number. The generation may be reset by drivers, which should be fine for consumers, assuming that all ResourceSlices in a pool are updated to match or deleted.
//
// Combined with ResourceSliceCount, this mechanism enables consumers to detect pools which are comprised of multiple ResourceSlices and are in an incomplete state.
func (o ResourcePoolPatchPtrOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ResourcePoolPatch) *int {
		if v == nil {
			return nil
		}
		return v.Generation
	}).(pulumi.IntPtrOutput)
}

// Name is used to identify the pool. For node-local devices, this is often the node name, but this is not required.
//
// It must not be longer than 253 characters and must consist of one or more DNS sub-domains separated by slashes. This field is immutable.
func (o ResourcePoolPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourcePoolPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ResourceSliceCount is the total number of ResourceSlices in the pool at this generation number. Must be greater than zero.
//
// Consumers can use this to check whether they have seen all ResourceSlices belonging to the same pool.
func (o ResourcePoolPatchPtrOutput) ResourceSliceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ResourcePoolPatch) *int {
		if v == nil {
			return nil
		}
		return v.ResourceSliceCount
	}).(pulumi.IntPtrOutput)
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSliceType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Contains the information published by the driver.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec ResourceSliceSpec `pulumi:"spec"`
}

// ResourceSliceTypeInput is an input type that accepts ResourceSliceTypeArgs and ResourceSliceTypeOutput values.
// You can construct a concrete instance of `ResourceSliceTypeInput` via:
//
//	ResourceSliceTypeArgs{...}
type ResourceSliceTypeInput interface {
	pulumi.Input

	ToResourceSliceTypeOutput() ResourceSliceTypeOutput
	ToResourceSliceTypeOutputWithContext(context.Context) ResourceSliceTypeOutput
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSliceTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Contains the information published by the driver.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec ResourceSliceSpecInput `pulumi:"spec"`
}

func (ResourceSliceTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceType)(nil)).Elem()
}

func (i ResourceSliceTypeArgs) ToResourceSliceTypeOutput() ResourceSliceTypeOutput {
	return i.ToResourceSliceTypeOutputWithContext(context.Background())
}

func (i ResourceSliceTypeArgs) ToResourceSliceTypeOutputWithContext(ctx context.Context) ResourceSliceTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceTypeOutput)
}

// ResourceSliceTypeArrayInput is an input type that accepts ResourceSliceTypeArray and ResourceSliceTypeArrayOutput values.
// You can construct a concrete instance of `ResourceSliceTypeArrayInput` via:
//
//	ResourceSliceTypeArray{ ResourceSliceTypeArgs{...} }
type ResourceSliceTypeArrayInput interface {
	pulumi.Input

	ToResourceSliceTypeArrayOutput() ResourceSliceTypeArrayOutput
	ToResourceSliceTypeArrayOutputWithContext(context.Context) ResourceSliceTypeArrayOutput
}

type ResourceSliceTypeArray []ResourceSliceTypeInput

func (ResourceSliceTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceSliceType)(nil)).Elem()
}

func (i ResourceSliceTypeArray) ToResourceSliceTypeArrayOutput() ResourceSliceTypeArrayOutput {
	return i.ToResourceSliceTypeArrayOutputWithContext(context.Background())
}

func (i ResourceSliceTypeArray) ToResourceSliceTypeArrayOutputWithContext(ctx context.Context) ResourceSliceTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceTypeArrayOutput)
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSliceTypeOutput struct{ *pulumi.OutputState }

func (ResourceSliceTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceType)(nil)).Elem()
}

func (o ResourceSliceTypeOutput) ToResourceSliceTypeOutput() ResourceSliceTypeOutput {
	return o
}

func (o ResourceSliceTypeOutput) ToResourceSliceTypeOutputWithContext(ctx context.Context) ResourceSliceTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceSliceTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceSliceTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceSliceTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ResourceSliceType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Contains the information published by the driver.
//
// Changing the spec automatically increments the metadata.generation number.
func (o ResourceSliceTypeOutput) Spec() ResourceSliceSpecOutput {
	return o.ApplyT(func(v ResourceSliceType) ResourceSliceSpec { return v.Spec }).(ResourceSliceSpecOutput)
}

type ResourceSliceTypeArrayOutput struct{ *pulumi.OutputState }

func (ResourceSliceTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceSliceType)(nil)).Elem()
}

func (o ResourceSliceTypeArrayOutput) ToResourceSliceTypeArrayOutput() ResourceSliceTypeArrayOutput {
	return o
}

func (o ResourceSliceTypeArrayOutput) ToResourceSliceTypeArrayOutputWithContext(ctx context.Context) ResourceSliceTypeArrayOutput {
	return o
}

func (o ResourceSliceTypeArrayOutput) Index(i pulumi.IntInput) ResourceSliceTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceSliceType {
		return vs[0].([]ResourceSliceType)[vs[1].(int)]
	}).(ResourceSliceTypeOutput)
}

// ResourceSliceList is a collection of ResourceSlices.
type ResourceSliceList struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of resource ResourceSlices.
	Items []ResourceSliceType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata
	ListMeta *metav1.ListMeta `pulumi:"listMeta"`
}

// ResourceSliceListInput is an input type that accepts ResourceSliceListArgs and ResourceSliceListOutput values.
// You can construct a concrete instance of `ResourceSliceListInput` via:
//
//	ResourceSliceListArgs{...}
type ResourceSliceListInput interface {
	pulumi.Input

	ToResourceSliceListOutput() ResourceSliceListOutput
	ToResourceSliceListOutputWithContext(context.Context) ResourceSliceListOutput
}

// ResourceSliceList is a collection of ResourceSlices.
type ResourceSliceListArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is the list of resource ResourceSlices.
	Items ResourceSliceTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata
	ListMeta metav1.ListMetaPtrInput `pulumi:"listMeta"`
}

func (ResourceSliceListArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceList)(nil)).Elem()
}

func (i ResourceSliceListArgs) ToResourceSliceListOutput() ResourceSliceListOutput {
	return i.ToResourceSliceListOutputWithContext(context.Background())
}

func (i ResourceSliceListArgs) ToResourceSliceListOutputWithContext(ctx context.Context) ResourceSliceListOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceListOutput)
}

// ResourceSliceList is a collection of ResourceSlices.
type ResourceSliceListOutput struct{ *pulumi.OutputState }

func (ResourceSliceListOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceList)(nil)).Elem()
}

func (o ResourceSliceListOutput) ToResourceSliceListOutput() ResourceSliceListOutput {
	return o
}

func (o ResourceSliceListOutput) ToResourceSliceListOutputWithContext(ctx context.Context) ResourceSliceListOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceSliceListOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceList) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is the list of resource ResourceSlices.
func (o ResourceSliceListOutput) Items() ResourceSliceTypeArrayOutput {
	return o.ApplyT(func(v ResourceSliceList) []ResourceSliceType { return v.Items }).(ResourceSliceTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceSliceListOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceList) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata
func (o ResourceSliceListOutput) ListMeta() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ResourceSliceList) *metav1.ListMeta { return v.ListMeta }).(metav1.ListMetaPtrOutput)
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSlicePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Contains the information published by the driver.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec *ResourceSliceSpecPatch `pulumi:"spec"`
}

// ResourceSlicePatchTypeInput is an input type that accepts ResourceSlicePatchTypeArgs and ResourceSlicePatchTypeOutput values.
// You can construct a concrete instance of `ResourceSlicePatchTypeInput` via:
//
//	ResourceSlicePatchTypeArgs{...}
type ResourceSlicePatchTypeInput interface {
	pulumi.Input

	ToResourceSlicePatchTypeOutput() ResourceSlicePatchTypeOutput
	ToResourceSlicePatchTypeOutputWithContext(context.Context) ResourceSlicePatchTypeOutput
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSlicePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Contains the information published by the driver.
	//
	// Changing the spec automatically increments the metadata.generation number.
	Spec ResourceSliceSpecPatchPtrInput `pulumi:"spec"`
}

func (ResourceSlicePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSlicePatchType)(nil)).Elem()
}

func (i ResourceSlicePatchTypeArgs) ToResourceSlicePatchTypeOutput() ResourceSlicePatchTypeOutput {
	return i.ToResourceSlicePatchTypeOutputWithContext(context.Background())
}

func (i ResourceSlicePatchTypeArgs) ToResourceSlicePatchTypeOutputWithContext(ctx context.Context) ResourceSlicePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSlicePatchTypeOutput)
}

// ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.
//
// At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.
//
// Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.
//
// When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.
//
// For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation feature gate.
type ResourceSlicePatchTypeOutput struct{ *pulumi.OutputState }

func (ResourceSlicePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSlicePatchType)(nil)).Elem()
}

func (o ResourceSlicePatchTypeOutput) ToResourceSlicePatchTypeOutput() ResourceSlicePatchTypeOutput {
	return o
}

func (o ResourceSlicePatchTypeOutput) ToResourceSlicePatchTypeOutputWithContext(ctx context.Context) ResourceSlicePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ResourceSlicePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSlicePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ResourceSlicePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSlicePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object metadata
func (o ResourceSlicePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ResourceSlicePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Contains the information published by the driver.
//
// Changing the spec automatically increments the metadata.generation number.
func (o ResourceSlicePatchTypeOutput) Spec() ResourceSliceSpecPatchPtrOutput {
	return o.ApplyT(func(v ResourceSlicePatchType) *ResourceSliceSpecPatch { return v.Spec }).(ResourceSliceSpecPatchPtrOutput)
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpec struct {
	// AllNodes indicates that all nodes have access to the resources in the pool.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set.
	AllNodes *bool `pulumi:"allNodes"`
	// Devices lists some or all of the devices in this pool.
	//
	// Must not have more than 128 entries.
	Devices []Device `pulumi:"devices"`
	// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
	Driver string `pulumi:"driver"`
	// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
	//
	// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set. This field is immutable.
	NodeName *string `pulumi:"nodeName"`
	// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
	//
	// Must use exactly one term.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set.
	NodeSelector *corev1.NodeSelector `pulumi:"nodeSelector"`
	// Pool describes the pool that this ResourceSlice belongs to.
	Pool ResourcePool `pulumi:"pool"`
}

// ResourceSliceSpecInput is an input type that accepts ResourceSliceSpecArgs and ResourceSliceSpecOutput values.
// You can construct a concrete instance of `ResourceSliceSpecInput` via:
//
//	ResourceSliceSpecArgs{...}
type ResourceSliceSpecInput interface {
	pulumi.Input

	ToResourceSliceSpecOutput() ResourceSliceSpecOutput
	ToResourceSliceSpecOutputWithContext(context.Context) ResourceSliceSpecOutput
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecArgs struct {
	// AllNodes indicates that all nodes have access to the resources in the pool.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set.
	AllNodes pulumi.BoolPtrInput `pulumi:"allNodes"`
	// Devices lists some or all of the devices in this pool.
	//
	// Must not have more than 128 entries.
	Devices DeviceArrayInput `pulumi:"devices"`
	// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
	Driver pulumi.StringInput `pulumi:"driver"`
	// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
	//
	// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set. This field is immutable.
	NodeName pulumi.StringPtrInput `pulumi:"nodeName"`
	// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
	//
	// Must use exactly one term.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set.
	NodeSelector corev1.NodeSelectorPtrInput `pulumi:"nodeSelector"`
	// Pool describes the pool that this ResourceSlice belongs to.
	Pool ResourcePoolInput `pulumi:"pool"`
}

func (ResourceSliceSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceSpec)(nil)).Elem()
}

func (i ResourceSliceSpecArgs) ToResourceSliceSpecOutput() ResourceSliceSpecOutput {
	return i.ToResourceSliceSpecOutputWithContext(context.Background())
}

func (i ResourceSliceSpecArgs) ToResourceSliceSpecOutputWithContext(ctx context.Context) ResourceSliceSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceSpecOutput)
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecOutput struct{ *pulumi.OutputState }

func (ResourceSliceSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceSpec)(nil)).Elem()
}

func (o ResourceSliceSpecOutput) ToResourceSliceSpecOutput() ResourceSliceSpecOutput {
	return o
}

func (o ResourceSliceSpecOutput) ToResourceSliceSpecOutputWithContext(ctx context.Context) ResourceSliceSpecOutput {
	return o
}

// AllNodes indicates that all nodes have access to the resources in the pool.
//
// Exactly one of NodeName, NodeSelector and AllNodes must be set.
func (o ResourceSliceSpecOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpec) *bool { return v.AllNodes }).(pulumi.BoolPtrOutput)
}

// Devices lists some or all of the devices in this pool.
//
// Must not have more than 128 entries.
func (o ResourceSliceSpecOutput) Devices() DeviceArrayOutput {
	return o.ApplyT(func(v ResourceSliceSpec) []Device { return v.Devices }).(DeviceArrayOutput)
}

// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
func (o ResourceSliceSpecOutput) Driver() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceSliceSpec) string { return v.Driver }).(pulumi.StringOutput)
}

// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
//
// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
//
// Exactly one of NodeName, NodeSelector and AllNodes must be set. This field is immutable.
func (o ResourceSliceSpecOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpec) *string { return v.NodeName }).(pulumi.StringPtrOutput)
}

// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
//
// Must use exactly one term.
//
// Exactly one of NodeName, NodeSelector and AllNodes must be set.
func (o ResourceSliceSpecOutput) NodeSelector() corev1.NodeSelectorPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpec) *corev1.NodeSelector { return v.NodeSelector }).(corev1.NodeSelectorPtrOutput)
}

// Pool describes the pool that this ResourceSlice belongs to.
func (o ResourceSliceSpecOutput) Pool() ResourcePoolOutput {
	return o.ApplyT(func(v ResourceSliceSpec) ResourcePool { return v.Pool }).(ResourcePoolOutput)
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecPatch struct {
	// AllNodes indicates that all nodes have access to the resources in the pool.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set.
	AllNodes *bool `pulumi:"allNodes"`
	// Devices lists some or all of the devices in this pool.
	//
	// Must not have more than 128 entries.
	Devices []DevicePatch `pulumi:"devices"`
	// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
	Driver *string `pulumi:"driver"`
	// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
	//
	// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set. This field is immutable.
	NodeName *string `pulumi:"nodeName"`
	// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
	//
	// Must use exactly one term.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set.
	NodeSelector *corev1.NodeSelectorPatch `pulumi:"nodeSelector"`
	// Pool describes the pool that this ResourceSlice belongs to.
	Pool *ResourcePoolPatch `pulumi:"pool"`
}

// ResourceSliceSpecPatchInput is an input type that accepts ResourceSliceSpecPatchArgs and ResourceSliceSpecPatchOutput values.
// You can construct a concrete instance of `ResourceSliceSpecPatchInput` via:
//
//	ResourceSliceSpecPatchArgs{...}
type ResourceSliceSpecPatchInput interface {
	pulumi.Input

	ToResourceSliceSpecPatchOutput() ResourceSliceSpecPatchOutput
	ToResourceSliceSpecPatchOutputWithContext(context.Context) ResourceSliceSpecPatchOutput
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecPatchArgs struct {
	// AllNodes indicates that all nodes have access to the resources in the pool.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set.
	AllNodes pulumi.BoolPtrInput `pulumi:"allNodes"`
	// Devices lists some or all of the devices in this pool.
	//
	// Must not have more than 128 entries.
	Devices DevicePatchArrayInput `pulumi:"devices"`
	// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
	//
	// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
	Driver pulumi.StringPtrInput `pulumi:"driver"`
	// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
	//
	// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set. This field is immutable.
	NodeName pulumi.StringPtrInput `pulumi:"nodeName"`
	// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
	//
	// Must use exactly one term.
	//
	// Exactly one of NodeName, NodeSelector and AllNodes must be set.
	NodeSelector corev1.NodeSelectorPatchPtrInput `pulumi:"nodeSelector"`
	// Pool describes the pool that this ResourceSlice belongs to.
	Pool ResourcePoolPatchPtrInput `pulumi:"pool"`
}

func (ResourceSliceSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceSpecPatch)(nil)).Elem()
}

func (i ResourceSliceSpecPatchArgs) ToResourceSliceSpecPatchOutput() ResourceSliceSpecPatchOutput {
	return i.ToResourceSliceSpecPatchOutputWithContext(context.Background())
}

func (i ResourceSliceSpecPatchArgs) ToResourceSliceSpecPatchOutputWithContext(ctx context.Context) ResourceSliceSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceSpecPatchOutput)
}

func (i ResourceSliceSpecPatchArgs) ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput {
	return i.ToResourceSliceSpecPatchPtrOutputWithContext(context.Background())
}

func (i ResourceSliceSpecPatchArgs) ToResourceSliceSpecPatchPtrOutputWithContext(ctx context.Context) ResourceSliceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceSpecPatchOutput).ToResourceSliceSpecPatchPtrOutputWithContext(ctx)
}

// ResourceSliceSpecPatchPtrInput is an input type that accepts ResourceSliceSpecPatchArgs, ResourceSliceSpecPatchPtr and ResourceSliceSpecPatchPtrOutput values.
// You can construct a concrete instance of `ResourceSliceSpecPatchPtrInput` via:
//
//	        ResourceSliceSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ResourceSliceSpecPatchPtrInput interface {
	pulumi.Input

	ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput
	ToResourceSliceSpecPatchPtrOutputWithContext(context.Context) ResourceSliceSpecPatchPtrOutput
}

type resourceSliceSpecPatchPtrType ResourceSliceSpecPatchArgs

func ResourceSliceSpecPatchPtr(v *ResourceSliceSpecPatchArgs) ResourceSliceSpecPatchPtrInput {
	return (*resourceSliceSpecPatchPtrType)(v)
}

func (*resourceSliceSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceSliceSpecPatch)(nil)).Elem()
}

func (i *resourceSliceSpecPatchPtrType) ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput {
	return i.ToResourceSliceSpecPatchPtrOutputWithContext(context.Background())
}

func (i *resourceSliceSpecPatchPtrType) ToResourceSliceSpecPatchPtrOutputWithContext(ctx context.Context) ResourceSliceSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSliceSpecPatchPtrOutput)
}

// ResourceSliceSpec contains the information published by the driver in one ResourceSlice.
type ResourceSliceSpecPatchOutput struct{ *pulumi.OutputState }

func (ResourceSliceSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSliceSpecPatch)(nil)).Elem()
}

func (o ResourceSliceSpecPatchOutput) ToResourceSliceSpecPatchOutput() ResourceSliceSpecPatchOutput {
	return o
}

func (o ResourceSliceSpecPatchOutput) ToResourceSliceSpecPatchOutputWithContext(ctx context.Context) ResourceSliceSpecPatchOutput {
	return o
}

func (o ResourceSliceSpecPatchOutput) ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput {
	return o.ToResourceSliceSpecPatchPtrOutputWithContext(context.Background())
}

func (o ResourceSliceSpecPatchOutput) ToResourceSliceSpecPatchPtrOutputWithContext(ctx context.Context) ResourceSliceSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceSliceSpecPatch) *ResourceSliceSpecPatch {
		return &v
	}).(ResourceSliceSpecPatchPtrOutput)
}

// AllNodes indicates that all nodes have access to the resources in the pool.
//
// Exactly one of NodeName, NodeSelector and AllNodes must be set.
func (o ResourceSliceSpecPatchOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *bool { return v.AllNodes }).(pulumi.BoolPtrOutput)
}

// Devices lists some or all of the devices in this pool.
//
// Must not have more than 128 entries.
func (o ResourceSliceSpecPatchOutput) Devices() DevicePatchArrayOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) []DevicePatch { return v.Devices }).(DevicePatchArrayOutput)
}

// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
func (o ResourceSliceSpecPatchOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *string { return v.Driver }).(pulumi.StringPtrOutput)
}

// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
//
// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
//
// Exactly one of NodeName, NodeSelector and AllNodes must be set. This field is immutable.
func (o ResourceSliceSpecPatchOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *string { return v.NodeName }).(pulumi.StringPtrOutput)
}

// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
//
// Must use exactly one term.
//
// Exactly one of NodeName, NodeSelector and AllNodes must be set.
func (o ResourceSliceSpecPatchOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *corev1.NodeSelectorPatch { return v.NodeSelector }).(corev1.NodeSelectorPatchPtrOutput)
}

// Pool describes the pool that this ResourceSlice belongs to.
func (o ResourceSliceSpecPatchOutput) Pool() ResourcePoolPatchPtrOutput {
	return o.ApplyT(func(v ResourceSliceSpecPatch) *ResourcePoolPatch { return v.Pool }).(ResourcePoolPatchPtrOutput)
}

type ResourceSliceSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ResourceSliceSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceSliceSpecPatch)(nil)).Elem()
}

func (o ResourceSliceSpecPatchPtrOutput) ToResourceSliceSpecPatchPtrOutput() ResourceSliceSpecPatchPtrOutput {
	return o
}

func (o ResourceSliceSpecPatchPtrOutput) ToResourceSliceSpecPatchPtrOutputWithContext(ctx context.Context) ResourceSliceSpecPatchPtrOutput {
	return o
}

func (o ResourceSliceSpecPatchPtrOutput) Elem() ResourceSliceSpecPatchOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) ResourceSliceSpecPatch {
		if v != nil {
			return *v
		}
		var ret ResourceSliceSpecPatch
		return ret
	}).(ResourceSliceSpecPatchOutput)
}

// AllNodes indicates that all nodes have access to the resources in the pool.
//
// Exactly one of NodeName, NodeSelector and AllNodes must be set.
func (o ResourceSliceSpecPatchPtrOutput) AllNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *bool {
		if v == nil {
			return nil
		}
		return v.AllNodes
	}).(pulumi.BoolPtrOutput)
}

// Devices lists some or all of the devices in this pool.
//
// Must not have more than 128 entries.
func (o ResourceSliceSpecPatchPtrOutput) Devices() DevicePatchArrayOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) []DevicePatch {
		if v == nil {
			return nil
		}
		return v.Devices
	}).(DevicePatchArrayOutput)
}

// Driver identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
//
// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver. This field is immutable.
func (o ResourceSliceSpecPatchPtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Driver
	}).(pulumi.StringPtrOutput)
}

// NodeName identifies the node which provides the resources in this pool. A field selector can be used to list only ResourceSlice objects belonging to a certain node.
//
// This field can be used to limit access from nodes to ResourceSlices with the same node name. It also indicates to autoscalers that adding new nodes of the same type as some old node might also make new resources available.
//
// Exactly one of NodeName, NodeSelector and AllNodes must be set. This field is immutable.
func (o ResourceSliceSpecPatchPtrOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.NodeName
	}).(pulumi.StringPtrOutput)
}

// NodeSelector defines which nodes have access to the resources in the pool, when that pool is not limited to a single node.
//
// Must use exactly one term.
//
// Exactly one of NodeName, NodeSelector and AllNodes must be set.
func (o ResourceSliceSpecPatchPtrOutput) NodeSelector() corev1.NodeSelectorPatchPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *corev1.NodeSelectorPatch {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(corev1.NodeSelectorPatchPtrOutput)
}

// Pool describes the pool that this ResourceSlice belongs to.
func (o ResourceSliceSpecPatchPtrOutput) Pool() ResourcePoolPatchPtrOutput {
	return o.ApplyT(func(v *ResourceSliceSpecPatch) *ResourcePoolPatch {
		if v == nil {
			return nil
		}
		return v.Pool
	}).(ResourcePoolPatchPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationResultInput)(nil)).Elem(), AllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationResultPtrInput)(nil)).Elem(), AllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationResultPatchInput)(nil)).Elem(), AllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationResultPatchPtrInput)(nil)).Elem(), AllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicDeviceInput)(nil)).Elem(), BasicDeviceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicDevicePtrInput)(nil)).Elem(), BasicDeviceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicDevicePatchInput)(nil)).Elem(), BasicDevicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicDevicePatchPtrInput)(nil)).Elem(), BasicDevicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CELDeviceSelectorInput)(nil)).Elem(), CELDeviceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CELDeviceSelectorPtrInput)(nil)).Elem(), CELDeviceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CELDeviceSelectorPatchInput)(nil)).Elem(), CELDeviceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CELDeviceSelectorPatchPtrInput)(nil)).Elem(), CELDeviceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceInput)(nil)).Elem(), DeviceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceArrayInput)(nil)).Elem(), DeviceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationConfigurationInput)(nil)).Elem(), DeviceAllocationConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationConfigurationArrayInput)(nil)).Elem(), DeviceAllocationConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationConfigurationPatchInput)(nil)).Elem(), DeviceAllocationConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationConfigurationPatchArrayInput)(nil)).Elem(), DeviceAllocationConfigurationPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationResultInput)(nil)).Elem(), DeviceAllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationResultPtrInput)(nil)).Elem(), DeviceAllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationResultPatchInput)(nil)).Elem(), DeviceAllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAllocationResultPatchPtrInput)(nil)).Elem(), DeviceAllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAttributeInput)(nil)).Elem(), DeviceAttributeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAttributeMapInput)(nil)).Elem(), DeviceAttributeMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceAttributePatchInput)(nil)).Elem(), DeviceAttributePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimInput)(nil)).Elem(), DeviceClaimArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimPtrInput)(nil)).Elem(), DeviceClaimArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimConfigurationInput)(nil)).Elem(), DeviceClaimConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimConfigurationArrayInput)(nil)).Elem(), DeviceClaimConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimConfigurationPatchInput)(nil)).Elem(), DeviceClaimConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimConfigurationPatchArrayInput)(nil)).Elem(), DeviceClaimConfigurationPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimPatchInput)(nil)).Elem(), DeviceClaimPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClaimPatchPtrInput)(nil)).Elem(), DeviceClaimPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassTypeInput)(nil)).Elem(), DeviceClassTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassTypeArrayInput)(nil)).Elem(), DeviceClassTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassConfigurationInput)(nil)).Elem(), DeviceClassConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassConfigurationArrayInput)(nil)).Elem(), DeviceClassConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassConfigurationPatchInput)(nil)).Elem(), DeviceClassConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassConfigurationPatchArrayInput)(nil)).Elem(), DeviceClassConfigurationPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassListTypeInput)(nil)).Elem(), DeviceClassListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassPatchTypeInput)(nil)).Elem(), DeviceClassPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassSpecInput)(nil)).Elem(), DeviceClassSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassSpecPatchInput)(nil)).Elem(), DeviceClassSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceClassSpecPatchPtrInput)(nil)).Elem(), DeviceClassSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceConstraintInput)(nil)).Elem(), DeviceConstraintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceConstraintArrayInput)(nil)).Elem(), DeviceConstraintArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceConstraintPatchInput)(nil)).Elem(), DeviceConstraintPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceConstraintPatchArrayInput)(nil)).Elem(), DeviceConstraintPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DevicePatchInput)(nil)).Elem(), DevicePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DevicePatchArrayInput)(nil)).Elem(), DevicePatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestInput)(nil)).Elem(), DeviceRequestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestArrayInput)(nil)).Elem(), DeviceRequestArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestAllocationResultInput)(nil)).Elem(), DeviceRequestAllocationResultArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestAllocationResultArrayInput)(nil)).Elem(), DeviceRequestAllocationResultArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestAllocationResultPatchInput)(nil)).Elem(), DeviceRequestAllocationResultPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestAllocationResultPatchArrayInput)(nil)).Elem(), DeviceRequestAllocationResultPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestPatchInput)(nil)).Elem(), DeviceRequestPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceRequestPatchArrayInput)(nil)).Elem(), DeviceRequestPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSelectorInput)(nil)).Elem(), DeviceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSelectorArrayInput)(nil)).Elem(), DeviceSelectorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSelectorPatchInput)(nil)).Elem(), DeviceSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceSelectorPatchArrayInput)(nil)).Elem(), DeviceSelectorPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintInput)(nil)).Elem(), DeviceTaintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintPatchInput)(nil)).Elem(), DeviceTaintPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintPatchPtrInput)(nil)).Elem(), DeviceTaintPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintRuleTypeInput)(nil)).Elem(), DeviceTaintRuleTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintRuleTypeArrayInput)(nil)).Elem(), DeviceTaintRuleTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintRuleListTypeInput)(nil)).Elem(), DeviceTaintRuleListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintRulePatchTypeInput)(nil)).Elem(), DeviceTaintRulePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintRuleSpecInput)(nil)).Elem(), DeviceTaintRuleSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintRuleSpecPatchInput)(nil)).Elem(), DeviceTaintRuleSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintRuleSpecPatchPtrInput)(nil)).Elem(), DeviceTaintRuleSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintSelectorInput)(nil)).Elem(), DeviceTaintSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintSelectorPtrInput)(nil)).Elem(), DeviceTaintSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintSelectorPatchInput)(nil)).Elem(), DeviceTaintSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeviceTaintSelectorPatchPtrInput)(nil)).Elem(), DeviceTaintSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpaqueDeviceConfigurationInput)(nil)).Elem(), OpaqueDeviceConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpaqueDeviceConfigurationPtrInput)(nil)).Elem(), OpaqueDeviceConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpaqueDeviceConfigurationPatchInput)(nil)).Elem(), OpaqueDeviceConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpaqueDeviceConfigurationPatchPtrInput)(nil)).Elem(), OpaqueDeviceConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextTypeInput)(nil)).Elem(), PodSchedulingContextTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextTypeArrayInput)(nil)).Elem(), PodSchedulingContextTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextListTypeInput)(nil)).Elem(), PodSchedulingContextListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextPatchTypeInput)(nil)).Elem(), PodSchedulingContextPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextSpecInput)(nil)).Elem(), PodSchedulingContextSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextSpecPatchInput)(nil)).Elem(), PodSchedulingContextSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextSpecPatchPtrInput)(nil)).Elem(), PodSchedulingContextSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextStatusInput)(nil)).Elem(), PodSchedulingContextStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextStatusPtrInput)(nil)).Elem(), PodSchedulingContextStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextStatusPatchInput)(nil)).Elem(), PodSchedulingContextStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodSchedulingContextStatusPatchPtrInput)(nil)).Elem(), PodSchedulingContextStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTypeInput)(nil)).Elem(), ResourceClaimTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTypeArrayInput)(nil)).Elem(), ResourceClaimTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimConsumerReferenceInput)(nil)).Elem(), ResourceClaimConsumerReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimConsumerReferenceArrayInput)(nil)).Elem(), ResourceClaimConsumerReferenceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimConsumerReferencePatchInput)(nil)).Elem(), ResourceClaimConsumerReferencePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimConsumerReferencePatchArrayInput)(nil)).Elem(), ResourceClaimConsumerReferencePatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimListTypeInput)(nil)).Elem(), ResourceClaimListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimPatchTypeInput)(nil)).Elem(), ResourceClaimPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSchedulingStatusInput)(nil)).Elem(), ResourceClaimSchedulingStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSchedulingStatusArrayInput)(nil)).Elem(), ResourceClaimSchedulingStatusArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSchedulingStatusPatchInput)(nil)).Elem(), ResourceClaimSchedulingStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSchedulingStatusPatchArrayInput)(nil)).Elem(), ResourceClaimSchedulingStatusPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSpecInput)(nil)).Elem(), ResourceClaimSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSpecPatchInput)(nil)).Elem(), ResourceClaimSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimSpecPatchPtrInput)(nil)).Elem(), ResourceClaimSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimStatusInput)(nil)).Elem(), ResourceClaimStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimStatusPtrInput)(nil)).Elem(), ResourceClaimStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimStatusPatchInput)(nil)).Elem(), ResourceClaimStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimStatusPatchPtrInput)(nil)).Elem(), ResourceClaimStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateTypeInput)(nil)).Elem(), ResourceClaimTemplateTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateTypeArrayInput)(nil)).Elem(), ResourceClaimTemplateTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateListTypeInput)(nil)).Elem(), ResourceClaimTemplateListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplatePatchTypeInput)(nil)).Elem(), ResourceClaimTemplatePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateSpecInput)(nil)).Elem(), ResourceClaimTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateSpecPatchInput)(nil)).Elem(), ResourceClaimTemplateSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceClaimTemplateSpecPatchPtrInput)(nil)).Elem(), ResourceClaimTemplateSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePoolInput)(nil)).Elem(), ResourcePoolArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePoolPatchInput)(nil)).Elem(), ResourcePoolPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePoolPatchPtrInput)(nil)).Elem(), ResourcePoolPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceTypeInput)(nil)).Elem(), ResourceSliceTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceTypeArrayInput)(nil)).Elem(), ResourceSliceTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceListInput)(nil)).Elem(), ResourceSliceListArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSlicePatchTypeInput)(nil)).Elem(), ResourceSlicePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceSpecInput)(nil)).Elem(), ResourceSliceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceSpecPatchInput)(nil)).Elem(), ResourceSliceSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSliceSpecPatchPtrInput)(nil)).Elem(), ResourceSliceSpecPatchArgs{})
	pulumi.RegisterOutputType(AllocationResultOutput{})
	pulumi.RegisterOutputType(AllocationResultPtrOutput{})
	pulumi.RegisterOutputType(AllocationResultPatchOutput{})
	pulumi.RegisterOutputType(AllocationResultPatchPtrOutput{})
	pulumi.RegisterOutputType(BasicDeviceOutput{})
	pulumi.RegisterOutputType(BasicDevicePtrOutput{})
	pulumi.RegisterOutputType(BasicDevicePatchOutput{})
	pulumi.RegisterOutputType(BasicDevicePatchPtrOutput{})
	pulumi.RegisterOutputType(CELDeviceSelectorOutput{})
	pulumi.RegisterOutputType(CELDeviceSelectorPtrOutput{})
	pulumi.RegisterOutputType(CELDeviceSelectorPatchOutput{})
	pulumi.RegisterOutputType(CELDeviceSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(DeviceOutput{})
	pulumi.RegisterOutputType(DeviceArrayOutput{})
	pulumi.RegisterOutputType(DeviceAllocationConfigurationOutput{})
	pulumi.RegisterOutputType(DeviceAllocationConfigurationArrayOutput{})
	pulumi.RegisterOutputType(DeviceAllocationConfigurationPatchOutput{})
	pulumi.RegisterOutputType(DeviceAllocationConfigurationPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceAllocationResultOutput{})
	pulumi.RegisterOutputType(DeviceAllocationResultPtrOutput{})
	pulumi.RegisterOutputType(DeviceAllocationResultPatchOutput{})
	pulumi.RegisterOutputType(DeviceAllocationResultPatchPtrOutput{})
	pulumi.RegisterOutputType(DeviceAttributeOutput{})
	pulumi.RegisterOutputType(DeviceAttributeMapOutput{})
	pulumi.RegisterOutputType(DeviceAttributePatchOutput{})
	pulumi.RegisterOutputType(DeviceClaimOutput{})
	pulumi.RegisterOutputType(DeviceClaimPtrOutput{})
	pulumi.RegisterOutputType(DeviceClaimConfigurationOutput{})
	pulumi.RegisterOutputType(DeviceClaimConfigurationArrayOutput{})
	pulumi.RegisterOutputType(DeviceClaimConfigurationPatchOutput{})
	pulumi.RegisterOutputType(DeviceClaimConfigurationPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceClaimPatchOutput{})
	pulumi.RegisterOutputType(DeviceClaimPatchPtrOutput{})
	pulumi.RegisterOutputType(DeviceClassTypeOutput{})
	pulumi.RegisterOutputType(DeviceClassTypeArrayOutput{})
	pulumi.RegisterOutputType(DeviceClassConfigurationOutput{})
	pulumi.RegisterOutputType(DeviceClassConfigurationArrayOutput{})
	pulumi.RegisterOutputType(DeviceClassConfigurationPatchOutput{})
	pulumi.RegisterOutputType(DeviceClassConfigurationPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceClassListTypeOutput{})
	pulumi.RegisterOutputType(DeviceClassPatchTypeOutput{})
	pulumi.RegisterOutputType(DeviceClassSpecOutput{})
	pulumi.RegisterOutputType(DeviceClassSpecPatchOutput{})
	pulumi.RegisterOutputType(DeviceClassSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(DeviceConstraintOutput{})
	pulumi.RegisterOutputType(DeviceConstraintArrayOutput{})
	pulumi.RegisterOutputType(DeviceConstraintPatchOutput{})
	pulumi.RegisterOutputType(DeviceConstraintPatchArrayOutput{})
	pulumi.RegisterOutputType(DevicePatchOutput{})
	pulumi.RegisterOutputType(DevicePatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceRequestOutput{})
	pulumi.RegisterOutputType(DeviceRequestArrayOutput{})
	pulumi.RegisterOutputType(DeviceRequestAllocationResultOutput{})
	pulumi.RegisterOutputType(DeviceRequestAllocationResultArrayOutput{})
	pulumi.RegisterOutputType(DeviceRequestAllocationResultPatchOutput{})
	pulumi.RegisterOutputType(DeviceRequestAllocationResultPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceRequestPatchOutput{})
	pulumi.RegisterOutputType(DeviceRequestPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceSelectorOutput{})
	pulumi.RegisterOutputType(DeviceSelectorArrayOutput{})
	pulumi.RegisterOutputType(DeviceSelectorPatchOutput{})
	pulumi.RegisterOutputType(DeviceSelectorPatchArrayOutput{})
	pulumi.RegisterOutputType(DeviceTaintOutput{})
	pulumi.RegisterOutputType(DeviceTaintPatchOutput{})
	pulumi.RegisterOutputType(DeviceTaintPatchPtrOutput{})
	pulumi.RegisterOutputType(DeviceTaintRuleTypeOutput{})
	pulumi.RegisterOutputType(DeviceTaintRuleTypeArrayOutput{})
	pulumi.RegisterOutputType(DeviceTaintRuleListTypeOutput{})
	pulumi.RegisterOutputType(DeviceTaintRulePatchTypeOutput{})
	pulumi.RegisterOutputType(DeviceTaintRuleSpecOutput{})
	pulumi.RegisterOutputType(DeviceTaintRuleSpecPatchOutput{})
	pulumi.RegisterOutputType(DeviceTaintRuleSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(DeviceTaintSelectorOutput{})
	pulumi.RegisterOutputType(DeviceTaintSelectorPtrOutput{})
	pulumi.RegisterOutputType(DeviceTaintSelectorPatchOutput{})
	pulumi.RegisterOutputType(DeviceTaintSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(OpaqueDeviceConfigurationOutput{})
	pulumi.RegisterOutputType(OpaqueDeviceConfigurationPtrOutput{})
	pulumi.RegisterOutputType(OpaqueDeviceConfigurationPatchOutput{})
	pulumi.RegisterOutputType(OpaqueDeviceConfigurationPatchPtrOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextTypeOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextTypeArrayOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextListTypeOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextPatchTypeOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextSpecOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextSpecPatchOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextStatusOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextStatusPtrOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextStatusPatchOutput{})
	pulumi.RegisterOutputType(PodSchedulingContextStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourceClaimTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimTypeArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimConsumerReferenceOutput{})
	pulumi.RegisterOutputType(ResourceClaimConsumerReferenceArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimConsumerReferencePatchOutput{})
	pulumi.RegisterOutputType(ResourceClaimConsumerReferencePatchArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimListTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimPatchTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimSchedulingStatusOutput{})
	pulumi.RegisterOutputType(ResourceClaimSchedulingStatusArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimSchedulingStatusPatchOutput{})
	pulumi.RegisterOutputType(ResourceClaimSchedulingStatusPatchArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimSpecOutput{})
	pulumi.RegisterOutputType(ResourceClaimSpecPatchOutput{})
	pulumi.RegisterOutputType(ResourceClaimSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourceClaimStatusOutput{})
	pulumi.RegisterOutputType(ResourceClaimStatusPtrOutput{})
	pulumi.RegisterOutputType(ResourceClaimStatusPatchOutput{})
	pulumi.RegisterOutputType(ResourceClaimStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateTypeArrayOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateListTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplatePatchTypeOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateSpecOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateSpecPatchOutput{})
	pulumi.RegisterOutputType(ResourceClaimTemplateSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourcePoolOutput{})
	pulumi.RegisterOutputType(ResourcePoolPatchOutput{})
	pulumi.RegisterOutputType(ResourcePoolPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourceSliceTypeOutput{})
	pulumi.RegisterOutputType(ResourceSliceTypeArrayOutput{})
	pulumi.RegisterOutputType(ResourceSliceListOutput{})
	pulumi.RegisterOutputType(ResourceSlicePatchTypeOutput{})
	pulumi.RegisterOutputType(ResourceSliceSpecOutput{})
	pulumi.RegisterOutputType(ResourceSliceSpecPatchOutput{})
	pulumi.RegisterOutputType(ResourceSliceSpecPatchPtrOutput{})
}
