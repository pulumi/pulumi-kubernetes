// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	"errors"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// VolumeAttributesClass represents a specification of mutable volume attributes defined by the CSI driver. The class can be specified during dynamic provisioning of PersistentVolumeClaims, and changed in the PersistentVolumeClaim spec after provisioning.
type VolumeAttributesClass struct {
	pulumi.CustomResourceState

	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringOutput `pulumi:"apiVersion"`
	// Name of the CSI driver This field is immutable.
	DriverName pulumi.StringOutput `pulumi:"driverName"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringOutput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaOutput `pulumi:"metadata"`
	// parameters hold volume attributes defined by the CSI driver. These values are opaque to the Kubernetes and are passed directly to the CSI driver. The underlying storage provider supports changing these attributes on an existing volume, however the parameters field itself is immutable. To invoke a volume update, a new VolumeAttributesClass should be created with new parameters, and the PersistentVolumeClaim should be updated to reference the new VolumeAttributesClass.
	//
	// This field is required and must contain at least one key/value pair. The keys cannot be empty, and the maximum number of parameters is 512, with a cumulative max size of 256K. If the CSI driver rejects invalid parameters, the target PersistentVolumeClaim will be set to an "Infeasible" state in the modifyVolumeStatus field.
	Parameters pulumi.StringMapOutput `pulumi:"parameters"`
}

// NewVolumeAttributesClass registers a new resource with the given unique name, arguments, and options.
func NewVolumeAttributesClass(ctx *pulumi.Context,
	name string, args *VolumeAttributesClassArgs, opts ...pulumi.ResourceOption) (*VolumeAttributesClass, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DriverName == nil {
		return nil, errors.New("invalid value for required argument 'DriverName'")
	}
	args.ApiVersion = pulumi.StringPtr("storage.k8s.io/v1beta1")
	args.Kind = pulumi.StringPtr("VolumeAttributesClass")
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("kubernetes:storage.k8s.io/v1alpha1:VolumeAttributesClass"),
		},
	})
	opts = append(opts, aliases)
	opts = utilities.PkgResourceDefaultOpts(opts)
	var resource VolumeAttributesClass
	err := ctx.RegisterResource("kubernetes:storage.k8s.io/v1beta1:VolumeAttributesClass", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVolumeAttributesClass gets an existing VolumeAttributesClass resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVolumeAttributesClass(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VolumeAttributesClassState, opts ...pulumi.ResourceOption) (*VolumeAttributesClass, error) {
	var resource VolumeAttributesClass
	err := ctx.ReadResource("kubernetes:storage.k8s.io/v1beta1:VolumeAttributesClass", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VolumeAttributesClass resources.
type volumeAttributesClassState struct {
}

type VolumeAttributesClassState struct {
}

func (VolumeAttributesClassState) ElementType() reflect.Type {
	return reflect.TypeOf((*volumeAttributesClassState)(nil)).Elem()
}

type volumeAttributesClassArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Name of the CSI driver This field is immutable.
	DriverName string `pulumi:"driverName"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// parameters hold volume attributes defined by the CSI driver. These values are opaque to the Kubernetes and are passed directly to the CSI driver. The underlying storage provider supports changing these attributes on an existing volume, however the parameters field itself is immutable. To invoke a volume update, a new VolumeAttributesClass should be created with new parameters, and the PersistentVolumeClaim should be updated to reference the new VolumeAttributesClass.
	//
	// This field is required and must contain at least one key/value pair. The keys cannot be empty, and the maximum number of parameters is 512, with a cumulative max size of 256K. If the CSI driver rejects invalid parameters, the target PersistentVolumeClaim will be set to an "Infeasible" state in the modifyVolumeStatus field.
	Parameters map[string]string `pulumi:"parameters"`
}

// The set of arguments for constructing a VolumeAttributesClass resource.
type VolumeAttributesClassArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput
	// Name of the CSI driver This field is immutable.
	DriverName pulumi.StringInput
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput
	// parameters hold volume attributes defined by the CSI driver. These values are opaque to the Kubernetes and are passed directly to the CSI driver. The underlying storage provider supports changing these attributes on an existing volume, however the parameters field itself is immutable. To invoke a volume update, a new VolumeAttributesClass should be created with new parameters, and the PersistentVolumeClaim should be updated to reference the new VolumeAttributesClass.
	//
	// This field is required and must contain at least one key/value pair. The keys cannot be empty, and the maximum number of parameters is 512, with a cumulative max size of 256K. If the CSI driver rejects invalid parameters, the target PersistentVolumeClaim will be set to an "Infeasible" state in the modifyVolumeStatus field.
	Parameters pulumi.StringMapInput
}

func (VolumeAttributesClassArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*volumeAttributesClassArgs)(nil)).Elem()
}

type VolumeAttributesClassInput interface {
	pulumi.Input

	ToVolumeAttributesClassOutput() VolumeAttributesClassOutput
	ToVolumeAttributesClassOutputWithContext(ctx context.Context) VolumeAttributesClassOutput
}

func (*VolumeAttributesClass) ElementType() reflect.Type {
	return reflect.TypeOf((**VolumeAttributesClass)(nil)).Elem()
}

func (i *VolumeAttributesClass) ToVolumeAttributesClassOutput() VolumeAttributesClassOutput {
	return i.ToVolumeAttributesClassOutputWithContext(context.Background())
}

func (i *VolumeAttributesClass) ToVolumeAttributesClassOutputWithContext(ctx context.Context) VolumeAttributesClassOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeAttributesClassOutput)
}

// VolumeAttributesClassArrayInput is an input type that accepts VolumeAttributesClassArray and VolumeAttributesClassArrayOutput values.
// You can construct a concrete instance of `VolumeAttributesClassArrayInput` via:
//
//	VolumeAttributesClassArray{ VolumeAttributesClassArgs{...} }
type VolumeAttributesClassArrayInput interface {
	pulumi.Input

	ToVolumeAttributesClassArrayOutput() VolumeAttributesClassArrayOutput
	ToVolumeAttributesClassArrayOutputWithContext(context.Context) VolumeAttributesClassArrayOutput
}

type VolumeAttributesClassArray []VolumeAttributesClassInput

func (VolumeAttributesClassArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VolumeAttributesClass)(nil)).Elem()
}

func (i VolumeAttributesClassArray) ToVolumeAttributesClassArrayOutput() VolumeAttributesClassArrayOutput {
	return i.ToVolumeAttributesClassArrayOutputWithContext(context.Background())
}

func (i VolumeAttributesClassArray) ToVolumeAttributesClassArrayOutputWithContext(ctx context.Context) VolumeAttributesClassArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeAttributesClassArrayOutput)
}

// VolumeAttributesClassMapInput is an input type that accepts VolumeAttributesClassMap and VolumeAttributesClassMapOutput values.
// You can construct a concrete instance of `VolumeAttributesClassMapInput` via:
//
//	VolumeAttributesClassMap{ "key": VolumeAttributesClassArgs{...} }
type VolumeAttributesClassMapInput interface {
	pulumi.Input

	ToVolumeAttributesClassMapOutput() VolumeAttributesClassMapOutput
	ToVolumeAttributesClassMapOutputWithContext(context.Context) VolumeAttributesClassMapOutput
}

type VolumeAttributesClassMap map[string]VolumeAttributesClassInput

func (VolumeAttributesClassMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VolumeAttributesClass)(nil)).Elem()
}

func (i VolumeAttributesClassMap) ToVolumeAttributesClassMapOutput() VolumeAttributesClassMapOutput {
	return i.ToVolumeAttributesClassMapOutputWithContext(context.Background())
}

func (i VolumeAttributesClassMap) ToVolumeAttributesClassMapOutputWithContext(ctx context.Context) VolumeAttributesClassMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeAttributesClassMapOutput)
}

type VolumeAttributesClassOutput struct{ *pulumi.OutputState }

func (VolumeAttributesClassOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VolumeAttributesClass)(nil)).Elem()
}

func (o VolumeAttributesClassOutput) ToVolumeAttributesClassOutput() VolumeAttributesClassOutput {
	return o
}

func (o VolumeAttributesClassOutput) ToVolumeAttributesClassOutputWithContext(ctx context.Context) VolumeAttributesClassOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o VolumeAttributesClassOutput) ApiVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *VolumeAttributesClass) pulumi.StringOutput { return v.ApiVersion }).(pulumi.StringOutput)
}

// Name of the CSI driver This field is immutable.
func (o VolumeAttributesClassOutput) DriverName() pulumi.StringOutput {
	return o.ApplyT(func(v *VolumeAttributesClass) pulumi.StringOutput { return v.DriverName }).(pulumi.StringOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o VolumeAttributesClassOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v *VolumeAttributesClass) pulumi.StringOutput { return v.Kind }).(pulumi.StringOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o VolumeAttributesClassOutput) Metadata() metav1.ObjectMetaOutput {
	return o.ApplyT(func(v *VolumeAttributesClass) metav1.ObjectMetaOutput { return v.Metadata }).(metav1.ObjectMetaOutput)
}

// parameters hold volume attributes defined by the CSI driver. These values are opaque to the Kubernetes and are passed directly to the CSI driver. The underlying storage provider supports changing these attributes on an existing volume, however the parameters field itself is immutable. To invoke a volume update, a new VolumeAttributesClass should be created with new parameters, and the PersistentVolumeClaim should be updated to reference the new VolumeAttributesClass.
//
// This field is required and must contain at least one key/value pair. The keys cannot be empty, and the maximum number of parameters is 512, with a cumulative max size of 256K. If the CSI driver rejects invalid parameters, the target PersistentVolumeClaim will be set to an "Infeasible" state in the modifyVolumeStatus field.
func (o VolumeAttributesClassOutput) Parameters() pulumi.StringMapOutput {
	return o.ApplyT(func(v *VolumeAttributesClass) pulumi.StringMapOutput { return v.Parameters }).(pulumi.StringMapOutput)
}

type VolumeAttributesClassArrayOutput struct{ *pulumi.OutputState }

func (VolumeAttributesClassArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VolumeAttributesClass)(nil)).Elem()
}

func (o VolumeAttributesClassArrayOutput) ToVolumeAttributesClassArrayOutput() VolumeAttributesClassArrayOutput {
	return o
}

func (o VolumeAttributesClassArrayOutput) ToVolumeAttributesClassArrayOutputWithContext(ctx context.Context) VolumeAttributesClassArrayOutput {
	return o
}

func (o VolumeAttributesClassArrayOutput) Index(i pulumi.IntInput) VolumeAttributesClassOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VolumeAttributesClass {
		return vs[0].([]*VolumeAttributesClass)[vs[1].(int)]
	}).(VolumeAttributesClassOutput)
}

type VolumeAttributesClassMapOutput struct{ *pulumi.OutputState }

func (VolumeAttributesClassMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VolumeAttributesClass)(nil)).Elem()
}

func (o VolumeAttributesClassMapOutput) ToVolumeAttributesClassMapOutput() VolumeAttributesClassMapOutput {
	return o
}

func (o VolumeAttributesClassMapOutput) ToVolumeAttributesClassMapOutputWithContext(ctx context.Context) VolumeAttributesClassMapOutput {
	return o
}

func (o VolumeAttributesClassMapOutput) MapIndex(k pulumi.StringInput) VolumeAttributesClassOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VolumeAttributesClass {
		return vs[0].(map[string]*VolumeAttributesClass)[vs[1].(string)]
	}).(VolumeAttributesClassOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeAttributesClassInput)(nil)).Elem(), &VolumeAttributesClass{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeAttributesClassArrayInput)(nil)).Elem(), VolumeAttributesClassArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeAttributesClassMapInput)(nil)).Elem(), VolumeAttributesClassMap{})
	pulumi.RegisterOutputType(VolumeAttributesClassOutput{})
	pulumi.RegisterOutputType(VolumeAttributesClassArrayOutput{})
	pulumi.RegisterOutputType(VolumeAttributesClassMapOutput{})
}
