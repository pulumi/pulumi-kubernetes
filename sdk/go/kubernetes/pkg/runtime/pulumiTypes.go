// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package runtime

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// RawExtension is used to hold extensions in external versions.
//
// To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.
//
// // Internal package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.Object `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // External package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.RawExtension `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // On the wire, the JSON will look something like this:
//
//	{
//	    "kind":"MyAPIObject",
//	    "apiVersion":"v1",
//	    "myPlugin": {
//	        "kind":"PluginA",
//	        "aOption":"foo",
//	    },
//	}
//
// So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)
type RawExtension struct {
}

// RawExtensionInput is an input type that accepts RawExtensionArgs and RawExtensionOutput values.
// You can construct a concrete instance of `RawExtensionInput` via:
//
//	RawExtensionArgs{...}
type RawExtensionInput interface {
	pulumi.Input

	ToRawExtensionOutput() RawExtensionOutput
	ToRawExtensionOutputWithContext(context.Context) RawExtensionOutput
}

// RawExtension is used to hold extensions in external versions.
//
// To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.
//
// // Internal package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.Object `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // External package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.RawExtension `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // On the wire, the JSON will look something like this:
//
//	{
//	    "kind":"MyAPIObject",
//	    "apiVersion":"v1",
//	    "myPlugin": {
//	        "kind":"PluginA",
//	        "aOption":"foo",
//	    },
//	}
//
// So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)
type RawExtensionArgs struct {
}

func (RawExtensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RawExtension)(nil)).Elem()
}

func (i RawExtensionArgs) ToRawExtensionOutput() RawExtensionOutput {
	return i.ToRawExtensionOutputWithContext(context.Background())
}

func (i RawExtensionArgs) ToRawExtensionOutputWithContext(ctx context.Context) RawExtensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RawExtensionOutput)
}

// RawExtension is used to hold extensions in external versions.
//
// To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.
//
// // Internal package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.Object `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // External package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.RawExtension `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // On the wire, the JSON will look something like this:
//
//	{
//	    "kind":"MyAPIObject",
//	    "apiVersion":"v1",
//	    "myPlugin": {
//	        "kind":"PluginA",
//	        "aOption":"foo",
//	    },
//	}
//
// So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)
type RawExtensionOutput struct{ *pulumi.OutputState }

func (RawExtensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RawExtension)(nil)).Elem()
}

func (o RawExtensionOutput) ToRawExtensionOutput() RawExtensionOutput {
	return o
}

func (o RawExtensionOutput) ToRawExtensionOutputWithContext(ctx context.Context) RawExtensionOutput {
	return o
}

// RawExtension is used to hold extensions in external versions.
//
// To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.
//
// // Internal package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.Object `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // External package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.RawExtension `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // On the wire, the JSON will look something like this:
//
//	{
//	    "kind":"MyAPIObject",
//	    "apiVersion":"v1",
//	    "myPlugin": {
//	        "kind":"PluginA",
//	        "aOption":"foo",
//	    },
//	}
//
// So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)
type RawExtensionPatch struct {
}

// RawExtensionPatchInput is an input type that accepts RawExtensionPatchArgs and RawExtensionPatchOutput values.
// You can construct a concrete instance of `RawExtensionPatchInput` via:
//
//	RawExtensionPatchArgs{...}
type RawExtensionPatchInput interface {
	pulumi.Input

	ToRawExtensionPatchOutput() RawExtensionPatchOutput
	ToRawExtensionPatchOutputWithContext(context.Context) RawExtensionPatchOutput
}

// RawExtension is used to hold extensions in external versions.
//
// To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.
//
// // Internal package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.Object `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // External package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.RawExtension `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // On the wire, the JSON will look something like this:
//
//	{
//	    "kind":"MyAPIObject",
//	    "apiVersion":"v1",
//	    "myPlugin": {
//	        "kind":"PluginA",
//	        "aOption":"foo",
//	    },
//	}
//
// So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)
type RawExtensionPatchArgs struct {
}

func (RawExtensionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RawExtensionPatch)(nil)).Elem()
}

func (i RawExtensionPatchArgs) ToRawExtensionPatchOutput() RawExtensionPatchOutput {
	return i.ToRawExtensionPatchOutputWithContext(context.Background())
}

func (i RawExtensionPatchArgs) ToRawExtensionPatchOutputWithContext(ctx context.Context) RawExtensionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RawExtensionPatchOutput)
}

// RawExtension is used to hold extensions in external versions.
//
// To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.
//
// // Internal package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.Object `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // External package:
//
//	type MyAPIObject struct {
//	    runtime.TypeMeta `json:",inline"`
//	    MyPlugin runtime.RawExtension `json:"myPlugin"`
//	}
//
//	type PluginA struct {
//	    AOption string `json:"aOption"`
//	}
//
// // On the wire, the JSON will look something like this:
//
//	{
//	    "kind":"MyAPIObject",
//	    "apiVersion":"v1",
//	    "myPlugin": {
//	        "kind":"PluginA",
//	        "aOption":"foo",
//	    },
//	}
//
// So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)
type RawExtensionPatchOutput struct{ *pulumi.OutputState }

func (RawExtensionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RawExtensionPatch)(nil)).Elem()
}

func (o RawExtensionPatchOutput) ToRawExtensionPatchOutput() RawExtensionPatchOutput {
	return o
}

func (o RawExtensionPatchOutput) ToRawExtensionPatchOutputWithContext(ctx context.Context) RawExtensionPatchOutput {
	return o
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RawExtensionInput)(nil)).Elem(), RawExtensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RawExtensionPatchInput)(nil)).Elem(), RawExtensionPatchArgs{})
	pulumi.RegisterOutputType(RawExtensionOutput{})
	pulumi.RegisterOutputType(RawExtensionPatchOutput{})
}
