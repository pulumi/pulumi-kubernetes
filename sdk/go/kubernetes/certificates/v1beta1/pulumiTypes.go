// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Describes a certificate signing request
type CertificateSigningRequestType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string            `pulumi:"kind"`
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// The certificate request itself and any additional information.
	Spec *CertificateSigningRequestSpec `pulumi:"spec"`
	// Derived information about the request.
	Status *CertificateSigningRequestStatus `pulumi:"status"`
}

// CertificateSigningRequestTypeInput is an input type that accepts CertificateSigningRequestTypeArgs and CertificateSigningRequestTypeOutput values.
// You can construct a concrete instance of `CertificateSigningRequestTypeInput` via:
//
//	CertificateSigningRequestTypeArgs{...}
type CertificateSigningRequestTypeInput interface {
	pulumi.Input

	ToCertificateSigningRequestTypeOutput() CertificateSigningRequestTypeOutput
	ToCertificateSigningRequestTypeOutputWithContext(context.Context) CertificateSigningRequestTypeOutput
}

// Describes a certificate signing request
type CertificateSigningRequestTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// The certificate request itself and any additional information.
	Spec CertificateSigningRequestSpecPtrInput `pulumi:"spec"`
	// Derived information about the request.
	Status CertificateSigningRequestStatusPtrInput `pulumi:"status"`
}

func (CertificateSigningRequestTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestType)(nil)).Elem()
}

func (i CertificateSigningRequestTypeArgs) ToCertificateSigningRequestTypeOutput() CertificateSigningRequestTypeOutput {
	return i.ToCertificateSigningRequestTypeOutputWithContext(context.Background())
}

func (i CertificateSigningRequestTypeArgs) ToCertificateSigningRequestTypeOutputWithContext(ctx context.Context) CertificateSigningRequestTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestTypeOutput)
}

// CertificateSigningRequestTypeArrayInput is an input type that accepts CertificateSigningRequestTypeArray and CertificateSigningRequestTypeArrayOutput values.
// You can construct a concrete instance of `CertificateSigningRequestTypeArrayInput` via:
//
//	CertificateSigningRequestTypeArray{ CertificateSigningRequestTypeArgs{...} }
type CertificateSigningRequestTypeArrayInput interface {
	pulumi.Input

	ToCertificateSigningRequestTypeArrayOutput() CertificateSigningRequestTypeArrayOutput
	ToCertificateSigningRequestTypeArrayOutputWithContext(context.Context) CertificateSigningRequestTypeArrayOutput
}

type CertificateSigningRequestTypeArray []CertificateSigningRequestTypeInput

func (CertificateSigningRequestTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestType)(nil)).Elem()
}

func (i CertificateSigningRequestTypeArray) ToCertificateSigningRequestTypeArrayOutput() CertificateSigningRequestTypeArrayOutput {
	return i.ToCertificateSigningRequestTypeArrayOutputWithContext(context.Background())
}

func (i CertificateSigningRequestTypeArray) ToCertificateSigningRequestTypeArrayOutputWithContext(ctx context.Context) CertificateSigningRequestTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestTypeArrayOutput)
}

// Describes a certificate signing request
type CertificateSigningRequestTypeOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestType)(nil)).Elem()
}

func (o CertificateSigningRequestTypeOutput) ToCertificateSigningRequestTypeOutput() CertificateSigningRequestTypeOutput {
	return o
}

func (o CertificateSigningRequestTypeOutput) ToCertificateSigningRequestTypeOutputWithContext(ctx context.Context) CertificateSigningRequestTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o CertificateSigningRequestTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o CertificateSigningRequestTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o CertificateSigningRequestTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// The certificate request itself and any additional information.
func (o CertificateSigningRequestTypeOutput) Spec() CertificateSigningRequestSpecPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) *CertificateSigningRequestSpec { return v.Spec }).(CertificateSigningRequestSpecPtrOutput)
}

// Derived information about the request.
func (o CertificateSigningRequestTypeOutput) Status() CertificateSigningRequestStatusPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) *CertificateSigningRequestStatus { return v.Status }).(CertificateSigningRequestStatusPtrOutput)
}

type CertificateSigningRequestTypeArrayOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestType)(nil)).Elem()
}

func (o CertificateSigningRequestTypeArrayOutput) ToCertificateSigningRequestTypeArrayOutput() CertificateSigningRequestTypeArrayOutput {
	return o
}

func (o CertificateSigningRequestTypeArrayOutput) ToCertificateSigningRequestTypeArrayOutputWithContext(ctx context.Context) CertificateSigningRequestTypeArrayOutput {
	return o
}

func (o CertificateSigningRequestTypeArrayOutput) Index(i pulumi.IntInput) CertificateSigningRequestTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CertificateSigningRequestType {
		return vs[0].([]CertificateSigningRequestType)[vs[1].(int)]
	}).(CertificateSigningRequestTypeOutput)
}

type CertificateSigningRequestCondition struct {
	// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// timestamp for the last update to this condition
	LastUpdateTime *string `pulumi:"lastUpdateTime"`
	// human readable message with details about the request state
	Message *string `pulumi:"message"`
	// brief reason for the request state
	Reason *string `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown". Defaults to "True". If unset, should be treated as "True".
	Status *string `pulumi:"status"`
	// request approval state, currently Approved or Denied.
	Type string `pulumi:"type"`
}

// CertificateSigningRequestConditionInput is an input type that accepts CertificateSigningRequestConditionArgs and CertificateSigningRequestConditionOutput values.
// You can construct a concrete instance of `CertificateSigningRequestConditionInput` via:
//
//	CertificateSigningRequestConditionArgs{...}
type CertificateSigningRequestConditionInput interface {
	pulumi.Input

	ToCertificateSigningRequestConditionOutput() CertificateSigningRequestConditionOutput
	ToCertificateSigningRequestConditionOutputWithContext(context.Context) CertificateSigningRequestConditionOutput
}

type CertificateSigningRequestConditionArgs struct {
	// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// timestamp for the last update to this condition
	LastUpdateTime pulumi.StringPtrInput `pulumi:"lastUpdateTime"`
	// human readable message with details about the request state
	Message pulumi.StringPtrInput `pulumi:"message"`
	// brief reason for the request state
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown". Defaults to "True". If unset, should be treated as "True".
	Status pulumi.StringPtrInput `pulumi:"status"`
	// request approval state, currently Approved or Denied.
	Type pulumi.StringInput `pulumi:"type"`
}

func (CertificateSigningRequestConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestCondition)(nil)).Elem()
}

func (i CertificateSigningRequestConditionArgs) ToCertificateSigningRequestConditionOutput() CertificateSigningRequestConditionOutput {
	return i.ToCertificateSigningRequestConditionOutputWithContext(context.Background())
}

func (i CertificateSigningRequestConditionArgs) ToCertificateSigningRequestConditionOutputWithContext(ctx context.Context) CertificateSigningRequestConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestConditionOutput)
}

// CertificateSigningRequestConditionArrayInput is an input type that accepts CertificateSigningRequestConditionArray and CertificateSigningRequestConditionArrayOutput values.
// You can construct a concrete instance of `CertificateSigningRequestConditionArrayInput` via:
//
//	CertificateSigningRequestConditionArray{ CertificateSigningRequestConditionArgs{...} }
type CertificateSigningRequestConditionArrayInput interface {
	pulumi.Input

	ToCertificateSigningRequestConditionArrayOutput() CertificateSigningRequestConditionArrayOutput
	ToCertificateSigningRequestConditionArrayOutputWithContext(context.Context) CertificateSigningRequestConditionArrayOutput
}

type CertificateSigningRequestConditionArray []CertificateSigningRequestConditionInput

func (CertificateSigningRequestConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestCondition)(nil)).Elem()
}

func (i CertificateSigningRequestConditionArray) ToCertificateSigningRequestConditionArrayOutput() CertificateSigningRequestConditionArrayOutput {
	return i.ToCertificateSigningRequestConditionArrayOutputWithContext(context.Background())
}

func (i CertificateSigningRequestConditionArray) ToCertificateSigningRequestConditionArrayOutputWithContext(ctx context.Context) CertificateSigningRequestConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestConditionArrayOutput)
}

type CertificateSigningRequestConditionOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestCondition)(nil)).Elem()
}

func (o CertificateSigningRequestConditionOutput) ToCertificateSigningRequestConditionOutput() CertificateSigningRequestConditionOutput {
	return o
}

func (o CertificateSigningRequestConditionOutput) ToCertificateSigningRequestConditionOutputWithContext(ctx context.Context) CertificateSigningRequestConditionOutput {
	return o
}

// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
func (o CertificateSigningRequestConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// timestamp for the last update to this condition
func (o CertificateSigningRequestConditionOutput) LastUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) *string { return v.LastUpdateTime }).(pulumi.StringPtrOutput)
}

// human readable message with details about the request state
func (o CertificateSigningRequestConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// brief reason for the request state
func (o CertificateSigningRequestConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown". Defaults to "True". If unset, should be treated as "True".
func (o CertificateSigningRequestConditionOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// request approval state, currently Approved or Denied.
func (o CertificateSigningRequestConditionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) string { return v.Type }).(pulumi.StringOutput)
}

type CertificateSigningRequestConditionArrayOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestCondition)(nil)).Elem()
}

func (o CertificateSigningRequestConditionArrayOutput) ToCertificateSigningRequestConditionArrayOutput() CertificateSigningRequestConditionArrayOutput {
	return o
}

func (o CertificateSigningRequestConditionArrayOutput) ToCertificateSigningRequestConditionArrayOutputWithContext(ctx context.Context) CertificateSigningRequestConditionArrayOutput {
	return o
}

func (o CertificateSigningRequestConditionArrayOutput) Index(i pulumi.IntInput) CertificateSigningRequestConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CertificateSigningRequestCondition {
		return vs[0].([]CertificateSigningRequestCondition)[vs[1].(int)]
	}).(CertificateSigningRequestConditionOutput)
}

type CertificateSigningRequestConditionPatch struct {
	// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// timestamp for the last update to this condition
	LastUpdateTime *string `pulumi:"lastUpdateTime"`
	// human readable message with details about the request state
	Message *string `pulumi:"message"`
	// brief reason for the request state
	Reason *string `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown". Defaults to "True". If unset, should be treated as "True".
	Status *string `pulumi:"status"`
	// request approval state, currently Approved or Denied.
	Type *string `pulumi:"type"`
}

// CertificateSigningRequestConditionPatchInput is an input type that accepts CertificateSigningRequestConditionPatchArgs and CertificateSigningRequestConditionPatchOutput values.
// You can construct a concrete instance of `CertificateSigningRequestConditionPatchInput` via:
//
//	CertificateSigningRequestConditionPatchArgs{...}
type CertificateSigningRequestConditionPatchInput interface {
	pulumi.Input

	ToCertificateSigningRequestConditionPatchOutput() CertificateSigningRequestConditionPatchOutput
	ToCertificateSigningRequestConditionPatchOutputWithContext(context.Context) CertificateSigningRequestConditionPatchOutput
}

type CertificateSigningRequestConditionPatchArgs struct {
	// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// timestamp for the last update to this condition
	LastUpdateTime pulumi.StringPtrInput `pulumi:"lastUpdateTime"`
	// human readable message with details about the request state
	Message pulumi.StringPtrInput `pulumi:"message"`
	// brief reason for the request state
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown". Defaults to "True". If unset, should be treated as "True".
	Status pulumi.StringPtrInput `pulumi:"status"`
	// request approval state, currently Approved or Denied.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (CertificateSigningRequestConditionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestConditionPatch)(nil)).Elem()
}

func (i CertificateSigningRequestConditionPatchArgs) ToCertificateSigningRequestConditionPatchOutput() CertificateSigningRequestConditionPatchOutput {
	return i.ToCertificateSigningRequestConditionPatchOutputWithContext(context.Background())
}

func (i CertificateSigningRequestConditionPatchArgs) ToCertificateSigningRequestConditionPatchOutputWithContext(ctx context.Context) CertificateSigningRequestConditionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestConditionPatchOutput)
}

// CertificateSigningRequestConditionPatchArrayInput is an input type that accepts CertificateSigningRequestConditionPatchArray and CertificateSigningRequestConditionPatchArrayOutput values.
// You can construct a concrete instance of `CertificateSigningRequestConditionPatchArrayInput` via:
//
//	CertificateSigningRequestConditionPatchArray{ CertificateSigningRequestConditionPatchArgs{...} }
type CertificateSigningRequestConditionPatchArrayInput interface {
	pulumi.Input

	ToCertificateSigningRequestConditionPatchArrayOutput() CertificateSigningRequestConditionPatchArrayOutput
	ToCertificateSigningRequestConditionPatchArrayOutputWithContext(context.Context) CertificateSigningRequestConditionPatchArrayOutput
}

type CertificateSigningRequestConditionPatchArray []CertificateSigningRequestConditionPatchInput

func (CertificateSigningRequestConditionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestConditionPatch)(nil)).Elem()
}

func (i CertificateSigningRequestConditionPatchArray) ToCertificateSigningRequestConditionPatchArrayOutput() CertificateSigningRequestConditionPatchArrayOutput {
	return i.ToCertificateSigningRequestConditionPatchArrayOutputWithContext(context.Background())
}

func (i CertificateSigningRequestConditionPatchArray) ToCertificateSigningRequestConditionPatchArrayOutputWithContext(ctx context.Context) CertificateSigningRequestConditionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestConditionPatchArrayOutput)
}

type CertificateSigningRequestConditionPatchOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestConditionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestConditionPatch)(nil)).Elem()
}

func (o CertificateSigningRequestConditionPatchOutput) ToCertificateSigningRequestConditionPatchOutput() CertificateSigningRequestConditionPatchOutput {
	return o
}

func (o CertificateSigningRequestConditionPatchOutput) ToCertificateSigningRequestConditionPatchOutputWithContext(ctx context.Context) CertificateSigningRequestConditionPatchOutput {
	return o
}

// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
func (o CertificateSigningRequestConditionPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// timestamp for the last update to this condition
func (o CertificateSigningRequestConditionPatchOutput) LastUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.LastUpdateTime }).(pulumi.StringPtrOutput)
}

// human readable message with details about the request state
func (o CertificateSigningRequestConditionPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// brief reason for the request state
func (o CertificateSigningRequestConditionPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown". Defaults to "True". If unset, should be treated as "True".
func (o CertificateSigningRequestConditionPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// request approval state, currently Approved or Denied.
func (o CertificateSigningRequestConditionPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type CertificateSigningRequestConditionPatchArrayOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestConditionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestConditionPatch)(nil)).Elem()
}

func (o CertificateSigningRequestConditionPatchArrayOutput) ToCertificateSigningRequestConditionPatchArrayOutput() CertificateSigningRequestConditionPatchArrayOutput {
	return o
}

func (o CertificateSigningRequestConditionPatchArrayOutput) ToCertificateSigningRequestConditionPatchArrayOutputWithContext(ctx context.Context) CertificateSigningRequestConditionPatchArrayOutput {
	return o
}

func (o CertificateSigningRequestConditionPatchArrayOutput) Index(i pulumi.IntInput) CertificateSigningRequestConditionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CertificateSigningRequestConditionPatch {
		return vs[0].([]CertificateSigningRequestConditionPatch)[vs[1].(int)]
	}).(CertificateSigningRequestConditionPatchOutput)
}

type CertificateSigningRequestListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string                         `pulumi:"apiVersion"`
	Items      []CertificateSigningRequestType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string          `pulumi:"kind"`
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// CertificateSigningRequestListTypeInput is an input type that accepts CertificateSigningRequestListTypeArgs and CertificateSigningRequestListTypeOutput values.
// You can construct a concrete instance of `CertificateSigningRequestListTypeInput` via:
//
//	CertificateSigningRequestListTypeArgs{...}
type CertificateSigningRequestListTypeInput interface {
	pulumi.Input

	ToCertificateSigningRequestListTypeOutput() CertificateSigningRequestListTypeOutput
	ToCertificateSigningRequestListTypeOutputWithContext(context.Context) CertificateSigningRequestListTypeOutput
}

type CertificateSigningRequestListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput                   `pulumi:"apiVersion"`
	Items      CertificateSigningRequestTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput   `pulumi:"kind"`
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (CertificateSigningRequestListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestListType)(nil)).Elem()
}

func (i CertificateSigningRequestListTypeArgs) ToCertificateSigningRequestListTypeOutput() CertificateSigningRequestListTypeOutput {
	return i.ToCertificateSigningRequestListTypeOutputWithContext(context.Background())
}

func (i CertificateSigningRequestListTypeArgs) ToCertificateSigningRequestListTypeOutputWithContext(ctx context.Context) CertificateSigningRequestListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestListTypeOutput)
}

type CertificateSigningRequestListTypeOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestListType)(nil)).Elem()
}

func (o CertificateSigningRequestListTypeOutput) ToCertificateSigningRequestListTypeOutput() CertificateSigningRequestListTypeOutput {
	return o
}

func (o CertificateSigningRequestListTypeOutput) ToCertificateSigningRequestListTypeOutputWithContext(ctx context.Context) CertificateSigningRequestListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o CertificateSigningRequestListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o CertificateSigningRequestListTypeOutput) Items() CertificateSigningRequestTypeArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestListType) []CertificateSigningRequestType { return v.Items }).(CertificateSigningRequestTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o CertificateSigningRequestListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o CertificateSigningRequestListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// Describes a certificate signing request
type CertificateSigningRequestPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string                 `pulumi:"kind"`
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// The certificate request itself and any additional information.
	Spec *CertificateSigningRequestSpecPatch `pulumi:"spec"`
	// Derived information about the request.
	Status *CertificateSigningRequestStatusPatch `pulumi:"status"`
}

// CertificateSigningRequestPatchTypeInput is an input type that accepts CertificateSigningRequestPatchTypeArgs and CertificateSigningRequestPatchTypeOutput values.
// You can construct a concrete instance of `CertificateSigningRequestPatchTypeInput` via:
//
//	CertificateSigningRequestPatchTypeArgs{...}
type CertificateSigningRequestPatchTypeInput interface {
	pulumi.Input

	ToCertificateSigningRequestPatchTypeOutput() CertificateSigningRequestPatchTypeOutput
	ToCertificateSigningRequestPatchTypeOutputWithContext(context.Context) CertificateSigningRequestPatchTypeOutput
}

// Describes a certificate signing request
type CertificateSigningRequestPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput          `pulumi:"kind"`
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// The certificate request itself and any additional information.
	Spec CertificateSigningRequestSpecPatchPtrInput `pulumi:"spec"`
	// Derived information about the request.
	Status CertificateSigningRequestStatusPatchPtrInput `pulumi:"status"`
}

func (CertificateSigningRequestPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestPatchType)(nil)).Elem()
}

func (i CertificateSigningRequestPatchTypeArgs) ToCertificateSigningRequestPatchTypeOutput() CertificateSigningRequestPatchTypeOutput {
	return i.ToCertificateSigningRequestPatchTypeOutputWithContext(context.Background())
}

func (i CertificateSigningRequestPatchTypeArgs) ToCertificateSigningRequestPatchTypeOutputWithContext(ctx context.Context) CertificateSigningRequestPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestPatchTypeOutput)
}

// Describes a certificate signing request
type CertificateSigningRequestPatchTypeOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestPatchType)(nil)).Elem()
}

func (o CertificateSigningRequestPatchTypeOutput) ToCertificateSigningRequestPatchTypeOutput() CertificateSigningRequestPatchTypeOutput {
	return o
}

func (o CertificateSigningRequestPatchTypeOutput) ToCertificateSigningRequestPatchTypeOutputWithContext(ctx context.Context) CertificateSigningRequestPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o CertificateSigningRequestPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o CertificateSigningRequestPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o CertificateSigningRequestPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// The certificate request itself and any additional information.
func (o CertificateSigningRequestPatchTypeOutput) Spec() CertificateSigningRequestSpecPatchPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *CertificateSigningRequestSpecPatch { return v.Spec }).(CertificateSigningRequestSpecPatchPtrOutput)
}

// Derived information about the request.
func (o CertificateSigningRequestPatchTypeOutput) Status() CertificateSigningRequestStatusPatchPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *CertificateSigningRequestStatusPatch { return v.Status }).(CertificateSigningRequestStatusPatchPtrOutput)
}

// This information is immutable after the request is created. Only the Request and Usages fields can be set on creation, other fields are derived by Kubernetes and cannot be modified by users.
type CertificateSigningRequestSpec struct {
	// Extra information about the requesting user. See user.Info interface for details.
	Extra map[string][]string `pulumi:"extra"`
	// Group information about the requesting user. See user.Info interface for details.
	Groups []string `pulumi:"groups"`
	// Base64-encoded PKCS#10 CSR data
	Request string `pulumi:"request"`
	// Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:
	//  1. If it's a kubelet client certificate, it is assigned
	//     "kubernetes.io/kube-apiserver-client-kubelet".
	//  2. If it's a kubelet serving certificate, it is assigned
	//     "kubernetes.io/kubelet-serving".
	//  3. Otherwise, it is assigned "kubernetes.io/legacy-unknown".
	//     Distribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.
	SignerName *string `pulumi:"signerName"`
	// UID information about the requesting user. See user.Info interface for details.
	Uid *string `pulumi:"uid"`
	// allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
	//      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
	Usages []string `pulumi:"usages"`
	// Information about the requesting user. See user.Info interface for details.
	Username *string `pulumi:"username"`
}

// CertificateSigningRequestSpecInput is an input type that accepts CertificateSigningRequestSpecArgs and CertificateSigningRequestSpecOutput values.
// You can construct a concrete instance of `CertificateSigningRequestSpecInput` via:
//
//	CertificateSigningRequestSpecArgs{...}
type CertificateSigningRequestSpecInput interface {
	pulumi.Input

	ToCertificateSigningRequestSpecOutput() CertificateSigningRequestSpecOutput
	ToCertificateSigningRequestSpecOutputWithContext(context.Context) CertificateSigningRequestSpecOutput
}

// This information is immutable after the request is created. Only the Request and Usages fields can be set on creation, other fields are derived by Kubernetes and cannot be modified by users.
type CertificateSigningRequestSpecArgs struct {
	// Extra information about the requesting user. See user.Info interface for details.
	Extra pulumi.StringArrayMapInput `pulumi:"extra"`
	// Group information about the requesting user. See user.Info interface for details.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// Base64-encoded PKCS#10 CSR data
	Request pulumi.StringInput `pulumi:"request"`
	// Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:
	//  1. If it's a kubelet client certificate, it is assigned
	//     "kubernetes.io/kube-apiserver-client-kubelet".
	//  2. If it's a kubelet serving certificate, it is assigned
	//     "kubernetes.io/kubelet-serving".
	//  3. Otherwise, it is assigned "kubernetes.io/legacy-unknown".
	//     Distribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.
	SignerName pulumi.StringPtrInput `pulumi:"signerName"`
	// UID information about the requesting user. See user.Info interface for details.
	Uid pulumi.StringPtrInput `pulumi:"uid"`
	// allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
	//      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
	Usages pulumi.StringArrayInput `pulumi:"usages"`
	// Information about the requesting user. See user.Info interface for details.
	Username pulumi.StringPtrInput `pulumi:"username"`
}

func (CertificateSigningRequestSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestSpec)(nil)).Elem()
}

func (i CertificateSigningRequestSpecArgs) ToCertificateSigningRequestSpecOutput() CertificateSigningRequestSpecOutput {
	return i.ToCertificateSigningRequestSpecOutputWithContext(context.Background())
}

func (i CertificateSigningRequestSpecArgs) ToCertificateSigningRequestSpecOutputWithContext(ctx context.Context) CertificateSigningRequestSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecOutput)
}

func (i CertificateSigningRequestSpecArgs) ToCertificateSigningRequestSpecPtrOutput() CertificateSigningRequestSpecPtrOutput {
	return i.ToCertificateSigningRequestSpecPtrOutputWithContext(context.Background())
}

func (i CertificateSigningRequestSpecArgs) ToCertificateSigningRequestSpecPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecOutput).ToCertificateSigningRequestSpecPtrOutputWithContext(ctx)
}

// CertificateSigningRequestSpecPtrInput is an input type that accepts CertificateSigningRequestSpecArgs, CertificateSigningRequestSpecPtr and CertificateSigningRequestSpecPtrOutput values.
// You can construct a concrete instance of `CertificateSigningRequestSpecPtrInput` via:
//
//	        CertificateSigningRequestSpecArgs{...}
//
//	or:
//
//	        nil
type CertificateSigningRequestSpecPtrInput interface {
	pulumi.Input

	ToCertificateSigningRequestSpecPtrOutput() CertificateSigningRequestSpecPtrOutput
	ToCertificateSigningRequestSpecPtrOutputWithContext(context.Context) CertificateSigningRequestSpecPtrOutput
}

type certificateSigningRequestSpecPtrType CertificateSigningRequestSpecArgs

func CertificateSigningRequestSpecPtr(v *CertificateSigningRequestSpecArgs) CertificateSigningRequestSpecPtrInput {
	return (*certificateSigningRequestSpecPtrType)(v)
}

func (*certificateSigningRequestSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestSpec)(nil)).Elem()
}

func (i *certificateSigningRequestSpecPtrType) ToCertificateSigningRequestSpecPtrOutput() CertificateSigningRequestSpecPtrOutput {
	return i.ToCertificateSigningRequestSpecPtrOutputWithContext(context.Background())
}

func (i *certificateSigningRequestSpecPtrType) ToCertificateSigningRequestSpecPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecPtrOutput)
}

// This information is immutable after the request is created. Only the Request and Usages fields can be set on creation, other fields are derived by Kubernetes and cannot be modified by users.
type CertificateSigningRequestSpecOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestSpec)(nil)).Elem()
}

func (o CertificateSigningRequestSpecOutput) ToCertificateSigningRequestSpecOutput() CertificateSigningRequestSpecOutput {
	return o
}

func (o CertificateSigningRequestSpecOutput) ToCertificateSigningRequestSpecOutputWithContext(ctx context.Context) CertificateSigningRequestSpecOutput {
	return o
}

func (o CertificateSigningRequestSpecOutput) ToCertificateSigningRequestSpecPtrOutput() CertificateSigningRequestSpecPtrOutput {
	return o.ToCertificateSigningRequestSpecPtrOutputWithContext(context.Background())
}

func (o CertificateSigningRequestSpecOutput) ToCertificateSigningRequestSpecPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CertificateSigningRequestSpec) *CertificateSigningRequestSpec {
		return &v
	}).(CertificateSigningRequestSpecPtrOutput)
}

// Extra information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecOutput) Extra() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) map[string][]string { return v.Extra }).(pulumi.StringArrayMapOutput)
}

// Group information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// Base64-encoded PKCS#10 CSR data
func (o CertificateSigningRequestSpecOutput) Request() pulumi.StringOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) string { return v.Request }).(pulumi.StringOutput)
}

// Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:
//  1. If it's a kubelet client certificate, it is assigned
//     "kubernetes.io/kube-apiserver-client-kubelet".
//  2. If it's a kubelet serving certificate, it is assigned
//     "kubernetes.io/kubelet-serving".
//  3. Otherwise, it is assigned "kubernetes.io/legacy-unknown".
//     Distribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.
func (o CertificateSigningRequestSpecOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) *string { return v.SignerName }).(pulumi.StringPtrOutput)
}

// UID information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

// allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
//
//	https://tools.ietf.org/html/rfc5280#section-4.2.1.12
func (o CertificateSigningRequestSpecOutput) Usages() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) []string { return v.Usages }).(pulumi.StringArrayOutput)
}

// Information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) *string { return v.Username }).(pulumi.StringPtrOutput)
}

type CertificateSigningRequestSpecPtrOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestSpec)(nil)).Elem()
}

func (o CertificateSigningRequestSpecPtrOutput) ToCertificateSigningRequestSpecPtrOutput() CertificateSigningRequestSpecPtrOutput {
	return o
}

func (o CertificateSigningRequestSpecPtrOutput) ToCertificateSigningRequestSpecPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPtrOutput {
	return o
}

func (o CertificateSigningRequestSpecPtrOutput) Elem() CertificateSigningRequestSpecOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpec) CertificateSigningRequestSpec {
		if v != nil {
			return *v
		}
		var ret CertificateSigningRequestSpec
		return ret
	}).(CertificateSigningRequestSpecOutput)
}

// Extra information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPtrOutput) Extra() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpec) map[string][]string {
		if v == nil {
			return nil
		}
		return v.Extra
	}).(pulumi.StringArrayMapOutput)
}

// Group information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPtrOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpec) []string {
		if v == nil {
			return nil
		}
		return v.Groups
	}).(pulumi.StringArrayOutput)
}

// Base64-encoded PKCS#10 CSR data
func (o CertificateSigningRequestSpecPtrOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Request
	}).(pulumi.StringPtrOutput)
}

// Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:
//  1. If it's a kubelet client certificate, it is assigned
//     "kubernetes.io/kube-apiserver-client-kubelet".
//  2. If it's a kubelet serving certificate, it is assigned
//     "kubernetes.io/kubelet-serving".
//  3. Otherwise, it is assigned "kubernetes.io/legacy-unknown".
//     Distribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.
func (o CertificateSigningRequestSpecPtrOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpec) *string {
		if v == nil {
			return nil
		}
		return v.SignerName
	}).(pulumi.StringPtrOutput)
}

// UID information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpec) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
//
//	https://tools.ietf.org/html/rfc5280#section-4.2.1.12
func (o CertificateSigningRequestSpecPtrOutput) Usages() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpec) []string {
		if v == nil {
			return nil
		}
		return v.Usages
	}).(pulumi.StringArrayOutput)
}

// Information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpec) *string {
		if v == nil {
			return nil
		}
		return v.Username
	}).(pulumi.StringPtrOutput)
}

// This information is immutable after the request is created. Only the Request and Usages fields can be set on creation, other fields are derived by Kubernetes and cannot be modified by users.
type CertificateSigningRequestSpecPatch struct {
	// Extra information about the requesting user. See user.Info interface for details.
	Extra map[string][]string `pulumi:"extra"`
	// Group information about the requesting user. See user.Info interface for details.
	Groups []string `pulumi:"groups"`
	// Base64-encoded PKCS#10 CSR data
	Request *string `pulumi:"request"`
	// Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:
	//  1. If it's a kubelet client certificate, it is assigned
	//     "kubernetes.io/kube-apiserver-client-kubelet".
	//  2. If it's a kubelet serving certificate, it is assigned
	//     "kubernetes.io/kubelet-serving".
	//  3. Otherwise, it is assigned "kubernetes.io/legacy-unknown".
	//     Distribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.
	SignerName *string `pulumi:"signerName"`
	// UID information about the requesting user. See user.Info interface for details.
	Uid *string `pulumi:"uid"`
	// allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
	//      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
	Usages []string `pulumi:"usages"`
	// Information about the requesting user. See user.Info interface for details.
	Username *string `pulumi:"username"`
}

// CertificateSigningRequestSpecPatchInput is an input type that accepts CertificateSigningRequestSpecPatchArgs and CertificateSigningRequestSpecPatchOutput values.
// You can construct a concrete instance of `CertificateSigningRequestSpecPatchInput` via:
//
//	CertificateSigningRequestSpecPatchArgs{...}
type CertificateSigningRequestSpecPatchInput interface {
	pulumi.Input

	ToCertificateSigningRequestSpecPatchOutput() CertificateSigningRequestSpecPatchOutput
	ToCertificateSigningRequestSpecPatchOutputWithContext(context.Context) CertificateSigningRequestSpecPatchOutput
}

// This information is immutable after the request is created. Only the Request and Usages fields can be set on creation, other fields are derived by Kubernetes and cannot be modified by users.
type CertificateSigningRequestSpecPatchArgs struct {
	// Extra information about the requesting user. See user.Info interface for details.
	Extra pulumi.StringArrayMapInput `pulumi:"extra"`
	// Group information about the requesting user. See user.Info interface for details.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// Base64-encoded PKCS#10 CSR data
	Request pulumi.StringPtrInput `pulumi:"request"`
	// Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:
	//  1. If it's a kubelet client certificate, it is assigned
	//     "kubernetes.io/kube-apiserver-client-kubelet".
	//  2. If it's a kubelet serving certificate, it is assigned
	//     "kubernetes.io/kubelet-serving".
	//  3. Otherwise, it is assigned "kubernetes.io/legacy-unknown".
	//     Distribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.
	SignerName pulumi.StringPtrInput `pulumi:"signerName"`
	// UID information about the requesting user. See user.Info interface for details.
	Uid pulumi.StringPtrInput `pulumi:"uid"`
	// allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
	//      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
	Usages pulumi.StringArrayInput `pulumi:"usages"`
	// Information about the requesting user. See user.Info interface for details.
	Username pulumi.StringPtrInput `pulumi:"username"`
}

func (CertificateSigningRequestSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestSpecPatch)(nil)).Elem()
}

func (i CertificateSigningRequestSpecPatchArgs) ToCertificateSigningRequestSpecPatchOutput() CertificateSigningRequestSpecPatchOutput {
	return i.ToCertificateSigningRequestSpecPatchOutputWithContext(context.Background())
}

func (i CertificateSigningRequestSpecPatchArgs) ToCertificateSigningRequestSpecPatchOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecPatchOutput)
}

func (i CertificateSigningRequestSpecPatchArgs) ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput {
	return i.ToCertificateSigningRequestSpecPatchPtrOutputWithContext(context.Background())
}

func (i CertificateSigningRequestSpecPatchArgs) ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecPatchOutput).ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx)
}

// CertificateSigningRequestSpecPatchPtrInput is an input type that accepts CertificateSigningRequestSpecPatchArgs, CertificateSigningRequestSpecPatchPtr and CertificateSigningRequestSpecPatchPtrOutput values.
// You can construct a concrete instance of `CertificateSigningRequestSpecPatchPtrInput` via:
//
//	        CertificateSigningRequestSpecPatchArgs{...}
//
//	or:
//
//	        nil
type CertificateSigningRequestSpecPatchPtrInput interface {
	pulumi.Input

	ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput
	ToCertificateSigningRequestSpecPatchPtrOutputWithContext(context.Context) CertificateSigningRequestSpecPatchPtrOutput
}

type certificateSigningRequestSpecPatchPtrType CertificateSigningRequestSpecPatchArgs

func CertificateSigningRequestSpecPatchPtr(v *CertificateSigningRequestSpecPatchArgs) CertificateSigningRequestSpecPatchPtrInput {
	return (*certificateSigningRequestSpecPatchPtrType)(v)
}

func (*certificateSigningRequestSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestSpecPatch)(nil)).Elem()
}

func (i *certificateSigningRequestSpecPatchPtrType) ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput {
	return i.ToCertificateSigningRequestSpecPatchPtrOutputWithContext(context.Background())
}

func (i *certificateSigningRequestSpecPatchPtrType) ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecPatchPtrOutput)
}

// This information is immutable after the request is created. Only the Request and Usages fields can be set on creation, other fields are derived by Kubernetes and cannot be modified by users.
type CertificateSigningRequestSpecPatchOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestSpecPatch)(nil)).Elem()
}

func (o CertificateSigningRequestSpecPatchOutput) ToCertificateSigningRequestSpecPatchOutput() CertificateSigningRequestSpecPatchOutput {
	return o
}

func (o CertificateSigningRequestSpecPatchOutput) ToCertificateSigningRequestSpecPatchOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchOutput {
	return o
}

func (o CertificateSigningRequestSpecPatchOutput) ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput {
	return o.ToCertificateSigningRequestSpecPatchPtrOutputWithContext(context.Background())
}

func (o CertificateSigningRequestSpecPatchOutput) ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CertificateSigningRequestSpecPatch) *CertificateSigningRequestSpecPatch {
		return &v
	}).(CertificateSigningRequestSpecPatchPtrOutput)
}

// Extra information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPatchOutput) Extra() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) map[string][]string { return v.Extra }).(pulumi.StringArrayMapOutput)
}

// Group information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPatchOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// Base64-encoded PKCS#10 CSR data
func (o CertificateSigningRequestSpecPatchOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) *string { return v.Request }).(pulumi.StringPtrOutput)
}

// Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:
//  1. If it's a kubelet client certificate, it is assigned
//     "kubernetes.io/kube-apiserver-client-kubelet".
//  2. If it's a kubelet serving certificate, it is assigned
//     "kubernetes.io/kubelet-serving".
//  3. Otherwise, it is assigned "kubernetes.io/legacy-unknown".
//     Distribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.
func (o CertificateSigningRequestSpecPatchOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) *string { return v.SignerName }).(pulumi.StringPtrOutput)
}

// UID information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPatchOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

// allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
//
//	https://tools.ietf.org/html/rfc5280#section-4.2.1.12
func (o CertificateSigningRequestSpecPatchOutput) Usages() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) []string { return v.Usages }).(pulumi.StringArrayOutput)
}

// Information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPatchOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) *string { return v.Username }).(pulumi.StringPtrOutput)
}

type CertificateSigningRequestSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestSpecPatch)(nil)).Elem()
}

func (o CertificateSigningRequestSpecPatchPtrOutput) ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput {
	return o
}

func (o CertificateSigningRequestSpecPatchPtrOutput) ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchPtrOutput {
	return o
}

func (o CertificateSigningRequestSpecPatchPtrOutput) Elem() CertificateSigningRequestSpecPatchOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) CertificateSigningRequestSpecPatch {
		if v != nil {
			return *v
		}
		var ret CertificateSigningRequestSpecPatch
		return ret
	}).(CertificateSigningRequestSpecPatchOutput)
}

// Extra information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPatchPtrOutput) Extra() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) map[string][]string {
		if v == nil {
			return nil
		}
		return v.Extra
	}).(pulumi.StringArrayMapOutput)
}

// Group information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPatchPtrOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.Groups
	}).(pulumi.StringArrayOutput)
}

// Base64-encoded PKCS#10 CSR data
func (o CertificateSigningRequestSpecPatchPtrOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Request
	}).(pulumi.StringPtrOutput)
}

// Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:
//  1. If it's a kubelet client certificate, it is assigned
//     "kubernetes.io/kube-apiserver-client-kubelet".
//  2. If it's a kubelet serving certificate, it is assigned
//     "kubernetes.io/kubelet-serving".
//  3. Otherwise, it is assigned "kubernetes.io/legacy-unknown".
//     Distribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.
func (o CertificateSigningRequestSpecPatchPtrOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.SignerName
	}).(pulumi.StringPtrOutput)
}

// UID information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPatchPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
//
//	https://tools.ietf.org/html/rfc5280#section-4.2.1.12
func (o CertificateSigningRequestSpecPatchPtrOutput) Usages() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.Usages
	}).(pulumi.StringArrayOutput)
}

// Information about the requesting user. See user.Info interface for details.
func (o CertificateSigningRequestSpecPatchPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Username
	}).(pulumi.StringPtrOutput)
}

type CertificateSigningRequestStatus struct {
	// If request was approved, the controller will place the issued certificate here.
	Certificate *string `pulumi:"certificate"`
	// Conditions applied to the request, such as approval or denial.
	Conditions []CertificateSigningRequestCondition `pulumi:"conditions"`
}

// CertificateSigningRequestStatusInput is an input type that accepts CertificateSigningRequestStatusArgs and CertificateSigningRequestStatusOutput values.
// You can construct a concrete instance of `CertificateSigningRequestStatusInput` via:
//
//	CertificateSigningRequestStatusArgs{...}
type CertificateSigningRequestStatusInput interface {
	pulumi.Input

	ToCertificateSigningRequestStatusOutput() CertificateSigningRequestStatusOutput
	ToCertificateSigningRequestStatusOutputWithContext(context.Context) CertificateSigningRequestStatusOutput
}

type CertificateSigningRequestStatusArgs struct {
	// If request was approved, the controller will place the issued certificate here.
	Certificate pulumi.StringPtrInput `pulumi:"certificate"`
	// Conditions applied to the request, such as approval or denial.
	Conditions CertificateSigningRequestConditionArrayInput `pulumi:"conditions"`
}

func (CertificateSigningRequestStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestStatus)(nil)).Elem()
}

func (i CertificateSigningRequestStatusArgs) ToCertificateSigningRequestStatusOutput() CertificateSigningRequestStatusOutput {
	return i.ToCertificateSigningRequestStatusOutputWithContext(context.Background())
}

func (i CertificateSigningRequestStatusArgs) ToCertificateSigningRequestStatusOutputWithContext(ctx context.Context) CertificateSigningRequestStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusOutput)
}

func (i CertificateSigningRequestStatusArgs) ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput {
	return i.ToCertificateSigningRequestStatusPtrOutputWithContext(context.Background())
}

func (i CertificateSigningRequestStatusArgs) ToCertificateSigningRequestStatusPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusOutput).ToCertificateSigningRequestStatusPtrOutputWithContext(ctx)
}

// CertificateSigningRequestStatusPtrInput is an input type that accepts CertificateSigningRequestStatusArgs, CertificateSigningRequestStatusPtr and CertificateSigningRequestStatusPtrOutput values.
// You can construct a concrete instance of `CertificateSigningRequestStatusPtrInput` via:
//
//	        CertificateSigningRequestStatusArgs{...}
//
//	or:
//
//	        nil
type CertificateSigningRequestStatusPtrInput interface {
	pulumi.Input

	ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput
	ToCertificateSigningRequestStatusPtrOutputWithContext(context.Context) CertificateSigningRequestStatusPtrOutput
}

type certificateSigningRequestStatusPtrType CertificateSigningRequestStatusArgs

func CertificateSigningRequestStatusPtr(v *CertificateSigningRequestStatusArgs) CertificateSigningRequestStatusPtrInput {
	return (*certificateSigningRequestStatusPtrType)(v)
}

func (*certificateSigningRequestStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestStatus)(nil)).Elem()
}

func (i *certificateSigningRequestStatusPtrType) ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput {
	return i.ToCertificateSigningRequestStatusPtrOutputWithContext(context.Background())
}

func (i *certificateSigningRequestStatusPtrType) ToCertificateSigningRequestStatusPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusPtrOutput)
}

type CertificateSigningRequestStatusOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestStatus)(nil)).Elem()
}

func (o CertificateSigningRequestStatusOutput) ToCertificateSigningRequestStatusOutput() CertificateSigningRequestStatusOutput {
	return o
}

func (o CertificateSigningRequestStatusOutput) ToCertificateSigningRequestStatusOutputWithContext(ctx context.Context) CertificateSigningRequestStatusOutput {
	return o
}

func (o CertificateSigningRequestStatusOutput) ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput {
	return o.ToCertificateSigningRequestStatusPtrOutputWithContext(context.Background())
}

func (o CertificateSigningRequestStatusOutput) ToCertificateSigningRequestStatusPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CertificateSigningRequestStatus) *CertificateSigningRequestStatus {
		return &v
	}).(CertificateSigningRequestStatusPtrOutput)
}

// If request was approved, the controller will place the issued certificate here.
func (o CertificateSigningRequestStatusOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestStatus) *string { return v.Certificate }).(pulumi.StringPtrOutput)
}

// Conditions applied to the request, such as approval or denial.
func (o CertificateSigningRequestStatusOutput) Conditions() CertificateSigningRequestConditionArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestStatus) []CertificateSigningRequestCondition { return v.Conditions }).(CertificateSigningRequestConditionArrayOutput)
}

type CertificateSigningRequestStatusPtrOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestStatus)(nil)).Elem()
}

func (o CertificateSigningRequestStatusPtrOutput) ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput {
	return o
}

func (o CertificateSigningRequestStatusPtrOutput) ToCertificateSigningRequestStatusPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPtrOutput {
	return o
}

func (o CertificateSigningRequestStatusPtrOutput) Elem() CertificateSigningRequestStatusOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatus) CertificateSigningRequestStatus {
		if v != nil {
			return *v
		}
		var ret CertificateSigningRequestStatus
		return ret
	}).(CertificateSigningRequestStatusOutput)
}

// If request was approved, the controller will place the issued certificate here.
func (o CertificateSigningRequestStatusPtrOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatus) *string {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(pulumi.StringPtrOutput)
}

// Conditions applied to the request, such as approval or denial.
func (o CertificateSigningRequestStatusPtrOutput) Conditions() CertificateSigningRequestConditionArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatus) []CertificateSigningRequestCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(CertificateSigningRequestConditionArrayOutput)
}

type CertificateSigningRequestStatusPatch struct {
	// If request was approved, the controller will place the issued certificate here.
	Certificate *string `pulumi:"certificate"`
	// Conditions applied to the request, such as approval or denial.
	Conditions []CertificateSigningRequestConditionPatch `pulumi:"conditions"`
}

// CertificateSigningRequestStatusPatchInput is an input type that accepts CertificateSigningRequestStatusPatchArgs and CertificateSigningRequestStatusPatchOutput values.
// You can construct a concrete instance of `CertificateSigningRequestStatusPatchInput` via:
//
//	CertificateSigningRequestStatusPatchArgs{...}
type CertificateSigningRequestStatusPatchInput interface {
	pulumi.Input

	ToCertificateSigningRequestStatusPatchOutput() CertificateSigningRequestStatusPatchOutput
	ToCertificateSigningRequestStatusPatchOutputWithContext(context.Context) CertificateSigningRequestStatusPatchOutput
}

type CertificateSigningRequestStatusPatchArgs struct {
	// If request was approved, the controller will place the issued certificate here.
	Certificate pulumi.StringPtrInput `pulumi:"certificate"`
	// Conditions applied to the request, such as approval or denial.
	Conditions CertificateSigningRequestConditionPatchArrayInput `pulumi:"conditions"`
}

func (CertificateSigningRequestStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestStatusPatch)(nil)).Elem()
}

func (i CertificateSigningRequestStatusPatchArgs) ToCertificateSigningRequestStatusPatchOutput() CertificateSigningRequestStatusPatchOutput {
	return i.ToCertificateSigningRequestStatusPatchOutputWithContext(context.Background())
}

func (i CertificateSigningRequestStatusPatchArgs) ToCertificateSigningRequestStatusPatchOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusPatchOutput)
}

func (i CertificateSigningRequestStatusPatchArgs) ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput {
	return i.ToCertificateSigningRequestStatusPatchPtrOutputWithContext(context.Background())
}

func (i CertificateSigningRequestStatusPatchArgs) ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusPatchOutput).ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx)
}

// CertificateSigningRequestStatusPatchPtrInput is an input type that accepts CertificateSigningRequestStatusPatchArgs, CertificateSigningRequestStatusPatchPtr and CertificateSigningRequestStatusPatchPtrOutput values.
// You can construct a concrete instance of `CertificateSigningRequestStatusPatchPtrInput` via:
//
//	        CertificateSigningRequestStatusPatchArgs{...}
//
//	or:
//
//	        nil
type CertificateSigningRequestStatusPatchPtrInput interface {
	pulumi.Input

	ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput
	ToCertificateSigningRequestStatusPatchPtrOutputWithContext(context.Context) CertificateSigningRequestStatusPatchPtrOutput
}

type certificateSigningRequestStatusPatchPtrType CertificateSigningRequestStatusPatchArgs

func CertificateSigningRequestStatusPatchPtr(v *CertificateSigningRequestStatusPatchArgs) CertificateSigningRequestStatusPatchPtrInput {
	return (*certificateSigningRequestStatusPatchPtrType)(v)
}

func (*certificateSigningRequestStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestStatusPatch)(nil)).Elem()
}

func (i *certificateSigningRequestStatusPatchPtrType) ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput {
	return i.ToCertificateSigningRequestStatusPatchPtrOutputWithContext(context.Background())
}

func (i *certificateSigningRequestStatusPatchPtrType) ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusPatchPtrOutput)
}

type CertificateSigningRequestStatusPatchOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestStatusPatch)(nil)).Elem()
}

func (o CertificateSigningRequestStatusPatchOutput) ToCertificateSigningRequestStatusPatchOutput() CertificateSigningRequestStatusPatchOutput {
	return o
}

func (o CertificateSigningRequestStatusPatchOutput) ToCertificateSigningRequestStatusPatchOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchOutput {
	return o
}

func (o CertificateSigningRequestStatusPatchOutput) ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput {
	return o.ToCertificateSigningRequestStatusPatchPtrOutputWithContext(context.Background())
}

func (o CertificateSigningRequestStatusPatchOutput) ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CertificateSigningRequestStatusPatch) *CertificateSigningRequestStatusPatch {
		return &v
	}).(CertificateSigningRequestStatusPatchPtrOutput)
}

// If request was approved, the controller will place the issued certificate here.
func (o CertificateSigningRequestStatusPatchOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestStatusPatch) *string { return v.Certificate }).(pulumi.StringPtrOutput)
}

// Conditions applied to the request, such as approval or denial.
func (o CertificateSigningRequestStatusPatchOutput) Conditions() CertificateSigningRequestConditionPatchArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestStatusPatch) []CertificateSigningRequestConditionPatch {
		return v.Conditions
	}).(CertificateSigningRequestConditionPatchArrayOutput)
}

type CertificateSigningRequestStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestStatusPatch)(nil)).Elem()
}

func (o CertificateSigningRequestStatusPatchPtrOutput) ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput {
	return o
}

func (o CertificateSigningRequestStatusPatchPtrOutput) ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchPtrOutput {
	return o
}

func (o CertificateSigningRequestStatusPatchPtrOutput) Elem() CertificateSigningRequestStatusPatchOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatusPatch) CertificateSigningRequestStatusPatch {
		if v != nil {
			return *v
		}
		var ret CertificateSigningRequestStatusPatch
		return ret
	}).(CertificateSigningRequestStatusPatchOutput)
}

// If request was approved, the controller will place the issued certificate here.
func (o CertificateSigningRequestStatusPatchPtrOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(pulumi.StringPtrOutput)
}

// Conditions applied to the request, such as approval or denial.
func (o CertificateSigningRequestStatusPatchPtrOutput) Conditions() CertificateSigningRequestConditionPatchArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatusPatch) []CertificateSigningRequestConditionPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(CertificateSigningRequestConditionPatchArrayOutput)
}

// ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).
//
// ClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.
//
// It can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle.
type ClusterTrustBundleType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// metadata contains the object metadata.
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// spec contains the signer (if any) and trust anchors.
	Spec ClusterTrustBundleSpec `pulumi:"spec"`
}

// ClusterTrustBundleTypeInput is an input type that accepts ClusterTrustBundleTypeArgs and ClusterTrustBundleTypeOutput values.
// You can construct a concrete instance of `ClusterTrustBundleTypeInput` via:
//
//	ClusterTrustBundleTypeArgs{...}
type ClusterTrustBundleTypeInput interface {
	pulumi.Input

	ToClusterTrustBundleTypeOutput() ClusterTrustBundleTypeOutput
	ToClusterTrustBundleTypeOutputWithContext(context.Context) ClusterTrustBundleTypeOutput
}

// ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).
//
// ClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.
//
// It can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle.
type ClusterTrustBundleTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// metadata contains the object metadata.
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// spec contains the signer (if any) and trust anchors.
	Spec ClusterTrustBundleSpecInput `pulumi:"spec"`
}

func (ClusterTrustBundleTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundleType)(nil)).Elem()
}

func (i ClusterTrustBundleTypeArgs) ToClusterTrustBundleTypeOutput() ClusterTrustBundleTypeOutput {
	return i.ToClusterTrustBundleTypeOutputWithContext(context.Background())
}

func (i ClusterTrustBundleTypeArgs) ToClusterTrustBundleTypeOutputWithContext(ctx context.Context) ClusterTrustBundleTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTrustBundleTypeOutput)
}

// ClusterTrustBundleTypeArrayInput is an input type that accepts ClusterTrustBundleTypeArray and ClusterTrustBundleTypeArrayOutput values.
// You can construct a concrete instance of `ClusterTrustBundleTypeArrayInput` via:
//
//	ClusterTrustBundleTypeArray{ ClusterTrustBundleTypeArgs{...} }
type ClusterTrustBundleTypeArrayInput interface {
	pulumi.Input

	ToClusterTrustBundleTypeArrayOutput() ClusterTrustBundleTypeArrayOutput
	ToClusterTrustBundleTypeArrayOutputWithContext(context.Context) ClusterTrustBundleTypeArrayOutput
}

type ClusterTrustBundleTypeArray []ClusterTrustBundleTypeInput

func (ClusterTrustBundleTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterTrustBundleType)(nil)).Elem()
}

func (i ClusterTrustBundleTypeArray) ToClusterTrustBundleTypeArrayOutput() ClusterTrustBundleTypeArrayOutput {
	return i.ToClusterTrustBundleTypeArrayOutputWithContext(context.Background())
}

func (i ClusterTrustBundleTypeArray) ToClusterTrustBundleTypeArrayOutputWithContext(ctx context.Context) ClusterTrustBundleTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTrustBundleTypeArrayOutput)
}

// ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).
//
// ClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.
//
// It can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle.
type ClusterTrustBundleTypeOutput struct{ *pulumi.OutputState }

func (ClusterTrustBundleTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundleType)(nil)).Elem()
}

func (o ClusterTrustBundleTypeOutput) ToClusterTrustBundleTypeOutput() ClusterTrustBundleTypeOutput {
	return o
}

func (o ClusterTrustBundleTypeOutput) ToClusterTrustBundleTypeOutputWithContext(ctx context.Context) ClusterTrustBundleTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ClusterTrustBundleTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundleType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ClusterTrustBundleTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundleType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// metadata contains the object metadata.
func (o ClusterTrustBundleTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundleType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// spec contains the signer (if any) and trust anchors.
func (o ClusterTrustBundleTypeOutput) Spec() ClusterTrustBundleSpecOutput {
	return o.ApplyT(func(v ClusterTrustBundleType) ClusterTrustBundleSpec { return v.Spec }).(ClusterTrustBundleSpecOutput)
}

type ClusterTrustBundleTypeArrayOutput struct{ *pulumi.OutputState }

func (ClusterTrustBundleTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterTrustBundleType)(nil)).Elem()
}

func (o ClusterTrustBundleTypeArrayOutput) ToClusterTrustBundleTypeArrayOutput() ClusterTrustBundleTypeArrayOutput {
	return o
}

func (o ClusterTrustBundleTypeArrayOutput) ToClusterTrustBundleTypeArrayOutputWithContext(ctx context.Context) ClusterTrustBundleTypeArrayOutput {
	return o
}

func (o ClusterTrustBundleTypeArrayOutput) Index(i pulumi.IntInput) ClusterTrustBundleTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterTrustBundleType {
		return vs[0].([]ClusterTrustBundleType)[vs[1].(int)]
	}).(ClusterTrustBundleTypeOutput)
}

// ClusterTrustBundleList is a collection of ClusterTrustBundle objects
type ClusterTrustBundleListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// items is a collection of ClusterTrustBundle objects
	Items []ClusterTrustBundleType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// metadata contains the list metadata.
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ClusterTrustBundleListTypeInput is an input type that accepts ClusterTrustBundleListTypeArgs and ClusterTrustBundleListTypeOutput values.
// You can construct a concrete instance of `ClusterTrustBundleListTypeInput` via:
//
//	ClusterTrustBundleListTypeArgs{...}
type ClusterTrustBundleListTypeInput interface {
	pulumi.Input

	ToClusterTrustBundleListTypeOutput() ClusterTrustBundleListTypeOutput
	ToClusterTrustBundleListTypeOutputWithContext(context.Context) ClusterTrustBundleListTypeOutput
}

// ClusterTrustBundleList is a collection of ClusterTrustBundle objects
type ClusterTrustBundleListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// items is a collection of ClusterTrustBundle objects
	Items ClusterTrustBundleTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// metadata contains the list metadata.
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (ClusterTrustBundleListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundleListType)(nil)).Elem()
}

func (i ClusterTrustBundleListTypeArgs) ToClusterTrustBundleListTypeOutput() ClusterTrustBundleListTypeOutput {
	return i.ToClusterTrustBundleListTypeOutputWithContext(context.Background())
}

func (i ClusterTrustBundleListTypeArgs) ToClusterTrustBundleListTypeOutputWithContext(ctx context.Context) ClusterTrustBundleListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTrustBundleListTypeOutput)
}

// ClusterTrustBundleList is a collection of ClusterTrustBundle objects
type ClusterTrustBundleListTypeOutput struct{ *pulumi.OutputState }

func (ClusterTrustBundleListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundleListType)(nil)).Elem()
}

func (o ClusterTrustBundleListTypeOutput) ToClusterTrustBundleListTypeOutput() ClusterTrustBundleListTypeOutput {
	return o
}

func (o ClusterTrustBundleListTypeOutput) ToClusterTrustBundleListTypeOutputWithContext(ctx context.Context) ClusterTrustBundleListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ClusterTrustBundleListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundleListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// items is a collection of ClusterTrustBundle objects
func (o ClusterTrustBundleListTypeOutput) Items() ClusterTrustBundleTypeArrayOutput {
	return o.ApplyT(func(v ClusterTrustBundleListType) []ClusterTrustBundleType { return v.Items }).(ClusterTrustBundleTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ClusterTrustBundleListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundleListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// metadata contains the list metadata.
func (o ClusterTrustBundleListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundleListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).
//
// ClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.
//
// It can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle.
type ClusterTrustBundlePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// metadata contains the object metadata.
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// spec contains the signer (if any) and trust anchors.
	Spec *ClusterTrustBundleSpecPatch `pulumi:"spec"`
}

// ClusterTrustBundlePatchTypeInput is an input type that accepts ClusterTrustBundlePatchTypeArgs and ClusterTrustBundlePatchTypeOutput values.
// You can construct a concrete instance of `ClusterTrustBundlePatchTypeInput` via:
//
//	ClusterTrustBundlePatchTypeArgs{...}
type ClusterTrustBundlePatchTypeInput interface {
	pulumi.Input

	ToClusterTrustBundlePatchTypeOutput() ClusterTrustBundlePatchTypeOutput
	ToClusterTrustBundlePatchTypeOutputWithContext(context.Context) ClusterTrustBundlePatchTypeOutput
}

// ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).
//
// ClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.
//
// It can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle.
type ClusterTrustBundlePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// metadata contains the object metadata.
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// spec contains the signer (if any) and trust anchors.
	Spec ClusterTrustBundleSpecPatchPtrInput `pulumi:"spec"`
}

func (ClusterTrustBundlePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundlePatchType)(nil)).Elem()
}

func (i ClusterTrustBundlePatchTypeArgs) ToClusterTrustBundlePatchTypeOutput() ClusterTrustBundlePatchTypeOutput {
	return i.ToClusterTrustBundlePatchTypeOutputWithContext(context.Background())
}

func (i ClusterTrustBundlePatchTypeArgs) ToClusterTrustBundlePatchTypeOutputWithContext(ctx context.Context) ClusterTrustBundlePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTrustBundlePatchTypeOutput)
}

// ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).
//
// ClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.
//
// It can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle.
type ClusterTrustBundlePatchTypeOutput struct{ *pulumi.OutputState }

func (ClusterTrustBundlePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundlePatchType)(nil)).Elem()
}

func (o ClusterTrustBundlePatchTypeOutput) ToClusterTrustBundlePatchTypeOutput() ClusterTrustBundlePatchTypeOutput {
	return o
}

func (o ClusterTrustBundlePatchTypeOutput) ToClusterTrustBundlePatchTypeOutputWithContext(ctx context.Context) ClusterTrustBundlePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ClusterTrustBundlePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundlePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ClusterTrustBundlePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundlePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// metadata contains the object metadata.
func (o ClusterTrustBundlePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundlePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// spec contains the signer (if any) and trust anchors.
func (o ClusterTrustBundlePatchTypeOutput) Spec() ClusterTrustBundleSpecPatchPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundlePatchType) *ClusterTrustBundleSpecPatch { return v.Spec }).(ClusterTrustBundleSpecPatchPtrOutput)
}

// ClusterTrustBundleSpec contains the signer and trust anchors.
type ClusterTrustBundleSpec struct {
	// signerName indicates the associated signer, if any.
	//
	// In order to create or update a ClusterTrustBundle that sets signerName, you must have the following cluster-scoped permission: group=certificates.k8s.io resource=signers resourceName=<the signer name> verb=attest.
	//
	// If signerName is not empty, then the ClusterTrustBundle object must be named with the signer name as a prefix (translating slashes to colons). For example, for the signer name `example.com/foo`, valid ClusterTrustBundle object names include `example.com:foo:abc` and `example.com:foo:v1`.
	//
	// If signerName is empty, then the ClusterTrustBundle object's name must not have such a prefix.
	//
	// List/watch requests for ClusterTrustBundles can filter on this field using a `spec.signerName=NAME` field selector.
	SignerName *string `pulumi:"signerName"`
	// trustBundle contains the individual X.509 trust anchors for this bundle, as PEM bundle of PEM-wrapped, DER-formatted X.509 certificates.
	//
	// The data must consist only of PEM certificate blocks that parse as valid X.509 certificates.  Each certificate must include a basic constraints extension with the CA bit set.  The API server will reject objects that contain duplicate certificates, or that use PEM block headers.
	//
	// Users of ClusterTrustBundles, including Kubelet, are free to reorder and deduplicate certificate blocks in this file according to their own logic, as well as to drop PEM block headers and inter-block data.
	TrustBundle string `pulumi:"trustBundle"`
}

// ClusterTrustBundleSpecInput is an input type that accepts ClusterTrustBundleSpecArgs and ClusterTrustBundleSpecOutput values.
// You can construct a concrete instance of `ClusterTrustBundleSpecInput` via:
//
//	ClusterTrustBundleSpecArgs{...}
type ClusterTrustBundleSpecInput interface {
	pulumi.Input

	ToClusterTrustBundleSpecOutput() ClusterTrustBundleSpecOutput
	ToClusterTrustBundleSpecOutputWithContext(context.Context) ClusterTrustBundleSpecOutput
}

// ClusterTrustBundleSpec contains the signer and trust anchors.
type ClusterTrustBundleSpecArgs struct {
	// signerName indicates the associated signer, if any.
	//
	// In order to create or update a ClusterTrustBundle that sets signerName, you must have the following cluster-scoped permission: group=certificates.k8s.io resource=signers resourceName=<the signer name> verb=attest.
	//
	// If signerName is not empty, then the ClusterTrustBundle object must be named with the signer name as a prefix (translating slashes to colons). For example, for the signer name `example.com/foo`, valid ClusterTrustBundle object names include `example.com:foo:abc` and `example.com:foo:v1`.
	//
	// If signerName is empty, then the ClusterTrustBundle object's name must not have such a prefix.
	//
	// List/watch requests for ClusterTrustBundles can filter on this field using a `spec.signerName=NAME` field selector.
	SignerName pulumi.StringPtrInput `pulumi:"signerName"`
	// trustBundle contains the individual X.509 trust anchors for this bundle, as PEM bundle of PEM-wrapped, DER-formatted X.509 certificates.
	//
	// The data must consist only of PEM certificate blocks that parse as valid X.509 certificates.  Each certificate must include a basic constraints extension with the CA bit set.  The API server will reject objects that contain duplicate certificates, or that use PEM block headers.
	//
	// Users of ClusterTrustBundles, including Kubelet, are free to reorder and deduplicate certificate blocks in this file according to their own logic, as well as to drop PEM block headers and inter-block data.
	TrustBundle pulumi.StringInput `pulumi:"trustBundle"`
}

func (ClusterTrustBundleSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundleSpec)(nil)).Elem()
}

func (i ClusterTrustBundleSpecArgs) ToClusterTrustBundleSpecOutput() ClusterTrustBundleSpecOutput {
	return i.ToClusterTrustBundleSpecOutputWithContext(context.Background())
}

func (i ClusterTrustBundleSpecArgs) ToClusterTrustBundleSpecOutputWithContext(ctx context.Context) ClusterTrustBundleSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTrustBundleSpecOutput)
}

// ClusterTrustBundleSpec contains the signer and trust anchors.
type ClusterTrustBundleSpecOutput struct{ *pulumi.OutputState }

func (ClusterTrustBundleSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundleSpec)(nil)).Elem()
}

func (o ClusterTrustBundleSpecOutput) ToClusterTrustBundleSpecOutput() ClusterTrustBundleSpecOutput {
	return o
}

func (o ClusterTrustBundleSpecOutput) ToClusterTrustBundleSpecOutputWithContext(ctx context.Context) ClusterTrustBundleSpecOutput {
	return o
}

// signerName indicates the associated signer, if any.
//
// In order to create or update a ClusterTrustBundle that sets signerName, you must have the following cluster-scoped permission: group=certificates.k8s.io resource=signers resourceName=<the signer name> verb=attest.
//
// If signerName is not empty, then the ClusterTrustBundle object must be named with the signer name as a prefix (translating slashes to colons). For example, for the signer name `example.com/foo`, valid ClusterTrustBundle object names include `example.com:foo:abc` and `example.com:foo:v1`.
//
// If signerName is empty, then the ClusterTrustBundle object's name must not have such a prefix.
//
// List/watch requests for ClusterTrustBundles can filter on this field using a `spec.signerName=NAME` field selector.
func (o ClusterTrustBundleSpecOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundleSpec) *string { return v.SignerName }).(pulumi.StringPtrOutput)
}

// trustBundle contains the individual X.509 trust anchors for this bundle, as PEM bundle of PEM-wrapped, DER-formatted X.509 certificates.
//
// The data must consist only of PEM certificate blocks that parse as valid X.509 certificates.  Each certificate must include a basic constraints extension with the CA bit set.  The API server will reject objects that contain duplicate certificates, or that use PEM block headers.
//
// Users of ClusterTrustBundles, including Kubelet, are free to reorder and deduplicate certificate blocks in this file according to their own logic, as well as to drop PEM block headers and inter-block data.
func (o ClusterTrustBundleSpecOutput) TrustBundle() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterTrustBundleSpec) string { return v.TrustBundle }).(pulumi.StringOutput)
}

// ClusterTrustBundleSpec contains the signer and trust anchors.
type ClusterTrustBundleSpecPatch struct {
	// signerName indicates the associated signer, if any.
	//
	// In order to create or update a ClusterTrustBundle that sets signerName, you must have the following cluster-scoped permission: group=certificates.k8s.io resource=signers resourceName=<the signer name> verb=attest.
	//
	// If signerName is not empty, then the ClusterTrustBundle object must be named with the signer name as a prefix (translating slashes to colons). For example, for the signer name `example.com/foo`, valid ClusterTrustBundle object names include `example.com:foo:abc` and `example.com:foo:v1`.
	//
	// If signerName is empty, then the ClusterTrustBundle object's name must not have such a prefix.
	//
	// List/watch requests for ClusterTrustBundles can filter on this field using a `spec.signerName=NAME` field selector.
	SignerName *string `pulumi:"signerName"`
	// trustBundle contains the individual X.509 trust anchors for this bundle, as PEM bundle of PEM-wrapped, DER-formatted X.509 certificates.
	//
	// The data must consist only of PEM certificate blocks that parse as valid X.509 certificates.  Each certificate must include a basic constraints extension with the CA bit set.  The API server will reject objects that contain duplicate certificates, or that use PEM block headers.
	//
	// Users of ClusterTrustBundles, including Kubelet, are free to reorder and deduplicate certificate blocks in this file according to their own logic, as well as to drop PEM block headers and inter-block data.
	TrustBundle *string `pulumi:"trustBundle"`
}

// ClusterTrustBundleSpecPatchInput is an input type that accepts ClusterTrustBundleSpecPatchArgs and ClusterTrustBundleSpecPatchOutput values.
// You can construct a concrete instance of `ClusterTrustBundleSpecPatchInput` via:
//
//	ClusterTrustBundleSpecPatchArgs{...}
type ClusterTrustBundleSpecPatchInput interface {
	pulumi.Input

	ToClusterTrustBundleSpecPatchOutput() ClusterTrustBundleSpecPatchOutput
	ToClusterTrustBundleSpecPatchOutputWithContext(context.Context) ClusterTrustBundleSpecPatchOutput
}

// ClusterTrustBundleSpec contains the signer and trust anchors.
type ClusterTrustBundleSpecPatchArgs struct {
	// signerName indicates the associated signer, if any.
	//
	// In order to create or update a ClusterTrustBundle that sets signerName, you must have the following cluster-scoped permission: group=certificates.k8s.io resource=signers resourceName=<the signer name> verb=attest.
	//
	// If signerName is not empty, then the ClusterTrustBundle object must be named with the signer name as a prefix (translating slashes to colons). For example, for the signer name `example.com/foo`, valid ClusterTrustBundle object names include `example.com:foo:abc` and `example.com:foo:v1`.
	//
	// If signerName is empty, then the ClusterTrustBundle object's name must not have such a prefix.
	//
	// List/watch requests for ClusterTrustBundles can filter on this field using a `spec.signerName=NAME` field selector.
	SignerName pulumi.StringPtrInput `pulumi:"signerName"`
	// trustBundle contains the individual X.509 trust anchors for this bundle, as PEM bundle of PEM-wrapped, DER-formatted X.509 certificates.
	//
	// The data must consist only of PEM certificate blocks that parse as valid X.509 certificates.  Each certificate must include a basic constraints extension with the CA bit set.  The API server will reject objects that contain duplicate certificates, or that use PEM block headers.
	//
	// Users of ClusterTrustBundles, including Kubelet, are free to reorder and deduplicate certificate blocks in this file according to their own logic, as well as to drop PEM block headers and inter-block data.
	TrustBundle pulumi.StringPtrInput `pulumi:"trustBundle"`
}

func (ClusterTrustBundleSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundleSpecPatch)(nil)).Elem()
}

func (i ClusterTrustBundleSpecPatchArgs) ToClusterTrustBundleSpecPatchOutput() ClusterTrustBundleSpecPatchOutput {
	return i.ToClusterTrustBundleSpecPatchOutputWithContext(context.Background())
}

func (i ClusterTrustBundleSpecPatchArgs) ToClusterTrustBundleSpecPatchOutputWithContext(ctx context.Context) ClusterTrustBundleSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTrustBundleSpecPatchOutput)
}

func (i ClusterTrustBundleSpecPatchArgs) ToClusterTrustBundleSpecPatchPtrOutput() ClusterTrustBundleSpecPatchPtrOutput {
	return i.ToClusterTrustBundleSpecPatchPtrOutputWithContext(context.Background())
}

func (i ClusterTrustBundleSpecPatchArgs) ToClusterTrustBundleSpecPatchPtrOutputWithContext(ctx context.Context) ClusterTrustBundleSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTrustBundleSpecPatchOutput).ToClusterTrustBundleSpecPatchPtrOutputWithContext(ctx)
}

// ClusterTrustBundleSpecPatchPtrInput is an input type that accepts ClusterTrustBundleSpecPatchArgs, ClusterTrustBundleSpecPatchPtr and ClusterTrustBundleSpecPatchPtrOutput values.
// You can construct a concrete instance of `ClusterTrustBundleSpecPatchPtrInput` via:
//
//	        ClusterTrustBundleSpecPatchArgs{...}
//
//	or:
//
//	        nil
type ClusterTrustBundleSpecPatchPtrInput interface {
	pulumi.Input

	ToClusterTrustBundleSpecPatchPtrOutput() ClusterTrustBundleSpecPatchPtrOutput
	ToClusterTrustBundleSpecPatchPtrOutputWithContext(context.Context) ClusterTrustBundleSpecPatchPtrOutput
}

type clusterTrustBundleSpecPatchPtrType ClusterTrustBundleSpecPatchArgs

func ClusterTrustBundleSpecPatchPtr(v *ClusterTrustBundleSpecPatchArgs) ClusterTrustBundleSpecPatchPtrInput {
	return (*clusterTrustBundleSpecPatchPtrType)(v)
}

func (*clusterTrustBundleSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterTrustBundleSpecPatch)(nil)).Elem()
}

func (i *clusterTrustBundleSpecPatchPtrType) ToClusterTrustBundleSpecPatchPtrOutput() ClusterTrustBundleSpecPatchPtrOutput {
	return i.ToClusterTrustBundleSpecPatchPtrOutputWithContext(context.Background())
}

func (i *clusterTrustBundleSpecPatchPtrType) ToClusterTrustBundleSpecPatchPtrOutputWithContext(ctx context.Context) ClusterTrustBundleSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTrustBundleSpecPatchPtrOutput)
}

// ClusterTrustBundleSpec contains the signer and trust anchors.
type ClusterTrustBundleSpecPatchOutput struct{ *pulumi.OutputState }

func (ClusterTrustBundleSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTrustBundleSpecPatch)(nil)).Elem()
}

func (o ClusterTrustBundleSpecPatchOutput) ToClusterTrustBundleSpecPatchOutput() ClusterTrustBundleSpecPatchOutput {
	return o
}

func (o ClusterTrustBundleSpecPatchOutput) ToClusterTrustBundleSpecPatchOutputWithContext(ctx context.Context) ClusterTrustBundleSpecPatchOutput {
	return o
}

func (o ClusterTrustBundleSpecPatchOutput) ToClusterTrustBundleSpecPatchPtrOutput() ClusterTrustBundleSpecPatchPtrOutput {
	return o.ToClusterTrustBundleSpecPatchPtrOutputWithContext(context.Background())
}

func (o ClusterTrustBundleSpecPatchOutput) ToClusterTrustBundleSpecPatchPtrOutputWithContext(ctx context.Context) ClusterTrustBundleSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterTrustBundleSpecPatch) *ClusterTrustBundleSpecPatch {
		return &v
	}).(ClusterTrustBundleSpecPatchPtrOutput)
}

// signerName indicates the associated signer, if any.
//
// In order to create or update a ClusterTrustBundle that sets signerName, you must have the following cluster-scoped permission: group=certificates.k8s.io resource=signers resourceName=<the signer name> verb=attest.
//
// If signerName is not empty, then the ClusterTrustBundle object must be named with the signer name as a prefix (translating slashes to colons). For example, for the signer name `example.com/foo`, valid ClusterTrustBundle object names include `example.com:foo:abc` and `example.com:foo:v1`.
//
// If signerName is empty, then the ClusterTrustBundle object's name must not have such a prefix.
//
// List/watch requests for ClusterTrustBundles can filter on this field using a `spec.signerName=NAME` field selector.
func (o ClusterTrustBundleSpecPatchOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundleSpecPatch) *string { return v.SignerName }).(pulumi.StringPtrOutput)
}

// trustBundle contains the individual X.509 trust anchors for this bundle, as PEM bundle of PEM-wrapped, DER-formatted X.509 certificates.
//
// The data must consist only of PEM certificate blocks that parse as valid X.509 certificates.  Each certificate must include a basic constraints extension with the CA bit set.  The API server will reject objects that contain duplicate certificates, or that use PEM block headers.
//
// Users of ClusterTrustBundles, including Kubelet, are free to reorder and deduplicate certificate blocks in this file according to their own logic, as well as to drop PEM block headers and inter-block data.
func (o ClusterTrustBundleSpecPatchOutput) TrustBundle() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTrustBundleSpecPatch) *string { return v.TrustBundle }).(pulumi.StringPtrOutput)
}

type ClusterTrustBundleSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (ClusterTrustBundleSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterTrustBundleSpecPatch)(nil)).Elem()
}

func (o ClusterTrustBundleSpecPatchPtrOutput) ToClusterTrustBundleSpecPatchPtrOutput() ClusterTrustBundleSpecPatchPtrOutput {
	return o
}

func (o ClusterTrustBundleSpecPatchPtrOutput) ToClusterTrustBundleSpecPatchPtrOutputWithContext(ctx context.Context) ClusterTrustBundleSpecPatchPtrOutput {
	return o
}

func (o ClusterTrustBundleSpecPatchPtrOutput) Elem() ClusterTrustBundleSpecPatchOutput {
	return o.ApplyT(func(v *ClusterTrustBundleSpecPatch) ClusterTrustBundleSpecPatch {
		if v != nil {
			return *v
		}
		var ret ClusterTrustBundleSpecPatch
		return ret
	}).(ClusterTrustBundleSpecPatchOutput)
}

// signerName indicates the associated signer, if any.
//
// In order to create or update a ClusterTrustBundle that sets signerName, you must have the following cluster-scoped permission: group=certificates.k8s.io resource=signers resourceName=<the signer name> verb=attest.
//
// If signerName is not empty, then the ClusterTrustBundle object must be named with the signer name as a prefix (translating slashes to colons). For example, for the signer name `example.com/foo`, valid ClusterTrustBundle object names include `example.com:foo:abc` and `example.com:foo:v1`.
//
// If signerName is empty, then the ClusterTrustBundle object's name must not have such a prefix.
//
// List/watch requests for ClusterTrustBundles can filter on this field using a `spec.signerName=NAME` field selector.
func (o ClusterTrustBundleSpecPatchPtrOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterTrustBundleSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.SignerName
	}).(pulumi.StringPtrOutput)
}

// trustBundle contains the individual X.509 trust anchors for this bundle, as PEM bundle of PEM-wrapped, DER-formatted X.509 certificates.
//
// The data must consist only of PEM certificate blocks that parse as valid X.509 certificates.  Each certificate must include a basic constraints extension with the CA bit set.  The API server will reject objects that contain duplicate certificates, or that use PEM block headers.
//
// Users of ClusterTrustBundles, including Kubelet, are free to reorder and deduplicate certificate blocks in this file according to their own logic, as well as to drop PEM block headers and inter-block data.
func (o ClusterTrustBundleSpecPatchPtrOutput) TrustBundle() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterTrustBundleSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.TrustBundle
	}).(pulumi.StringPtrOutput)
}

// PodCertificateRequest encodes a pod requesting a certificate from a given signer.
//
// Kubelets use this API to implement podCertificate projected volumes
type PodCertificateRequestType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// metadata contains the object metadata.
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// spec contains the details about the certificate being requested.
	Spec PodCertificateRequestSpec `pulumi:"spec"`
	// status contains the issued certificate, and a standard set of conditions.
	Status *PodCertificateRequestStatus `pulumi:"status"`
}

// PodCertificateRequestTypeInput is an input type that accepts PodCertificateRequestTypeArgs and PodCertificateRequestTypeOutput values.
// You can construct a concrete instance of `PodCertificateRequestTypeInput` via:
//
//	PodCertificateRequestTypeArgs{...}
type PodCertificateRequestTypeInput interface {
	pulumi.Input

	ToPodCertificateRequestTypeOutput() PodCertificateRequestTypeOutput
	ToPodCertificateRequestTypeOutputWithContext(context.Context) PodCertificateRequestTypeOutput
}

// PodCertificateRequest encodes a pod requesting a certificate from a given signer.
//
// Kubelets use this API to implement podCertificate projected volumes
type PodCertificateRequestTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// metadata contains the object metadata.
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// spec contains the details about the certificate being requested.
	Spec PodCertificateRequestSpecInput `pulumi:"spec"`
	// status contains the issued certificate, and a standard set of conditions.
	Status PodCertificateRequestStatusPtrInput `pulumi:"status"`
}

func (PodCertificateRequestTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestType)(nil)).Elem()
}

func (i PodCertificateRequestTypeArgs) ToPodCertificateRequestTypeOutput() PodCertificateRequestTypeOutput {
	return i.ToPodCertificateRequestTypeOutputWithContext(context.Background())
}

func (i PodCertificateRequestTypeArgs) ToPodCertificateRequestTypeOutputWithContext(ctx context.Context) PodCertificateRequestTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestTypeOutput)
}

// PodCertificateRequestTypeArrayInput is an input type that accepts PodCertificateRequestTypeArray and PodCertificateRequestTypeArrayOutput values.
// You can construct a concrete instance of `PodCertificateRequestTypeArrayInput` via:
//
//	PodCertificateRequestTypeArray{ PodCertificateRequestTypeArgs{...} }
type PodCertificateRequestTypeArrayInput interface {
	pulumi.Input

	ToPodCertificateRequestTypeArrayOutput() PodCertificateRequestTypeArrayOutput
	ToPodCertificateRequestTypeArrayOutputWithContext(context.Context) PodCertificateRequestTypeArrayOutput
}

type PodCertificateRequestTypeArray []PodCertificateRequestTypeInput

func (PodCertificateRequestTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PodCertificateRequestType)(nil)).Elem()
}

func (i PodCertificateRequestTypeArray) ToPodCertificateRequestTypeArrayOutput() PodCertificateRequestTypeArrayOutput {
	return i.ToPodCertificateRequestTypeArrayOutputWithContext(context.Background())
}

func (i PodCertificateRequestTypeArray) ToPodCertificateRequestTypeArrayOutputWithContext(ctx context.Context) PodCertificateRequestTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestTypeArrayOutput)
}

// PodCertificateRequest encodes a pod requesting a certificate from a given signer.
//
// Kubelets use this API to implement podCertificate projected volumes
type PodCertificateRequestTypeOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestType)(nil)).Elem()
}

func (o PodCertificateRequestTypeOutput) ToPodCertificateRequestTypeOutput() PodCertificateRequestTypeOutput {
	return o
}

func (o PodCertificateRequestTypeOutput) ToPodCertificateRequestTypeOutputWithContext(ctx context.Context) PodCertificateRequestTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodCertificateRequestTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodCertificateRequestTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// metadata contains the object metadata.
func (o PodCertificateRequestTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// spec contains the details about the certificate being requested.
func (o PodCertificateRequestTypeOutput) Spec() PodCertificateRequestSpecOutput {
	return o.ApplyT(func(v PodCertificateRequestType) PodCertificateRequestSpec { return v.Spec }).(PodCertificateRequestSpecOutput)
}

// status contains the issued certificate, and a standard set of conditions.
func (o PodCertificateRequestTypeOutput) Status() PodCertificateRequestStatusPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestType) *PodCertificateRequestStatus { return v.Status }).(PodCertificateRequestStatusPtrOutput)
}

type PodCertificateRequestTypeArrayOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PodCertificateRequestType)(nil)).Elem()
}

func (o PodCertificateRequestTypeArrayOutput) ToPodCertificateRequestTypeArrayOutput() PodCertificateRequestTypeArrayOutput {
	return o
}

func (o PodCertificateRequestTypeArrayOutput) ToPodCertificateRequestTypeArrayOutputWithContext(ctx context.Context) PodCertificateRequestTypeArrayOutput {
	return o
}

func (o PodCertificateRequestTypeArrayOutput) Index(i pulumi.IntInput) PodCertificateRequestTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PodCertificateRequestType {
		return vs[0].([]PodCertificateRequestType)[vs[1].(int)]
	}).(PodCertificateRequestTypeOutput)
}

// PodCertificateRequestList is a collection of PodCertificateRequest objects
type PodCertificateRequestListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// items is a collection of PodCertificateRequest objects
	Items []PodCertificateRequestType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// metadata contains the list metadata.
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// PodCertificateRequestListTypeInput is an input type that accepts PodCertificateRequestListTypeArgs and PodCertificateRequestListTypeOutput values.
// You can construct a concrete instance of `PodCertificateRequestListTypeInput` via:
//
//	PodCertificateRequestListTypeArgs{...}
type PodCertificateRequestListTypeInput interface {
	pulumi.Input

	ToPodCertificateRequestListTypeOutput() PodCertificateRequestListTypeOutput
	ToPodCertificateRequestListTypeOutputWithContext(context.Context) PodCertificateRequestListTypeOutput
}

// PodCertificateRequestList is a collection of PodCertificateRequest objects
type PodCertificateRequestListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// items is a collection of PodCertificateRequest objects
	Items PodCertificateRequestTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// metadata contains the list metadata.
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (PodCertificateRequestListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestListType)(nil)).Elem()
}

func (i PodCertificateRequestListTypeArgs) ToPodCertificateRequestListTypeOutput() PodCertificateRequestListTypeOutput {
	return i.ToPodCertificateRequestListTypeOutputWithContext(context.Background())
}

func (i PodCertificateRequestListTypeArgs) ToPodCertificateRequestListTypeOutputWithContext(ctx context.Context) PodCertificateRequestListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestListTypeOutput)
}

// PodCertificateRequestList is a collection of PodCertificateRequest objects
type PodCertificateRequestListTypeOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestListType)(nil)).Elem()
}

func (o PodCertificateRequestListTypeOutput) ToPodCertificateRequestListTypeOutput() PodCertificateRequestListTypeOutput {
	return o
}

func (o PodCertificateRequestListTypeOutput) ToPodCertificateRequestListTypeOutputWithContext(ctx context.Context) PodCertificateRequestListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodCertificateRequestListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// items is a collection of PodCertificateRequest objects
func (o PodCertificateRequestListTypeOutput) Items() PodCertificateRequestTypeArrayOutput {
	return o.ApplyT(func(v PodCertificateRequestListType) []PodCertificateRequestType { return v.Items }).(PodCertificateRequestTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodCertificateRequestListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// metadata contains the list metadata.
func (o PodCertificateRequestListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// PodCertificateRequest encodes a pod requesting a certificate from a given signer.
//
// Kubelets use this API to implement podCertificate projected volumes
type PodCertificateRequestPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// metadata contains the object metadata.
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// spec contains the details about the certificate being requested.
	Spec *PodCertificateRequestSpecPatch `pulumi:"spec"`
	// status contains the issued certificate, and a standard set of conditions.
	Status *PodCertificateRequestStatusPatch `pulumi:"status"`
}

// PodCertificateRequestPatchTypeInput is an input type that accepts PodCertificateRequestPatchTypeArgs and PodCertificateRequestPatchTypeOutput values.
// You can construct a concrete instance of `PodCertificateRequestPatchTypeInput` via:
//
//	PodCertificateRequestPatchTypeArgs{...}
type PodCertificateRequestPatchTypeInput interface {
	pulumi.Input

	ToPodCertificateRequestPatchTypeOutput() PodCertificateRequestPatchTypeOutput
	ToPodCertificateRequestPatchTypeOutputWithContext(context.Context) PodCertificateRequestPatchTypeOutput
}

// PodCertificateRequest encodes a pod requesting a certificate from a given signer.
//
// Kubelets use this API to implement podCertificate projected volumes
type PodCertificateRequestPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// metadata contains the object metadata.
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// spec contains the details about the certificate being requested.
	Spec PodCertificateRequestSpecPatchPtrInput `pulumi:"spec"`
	// status contains the issued certificate, and a standard set of conditions.
	Status PodCertificateRequestStatusPatchPtrInput `pulumi:"status"`
}

func (PodCertificateRequestPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestPatchType)(nil)).Elem()
}

func (i PodCertificateRequestPatchTypeArgs) ToPodCertificateRequestPatchTypeOutput() PodCertificateRequestPatchTypeOutput {
	return i.ToPodCertificateRequestPatchTypeOutputWithContext(context.Background())
}

func (i PodCertificateRequestPatchTypeArgs) ToPodCertificateRequestPatchTypeOutputWithContext(ctx context.Context) PodCertificateRequestPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestPatchTypeOutput)
}

// PodCertificateRequest encodes a pod requesting a certificate from a given signer.
//
// Kubelets use this API to implement podCertificate projected volumes
type PodCertificateRequestPatchTypeOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestPatchType)(nil)).Elem()
}

func (o PodCertificateRequestPatchTypeOutput) ToPodCertificateRequestPatchTypeOutput() PodCertificateRequestPatchTypeOutput {
	return o
}

func (o PodCertificateRequestPatchTypeOutput) ToPodCertificateRequestPatchTypeOutputWithContext(ctx context.Context) PodCertificateRequestPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodCertificateRequestPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodCertificateRequestPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// metadata contains the object metadata.
func (o PodCertificateRequestPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// spec contains the details about the certificate being requested.
func (o PodCertificateRequestPatchTypeOutput) Spec() PodCertificateRequestSpecPatchPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestPatchType) *PodCertificateRequestSpecPatch { return v.Spec }).(PodCertificateRequestSpecPatchPtrOutput)
}

// status contains the issued certificate, and a standard set of conditions.
func (o PodCertificateRequestPatchTypeOutput) Status() PodCertificateRequestStatusPatchPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestPatchType) *PodCertificateRequestStatusPatch { return v.Status }).(PodCertificateRequestStatusPatchPtrOutput)
}

// PodCertificateRequestSpec describes the certificate request.  All fields are immutable after creation.
type PodCertificateRequestSpec struct {
	// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
	//
	// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
	//
	// The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
	MaxExpirationSeconds *int `pulumi:"maxExpirationSeconds"`
	// nodeName is the name of the node the pod is assigned to.
	NodeName string `pulumi:"nodeName"`
	// nodeUID is the UID of the node the pod is assigned to.
	NodeUID string `pulumi:"nodeUID"`
	// pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
	//
	// The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
	//
	// Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of "Denied" and a reason of "UnsupportedKeyType". It may also suggest a key type that it does support in the message field.
	PkixPublicKey string `pulumi:"pkixPublicKey"`
	// podName is the name of the pod into which the certificate will be mounted.
	PodName string `pulumi:"podName"`
	// podUID is the UID of the pod into which the certificate will be mounted.
	PodUID string `pulumi:"podUID"`
	// proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
	//
	// It is contructed by signing the ASCII bytes of the pod's UID using `pkixPublicKey`.
	//
	// kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
	//
	// If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
	//
	// If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
	//
	// If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
	ProofOfPossession string `pulumi:"proofOfPossession"`
	// serviceAccountName is the name of the service account the pod is running as.
	ServiceAccountName string `pulumi:"serviceAccountName"`
	// serviceAccountUID is the UID of the service account the pod is running as.
	ServiceAccountUID string `pulumi:"serviceAccountUID"`
	// signerName indicates the requested signer.
	//
	// All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
	SignerName string `pulumi:"signerName"`
	// unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
	//
	// Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
	//
	// Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
	UnverifiedUserAnnotations map[string]string `pulumi:"unverifiedUserAnnotations"`
}

// PodCertificateRequestSpecInput is an input type that accepts PodCertificateRequestSpecArgs and PodCertificateRequestSpecOutput values.
// You can construct a concrete instance of `PodCertificateRequestSpecInput` via:
//
//	PodCertificateRequestSpecArgs{...}
type PodCertificateRequestSpecInput interface {
	pulumi.Input

	ToPodCertificateRequestSpecOutput() PodCertificateRequestSpecOutput
	ToPodCertificateRequestSpecOutputWithContext(context.Context) PodCertificateRequestSpecOutput
}

// PodCertificateRequestSpec describes the certificate request.  All fields are immutable after creation.
type PodCertificateRequestSpecArgs struct {
	// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
	//
	// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
	//
	// The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
	MaxExpirationSeconds pulumi.IntPtrInput `pulumi:"maxExpirationSeconds"`
	// nodeName is the name of the node the pod is assigned to.
	NodeName pulumi.StringInput `pulumi:"nodeName"`
	// nodeUID is the UID of the node the pod is assigned to.
	NodeUID pulumi.StringInput `pulumi:"nodeUID"`
	// pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
	//
	// The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
	//
	// Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of "Denied" and a reason of "UnsupportedKeyType". It may also suggest a key type that it does support in the message field.
	PkixPublicKey pulumi.StringInput `pulumi:"pkixPublicKey"`
	// podName is the name of the pod into which the certificate will be mounted.
	PodName pulumi.StringInput `pulumi:"podName"`
	// podUID is the UID of the pod into which the certificate will be mounted.
	PodUID pulumi.StringInput `pulumi:"podUID"`
	// proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
	//
	// It is contructed by signing the ASCII bytes of the pod's UID using `pkixPublicKey`.
	//
	// kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
	//
	// If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
	//
	// If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
	//
	// If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
	ProofOfPossession pulumi.StringInput `pulumi:"proofOfPossession"`
	// serviceAccountName is the name of the service account the pod is running as.
	ServiceAccountName pulumi.StringInput `pulumi:"serviceAccountName"`
	// serviceAccountUID is the UID of the service account the pod is running as.
	ServiceAccountUID pulumi.StringInput `pulumi:"serviceAccountUID"`
	// signerName indicates the requested signer.
	//
	// All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
	SignerName pulumi.StringInput `pulumi:"signerName"`
	// unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
	//
	// Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
	//
	// Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
	UnverifiedUserAnnotations pulumi.StringMapInput `pulumi:"unverifiedUserAnnotations"`
}

func (PodCertificateRequestSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestSpec)(nil)).Elem()
}

func (i PodCertificateRequestSpecArgs) ToPodCertificateRequestSpecOutput() PodCertificateRequestSpecOutput {
	return i.ToPodCertificateRequestSpecOutputWithContext(context.Background())
}

func (i PodCertificateRequestSpecArgs) ToPodCertificateRequestSpecOutputWithContext(ctx context.Context) PodCertificateRequestSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestSpecOutput)
}

// PodCertificateRequestSpec describes the certificate request.  All fields are immutable after creation.
type PodCertificateRequestSpecOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestSpec)(nil)).Elem()
}

func (o PodCertificateRequestSpecOutput) ToPodCertificateRequestSpecOutput() PodCertificateRequestSpecOutput {
	return o
}

func (o PodCertificateRequestSpecOutput) ToPodCertificateRequestSpecOutputWithContext(ctx context.Context) PodCertificateRequestSpecOutput {
	return o
}

// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
//
// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
//
// The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
func (o PodCertificateRequestSpecOutput) MaxExpirationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) *int { return v.MaxExpirationSeconds }).(pulumi.IntPtrOutput)
}

// nodeName is the name of the node the pod is assigned to.
func (o PodCertificateRequestSpecOutput) NodeName() pulumi.StringOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) string { return v.NodeName }).(pulumi.StringOutput)
}

// nodeUID is the UID of the node the pod is assigned to.
func (o PodCertificateRequestSpecOutput) NodeUID() pulumi.StringOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) string { return v.NodeUID }).(pulumi.StringOutput)
}

// pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
//
// The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
//
// Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of "Denied" and a reason of "UnsupportedKeyType". It may also suggest a key type that it does support in the message field.
func (o PodCertificateRequestSpecOutput) PkixPublicKey() pulumi.StringOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) string { return v.PkixPublicKey }).(pulumi.StringOutput)
}

// podName is the name of the pod into which the certificate will be mounted.
func (o PodCertificateRequestSpecOutput) PodName() pulumi.StringOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) string { return v.PodName }).(pulumi.StringOutput)
}

// podUID is the UID of the pod into which the certificate will be mounted.
func (o PodCertificateRequestSpecOutput) PodUID() pulumi.StringOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) string { return v.PodUID }).(pulumi.StringOutput)
}

// proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
//
// It is contructed by signing the ASCII bytes of the pod's UID using `pkixPublicKey`.
//
// kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
//
// If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
//
// If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
//
// If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
func (o PodCertificateRequestSpecOutput) ProofOfPossession() pulumi.StringOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) string { return v.ProofOfPossession }).(pulumi.StringOutput)
}

// serviceAccountName is the name of the service account the pod is running as.
func (o PodCertificateRequestSpecOutput) ServiceAccountName() pulumi.StringOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) string { return v.ServiceAccountName }).(pulumi.StringOutput)
}

// serviceAccountUID is the UID of the service account the pod is running as.
func (o PodCertificateRequestSpecOutput) ServiceAccountUID() pulumi.StringOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) string { return v.ServiceAccountUID }).(pulumi.StringOutput)
}

// signerName indicates the requested signer.
//
// All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
func (o PodCertificateRequestSpecOutput) SignerName() pulumi.StringOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) string { return v.SignerName }).(pulumi.StringOutput)
}

// unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
//
// Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
//
// Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
func (o PodCertificateRequestSpecOutput) UnverifiedUserAnnotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v PodCertificateRequestSpec) map[string]string { return v.UnverifiedUserAnnotations }).(pulumi.StringMapOutput)
}

// PodCertificateRequestSpec describes the certificate request.  All fields are immutable after creation.
type PodCertificateRequestSpecPatch struct {
	// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
	//
	// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
	//
	// The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
	MaxExpirationSeconds *int `pulumi:"maxExpirationSeconds"`
	// nodeName is the name of the node the pod is assigned to.
	NodeName *string `pulumi:"nodeName"`
	// nodeUID is the UID of the node the pod is assigned to.
	NodeUID *string `pulumi:"nodeUID"`
	// pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
	//
	// The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
	//
	// Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of "Denied" and a reason of "UnsupportedKeyType". It may also suggest a key type that it does support in the message field.
	PkixPublicKey *string `pulumi:"pkixPublicKey"`
	// podName is the name of the pod into which the certificate will be mounted.
	PodName *string `pulumi:"podName"`
	// podUID is the UID of the pod into which the certificate will be mounted.
	PodUID *string `pulumi:"podUID"`
	// proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
	//
	// It is contructed by signing the ASCII bytes of the pod's UID using `pkixPublicKey`.
	//
	// kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
	//
	// If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
	//
	// If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
	//
	// If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
	ProofOfPossession *string `pulumi:"proofOfPossession"`
	// serviceAccountName is the name of the service account the pod is running as.
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// serviceAccountUID is the UID of the service account the pod is running as.
	ServiceAccountUID *string `pulumi:"serviceAccountUID"`
	// signerName indicates the requested signer.
	//
	// All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
	SignerName *string `pulumi:"signerName"`
	// unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
	//
	// Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
	//
	// Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
	UnverifiedUserAnnotations map[string]string `pulumi:"unverifiedUserAnnotations"`
}

// PodCertificateRequestSpecPatchInput is an input type that accepts PodCertificateRequestSpecPatchArgs and PodCertificateRequestSpecPatchOutput values.
// You can construct a concrete instance of `PodCertificateRequestSpecPatchInput` via:
//
//	PodCertificateRequestSpecPatchArgs{...}
type PodCertificateRequestSpecPatchInput interface {
	pulumi.Input

	ToPodCertificateRequestSpecPatchOutput() PodCertificateRequestSpecPatchOutput
	ToPodCertificateRequestSpecPatchOutputWithContext(context.Context) PodCertificateRequestSpecPatchOutput
}

// PodCertificateRequestSpec describes the certificate request.  All fields are immutable after creation.
type PodCertificateRequestSpecPatchArgs struct {
	// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
	//
	// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
	//
	// The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
	MaxExpirationSeconds pulumi.IntPtrInput `pulumi:"maxExpirationSeconds"`
	// nodeName is the name of the node the pod is assigned to.
	NodeName pulumi.StringPtrInput `pulumi:"nodeName"`
	// nodeUID is the UID of the node the pod is assigned to.
	NodeUID pulumi.StringPtrInput `pulumi:"nodeUID"`
	// pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
	//
	// The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
	//
	// Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of "Denied" and a reason of "UnsupportedKeyType". It may also suggest a key type that it does support in the message field.
	PkixPublicKey pulumi.StringPtrInput `pulumi:"pkixPublicKey"`
	// podName is the name of the pod into which the certificate will be mounted.
	PodName pulumi.StringPtrInput `pulumi:"podName"`
	// podUID is the UID of the pod into which the certificate will be mounted.
	PodUID pulumi.StringPtrInput `pulumi:"podUID"`
	// proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
	//
	// It is contructed by signing the ASCII bytes of the pod's UID using `pkixPublicKey`.
	//
	// kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
	//
	// If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
	//
	// If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
	//
	// If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
	ProofOfPossession pulumi.StringPtrInput `pulumi:"proofOfPossession"`
	// serviceAccountName is the name of the service account the pod is running as.
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// serviceAccountUID is the UID of the service account the pod is running as.
	ServiceAccountUID pulumi.StringPtrInput `pulumi:"serviceAccountUID"`
	// signerName indicates the requested signer.
	//
	// All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
	SignerName pulumi.StringPtrInput `pulumi:"signerName"`
	// unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
	//
	// Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
	//
	// Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
	UnverifiedUserAnnotations pulumi.StringMapInput `pulumi:"unverifiedUserAnnotations"`
}

func (PodCertificateRequestSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestSpecPatch)(nil)).Elem()
}

func (i PodCertificateRequestSpecPatchArgs) ToPodCertificateRequestSpecPatchOutput() PodCertificateRequestSpecPatchOutput {
	return i.ToPodCertificateRequestSpecPatchOutputWithContext(context.Background())
}

func (i PodCertificateRequestSpecPatchArgs) ToPodCertificateRequestSpecPatchOutputWithContext(ctx context.Context) PodCertificateRequestSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestSpecPatchOutput)
}

func (i PodCertificateRequestSpecPatchArgs) ToPodCertificateRequestSpecPatchPtrOutput() PodCertificateRequestSpecPatchPtrOutput {
	return i.ToPodCertificateRequestSpecPatchPtrOutputWithContext(context.Background())
}

func (i PodCertificateRequestSpecPatchArgs) ToPodCertificateRequestSpecPatchPtrOutputWithContext(ctx context.Context) PodCertificateRequestSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestSpecPatchOutput).ToPodCertificateRequestSpecPatchPtrOutputWithContext(ctx)
}

// PodCertificateRequestSpecPatchPtrInput is an input type that accepts PodCertificateRequestSpecPatchArgs, PodCertificateRequestSpecPatchPtr and PodCertificateRequestSpecPatchPtrOutput values.
// You can construct a concrete instance of `PodCertificateRequestSpecPatchPtrInput` via:
//
//	        PodCertificateRequestSpecPatchArgs{...}
//
//	or:
//
//	        nil
type PodCertificateRequestSpecPatchPtrInput interface {
	pulumi.Input

	ToPodCertificateRequestSpecPatchPtrOutput() PodCertificateRequestSpecPatchPtrOutput
	ToPodCertificateRequestSpecPatchPtrOutputWithContext(context.Context) PodCertificateRequestSpecPatchPtrOutput
}

type podCertificateRequestSpecPatchPtrType PodCertificateRequestSpecPatchArgs

func PodCertificateRequestSpecPatchPtr(v *PodCertificateRequestSpecPatchArgs) PodCertificateRequestSpecPatchPtrInput {
	return (*podCertificateRequestSpecPatchPtrType)(v)
}

func (*podCertificateRequestSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodCertificateRequestSpecPatch)(nil)).Elem()
}

func (i *podCertificateRequestSpecPatchPtrType) ToPodCertificateRequestSpecPatchPtrOutput() PodCertificateRequestSpecPatchPtrOutput {
	return i.ToPodCertificateRequestSpecPatchPtrOutputWithContext(context.Background())
}

func (i *podCertificateRequestSpecPatchPtrType) ToPodCertificateRequestSpecPatchPtrOutputWithContext(ctx context.Context) PodCertificateRequestSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestSpecPatchPtrOutput)
}

// PodCertificateRequestSpec describes the certificate request.  All fields are immutable after creation.
type PodCertificateRequestSpecPatchOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestSpecPatch)(nil)).Elem()
}

func (o PodCertificateRequestSpecPatchOutput) ToPodCertificateRequestSpecPatchOutput() PodCertificateRequestSpecPatchOutput {
	return o
}

func (o PodCertificateRequestSpecPatchOutput) ToPodCertificateRequestSpecPatchOutputWithContext(ctx context.Context) PodCertificateRequestSpecPatchOutput {
	return o
}

func (o PodCertificateRequestSpecPatchOutput) ToPodCertificateRequestSpecPatchPtrOutput() PodCertificateRequestSpecPatchPtrOutput {
	return o.ToPodCertificateRequestSpecPatchPtrOutputWithContext(context.Background())
}

func (o PodCertificateRequestSpecPatchOutput) ToPodCertificateRequestSpecPatchPtrOutputWithContext(ctx context.Context) PodCertificateRequestSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodCertificateRequestSpecPatch) *PodCertificateRequestSpecPatch {
		return &v
	}).(PodCertificateRequestSpecPatchPtrOutput)
}

// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
//
// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
//
// The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
func (o PodCertificateRequestSpecPatchOutput) MaxExpirationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *int { return v.MaxExpirationSeconds }).(pulumi.IntPtrOutput)
}

// nodeName is the name of the node the pod is assigned to.
func (o PodCertificateRequestSpecPatchOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *string { return v.NodeName }).(pulumi.StringPtrOutput)
}

// nodeUID is the UID of the node the pod is assigned to.
func (o PodCertificateRequestSpecPatchOutput) NodeUID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *string { return v.NodeUID }).(pulumi.StringPtrOutput)
}

// pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
//
// The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
//
// Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of "Denied" and a reason of "UnsupportedKeyType". It may also suggest a key type that it does support in the message field.
func (o PodCertificateRequestSpecPatchOutput) PkixPublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *string { return v.PkixPublicKey }).(pulumi.StringPtrOutput)
}

// podName is the name of the pod into which the certificate will be mounted.
func (o PodCertificateRequestSpecPatchOutput) PodName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *string { return v.PodName }).(pulumi.StringPtrOutput)
}

// podUID is the UID of the pod into which the certificate will be mounted.
func (o PodCertificateRequestSpecPatchOutput) PodUID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *string { return v.PodUID }).(pulumi.StringPtrOutput)
}

// proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
//
// It is contructed by signing the ASCII bytes of the pod's UID using `pkixPublicKey`.
//
// kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
//
// If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
//
// If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
//
// If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
func (o PodCertificateRequestSpecPatchOutput) ProofOfPossession() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *string { return v.ProofOfPossession }).(pulumi.StringPtrOutput)
}

// serviceAccountName is the name of the service account the pod is running as.
func (o PodCertificateRequestSpecPatchOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// serviceAccountUID is the UID of the service account the pod is running as.
func (o PodCertificateRequestSpecPatchOutput) ServiceAccountUID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *string { return v.ServiceAccountUID }).(pulumi.StringPtrOutput)
}

// signerName indicates the requested signer.
//
// All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
func (o PodCertificateRequestSpecPatchOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) *string { return v.SignerName }).(pulumi.StringPtrOutput)
}

// unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
//
// Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
//
// Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
func (o PodCertificateRequestSpecPatchOutput) UnverifiedUserAnnotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v PodCertificateRequestSpecPatch) map[string]string { return v.UnverifiedUserAnnotations }).(pulumi.StringMapOutput)
}

type PodCertificateRequestSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodCertificateRequestSpecPatch)(nil)).Elem()
}

func (o PodCertificateRequestSpecPatchPtrOutput) ToPodCertificateRequestSpecPatchPtrOutput() PodCertificateRequestSpecPatchPtrOutput {
	return o
}

func (o PodCertificateRequestSpecPatchPtrOutput) ToPodCertificateRequestSpecPatchPtrOutputWithContext(ctx context.Context) PodCertificateRequestSpecPatchPtrOutput {
	return o
}

func (o PodCertificateRequestSpecPatchPtrOutput) Elem() PodCertificateRequestSpecPatchOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) PodCertificateRequestSpecPatch {
		if v != nil {
			return *v
		}
		var ret PodCertificateRequestSpecPatch
		return ret
	}).(PodCertificateRequestSpecPatchOutput)
}

// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
//
// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
//
// The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
func (o PodCertificateRequestSpecPatchPtrOutput) MaxExpirationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.MaxExpirationSeconds
	}).(pulumi.IntPtrOutput)
}

// nodeName is the name of the node the pod is assigned to.
func (o PodCertificateRequestSpecPatchPtrOutput) NodeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.NodeName
	}).(pulumi.StringPtrOutput)
}

// nodeUID is the UID of the node the pod is assigned to.
func (o PodCertificateRequestSpecPatchPtrOutput) NodeUID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.NodeUID
	}).(pulumi.StringPtrOutput)
}

// pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
//
// The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
//
// Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of "Denied" and a reason of "UnsupportedKeyType". It may also suggest a key type that it does support in the message field.
func (o PodCertificateRequestSpecPatchPtrOutput) PkixPublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.PkixPublicKey
	}).(pulumi.StringPtrOutput)
}

// podName is the name of the pod into which the certificate will be mounted.
func (o PodCertificateRequestSpecPatchPtrOutput) PodName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.PodName
	}).(pulumi.StringPtrOutput)
}

// podUID is the UID of the pod into which the certificate will be mounted.
func (o PodCertificateRequestSpecPatchPtrOutput) PodUID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.PodUID
	}).(pulumi.StringPtrOutput)
}

// proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
//
// It is contructed by signing the ASCII bytes of the pod's UID using `pkixPublicKey`.
//
// kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
//
// If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
//
// If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
//
// If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
func (o PodCertificateRequestSpecPatchPtrOutput) ProofOfPossession() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ProofOfPossession
	}).(pulumi.StringPtrOutput)
}

// serviceAccountName is the name of the service account the pod is running as.
func (o PodCertificateRequestSpecPatchPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// serviceAccountUID is the UID of the service account the pod is running as.
func (o PodCertificateRequestSpecPatchPtrOutput) ServiceAccountUID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountUID
	}).(pulumi.StringPtrOutput)
}

// signerName indicates the requested signer.
//
// All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
func (o PodCertificateRequestSpecPatchPtrOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.SignerName
	}).(pulumi.StringPtrOutput)
}

// unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
//
// Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
//
// Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
func (o PodCertificateRequestSpecPatchPtrOutput) UnverifiedUserAnnotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *PodCertificateRequestSpecPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.UnverifiedUserAnnotations
	}).(pulumi.StringMapOutput)
}

// PodCertificateRequestStatus describes the status of the request, and holds the certificate data if the request is issued.
type PodCertificateRequestStatus struct {
	// beginRefreshAt is the time at which the kubelet should begin trying to refresh the certificate.  This field is set via the /status subresource, and must be set at the same time as certificateChain.  Once populated, this field is immutable.
	//
	// This field is only a hint.  Kubelet may start refreshing before or after this time if necessary.
	BeginRefreshAt *string `pulumi:"beginRefreshAt"`
	// certificateChain is populated with an issued certificate by the signer. This field is set via the /status subresource. Once populated, this field is immutable.
	//
	// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
	//
	// Validation requirements:
	//  1. certificateChain must consist of one or more PEM-formatted certificates.
	//  2. Each entry must be a valid PEM-wrapped, DER-encoded ASN.1 Certificate as
	//     described in section 4 of RFC5280.
	//
	// If more than one block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.  When projecting the chain into a pod volume, kubelet will drop any data in-between the PEM blocks, as well as any PEM block headers.
	CertificateChain *string `pulumi:"certificateChain"`
	// conditions applied to the request.
	//
	// The types "Issued", "Denied", and "Failed" have special handling.  At most one of these conditions may be present, and they must have status "True".
	//
	// If the request is denied with `Reason=UnsupportedKeyType`, the signer may suggest a key type that will work in the message field.
	Conditions []metav1.Condition `pulumi:"conditions"`
	// notAfter is the time at which the certificate expires.  The value must be the same as the notAfter value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable.  The signer must set this field at the same time it sets certificateChain.
	NotAfter *string `pulumi:"notAfter"`
	// notBefore is the time at which the certificate becomes valid.  The value must be the same as the notBefore value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable. The signer must set this field at the same time it sets certificateChain.
	NotBefore *string `pulumi:"notBefore"`
}

// PodCertificateRequestStatusInput is an input type that accepts PodCertificateRequestStatusArgs and PodCertificateRequestStatusOutput values.
// You can construct a concrete instance of `PodCertificateRequestStatusInput` via:
//
//	PodCertificateRequestStatusArgs{...}
type PodCertificateRequestStatusInput interface {
	pulumi.Input

	ToPodCertificateRequestStatusOutput() PodCertificateRequestStatusOutput
	ToPodCertificateRequestStatusOutputWithContext(context.Context) PodCertificateRequestStatusOutput
}

// PodCertificateRequestStatus describes the status of the request, and holds the certificate data if the request is issued.
type PodCertificateRequestStatusArgs struct {
	// beginRefreshAt is the time at which the kubelet should begin trying to refresh the certificate.  This field is set via the /status subresource, and must be set at the same time as certificateChain.  Once populated, this field is immutable.
	//
	// This field is only a hint.  Kubelet may start refreshing before or after this time if necessary.
	BeginRefreshAt pulumi.StringPtrInput `pulumi:"beginRefreshAt"`
	// certificateChain is populated with an issued certificate by the signer. This field is set via the /status subresource. Once populated, this field is immutable.
	//
	// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
	//
	// Validation requirements:
	//  1. certificateChain must consist of one or more PEM-formatted certificates.
	//  2. Each entry must be a valid PEM-wrapped, DER-encoded ASN.1 Certificate as
	//     described in section 4 of RFC5280.
	//
	// If more than one block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.  When projecting the chain into a pod volume, kubelet will drop any data in-between the PEM blocks, as well as any PEM block headers.
	CertificateChain pulumi.StringPtrInput `pulumi:"certificateChain"`
	// conditions applied to the request.
	//
	// The types "Issued", "Denied", and "Failed" have special handling.  At most one of these conditions may be present, and they must have status "True".
	//
	// If the request is denied with `Reason=UnsupportedKeyType`, the signer may suggest a key type that will work in the message field.
	Conditions metav1.ConditionArrayInput `pulumi:"conditions"`
	// notAfter is the time at which the certificate expires.  The value must be the same as the notAfter value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable.  The signer must set this field at the same time it sets certificateChain.
	NotAfter pulumi.StringPtrInput `pulumi:"notAfter"`
	// notBefore is the time at which the certificate becomes valid.  The value must be the same as the notBefore value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable. The signer must set this field at the same time it sets certificateChain.
	NotBefore pulumi.StringPtrInput `pulumi:"notBefore"`
}

func (PodCertificateRequestStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestStatus)(nil)).Elem()
}

func (i PodCertificateRequestStatusArgs) ToPodCertificateRequestStatusOutput() PodCertificateRequestStatusOutput {
	return i.ToPodCertificateRequestStatusOutputWithContext(context.Background())
}

func (i PodCertificateRequestStatusArgs) ToPodCertificateRequestStatusOutputWithContext(ctx context.Context) PodCertificateRequestStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestStatusOutput)
}

func (i PodCertificateRequestStatusArgs) ToPodCertificateRequestStatusPtrOutput() PodCertificateRequestStatusPtrOutput {
	return i.ToPodCertificateRequestStatusPtrOutputWithContext(context.Background())
}

func (i PodCertificateRequestStatusArgs) ToPodCertificateRequestStatusPtrOutputWithContext(ctx context.Context) PodCertificateRequestStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestStatusOutput).ToPodCertificateRequestStatusPtrOutputWithContext(ctx)
}

// PodCertificateRequestStatusPtrInput is an input type that accepts PodCertificateRequestStatusArgs, PodCertificateRequestStatusPtr and PodCertificateRequestStatusPtrOutput values.
// You can construct a concrete instance of `PodCertificateRequestStatusPtrInput` via:
//
//	        PodCertificateRequestStatusArgs{...}
//
//	or:
//
//	        nil
type PodCertificateRequestStatusPtrInput interface {
	pulumi.Input

	ToPodCertificateRequestStatusPtrOutput() PodCertificateRequestStatusPtrOutput
	ToPodCertificateRequestStatusPtrOutputWithContext(context.Context) PodCertificateRequestStatusPtrOutput
}

type podCertificateRequestStatusPtrType PodCertificateRequestStatusArgs

func PodCertificateRequestStatusPtr(v *PodCertificateRequestStatusArgs) PodCertificateRequestStatusPtrInput {
	return (*podCertificateRequestStatusPtrType)(v)
}

func (*podCertificateRequestStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodCertificateRequestStatus)(nil)).Elem()
}

func (i *podCertificateRequestStatusPtrType) ToPodCertificateRequestStatusPtrOutput() PodCertificateRequestStatusPtrOutput {
	return i.ToPodCertificateRequestStatusPtrOutputWithContext(context.Background())
}

func (i *podCertificateRequestStatusPtrType) ToPodCertificateRequestStatusPtrOutputWithContext(ctx context.Context) PodCertificateRequestStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestStatusPtrOutput)
}

// PodCertificateRequestStatus describes the status of the request, and holds the certificate data if the request is issued.
type PodCertificateRequestStatusOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestStatus)(nil)).Elem()
}

func (o PodCertificateRequestStatusOutput) ToPodCertificateRequestStatusOutput() PodCertificateRequestStatusOutput {
	return o
}

func (o PodCertificateRequestStatusOutput) ToPodCertificateRequestStatusOutputWithContext(ctx context.Context) PodCertificateRequestStatusOutput {
	return o
}

func (o PodCertificateRequestStatusOutput) ToPodCertificateRequestStatusPtrOutput() PodCertificateRequestStatusPtrOutput {
	return o.ToPodCertificateRequestStatusPtrOutputWithContext(context.Background())
}

func (o PodCertificateRequestStatusOutput) ToPodCertificateRequestStatusPtrOutputWithContext(ctx context.Context) PodCertificateRequestStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodCertificateRequestStatus) *PodCertificateRequestStatus {
		return &v
	}).(PodCertificateRequestStatusPtrOutput)
}

// beginRefreshAt is the time at which the kubelet should begin trying to refresh the certificate.  This field is set via the /status subresource, and must be set at the same time as certificateChain.  Once populated, this field is immutable.
//
// This field is only a hint.  Kubelet may start refreshing before or after this time if necessary.
func (o PodCertificateRequestStatusOutput) BeginRefreshAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestStatus) *string { return v.BeginRefreshAt }).(pulumi.StringPtrOutput)
}

// certificateChain is populated with an issued certificate by the signer. This field is set via the /status subresource. Once populated, this field is immutable.
//
// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
//
// Validation requirements:
//  1. certificateChain must consist of one or more PEM-formatted certificates.
//  2. Each entry must be a valid PEM-wrapped, DER-encoded ASN.1 Certificate as
//     described in section 4 of RFC5280.
//
// If more than one block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.  When projecting the chain into a pod volume, kubelet will drop any data in-between the PEM blocks, as well as any PEM block headers.
func (o PodCertificateRequestStatusOutput) CertificateChain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestStatus) *string { return v.CertificateChain }).(pulumi.StringPtrOutput)
}

// conditions applied to the request.
//
// The types "Issued", "Denied", and "Failed" have special handling.  At most one of these conditions may be present, and they must have status "True".
//
// If the request is denied with `Reason=UnsupportedKeyType`, the signer may suggest a key type that will work in the message field.
func (o PodCertificateRequestStatusOutput) Conditions() metav1.ConditionArrayOutput {
	return o.ApplyT(func(v PodCertificateRequestStatus) []metav1.Condition { return v.Conditions }).(metav1.ConditionArrayOutput)
}

// notAfter is the time at which the certificate expires.  The value must be the same as the notAfter value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable.  The signer must set this field at the same time it sets certificateChain.
func (o PodCertificateRequestStatusOutput) NotAfter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestStatus) *string { return v.NotAfter }).(pulumi.StringPtrOutput)
}

// notBefore is the time at which the certificate becomes valid.  The value must be the same as the notBefore value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable. The signer must set this field at the same time it sets certificateChain.
func (o PodCertificateRequestStatusOutput) NotBefore() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestStatus) *string { return v.NotBefore }).(pulumi.StringPtrOutput)
}

type PodCertificateRequestStatusPtrOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodCertificateRequestStatus)(nil)).Elem()
}

func (o PodCertificateRequestStatusPtrOutput) ToPodCertificateRequestStatusPtrOutput() PodCertificateRequestStatusPtrOutput {
	return o
}

func (o PodCertificateRequestStatusPtrOutput) ToPodCertificateRequestStatusPtrOutputWithContext(ctx context.Context) PodCertificateRequestStatusPtrOutput {
	return o
}

func (o PodCertificateRequestStatusPtrOutput) Elem() PodCertificateRequestStatusOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatus) PodCertificateRequestStatus {
		if v != nil {
			return *v
		}
		var ret PodCertificateRequestStatus
		return ret
	}).(PodCertificateRequestStatusOutput)
}

// beginRefreshAt is the time at which the kubelet should begin trying to refresh the certificate.  This field is set via the /status subresource, and must be set at the same time as certificateChain.  Once populated, this field is immutable.
//
// This field is only a hint.  Kubelet may start refreshing before or after this time if necessary.
func (o PodCertificateRequestStatusPtrOutput) BeginRefreshAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatus) *string {
		if v == nil {
			return nil
		}
		return v.BeginRefreshAt
	}).(pulumi.StringPtrOutput)
}

// certificateChain is populated with an issued certificate by the signer. This field is set via the /status subresource. Once populated, this field is immutable.
//
// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
//
// Validation requirements:
//  1. certificateChain must consist of one or more PEM-formatted certificates.
//  2. Each entry must be a valid PEM-wrapped, DER-encoded ASN.1 Certificate as
//     described in section 4 of RFC5280.
//
// If more than one block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.  When projecting the chain into a pod volume, kubelet will drop any data in-between the PEM blocks, as well as any PEM block headers.
func (o PodCertificateRequestStatusPtrOutput) CertificateChain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatus) *string {
		if v == nil {
			return nil
		}
		return v.CertificateChain
	}).(pulumi.StringPtrOutput)
}

// conditions applied to the request.
//
// The types "Issued", "Denied", and "Failed" have special handling.  At most one of these conditions may be present, and they must have status "True".
//
// If the request is denied with `Reason=UnsupportedKeyType`, the signer may suggest a key type that will work in the message field.
func (o PodCertificateRequestStatusPtrOutput) Conditions() metav1.ConditionArrayOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatus) []metav1.Condition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(metav1.ConditionArrayOutput)
}

// notAfter is the time at which the certificate expires.  The value must be the same as the notAfter value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable.  The signer must set this field at the same time it sets certificateChain.
func (o PodCertificateRequestStatusPtrOutput) NotAfter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatus) *string {
		if v == nil {
			return nil
		}
		return v.NotAfter
	}).(pulumi.StringPtrOutput)
}

// notBefore is the time at which the certificate becomes valid.  The value must be the same as the notBefore value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable. The signer must set this field at the same time it sets certificateChain.
func (o PodCertificateRequestStatusPtrOutput) NotBefore() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatus) *string {
		if v == nil {
			return nil
		}
		return v.NotBefore
	}).(pulumi.StringPtrOutput)
}

// PodCertificateRequestStatus describes the status of the request, and holds the certificate data if the request is issued.
type PodCertificateRequestStatusPatch struct {
	// beginRefreshAt is the time at which the kubelet should begin trying to refresh the certificate.  This field is set via the /status subresource, and must be set at the same time as certificateChain.  Once populated, this field is immutable.
	//
	// This field is only a hint.  Kubelet may start refreshing before or after this time if necessary.
	BeginRefreshAt *string `pulumi:"beginRefreshAt"`
	// certificateChain is populated with an issued certificate by the signer. This field is set via the /status subresource. Once populated, this field is immutable.
	//
	// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
	//
	// Validation requirements:
	//  1. certificateChain must consist of one or more PEM-formatted certificates.
	//  2. Each entry must be a valid PEM-wrapped, DER-encoded ASN.1 Certificate as
	//     described in section 4 of RFC5280.
	//
	// If more than one block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.  When projecting the chain into a pod volume, kubelet will drop any data in-between the PEM blocks, as well as any PEM block headers.
	CertificateChain *string `pulumi:"certificateChain"`
	// conditions applied to the request.
	//
	// The types "Issued", "Denied", and "Failed" have special handling.  At most one of these conditions may be present, and they must have status "True".
	//
	// If the request is denied with `Reason=UnsupportedKeyType`, the signer may suggest a key type that will work in the message field.
	Conditions []metav1.ConditionPatch `pulumi:"conditions"`
	// notAfter is the time at which the certificate expires.  The value must be the same as the notAfter value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable.  The signer must set this field at the same time it sets certificateChain.
	NotAfter *string `pulumi:"notAfter"`
	// notBefore is the time at which the certificate becomes valid.  The value must be the same as the notBefore value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable. The signer must set this field at the same time it sets certificateChain.
	NotBefore *string `pulumi:"notBefore"`
}

// PodCertificateRequestStatusPatchInput is an input type that accepts PodCertificateRequestStatusPatchArgs and PodCertificateRequestStatusPatchOutput values.
// You can construct a concrete instance of `PodCertificateRequestStatusPatchInput` via:
//
//	PodCertificateRequestStatusPatchArgs{...}
type PodCertificateRequestStatusPatchInput interface {
	pulumi.Input

	ToPodCertificateRequestStatusPatchOutput() PodCertificateRequestStatusPatchOutput
	ToPodCertificateRequestStatusPatchOutputWithContext(context.Context) PodCertificateRequestStatusPatchOutput
}

// PodCertificateRequestStatus describes the status of the request, and holds the certificate data if the request is issued.
type PodCertificateRequestStatusPatchArgs struct {
	// beginRefreshAt is the time at which the kubelet should begin trying to refresh the certificate.  This field is set via the /status subresource, and must be set at the same time as certificateChain.  Once populated, this field is immutable.
	//
	// This field is only a hint.  Kubelet may start refreshing before or after this time if necessary.
	BeginRefreshAt pulumi.StringPtrInput `pulumi:"beginRefreshAt"`
	// certificateChain is populated with an issued certificate by the signer. This field is set via the /status subresource. Once populated, this field is immutable.
	//
	// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
	//
	// Validation requirements:
	//  1. certificateChain must consist of one or more PEM-formatted certificates.
	//  2. Each entry must be a valid PEM-wrapped, DER-encoded ASN.1 Certificate as
	//     described in section 4 of RFC5280.
	//
	// If more than one block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.  When projecting the chain into a pod volume, kubelet will drop any data in-between the PEM blocks, as well as any PEM block headers.
	CertificateChain pulumi.StringPtrInput `pulumi:"certificateChain"`
	// conditions applied to the request.
	//
	// The types "Issued", "Denied", and "Failed" have special handling.  At most one of these conditions may be present, and they must have status "True".
	//
	// If the request is denied with `Reason=UnsupportedKeyType`, the signer may suggest a key type that will work in the message field.
	Conditions metav1.ConditionPatchArrayInput `pulumi:"conditions"`
	// notAfter is the time at which the certificate expires.  The value must be the same as the notAfter value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable.  The signer must set this field at the same time it sets certificateChain.
	NotAfter pulumi.StringPtrInput `pulumi:"notAfter"`
	// notBefore is the time at which the certificate becomes valid.  The value must be the same as the notBefore value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable. The signer must set this field at the same time it sets certificateChain.
	NotBefore pulumi.StringPtrInput `pulumi:"notBefore"`
}

func (PodCertificateRequestStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestStatusPatch)(nil)).Elem()
}

func (i PodCertificateRequestStatusPatchArgs) ToPodCertificateRequestStatusPatchOutput() PodCertificateRequestStatusPatchOutput {
	return i.ToPodCertificateRequestStatusPatchOutputWithContext(context.Background())
}

func (i PodCertificateRequestStatusPatchArgs) ToPodCertificateRequestStatusPatchOutputWithContext(ctx context.Context) PodCertificateRequestStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestStatusPatchOutput)
}

func (i PodCertificateRequestStatusPatchArgs) ToPodCertificateRequestStatusPatchPtrOutput() PodCertificateRequestStatusPatchPtrOutput {
	return i.ToPodCertificateRequestStatusPatchPtrOutputWithContext(context.Background())
}

func (i PodCertificateRequestStatusPatchArgs) ToPodCertificateRequestStatusPatchPtrOutputWithContext(ctx context.Context) PodCertificateRequestStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestStatusPatchOutput).ToPodCertificateRequestStatusPatchPtrOutputWithContext(ctx)
}

// PodCertificateRequestStatusPatchPtrInput is an input type that accepts PodCertificateRequestStatusPatchArgs, PodCertificateRequestStatusPatchPtr and PodCertificateRequestStatusPatchPtrOutput values.
// You can construct a concrete instance of `PodCertificateRequestStatusPatchPtrInput` via:
//
//	        PodCertificateRequestStatusPatchArgs{...}
//
//	or:
//
//	        nil
type PodCertificateRequestStatusPatchPtrInput interface {
	pulumi.Input

	ToPodCertificateRequestStatusPatchPtrOutput() PodCertificateRequestStatusPatchPtrOutput
	ToPodCertificateRequestStatusPatchPtrOutputWithContext(context.Context) PodCertificateRequestStatusPatchPtrOutput
}

type podCertificateRequestStatusPatchPtrType PodCertificateRequestStatusPatchArgs

func PodCertificateRequestStatusPatchPtr(v *PodCertificateRequestStatusPatchArgs) PodCertificateRequestStatusPatchPtrInput {
	return (*podCertificateRequestStatusPatchPtrType)(v)
}

func (*podCertificateRequestStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodCertificateRequestStatusPatch)(nil)).Elem()
}

func (i *podCertificateRequestStatusPatchPtrType) ToPodCertificateRequestStatusPatchPtrOutput() PodCertificateRequestStatusPatchPtrOutput {
	return i.ToPodCertificateRequestStatusPatchPtrOutputWithContext(context.Background())
}

func (i *podCertificateRequestStatusPatchPtrType) ToPodCertificateRequestStatusPatchPtrOutputWithContext(ctx context.Context) PodCertificateRequestStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodCertificateRequestStatusPatchPtrOutput)
}

// PodCertificateRequestStatus describes the status of the request, and holds the certificate data if the request is issued.
type PodCertificateRequestStatusPatchOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodCertificateRequestStatusPatch)(nil)).Elem()
}

func (o PodCertificateRequestStatusPatchOutput) ToPodCertificateRequestStatusPatchOutput() PodCertificateRequestStatusPatchOutput {
	return o
}

func (o PodCertificateRequestStatusPatchOutput) ToPodCertificateRequestStatusPatchOutputWithContext(ctx context.Context) PodCertificateRequestStatusPatchOutput {
	return o
}

func (o PodCertificateRequestStatusPatchOutput) ToPodCertificateRequestStatusPatchPtrOutput() PodCertificateRequestStatusPatchPtrOutput {
	return o.ToPodCertificateRequestStatusPatchPtrOutputWithContext(context.Background())
}

func (o PodCertificateRequestStatusPatchOutput) ToPodCertificateRequestStatusPatchPtrOutputWithContext(ctx context.Context) PodCertificateRequestStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodCertificateRequestStatusPatch) *PodCertificateRequestStatusPatch {
		return &v
	}).(PodCertificateRequestStatusPatchPtrOutput)
}

// beginRefreshAt is the time at which the kubelet should begin trying to refresh the certificate.  This field is set via the /status subresource, and must be set at the same time as certificateChain.  Once populated, this field is immutable.
//
// This field is only a hint.  Kubelet may start refreshing before or after this time if necessary.
func (o PodCertificateRequestStatusPatchOutput) BeginRefreshAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestStatusPatch) *string { return v.BeginRefreshAt }).(pulumi.StringPtrOutput)
}

// certificateChain is populated with an issued certificate by the signer. This field is set via the /status subresource. Once populated, this field is immutable.
//
// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
//
// Validation requirements:
//  1. certificateChain must consist of one or more PEM-formatted certificates.
//  2. Each entry must be a valid PEM-wrapped, DER-encoded ASN.1 Certificate as
//     described in section 4 of RFC5280.
//
// If more than one block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.  When projecting the chain into a pod volume, kubelet will drop any data in-between the PEM blocks, as well as any PEM block headers.
func (o PodCertificateRequestStatusPatchOutput) CertificateChain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestStatusPatch) *string { return v.CertificateChain }).(pulumi.StringPtrOutput)
}

// conditions applied to the request.
//
// The types "Issued", "Denied", and "Failed" have special handling.  At most one of these conditions may be present, and they must have status "True".
//
// If the request is denied with `Reason=UnsupportedKeyType`, the signer may suggest a key type that will work in the message field.
func (o PodCertificateRequestStatusPatchOutput) Conditions() metav1.ConditionPatchArrayOutput {
	return o.ApplyT(func(v PodCertificateRequestStatusPatch) []metav1.ConditionPatch { return v.Conditions }).(metav1.ConditionPatchArrayOutput)
}

// notAfter is the time at which the certificate expires.  The value must be the same as the notAfter value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable.  The signer must set this field at the same time it sets certificateChain.
func (o PodCertificateRequestStatusPatchOutput) NotAfter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestStatusPatch) *string { return v.NotAfter }).(pulumi.StringPtrOutput)
}

// notBefore is the time at which the certificate becomes valid.  The value must be the same as the notBefore value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable. The signer must set this field at the same time it sets certificateChain.
func (o PodCertificateRequestStatusPatchOutput) NotBefore() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodCertificateRequestStatusPatch) *string { return v.NotBefore }).(pulumi.StringPtrOutput)
}

type PodCertificateRequestStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (PodCertificateRequestStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodCertificateRequestStatusPatch)(nil)).Elem()
}

func (o PodCertificateRequestStatusPatchPtrOutput) ToPodCertificateRequestStatusPatchPtrOutput() PodCertificateRequestStatusPatchPtrOutput {
	return o
}

func (o PodCertificateRequestStatusPatchPtrOutput) ToPodCertificateRequestStatusPatchPtrOutputWithContext(ctx context.Context) PodCertificateRequestStatusPatchPtrOutput {
	return o
}

func (o PodCertificateRequestStatusPatchPtrOutput) Elem() PodCertificateRequestStatusPatchOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatusPatch) PodCertificateRequestStatusPatch {
		if v != nil {
			return *v
		}
		var ret PodCertificateRequestStatusPatch
		return ret
	}).(PodCertificateRequestStatusPatchOutput)
}

// beginRefreshAt is the time at which the kubelet should begin trying to refresh the certificate.  This field is set via the /status subresource, and must be set at the same time as certificateChain.  Once populated, this field is immutable.
//
// This field is only a hint.  Kubelet may start refreshing before or after this time if necessary.
func (o PodCertificateRequestStatusPatchPtrOutput) BeginRefreshAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.BeginRefreshAt
	}).(pulumi.StringPtrOutput)
}

// certificateChain is populated with an issued certificate by the signer. This field is set via the /status subresource. Once populated, this field is immutable.
//
// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
//
// Validation requirements:
//  1. certificateChain must consist of one or more PEM-formatted certificates.
//  2. Each entry must be a valid PEM-wrapped, DER-encoded ASN.1 Certificate as
//     described in section 4 of RFC5280.
//
// If more than one block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.  When projecting the chain into a pod volume, kubelet will drop any data in-between the PEM blocks, as well as any PEM block headers.
func (o PodCertificateRequestStatusPatchPtrOutput) CertificateChain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.CertificateChain
	}).(pulumi.StringPtrOutput)
}

// conditions applied to the request.
//
// The types "Issued", "Denied", and "Failed" have special handling.  At most one of these conditions may be present, and they must have status "True".
//
// If the request is denied with `Reason=UnsupportedKeyType`, the signer may suggest a key type that will work in the message field.
func (o PodCertificateRequestStatusPatchPtrOutput) Conditions() metav1.ConditionPatchArrayOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatusPatch) []metav1.ConditionPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(metav1.ConditionPatchArrayOutput)
}

// notAfter is the time at which the certificate expires.  The value must be the same as the notAfter value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable.  The signer must set this field at the same time it sets certificateChain.
func (o PodCertificateRequestStatusPatchPtrOutput) NotAfter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.NotAfter
	}).(pulumi.StringPtrOutput)
}

// notBefore is the time at which the certificate becomes valid.  The value must be the same as the notBefore value in the leaf certificate in certificateChain.  This field is set via the /status subresource.  Once populated, it is immutable. The signer must set this field at the same time it sets certificateChain.
func (o PodCertificateRequestStatusPatchPtrOutput) NotBefore() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodCertificateRequestStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.NotBefore
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestTypeInput)(nil)).Elem(), CertificateSigningRequestTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestTypeArrayInput)(nil)).Elem(), CertificateSigningRequestTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestConditionInput)(nil)).Elem(), CertificateSigningRequestConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestConditionArrayInput)(nil)).Elem(), CertificateSigningRequestConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestConditionPatchInput)(nil)).Elem(), CertificateSigningRequestConditionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestConditionPatchArrayInput)(nil)).Elem(), CertificateSigningRequestConditionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestListTypeInput)(nil)).Elem(), CertificateSigningRequestListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestPatchTypeInput)(nil)).Elem(), CertificateSigningRequestPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestSpecInput)(nil)).Elem(), CertificateSigningRequestSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestSpecPtrInput)(nil)).Elem(), CertificateSigningRequestSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestSpecPatchInput)(nil)).Elem(), CertificateSigningRequestSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestSpecPatchPtrInput)(nil)).Elem(), CertificateSigningRequestSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestStatusInput)(nil)).Elem(), CertificateSigningRequestStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestStatusPtrInput)(nil)).Elem(), CertificateSigningRequestStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestStatusPatchInput)(nil)).Elem(), CertificateSigningRequestStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestStatusPatchPtrInput)(nil)).Elem(), CertificateSigningRequestStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTrustBundleTypeInput)(nil)).Elem(), ClusterTrustBundleTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTrustBundleTypeArrayInput)(nil)).Elem(), ClusterTrustBundleTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTrustBundleListTypeInput)(nil)).Elem(), ClusterTrustBundleListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTrustBundlePatchTypeInput)(nil)).Elem(), ClusterTrustBundlePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTrustBundleSpecInput)(nil)).Elem(), ClusterTrustBundleSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTrustBundleSpecPatchInput)(nil)).Elem(), ClusterTrustBundleSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTrustBundleSpecPatchPtrInput)(nil)).Elem(), ClusterTrustBundleSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestTypeInput)(nil)).Elem(), PodCertificateRequestTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestTypeArrayInput)(nil)).Elem(), PodCertificateRequestTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestListTypeInput)(nil)).Elem(), PodCertificateRequestListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestPatchTypeInput)(nil)).Elem(), PodCertificateRequestPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestSpecInput)(nil)).Elem(), PodCertificateRequestSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestSpecPatchInput)(nil)).Elem(), PodCertificateRequestSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestSpecPatchPtrInput)(nil)).Elem(), PodCertificateRequestSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestStatusInput)(nil)).Elem(), PodCertificateRequestStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestStatusPtrInput)(nil)).Elem(), PodCertificateRequestStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestStatusPatchInput)(nil)).Elem(), PodCertificateRequestStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodCertificateRequestStatusPatchPtrInput)(nil)).Elem(), PodCertificateRequestStatusPatchArgs{})
	pulumi.RegisterOutputType(CertificateSigningRequestTypeOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestTypeArrayOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestConditionOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestConditionArrayOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestConditionPatchOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestConditionPatchArrayOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestListTypeOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestPatchTypeOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestSpecOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestSpecPtrOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestSpecPatchOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestStatusOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestStatusPtrOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestStatusPatchOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(ClusterTrustBundleTypeOutput{})
	pulumi.RegisterOutputType(ClusterTrustBundleTypeArrayOutput{})
	pulumi.RegisterOutputType(ClusterTrustBundleListTypeOutput{})
	pulumi.RegisterOutputType(ClusterTrustBundlePatchTypeOutput{})
	pulumi.RegisterOutputType(ClusterTrustBundleSpecOutput{})
	pulumi.RegisterOutputType(ClusterTrustBundleSpecPatchOutput{})
	pulumi.RegisterOutputType(ClusterTrustBundleSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestTypeOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestTypeArrayOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestListTypeOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestPatchTypeOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestSpecOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestSpecPatchOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestStatusOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestStatusPtrOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestStatusPatchOutput{})
	pulumi.RegisterOutputType(PodCertificateRequestStatusPatchPtrOutput{})
}
