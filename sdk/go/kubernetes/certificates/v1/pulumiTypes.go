// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.
//
// Kubelets use this API to obtain:
//  1. client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client-kubelet" signerName).
//  2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the "kubernetes.io/kubelet-serving" signerName).
//
// This API can be used to request client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client" signerName), or to obtain certificates from custom non-Kubernetes signers.
type CertificateSigningRequestType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string            `pulumi:"kind"`
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// spec contains the certificate request, and is immutable after creation. Only the request, signerName, expirationSeconds, and usages fields can be set on creation. Other fields are derived by Kubernetes and cannot be modified by users.
	Spec CertificateSigningRequestSpec `pulumi:"spec"`
	// status contains information about whether the request is approved or denied, and the certificate issued by the signer, or the failure condition indicating signer failure.
	Status *CertificateSigningRequestStatus `pulumi:"status"`
}

// CertificateSigningRequestTypeInput is an input type that accepts CertificateSigningRequestTypeArgs and CertificateSigningRequestTypeOutput values.
// You can construct a concrete instance of `CertificateSigningRequestTypeInput` via:
//
//	CertificateSigningRequestTypeArgs{...}
type CertificateSigningRequestTypeInput interface {
	pulumi.Input

	ToCertificateSigningRequestTypeOutput() CertificateSigningRequestTypeOutput
	ToCertificateSigningRequestTypeOutputWithContext(context.Context) CertificateSigningRequestTypeOutput
}

// CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.
//
// Kubelets use this API to obtain:
//  1. client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client-kubelet" signerName).
//  2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the "kubernetes.io/kubelet-serving" signerName).
//
// This API can be used to request client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client" signerName), or to obtain certificates from custom non-Kubernetes signers.
type CertificateSigningRequestTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// spec contains the certificate request, and is immutable after creation. Only the request, signerName, expirationSeconds, and usages fields can be set on creation. Other fields are derived by Kubernetes and cannot be modified by users.
	Spec CertificateSigningRequestSpecInput `pulumi:"spec"`
	// status contains information about whether the request is approved or denied, and the certificate issued by the signer, or the failure condition indicating signer failure.
	Status CertificateSigningRequestStatusPtrInput `pulumi:"status"`
}

func (CertificateSigningRequestTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestType)(nil)).Elem()
}

func (i CertificateSigningRequestTypeArgs) ToCertificateSigningRequestTypeOutput() CertificateSigningRequestTypeOutput {
	return i.ToCertificateSigningRequestTypeOutputWithContext(context.Background())
}

func (i CertificateSigningRequestTypeArgs) ToCertificateSigningRequestTypeOutputWithContext(ctx context.Context) CertificateSigningRequestTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestTypeOutput)
}

// CertificateSigningRequestTypeArrayInput is an input type that accepts CertificateSigningRequestTypeArray and CertificateSigningRequestTypeArrayOutput values.
// You can construct a concrete instance of `CertificateSigningRequestTypeArrayInput` via:
//
//	CertificateSigningRequestTypeArray{ CertificateSigningRequestTypeArgs{...} }
type CertificateSigningRequestTypeArrayInput interface {
	pulumi.Input

	ToCertificateSigningRequestTypeArrayOutput() CertificateSigningRequestTypeArrayOutput
	ToCertificateSigningRequestTypeArrayOutputWithContext(context.Context) CertificateSigningRequestTypeArrayOutput
}

type CertificateSigningRequestTypeArray []CertificateSigningRequestTypeInput

func (CertificateSigningRequestTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestType)(nil)).Elem()
}

func (i CertificateSigningRequestTypeArray) ToCertificateSigningRequestTypeArrayOutput() CertificateSigningRequestTypeArrayOutput {
	return i.ToCertificateSigningRequestTypeArrayOutputWithContext(context.Background())
}

func (i CertificateSigningRequestTypeArray) ToCertificateSigningRequestTypeArrayOutputWithContext(ctx context.Context) CertificateSigningRequestTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestTypeArrayOutput)
}

// CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.
//
// Kubelets use this API to obtain:
//  1. client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client-kubelet" signerName).
//  2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the "kubernetes.io/kubelet-serving" signerName).
//
// This API can be used to request client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client" signerName), or to obtain certificates from custom non-Kubernetes signers.
type CertificateSigningRequestTypeOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestType)(nil)).Elem()
}

func (o CertificateSigningRequestTypeOutput) ToCertificateSigningRequestTypeOutput() CertificateSigningRequestTypeOutput {
	return o
}

func (o CertificateSigningRequestTypeOutput) ToCertificateSigningRequestTypeOutputWithContext(ctx context.Context) CertificateSigningRequestTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o CertificateSigningRequestTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o CertificateSigningRequestTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o CertificateSigningRequestTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// spec contains the certificate request, and is immutable after creation. Only the request, signerName, expirationSeconds, and usages fields can be set on creation. Other fields are derived by Kubernetes and cannot be modified by users.
func (o CertificateSigningRequestTypeOutput) Spec() CertificateSigningRequestSpecOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) CertificateSigningRequestSpec { return v.Spec }).(CertificateSigningRequestSpecOutput)
}

// status contains information about whether the request is approved or denied, and the certificate issued by the signer, or the failure condition indicating signer failure.
func (o CertificateSigningRequestTypeOutput) Status() CertificateSigningRequestStatusPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestType) *CertificateSigningRequestStatus { return v.Status }).(CertificateSigningRequestStatusPtrOutput)
}

type CertificateSigningRequestTypeArrayOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestType)(nil)).Elem()
}

func (o CertificateSigningRequestTypeArrayOutput) ToCertificateSigningRequestTypeArrayOutput() CertificateSigningRequestTypeArrayOutput {
	return o
}

func (o CertificateSigningRequestTypeArrayOutput) ToCertificateSigningRequestTypeArrayOutputWithContext(ctx context.Context) CertificateSigningRequestTypeArrayOutput {
	return o
}

func (o CertificateSigningRequestTypeArrayOutput) Index(i pulumi.IntInput) CertificateSigningRequestTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CertificateSigningRequestType {
		return vs[0].([]CertificateSigningRequestType)[vs[1].(int)]
	}).(CertificateSigningRequestTypeOutput)
}

// CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object
type CertificateSigningRequestCondition struct {
	// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// lastUpdateTime is the time of the last update to this condition
	LastUpdateTime *string `pulumi:"lastUpdateTime"`
	// message contains a human readable message with details about the request state
	Message *string `pulumi:"message"`
	// reason indicates a brief reason for the request state
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown".
	Status string `pulumi:"status"`
	// type of the condition. Known conditions are "Approved", "Denied", and "Failed".
	//
	// An "Approved" condition is added via the /approval subresource, indicating the request was approved and should be issued by the signer.
	//
	// A "Denied" condition is added via the /approval subresource, indicating the request was denied and should not be issued by the signer.
	//
	// A "Failed" condition is added via the /status subresource, indicating the signer failed to issue the certificate.
	//
	// Approved and Denied conditions are mutually exclusive. Approved, Denied, and Failed conditions cannot be removed once added.
	//
	// Only one condition of a given type is allowed.
	Type string `pulumi:"type"`
}

// CertificateSigningRequestConditionInput is an input type that accepts CertificateSigningRequestConditionArgs and CertificateSigningRequestConditionOutput values.
// You can construct a concrete instance of `CertificateSigningRequestConditionInput` via:
//
//	CertificateSigningRequestConditionArgs{...}
type CertificateSigningRequestConditionInput interface {
	pulumi.Input

	ToCertificateSigningRequestConditionOutput() CertificateSigningRequestConditionOutput
	ToCertificateSigningRequestConditionOutputWithContext(context.Context) CertificateSigningRequestConditionOutput
}

// CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object
type CertificateSigningRequestConditionArgs struct {
	// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// lastUpdateTime is the time of the last update to this condition
	LastUpdateTime pulumi.StringPtrInput `pulumi:"lastUpdateTime"`
	// message contains a human readable message with details about the request state
	Message pulumi.StringPtrInput `pulumi:"message"`
	// reason indicates a brief reason for the request state
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown".
	Status pulumi.StringInput `pulumi:"status"`
	// type of the condition. Known conditions are "Approved", "Denied", and "Failed".
	//
	// An "Approved" condition is added via the /approval subresource, indicating the request was approved and should be issued by the signer.
	//
	// A "Denied" condition is added via the /approval subresource, indicating the request was denied and should not be issued by the signer.
	//
	// A "Failed" condition is added via the /status subresource, indicating the signer failed to issue the certificate.
	//
	// Approved and Denied conditions are mutually exclusive. Approved, Denied, and Failed conditions cannot be removed once added.
	//
	// Only one condition of a given type is allowed.
	Type pulumi.StringInput `pulumi:"type"`
}

func (CertificateSigningRequestConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestCondition)(nil)).Elem()
}

func (i CertificateSigningRequestConditionArgs) ToCertificateSigningRequestConditionOutput() CertificateSigningRequestConditionOutput {
	return i.ToCertificateSigningRequestConditionOutputWithContext(context.Background())
}

func (i CertificateSigningRequestConditionArgs) ToCertificateSigningRequestConditionOutputWithContext(ctx context.Context) CertificateSigningRequestConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestConditionOutput)
}

// CertificateSigningRequestConditionArrayInput is an input type that accepts CertificateSigningRequestConditionArray and CertificateSigningRequestConditionArrayOutput values.
// You can construct a concrete instance of `CertificateSigningRequestConditionArrayInput` via:
//
//	CertificateSigningRequestConditionArray{ CertificateSigningRequestConditionArgs{...} }
type CertificateSigningRequestConditionArrayInput interface {
	pulumi.Input

	ToCertificateSigningRequestConditionArrayOutput() CertificateSigningRequestConditionArrayOutput
	ToCertificateSigningRequestConditionArrayOutputWithContext(context.Context) CertificateSigningRequestConditionArrayOutput
}

type CertificateSigningRequestConditionArray []CertificateSigningRequestConditionInput

func (CertificateSigningRequestConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestCondition)(nil)).Elem()
}

func (i CertificateSigningRequestConditionArray) ToCertificateSigningRequestConditionArrayOutput() CertificateSigningRequestConditionArrayOutput {
	return i.ToCertificateSigningRequestConditionArrayOutputWithContext(context.Background())
}

func (i CertificateSigningRequestConditionArray) ToCertificateSigningRequestConditionArrayOutputWithContext(ctx context.Context) CertificateSigningRequestConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestConditionArrayOutput)
}

// CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object
type CertificateSigningRequestConditionOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestCondition)(nil)).Elem()
}

func (o CertificateSigningRequestConditionOutput) ToCertificateSigningRequestConditionOutput() CertificateSigningRequestConditionOutput {
	return o
}

func (o CertificateSigningRequestConditionOutput) ToCertificateSigningRequestConditionOutputWithContext(ctx context.Context) CertificateSigningRequestConditionOutput {
	return o
}

// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
func (o CertificateSigningRequestConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// lastUpdateTime is the time of the last update to this condition
func (o CertificateSigningRequestConditionOutput) LastUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) *string { return v.LastUpdateTime }).(pulumi.StringPtrOutput)
}

// message contains a human readable message with details about the request state
func (o CertificateSigningRequestConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// reason indicates a brief reason for the request state
func (o CertificateSigningRequestConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown".
func (o CertificateSigningRequestConditionOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) string { return v.Status }).(pulumi.StringOutput)
}

// type of the condition. Known conditions are "Approved", "Denied", and "Failed".
//
// An "Approved" condition is added via the /approval subresource, indicating the request was approved and should be issued by the signer.
//
// A "Denied" condition is added via the /approval subresource, indicating the request was denied and should not be issued by the signer.
//
// A "Failed" condition is added via the /status subresource, indicating the signer failed to issue the certificate.
//
// Approved and Denied conditions are mutually exclusive. Approved, Denied, and Failed conditions cannot be removed once added.
//
// Only one condition of a given type is allowed.
func (o CertificateSigningRequestConditionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v CertificateSigningRequestCondition) string { return v.Type }).(pulumi.StringOutput)
}

type CertificateSigningRequestConditionArrayOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestCondition)(nil)).Elem()
}

func (o CertificateSigningRequestConditionArrayOutput) ToCertificateSigningRequestConditionArrayOutput() CertificateSigningRequestConditionArrayOutput {
	return o
}

func (o CertificateSigningRequestConditionArrayOutput) ToCertificateSigningRequestConditionArrayOutputWithContext(ctx context.Context) CertificateSigningRequestConditionArrayOutput {
	return o
}

func (o CertificateSigningRequestConditionArrayOutput) Index(i pulumi.IntInput) CertificateSigningRequestConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CertificateSigningRequestCondition {
		return vs[0].([]CertificateSigningRequestCondition)[vs[1].(int)]
	}).(CertificateSigningRequestConditionOutput)
}

// CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object
type CertificateSigningRequestConditionPatch struct {
	// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// lastUpdateTime is the time of the last update to this condition
	LastUpdateTime *string `pulumi:"lastUpdateTime"`
	// message contains a human readable message with details about the request state
	Message *string `pulumi:"message"`
	// reason indicates a brief reason for the request state
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown".
	Status *string `pulumi:"status"`
	// type of the condition. Known conditions are "Approved", "Denied", and "Failed".
	//
	// An "Approved" condition is added via the /approval subresource, indicating the request was approved and should be issued by the signer.
	//
	// A "Denied" condition is added via the /approval subresource, indicating the request was denied and should not be issued by the signer.
	//
	// A "Failed" condition is added via the /status subresource, indicating the signer failed to issue the certificate.
	//
	// Approved and Denied conditions are mutually exclusive. Approved, Denied, and Failed conditions cannot be removed once added.
	//
	// Only one condition of a given type is allowed.
	Type *string `pulumi:"type"`
}

// CertificateSigningRequestConditionPatchInput is an input type that accepts CertificateSigningRequestConditionPatchArgs and CertificateSigningRequestConditionPatchOutput values.
// You can construct a concrete instance of `CertificateSigningRequestConditionPatchInput` via:
//
//	CertificateSigningRequestConditionPatchArgs{...}
type CertificateSigningRequestConditionPatchInput interface {
	pulumi.Input

	ToCertificateSigningRequestConditionPatchOutput() CertificateSigningRequestConditionPatchOutput
	ToCertificateSigningRequestConditionPatchOutputWithContext(context.Context) CertificateSigningRequestConditionPatchOutput
}

// CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object
type CertificateSigningRequestConditionPatchArgs struct {
	// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// lastUpdateTime is the time of the last update to this condition
	LastUpdateTime pulumi.StringPtrInput `pulumi:"lastUpdateTime"`
	// message contains a human readable message with details about the request state
	Message pulumi.StringPtrInput `pulumi:"message"`
	// reason indicates a brief reason for the request state
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown".
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of the condition. Known conditions are "Approved", "Denied", and "Failed".
	//
	// An "Approved" condition is added via the /approval subresource, indicating the request was approved and should be issued by the signer.
	//
	// A "Denied" condition is added via the /approval subresource, indicating the request was denied and should not be issued by the signer.
	//
	// A "Failed" condition is added via the /status subresource, indicating the signer failed to issue the certificate.
	//
	// Approved and Denied conditions are mutually exclusive. Approved, Denied, and Failed conditions cannot be removed once added.
	//
	// Only one condition of a given type is allowed.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (CertificateSigningRequestConditionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestConditionPatch)(nil)).Elem()
}

func (i CertificateSigningRequestConditionPatchArgs) ToCertificateSigningRequestConditionPatchOutput() CertificateSigningRequestConditionPatchOutput {
	return i.ToCertificateSigningRequestConditionPatchOutputWithContext(context.Background())
}

func (i CertificateSigningRequestConditionPatchArgs) ToCertificateSigningRequestConditionPatchOutputWithContext(ctx context.Context) CertificateSigningRequestConditionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestConditionPatchOutput)
}

// CertificateSigningRequestConditionPatchArrayInput is an input type that accepts CertificateSigningRequestConditionPatchArray and CertificateSigningRequestConditionPatchArrayOutput values.
// You can construct a concrete instance of `CertificateSigningRequestConditionPatchArrayInput` via:
//
//	CertificateSigningRequestConditionPatchArray{ CertificateSigningRequestConditionPatchArgs{...} }
type CertificateSigningRequestConditionPatchArrayInput interface {
	pulumi.Input

	ToCertificateSigningRequestConditionPatchArrayOutput() CertificateSigningRequestConditionPatchArrayOutput
	ToCertificateSigningRequestConditionPatchArrayOutputWithContext(context.Context) CertificateSigningRequestConditionPatchArrayOutput
}

type CertificateSigningRequestConditionPatchArray []CertificateSigningRequestConditionPatchInput

func (CertificateSigningRequestConditionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestConditionPatch)(nil)).Elem()
}

func (i CertificateSigningRequestConditionPatchArray) ToCertificateSigningRequestConditionPatchArrayOutput() CertificateSigningRequestConditionPatchArrayOutput {
	return i.ToCertificateSigningRequestConditionPatchArrayOutputWithContext(context.Background())
}

func (i CertificateSigningRequestConditionPatchArray) ToCertificateSigningRequestConditionPatchArrayOutputWithContext(ctx context.Context) CertificateSigningRequestConditionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestConditionPatchArrayOutput)
}

// CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object
type CertificateSigningRequestConditionPatchOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestConditionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestConditionPatch)(nil)).Elem()
}

func (o CertificateSigningRequestConditionPatchOutput) ToCertificateSigningRequestConditionPatchOutput() CertificateSigningRequestConditionPatchOutput {
	return o
}

func (o CertificateSigningRequestConditionPatchOutput) ToCertificateSigningRequestConditionPatchOutputWithContext(ctx context.Context) CertificateSigningRequestConditionPatchOutput {
	return o
}

// lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.
func (o CertificateSigningRequestConditionPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// lastUpdateTime is the time of the last update to this condition
func (o CertificateSigningRequestConditionPatchOutput) LastUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.LastUpdateTime }).(pulumi.StringPtrOutput)
}

// message contains a human readable message with details about the request state
func (o CertificateSigningRequestConditionPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// reason indicates a brief reason for the request state
func (o CertificateSigningRequestConditionPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown".
func (o CertificateSigningRequestConditionPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of the condition. Known conditions are "Approved", "Denied", and "Failed".
//
// An "Approved" condition is added via the /approval subresource, indicating the request was approved and should be issued by the signer.
//
// A "Denied" condition is added via the /approval subresource, indicating the request was denied and should not be issued by the signer.
//
// A "Failed" condition is added via the /status subresource, indicating the signer failed to issue the certificate.
//
// Approved and Denied conditions are mutually exclusive. Approved, Denied, and Failed conditions cannot be removed once added.
//
// Only one condition of a given type is allowed.
func (o CertificateSigningRequestConditionPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestConditionPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type CertificateSigningRequestConditionPatchArrayOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestConditionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CertificateSigningRequestConditionPatch)(nil)).Elem()
}

func (o CertificateSigningRequestConditionPatchArrayOutput) ToCertificateSigningRequestConditionPatchArrayOutput() CertificateSigningRequestConditionPatchArrayOutput {
	return o
}

func (o CertificateSigningRequestConditionPatchArrayOutput) ToCertificateSigningRequestConditionPatchArrayOutputWithContext(ctx context.Context) CertificateSigningRequestConditionPatchArrayOutput {
	return o
}

func (o CertificateSigningRequestConditionPatchArrayOutput) Index(i pulumi.IntInput) CertificateSigningRequestConditionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CertificateSigningRequestConditionPatch {
		return vs[0].([]CertificateSigningRequestConditionPatch)[vs[1].(int)]
	}).(CertificateSigningRequestConditionPatchOutput)
}

// CertificateSigningRequestList is a collection of CertificateSigningRequest objects
type CertificateSigningRequestListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// items is a collection of CertificateSigningRequest objects
	Items []CertificateSigningRequestType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string          `pulumi:"kind"`
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// CertificateSigningRequestListTypeInput is an input type that accepts CertificateSigningRequestListTypeArgs and CertificateSigningRequestListTypeOutput values.
// You can construct a concrete instance of `CertificateSigningRequestListTypeInput` via:
//
//	CertificateSigningRequestListTypeArgs{...}
type CertificateSigningRequestListTypeInput interface {
	pulumi.Input

	ToCertificateSigningRequestListTypeOutput() CertificateSigningRequestListTypeOutput
	ToCertificateSigningRequestListTypeOutputWithContext(context.Context) CertificateSigningRequestListTypeOutput
}

// CertificateSigningRequestList is a collection of CertificateSigningRequest objects
type CertificateSigningRequestListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// items is a collection of CertificateSigningRequest objects
	Items CertificateSigningRequestTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput   `pulumi:"kind"`
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (CertificateSigningRequestListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestListType)(nil)).Elem()
}

func (i CertificateSigningRequestListTypeArgs) ToCertificateSigningRequestListTypeOutput() CertificateSigningRequestListTypeOutput {
	return i.ToCertificateSigningRequestListTypeOutputWithContext(context.Background())
}

func (i CertificateSigningRequestListTypeArgs) ToCertificateSigningRequestListTypeOutputWithContext(ctx context.Context) CertificateSigningRequestListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestListTypeOutput)
}

// CertificateSigningRequestList is a collection of CertificateSigningRequest objects
type CertificateSigningRequestListTypeOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestListType)(nil)).Elem()
}

func (o CertificateSigningRequestListTypeOutput) ToCertificateSigningRequestListTypeOutput() CertificateSigningRequestListTypeOutput {
	return o
}

func (o CertificateSigningRequestListTypeOutput) ToCertificateSigningRequestListTypeOutputWithContext(ctx context.Context) CertificateSigningRequestListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o CertificateSigningRequestListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// items is a collection of CertificateSigningRequest objects
func (o CertificateSigningRequestListTypeOutput) Items() CertificateSigningRequestTypeArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestListType) []CertificateSigningRequestType { return v.Items }).(CertificateSigningRequestTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o CertificateSigningRequestListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o CertificateSigningRequestListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.
//
// Kubelets use this API to obtain:
//  1. client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client-kubelet" signerName).
//  2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the "kubernetes.io/kubelet-serving" signerName).
//
// This API can be used to request client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client" signerName), or to obtain certificates from custom non-Kubernetes signers.
type CertificateSigningRequestPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     *string                 `pulumi:"kind"`
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// spec contains the certificate request, and is immutable after creation. Only the request, signerName, expirationSeconds, and usages fields can be set on creation. Other fields are derived by Kubernetes and cannot be modified by users.
	Spec *CertificateSigningRequestSpecPatch `pulumi:"spec"`
	// status contains information about whether the request is approved or denied, and the certificate issued by the signer, or the failure condition indicating signer failure.
	Status *CertificateSigningRequestStatusPatch `pulumi:"status"`
}

// CertificateSigningRequestPatchTypeInput is an input type that accepts CertificateSigningRequestPatchTypeArgs and CertificateSigningRequestPatchTypeOutput values.
// You can construct a concrete instance of `CertificateSigningRequestPatchTypeInput` via:
//
//	CertificateSigningRequestPatchTypeArgs{...}
type CertificateSigningRequestPatchTypeInput interface {
	pulumi.Input

	ToCertificateSigningRequestPatchTypeOutput() CertificateSigningRequestPatchTypeOutput
	ToCertificateSigningRequestPatchTypeOutputWithContext(context.Context) CertificateSigningRequestPatchTypeOutput
}

// CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.
//
// Kubelets use this API to obtain:
//  1. client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client-kubelet" signerName).
//  2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the "kubernetes.io/kubelet-serving" signerName).
//
// This API can be used to request client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client" signerName), or to obtain certificates from custom non-Kubernetes signers.
type CertificateSigningRequestPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind     pulumi.StringPtrInput          `pulumi:"kind"`
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// spec contains the certificate request, and is immutable after creation. Only the request, signerName, expirationSeconds, and usages fields can be set on creation. Other fields are derived by Kubernetes and cannot be modified by users.
	Spec CertificateSigningRequestSpecPatchPtrInput `pulumi:"spec"`
	// status contains information about whether the request is approved or denied, and the certificate issued by the signer, or the failure condition indicating signer failure.
	Status CertificateSigningRequestStatusPatchPtrInput `pulumi:"status"`
}

func (CertificateSigningRequestPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestPatchType)(nil)).Elem()
}

func (i CertificateSigningRequestPatchTypeArgs) ToCertificateSigningRequestPatchTypeOutput() CertificateSigningRequestPatchTypeOutput {
	return i.ToCertificateSigningRequestPatchTypeOutputWithContext(context.Background())
}

func (i CertificateSigningRequestPatchTypeArgs) ToCertificateSigningRequestPatchTypeOutputWithContext(ctx context.Context) CertificateSigningRequestPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestPatchTypeOutput)
}

// CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.
//
// Kubelets use this API to obtain:
//  1. client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client-kubelet" signerName).
//  2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the "kubernetes.io/kubelet-serving" signerName).
//
// This API can be used to request client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client" signerName), or to obtain certificates from custom non-Kubernetes signers.
type CertificateSigningRequestPatchTypeOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestPatchType)(nil)).Elem()
}

func (o CertificateSigningRequestPatchTypeOutput) ToCertificateSigningRequestPatchTypeOutput() CertificateSigningRequestPatchTypeOutput {
	return o
}

func (o CertificateSigningRequestPatchTypeOutput) ToCertificateSigningRequestPatchTypeOutputWithContext(ctx context.Context) CertificateSigningRequestPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o CertificateSigningRequestPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o CertificateSigningRequestPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o CertificateSigningRequestPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// spec contains the certificate request, and is immutable after creation. Only the request, signerName, expirationSeconds, and usages fields can be set on creation. Other fields are derived by Kubernetes and cannot be modified by users.
func (o CertificateSigningRequestPatchTypeOutput) Spec() CertificateSigningRequestSpecPatchPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *CertificateSigningRequestSpecPatch { return v.Spec }).(CertificateSigningRequestSpecPatchPtrOutput)
}

// status contains information about whether the request is approved or denied, and the certificate issued by the signer, or the failure condition indicating signer failure.
func (o CertificateSigningRequestPatchTypeOutput) Status() CertificateSigningRequestStatusPatchPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestPatchType) *CertificateSigningRequestStatusPatch { return v.Status }).(CertificateSigningRequestStatusPatchPtrOutput)
}

// CertificateSigningRequestSpec contains the certificate request.
type CertificateSigningRequestSpec struct {
	// expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.
	//
	// The v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.
	//
	// Certificate signers may not honor this field for various reasons:
	//
	//   1. Old signer that is unaware of the field (such as the in-tree
	//      implementations prior to v1.22)
	//   2. Signer whose configured maximum is shorter than the requested duration
	//   3. Signer whose configured minimum is longer than the requested duration
	//
	// The minimum valid value for expirationSeconds is 600, i.e. 10 minutes.
	ExpirationSeconds *int `pulumi:"expirationSeconds"`
	// extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Extra map[string][]string `pulumi:"extra"`
	// groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Groups []string `pulumi:"groups"`
	// request contains an x509 certificate signing request encoded in a "CERTIFICATE REQUEST" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.
	Request string `pulumi:"request"`
	// signerName indicates the requested signer, and is a qualified name.
	//
	// List/watch requests for CertificateSigningRequests can filter on this field using a "spec.signerName=NAME" fieldSelector.
	//
	// Well-known Kubernetes signers are:
	//  1. "kubernetes.io/kube-apiserver-client": issues client certificates that can be used to authenticate to kube-apiserver.
	//       Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the "csrsigning" controller in kube-controller-manager.
	//  2. "kubernetes.io/kube-apiserver-client-kubelet": issues client certificates that kubelets use to authenticate to kube-apiserver.
	//       Requests for this signer can be auto-approved by the "csrapproving" controller in kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
	//  3. "kubernetes.io/kubelet-serving" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.
	//       Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
	//
	// More details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
	//
	// Custom signerNames can also be specified. The signer defines:
	//  1. Trust distribution: how trust (CA bundles) are distributed.
	//  2. Permitted subjects: and behavior when a disallowed subject is requested.
	//  3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.
	//  4. Required, permitted, or forbidden key usages / extended key usages.
	//  5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.
	//  6. Whether or not requests for CA certificates are allowed.
	SignerName string `pulumi:"signerName"`
	// uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Uid *string `pulumi:"uid"`
	// usages specifies a set of key usages requested in the issued certificate.
	//
	// Requests for TLS client certificates typically request: "digital signature", "key encipherment", "client auth".
	//
	// Requests for TLS serving certificates typically request: "key encipherment", "digital signature", "server auth".
	//
	// Valid values are:
	//  "signing", "digital signature", "content commitment",
	//  "key encipherment", "key agreement", "data encipherment",
	//  "cert sign", "crl sign", "encipher only", "decipher only", "any",
	//  "server auth", "client auth",
	//  "code signing", "email protection", "s/mime",
	//  "ipsec end system", "ipsec tunnel", "ipsec user",
	//  "timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
	Usages []string `pulumi:"usages"`
	// username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Username *string `pulumi:"username"`
}

// CertificateSigningRequestSpecInput is an input type that accepts CertificateSigningRequestSpecArgs and CertificateSigningRequestSpecOutput values.
// You can construct a concrete instance of `CertificateSigningRequestSpecInput` via:
//
//	CertificateSigningRequestSpecArgs{...}
type CertificateSigningRequestSpecInput interface {
	pulumi.Input

	ToCertificateSigningRequestSpecOutput() CertificateSigningRequestSpecOutput
	ToCertificateSigningRequestSpecOutputWithContext(context.Context) CertificateSigningRequestSpecOutput
}

// CertificateSigningRequestSpec contains the certificate request.
type CertificateSigningRequestSpecArgs struct {
	// expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.
	//
	// The v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.
	//
	// Certificate signers may not honor this field for various reasons:
	//
	//   1. Old signer that is unaware of the field (such as the in-tree
	//      implementations prior to v1.22)
	//   2. Signer whose configured maximum is shorter than the requested duration
	//   3. Signer whose configured minimum is longer than the requested duration
	//
	// The minimum valid value for expirationSeconds is 600, i.e. 10 minutes.
	ExpirationSeconds pulumi.IntPtrInput `pulumi:"expirationSeconds"`
	// extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Extra pulumi.StringArrayMapInput `pulumi:"extra"`
	// groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// request contains an x509 certificate signing request encoded in a "CERTIFICATE REQUEST" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.
	Request pulumi.StringInput `pulumi:"request"`
	// signerName indicates the requested signer, and is a qualified name.
	//
	// List/watch requests for CertificateSigningRequests can filter on this field using a "spec.signerName=NAME" fieldSelector.
	//
	// Well-known Kubernetes signers are:
	//  1. "kubernetes.io/kube-apiserver-client": issues client certificates that can be used to authenticate to kube-apiserver.
	//       Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the "csrsigning" controller in kube-controller-manager.
	//  2. "kubernetes.io/kube-apiserver-client-kubelet": issues client certificates that kubelets use to authenticate to kube-apiserver.
	//       Requests for this signer can be auto-approved by the "csrapproving" controller in kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
	//  3. "kubernetes.io/kubelet-serving" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.
	//       Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
	//
	// More details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
	//
	// Custom signerNames can also be specified. The signer defines:
	//  1. Trust distribution: how trust (CA bundles) are distributed.
	//  2. Permitted subjects: and behavior when a disallowed subject is requested.
	//  3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.
	//  4. Required, permitted, or forbidden key usages / extended key usages.
	//  5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.
	//  6. Whether or not requests for CA certificates are allowed.
	SignerName pulumi.StringInput `pulumi:"signerName"`
	// uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Uid pulumi.StringPtrInput `pulumi:"uid"`
	// usages specifies a set of key usages requested in the issued certificate.
	//
	// Requests for TLS client certificates typically request: "digital signature", "key encipherment", "client auth".
	//
	// Requests for TLS serving certificates typically request: "key encipherment", "digital signature", "server auth".
	//
	// Valid values are:
	//  "signing", "digital signature", "content commitment",
	//  "key encipherment", "key agreement", "data encipherment",
	//  "cert sign", "crl sign", "encipher only", "decipher only", "any",
	//  "server auth", "client auth",
	//  "code signing", "email protection", "s/mime",
	//  "ipsec end system", "ipsec tunnel", "ipsec user",
	//  "timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
	Usages pulumi.StringArrayInput `pulumi:"usages"`
	// username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Username pulumi.StringPtrInput `pulumi:"username"`
}

func (CertificateSigningRequestSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestSpec)(nil)).Elem()
}

func (i CertificateSigningRequestSpecArgs) ToCertificateSigningRequestSpecOutput() CertificateSigningRequestSpecOutput {
	return i.ToCertificateSigningRequestSpecOutputWithContext(context.Background())
}

func (i CertificateSigningRequestSpecArgs) ToCertificateSigningRequestSpecOutputWithContext(ctx context.Context) CertificateSigningRequestSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecOutput)
}

// CertificateSigningRequestSpec contains the certificate request.
type CertificateSigningRequestSpecOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestSpec)(nil)).Elem()
}

func (o CertificateSigningRequestSpecOutput) ToCertificateSigningRequestSpecOutput() CertificateSigningRequestSpecOutput {
	return o
}

func (o CertificateSigningRequestSpecOutput) ToCertificateSigningRequestSpecOutputWithContext(ctx context.Context) CertificateSigningRequestSpecOutput {
	return o
}

// expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.
//
// The v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.
//
// Certificate signers may not honor this field for various reasons:
//
//  1. Old signer that is unaware of the field (such as the in-tree
//     implementations prior to v1.22)
//  2. Signer whose configured maximum is shorter than the requested duration
//  3. Signer whose configured minimum is longer than the requested duration
//
// The minimum valid value for expirationSeconds is 600, i.e. 10 minutes.
func (o CertificateSigningRequestSpecOutput) ExpirationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) *int { return v.ExpirationSeconds }).(pulumi.IntPtrOutput)
}

// extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecOutput) Extra() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) map[string][]string { return v.Extra }).(pulumi.StringArrayMapOutput)
}

// groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// request contains an x509 certificate signing request encoded in a "CERTIFICATE REQUEST" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.
func (o CertificateSigningRequestSpecOutput) Request() pulumi.StringOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) string { return v.Request }).(pulumi.StringOutput)
}

// signerName indicates the requested signer, and is a qualified name.
//
// List/watch requests for CertificateSigningRequests can filter on this field using a "spec.signerName=NAME" fieldSelector.
//
// Well-known Kubernetes signers are:
//  1. "kubernetes.io/kube-apiserver-client": issues client certificates that can be used to authenticate to kube-apiserver.
//     Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the "csrsigning" controller in kube-controller-manager.
//  2. "kubernetes.io/kube-apiserver-client-kubelet": issues client certificates that kubelets use to authenticate to kube-apiserver.
//     Requests for this signer can be auto-approved by the "csrapproving" controller in kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
//  3. "kubernetes.io/kubelet-serving" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.
//     Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
//
// More details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
//
// Custom signerNames can also be specified. The signer defines:
//  1. Trust distribution: how trust (CA bundles) are distributed.
//  2. Permitted subjects: and behavior when a disallowed subject is requested.
//  3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.
//  4. Required, permitted, or forbidden key usages / extended key usages.
//  5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.
//  6. Whether or not requests for CA certificates are allowed.
func (o CertificateSigningRequestSpecOutput) SignerName() pulumi.StringOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) string { return v.SignerName }).(pulumi.StringOutput)
}

// uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

// usages specifies a set of key usages requested in the issued certificate.
//
// Requests for TLS client certificates typically request: "digital signature", "key encipherment", "client auth".
//
// Requests for TLS serving certificates typically request: "key encipherment", "digital signature", "server auth".
//
// Valid values are:
//
//	"signing", "digital signature", "content commitment",
//	"key encipherment", "key agreement", "data encipherment",
//	"cert sign", "crl sign", "encipher only", "decipher only", "any",
//	"server auth", "client auth",
//	"code signing", "email protection", "s/mime",
//	"ipsec end system", "ipsec tunnel", "ipsec user",
//	"timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
func (o CertificateSigningRequestSpecOutput) Usages() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) []string { return v.Usages }).(pulumi.StringArrayOutput)
}

// username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpec) *string { return v.Username }).(pulumi.StringPtrOutput)
}

// CertificateSigningRequestSpec contains the certificate request.
type CertificateSigningRequestSpecPatch struct {
	// expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.
	//
	// The v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.
	//
	// Certificate signers may not honor this field for various reasons:
	//
	//   1. Old signer that is unaware of the field (such as the in-tree
	//      implementations prior to v1.22)
	//   2. Signer whose configured maximum is shorter than the requested duration
	//   3. Signer whose configured minimum is longer than the requested duration
	//
	// The minimum valid value for expirationSeconds is 600, i.e. 10 minutes.
	ExpirationSeconds *int `pulumi:"expirationSeconds"`
	// extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Extra map[string][]string `pulumi:"extra"`
	// groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Groups []string `pulumi:"groups"`
	// request contains an x509 certificate signing request encoded in a "CERTIFICATE REQUEST" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.
	Request *string `pulumi:"request"`
	// signerName indicates the requested signer, and is a qualified name.
	//
	// List/watch requests for CertificateSigningRequests can filter on this field using a "spec.signerName=NAME" fieldSelector.
	//
	// Well-known Kubernetes signers are:
	//  1. "kubernetes.io/kube-apiserver-client": issues client certificates that can be used to authenticate to kube-apiserver.
	//       Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the "csrsigning" controller in kube-controller-manager.
	//  2. "kubernetes.io/kube-apiserver-client-kubelet": issues client certificates that kubelets use to authenticate to kube-apiserver.
	//       Requests for this signer can be auto-approved by the "csrapproving" controller in kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
	//  3. "kubernetes.io/kubelet-serving" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.
	//       Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
	//
	// More details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
	//
	// Custom signerNames can also be specified. The signer defines:
	//  1. Trust distribution: how trust (CA bundles) are distributed.
	//  2. Permitted subjects: and behavior when a disallowed subject is requested.
	//  3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.
	//  4. Required, permitted, or forbidden key usages / extended key usages.
	//  5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.
	//  6. Whether or not requests for CA certificates are allowed.
	SignerName *string `pulumi:"signerName"`
	// uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Uid *string `pulumi:"uid"`
	// usages specifies a set of key usages requested in the issued certificate.
	//
	// Requests for TLS client certificates typically request: "digital signature", "key encipherment", "client auth".
	//
	// Requests for TLS serving certificates typically request: "key encipherment", "digital signature", "server auth".
	//
	// Valid values are:
	//  "signing", "digital signature", "content commitment",
	//  "key encipherment", "key agreement", "data encipherment",
	//  "cert sign", "crl sign", "encipher only", "decipher only", "any",
	//  "server auth", "client auth",
	//  "code signing", "email protection", "s/mime",
	//  "ipsec end system", "ipsec tunnel", "ipsec user",
	//  "timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
	Usages []string `pulumi:"usages"`
	// username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Username *string `pulumi:"username"`
}

// CertificateSigningRequestSpecPatchInput is an input type that accepts CertificateSigningRequestSpecPatchArgs and CertificateSigningRequestSpecPatchOutput values.
// You can construct a concrete instance of `CertificateSigningRequestSpecPatchInput` via:
//
//	CertificateSigningRequestSpecPatchArgs{...}
type CertificateSigningRequestSpecPatchInput interface {
	pulumi.Input

	ToCertificateSigningRequestSpecPatchOutput() CertificateSigningRequestSpecPatchOutput
	ToCertificateSigningRequestSpecPatchOutputWithContext(context.Context) CertificateSigningRequestSpecPatchOutput
}

// CertificateSigningRequestSpec contains the certificate request.
type CertificateSigningRequestSpecPatchArgs struct {
	// expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.
	//
	// The v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.
	//
	// Certificate signers may not honor this field for various reasons:
	//
	//   1. Old signer that is unaware of the field (such as the in-tree
	//      implementations prior to v1.22)
	//   2. Signer whose configured maximum is shorter than the requested duration
	//   3. Signer whose configured minimum is longer than the requested duration
	//
	// The minimum valid value for expirationSeconds is 600, i.e. 10 minutes.
	ExpirationSeconds pulumi.IntPtrInput `pulumi:"expirationSeconds"`
	// extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Extra pulumi.StringArrayMapInput `pulumi:"extra"`
	// groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// request contains an x509 certificate signing request encoded in a "CERTIFICATE REQUEST" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.
	Request pulumi.StringPtrInput `pulumi:"request"`
	// signerName indicates the requested signer, and is a qualified name.
	//
	// List/watch requests for CertificateSigningRequests can filter on this field using a "spec.signerName=NAME" fieldSelector.
	//
	// Well-known Kubernetes signers are:
	//  1. "kubernetes.io/kube-apiserver-client": issues client certificates that can be used to authenticate to kube-apiserver.
	//       Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the "csrsigning" controller in kube-controller-manager.
	//  2. "kubernetes.io/kube-apiserver-client-kubelet": issues client certificates that kubelets use to authenticate to kube-apiserver.
	//       Requests for this signer can be auto-approved by the "csrapproving" controller in kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
	//  3. "kubernetes.io/kubelet-serving" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.
	//       Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
	//
	// More details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
	//
	// Custom signerNames can also be specified. The signer defines:
	//  1. Trust distribution: how trust (CA bundles) are distributed.
	//  2. Permitted subjects: and behavior when a disallowed subject is requested.
	//  3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.
	//  4. Required, permitted, or forbidden key usages / extended key usages.
	//  5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.
	//  6. Whether or not requests for CA certificates are allowed.
	SignerName pulumi.StringPtrInput `pulumi:"signerName"`
	// uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Uid pulumi.StringPtrInput `pulumi:"uid"`
	// usages specifies a set of key usages requested in the issued certificate.
	//
	// Requests for TLS client certificates typically request: "digital signature", "key encipherment", "client auth".
	//
	// Requests for TLS serving certificates typically request: "key encipherment", "digital signature", "server auth".
	//
	// Valid values are:
	//  "signing", "digital signature", "content commitment",
	//  "key encipherment", "key agreement", "data encipherment",
	//  "cert sign", "crl sign", "encipher only", "decipher only", "any",
	//  "server auth", "client auth",
	//  "code signing", "email protection", "s/mime",
	//  "ipsec end system", "ipsec tunnel", "ipsec user",
	//  "timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
	Usages pulumi.StringArrayInput `pulumi:"usages"`
	// username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
	Username pulumi.StringPtrInput `pulumi:"username"`
}

func (CertificateSigningRequestSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestSpecPatch)(nil)).Elem()
}

func (i CertificateSigningRequestSpecPatchArgs) ToCertificateSigningRequestSpecPatchOutput() CertificateSigningRequestSpecPatchOutput {
	return i.ToCertificateSigningRequestSpecPatchOutputWithContext(context.Background())
}

func (i CertificateSigningRequestSpecPatchArgs) ToCertificateSigningRequestSpecPatchOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecPatchOutput)
}

func (i CertificateSigningRequestSpecPatchArgs) ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput {
	return i.ToCertificateSigningRequestSpecPatchPtrOutputWithContext(context.Background())
}

func (i CertificateSigningRequestSpecPatchArgs) ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecPatchOutput).ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx)
}

// CertificateSigningRequestSpecPatchPtrInput is an input type that accepts CertificateSigningRequestSpecPatchArgs, CertificateSigningRequestSpecPatchPtr and CertificateSigningRequestSpecPatchPtrOutput values.
// You can construct a concrete instance of `CertificateSigningRequestSpecPatchPtrInput` via:
//
//	        CertificateSigningRequestSpecPatchArgs{...}
//
//	or:
//
//	        nil
type CertificateSigningRequestSpecPatchPtrInput interface {
	pulumi.Input

	ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput
	ToCertificateSigningRequestSpecPatchPtrOutputWithContext(context.Context) CertificateSigningRequestSpecPatchPtrOutput
}

type certificateSigningRequestSpecPatchPtrType CertificateSigningRequestSpecPatchArgs

func CertificateSigningRequestSpecPatchPtr(v *CertificateSigningRequestSpecPatchArgs) CertificateSigningRequestSpecPatchPtrInput {
	return (*certificateSigningRequestSpecPatchPtrType)(v)
}

func (*certificateSigningRequestSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestSpecPatch)(nil)).Elem()
}

func (i *certificateSigningRequestSpecPatchPtrType) ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput {
	return i.ToCertificateSigningRequestSpecPatchPtrOutputWithContext(context.Background())
}

func (i *certificateSigningRequestSpecPatchPtrType) ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestSpecPatchPtrOutput)
}

// CertificateSigningRequestSpec contains the certificate request.
type CertificateSigningRequestSpecPatchOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestSpecPatch)(nil)).Elem()
}

func (o CertificateSigningRequestSpecPatchOutput) ToCertificateSigningRequestSpecPatchOutput() CertificateSigningRequestSpecPatchOutput {
	return o
}

func (o CertificateSigningRequestSpecPatchOutput) ToCertificateSigningRequestSpecPatchOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchOutput {
	return o
}

func (o CertificateSigningRequestSpecPatchOutput) ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput {
	return o.ToCertificateSigningRequestSpecPatchPtrOutputWithContext(context.Background())
}

func (o CertificateSigningRequestSpecPatchOutput) ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CertificateSigningRequestSpecPatch) *CertificateSigningRequestSpecPatch {
		return &v
	}).(CertificateSigningRequestSpecPatchPtrOutput)
}

// expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.
//
// The v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.
//
// Certificate signers may not honor this field for various reasons:
//
//  1. Old signer that is unaware of the field (such as the in-tree
//     implementations prior to v1.22)
//  2. Signer whose configured maximum is shorter than the requested duration
//  3. Signer whose configured minimum is longer than the requested duration
//
// The minimum valid value for expirationSeconds is 600, i.e. 10 minutes.
func (o CertificateSigningRequestSpecPatchOutput) ExpirationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) *int { return v.ExpirationSeconds }).(pulumi.IntPtrOutput)
}

// extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecPatchOutput) Extra() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) map[string][]string { return v.Extra }).(pulumi.StringArrayMapOutput)
}

// groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecPatchOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// request contains an x509 certificate signing request encoded in a "CERTIFICATE REQUEST" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.
func (o CertificateSigningRequestSpecPatchOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) *string { return v.Request }).(pulumi.StringPtrOutput)
}

// signerName indicates the requested signer, and is a qualified name.
//
// List/watch requests for CertificateSigningRequests can filter on this field using a "spec.signerName=NAME" fieldSelector.
//
// Well-known Kubernetes signers are:
//  1. "kubernetes.io/kube-apiserver-client": issues client certificates that can be used to authenticate to kube-apiserver.
//     Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the "csrsigning" controller in kube-controller-manager.
//  2. "kubernetes.io/kube-apiserver-client-kubelet": issues client certificates that kubelets use to authenticate to kube-apiserver.
//     Requests for this signer can be auto-approved by the "csrapproving" controller in kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
//  3. "kubernetes.io/kubelet-serving" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.
//     Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
//
// More details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
//
// Custom signerNames can also be specified. The signer defines:
//  1. Trust distribution: how trust (CA bundles) are distributed.
//  2. Permitted subjects: and behavior when a disallowed subject is requested.
//  3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.
//  4. Required, permitted, or forbidden key usages / extended key usages.
//  5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.
//  6. Whether or not requests for CA certificates are allowed.
func (o CertificateSigningRequestSpecPatchOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) *string { return v.SignerName }).(pulumi.StringPtrOutput)
}

// uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecPatchOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

// usages specifies a set of key usages requested in the issued certificate.
//
// Requests for TLS client certificates typically request: "digital signature", "key encipherment", "client auth".
//
// Requests for TLS serving certificates typically request: "key encipherment", "digital signature", "server auth".
//
// Valid values are:
//
//	"signing", "digital signature", "content commitment",
//	"key encipherment", "key agreement", "data encipherment",
//	"cert sign", "crl sign", "encipher only", "decipher only", "any",
//	"server auth", "client auth",
//	"code signing", "email protection", "s/mime",
//	"ipsec end system", "ipsec tunnel", "ipsec user",
//	"timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
func (o CertificateSigningRequestSpecPatchOutput) Usages() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) []string { return v.Usages }).(pulumi.StringArrayOutput)
}

// username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecPatchOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestSpecPatch) *string { return v.Username }).(pulumi.StringPtrOutput)
}

type CertificateSigningRequestSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestSpecPatch)(nil)).Elem()
}

func (o CertificateSigningRequestSpecPatchPtrOutput) ToCertificateSigningRequestSpecPatchPtrOutput() CertificateSigningRequestSpecPatchPtrOutput {
	return o
}

func (o CertificateSigningRequestSpecPatchPtrOutput) ToCertificateSigningRequestSpecPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestSpecPatchPtrOutput {
	return o
}

func (o CertificateSigningRequestSpecPatchPtrOutput) Elem() CertificateSigningRequestSpecPatchOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) CertificateSigningRequestSpecPatch {
		if v != nil {
			return *v
		}
		var ret CertificateSigningRequestSpecPatch
		return ret
	}).(CertificateSigningRequestSpecPatchOutput)
}

// expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.
//
// The v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.
//
// Certificate signers may not honor this field for various reasons:
//
//  1. Old signer that is unaware of the field (such as the in-tree
//     implementations prior to v1.22)
//  2. Signer whose configured maximum is shorter than the requested duration
//  3. Signer whose configured minimum is longer than the requested duration
//
// The minimum valid value for expirationSeconds is 600, i.e. 10 minutes.
func (o CertificateSigningRequestSpecPatchPtrOutput) ExpirationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.ExpirationSeconds
	}).(pulumi.IntPtrOutput)
}

// extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecPatchPtrOutput) Extra() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) map[string][]string {
		if v == nil {
			return nil
		}
		return v.Extra
	}).(pulumi.StringArrayMapOutput)
}

// groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecPatchPtrOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.Groups
	}).(pulumi.StringArrayOutput)
}

// request contains an x509 certificate signing request encoded in a "CERTIFICATE REQUEST" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.
func (o CertificateSigningRequestSpecPatchPtrOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Request
	}).(pulumi.StringPtrOutput)
}

// signerName indicates the requested signer, and is a qualified name.
//
// List/watch requests for CertificateSigningRequests can filter on this field using a "spec.signerName=NAME" fieldSelector.
//
// Well-known Kubernetes signers are:
//  1. "kubernetes.io/kube-apiserver-client": issues client certificates that can be used to authenticate to kube-apiserver.
//     Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the "csrsigning" controller in kube-controller-manager.
//  2. "kubernetes.io/kube-apiserver-client-kubelet": issues client certificates that kubelets use to authenticate to kube-apiserver.
//     Requests for this signer can be auto-approved by the "csrapproving" controller in kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
//  3. "kubernetes.io/kubelet-serving" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.
//     Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
//
// More details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
//
// Custom signerNames can also be specified. The signer defines:
//  1. Trust distribution: how trust (CA bundles) are distributed.
//  2. Permitted subjects: and behavior when a disallowed subject is requested.
//  3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.
//  4. Required, permitted, or forbidden key usages / extended key usages.
//  5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.
//  6. Whether or not requests for CA certificates are allowed.
func (o CertificateSigningRequestSpecPatchPtrOutput) SignerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.SignerName
	}).(pulumi.StringPtrOutput)
}

// uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecPatchPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// usages specifies a set of key usages requested in the issued certificate.
//
// Requests for TLS client certificates typically request: "digital signature", "key encipherment", "client auth".
//
// Requests for TLS serving certificates typically request: "key encipherment", "digital signature", "server auth".
//
// Valid values are:
//
//	"signing", "digital signature", "content commitment",
//	"key encipherment", "key agreement", "data encipherment",
//	"cert sign", "crl sign", "encipher only", "decipher only", "any",
//	"server auth", "client auth",
//	"code signing", "email protection", "s/mime",
//	"ipsec end system", "ipsec tunnel", "ipsec user",
//	"timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
func (o CertificateSigningRequestSpecPatchPtrOutput) Usages() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.Usages
	}).(pulumi.StringArrayOutput)
}

// username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
func (o CertificateSigningRequestSpecPatchPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Username
	}).(pulumi.StringPtrOutput)
}

// CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate.
type CertificateSigningRequestStatus struct {
	// certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.
	//
	// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
	//
	// Validation requirements:
	//  1. certificate must contain one or more PEM blocks.
	//  2. All PEM blocks must have the "CERTIFICATE" label, contain no headers, and the encoded data
	//       must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.
	//  3. Non-PEM content may appear before or after the "CERTIFICATE" PEM blocks and is unvalidated,
	//       to allow for explanatory text as described in section 5.2 of RFC7468.
	//
	// If more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.
	//
	// The certificate is encoded in PEM format.
	//
	// When serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:
	//
	//     base64(
	//     -----BEGIN CERTIFICATE-----
	//     ...
	//     -----END CERTIFICATE-----
	//     )
	Certificate *string `pulumi:"certificate"`
	// conditions applied to the request. Known conditions are "Approved", "Denied", and "Failed".
	Conditions []CertificateSigningRequestCondition `pulumi:"conditions"`
}

// CertificateSigningRequestStatusInput is an input type that accepts CertificateSigningRequestStatusArgs and CertificateSigningRequestStatusOutput values.
// You can construct a concrete instance of `CertificateSigningRequestStatusInput` via:
//
//	CertificateSigningRequestStatusArgs{...}
type CertificateSigningRequestStatusInput interface {
	pulumi.Input

	ToCertificateSigningRequestStatusOutput() CertificateSigningRequestStatusOutput
	ToCertificateSigningRequestStatusOutputWithContext(context.Context) CertificateSigningRequestStatusOutput
}

// CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate.
type CertificateSigningRequestStatusArgs struct {
	// certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.
	//
	// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
	//
	// Validation requirements:
	//  1. certificate must contain one or more PEM blocks.
	//  2. All PEM blocks must have the "CERTIFICATE" label, contain no headers, and the encoded data
	//       must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.
	//  3. Non-PEM content may appear before or after the "CERTIFICATE" PEM blocks and is unvalidated,
	//       to allow for explanatory text as described in section 5.2 of RFC7468.
	//
	// If more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.
	//
	// The certificate is encoded in PEM format.
	//
	// When serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:
	//
	//     base64(
	//     -----BEGIN CERTIFICATE-----
	//     ...
	//     -----END CERTIFICATE-----
	//     )
	Certificate pulumi.StringPtrInput `pulumi:"certificate"`
	// conditions applied to the request. Known conditions are "Approved", "Denied", and "Failed".
	Conditions CertificateSigningRequestConditionArrayInput `pulumi:"conditions"`
}

func (CertificateSigningRequestStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestStatus)(nil)).Elem()
}

func (i CertificateSigningRequestStatusArgs) ToCertificateSigningRequestStatusOutput() CertificateSigningRequestStatusOutput {
	return i.ToCertificateSigningRequestStatusOutputWithContext(context.Background())
}

func (i CertificateSigningRequestStatusArgs) ToCertificateSigningRequestStatusOutputWithContext(ctx context.Context) CertificateSigningRequestStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusOutput)
}

func (i CertificateSigningRequestStatusArgs) ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput {
	return i.ToCertificateSigningRequestStatusPtrOutputWithContext(context.Background())
}

func (i CertificateSigningRequestStatusArgs) ToCertificateSigningRequestStatusPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusOutput).ToCertificateSigningRequestStatusPtrOutputWithContext(ctx)
}

// CertificateSigningRequestStatusPtrInput is an input type that accepts CertificateSigningRequestStatusArgs, CertificateSigningRequestStatusPtr and CertificateSigningRequestStatusPtrOutput values.
// You can construct a concrete instance of `CertificateSigningRequestStatusPtrInput` via:
//
//	        CertificateSigningRequestStatusArgs{...}
//
//	or:
//
//	        nil
type CertificateSigningRequestStatusPtrInput interface {
	pulumi.Input

	ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput
	ToCertificateSigningRequestStatusPtrOutputWithContext(context.Context) CertificateSigningRequestStatusPtrOutput
}

type certificateSigningRequestStatusPtrType CertificateSigningRequestStatusArgs

func CertificateSigningRequestStatusPtr(v *CertificateSigningRequestStatusArgs) CertificateSigningRequestStatusPtrInput {
	return (*certificateSigningRequestStatusPtrType)(v)
}

func (*certificateSigningRequestStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestStatus)(nil)).Elem()
}

func (i *certificateSigningRequestStatusPtrType) ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput {
	return i.ToCertificateSigningRequestStatusPtrOutputWithContext(context.Background())
}

func (i *certificateSigningRequestStatusPtrType) ToCertificateSigningRequestStatusPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusPtrOutput)
}

// CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate.
type CertificateSigningRequestStatusOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestStatus)(nil)).Elem()
}

func (o CertificateSigningRequestStatusOutput) ToCertificateSigningRequestStatusOutput() CertificateSigningRequestStatusOutput {
	return o
}

func (o CertificateSigningRequestStatusOutput) ToCertificateSigningRequestStatusOutputWithContext(ctx context.Context) CertificateSigningRequestStatusOutput {
	return o
}

func (o CertificateSigningRequestStatusOutput) ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput {
	return o.ToCertificateSigningRequestStatusPtrOutputWithContext(context.Background())
}

func (o CertificateSigningRequestStatusOutput) ToCertificateSigningRequestStatusPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CertificateSigningRequestStatus) *CertificateSigningRequestStatus {
		return &v
	}).(CertificateSigningRequestStatusPtrOutput)
}

// certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.
//
// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
//
// Validation requirements:
//  1. certificate must contain one or more PEM blocks.
//  2. All PEM blocks must have the "CERTIFICATE" label, contain no headers, and the encoded data
//     must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.
//  3. Non-PEM content may appear before or after the "CERTIFICATE" PEM blocks and is unvalidated,
//     to allow for explanatory text as described in section 5.2 of RFC7468.
//
// If more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.
//
// The certificate is encoded in PEM format.
//
// When serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:
//
//	base64(
//	-----BEGIN CERTIFICATE-----
//	...
//	-----END CERTIFICATE-----
//	)
func (o CertificateSigningRequestStatusOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestStatus) *string { return v.Certificate }).(pulumi.StringPtrOutput)
}

// conditions applied to the request. Known conditions are "Approved", "Denied", and "Failed".
func (o CertificateSigningRequestStatusOutput) Conditions() CertificateSigningRequestConditionArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestStatus) []CertificateSigningRequestCondition { return v.Conditions }).(CertificateSigningRequestConditionArrayOutput)
}

type CertificateSigningRequestStatusPtrOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestStatus)(nil)).Elem()
}

func (o CertificateSigningRequestStatusPtrOutput) ToCertificateSigningRequestStatusPtrOutput() CertificateSigningRequestStatusPtrOutput {
	return o
}

func (o CertificateSigningRequestStatusPtrOutput) ToCertificateSigningRequestStatusPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPtrOutput {
	return o
}

func (o CertificateSigningRequestStatusPtrOutput) Elem() CertificateSigningRequestStatusOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatus) CertificateSigningRequestStatus {
		if v != nil {
			return *v
		}
		var ret CertificateSigningRequestStatus
		return ret
	}).(CertificateSigningRequestStatusOutput)
}

// certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.
//
// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
//
// Validation requirements:
//  1. certificate must contain one or more PEM blocks.
//  2. All PEM blocks must have the "CERTIFICATE" label, contain no headers, and the encoded data
//     must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.
//  3. Non-PEM content may appear before or after the "CERTIFICATE" PEM blocks and is unvalidated,
//     to allow for explanatory text as described in section 5.2 of RFC7468.
//
// If more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.
//
// The certificate is encoded in PEM format.
//
// When serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:
//
//	base64(
//	-----BEGIN CERTIFICATE-----
//	...
//	-----END CERTIFICATE-----
//	)
func (o CertificateSigningRequestStatusPtrOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatus) *string {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(pulumi.StringPtrOutput)
}

// conditions applied to the request. Known conditions are "Approved", "Denied", and "Failed".
func (o CertificateSigningRequestStatusPtrOutput) Conditions() CertificateSigningRequestConditionArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatus) []CertificateSigningRequestCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(CertificateSigningRequestConditionArrayOutput)
}

// CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate.
type CertificateSigningRequestStatusPatch struct {
	// certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.
	//
	// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
	//
	// Validation requirements:
	//  1. certificate must contain one or more PEM blocks.
	//  2. All PEM blocks must have the "CERTIFICATE" label, contain no headers, and the encoded data
	//       must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.
	//  3. Non-PEM content may appear before or after the "CERTIFICATE" PEM blocks and is unvalidated,
	//       to allow for explanatory text as described in section 5.2 of RFC7468.
	//
	// If more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.
	//
	// The certificate is encoded in PEM format.
	//
	// When serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:
	//
	//     base64(
	//     -----BEGIN CERTIFICATE-----
	//     ...
	//     -----END CERTIFICATE-----
	//     )
	Certificate *string `pulumi:"certificate"`
	// conditions applied to the request. Known conditions are "Approved", "Denied", and "Failed".
	Conditions []CertificateSigningRequestConditionPatch `pulumi:"conditions"`
}

// CertificateSigningRequestStatusPatchInput is an input type that accepts CertificateSigningRequestStatusPatchArgs and CertificateSigningRequestStatusPatchOutput values.
// You can construct a concrete instance of `CertificateSigningRequestStatusPatchInput` via:
//
//	CertificateSigningRequestStatusPatchArgs{...}
type CertificateSigningRequestStatusPatchInput interface {
	pulumi.Input

	ToCertificateSigningRequestStatusPatchOutput() CertificateSigningRequestStatusPatchOutput
	ToCertificateSigningRequestStatusPatchOutputWithContext(context.Context) CertificateSigningRequestStatusPatchOutput
}

// CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate.
type CertificateSigningRequestStatusPatchArgs struct {
	// certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.
	//
	// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
	//
	// Validation requirements:
	//  1. certificate must contain one or more PEM blocks.
	//  2. All PEM blocks must have the "CERTIFICATE" label, contain no headers, and the encoded data
	//       must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.
	//  3. Non-PEM content may appear before or after the "CERTIFICATE" PEM blocks and is unvalidated,
	//       to allow for explanatory text as described in section 5.2 of RFC7468.
	//
	// If more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.
	//
	// The certificate is encoded in PEM format.
	//
	// When serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:
	//
	//     base64(
	//     -----BEGIN CERTIFICATE-----
	//     ...
	//     -----END CERTIFICATE-----
	//     )
	Certificate pulumi.StringPtrInput `pulumi:"certificate"`
	// conditions applied to the request. Known conditions are "Approved", "Denied", and "Failed".
	Conditions CertificateSigningRequestConditionPatchArrayInput `pulumi:"conditions"`
}

func (CertificateSigningRequestStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestStatusPatch)(nil)).Elem()
}

func (i CertificateSigningRequestStatusPatchArgs) ToCertificateSigningRequestStatusPatchOutput() CertificateSigningRequestStatusPatchOutput {
	return i.ToCertificateSigningRequestStatusPatchOutputWithContext(context.Background())
}

func (i CertificateSigningRequestStatusPatchArgs) ToCertificateSigningRequestStatusPatchOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusPatchOutput)
}

func (i CertificateSigningRequestStatusPatchArgs) ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput {
	return i.ToCertificateSigningRequestStatusPatchPtrOutputWithContext(context.Background())
}

func (i CertificateSigningRequestStatusPatchArgs) ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusPatchOutput).ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx)
}

// CertificateSigningRequestStatusPatchPtrInput is an input type that accepts CertificateSigningRequestStatusPatchArgs, CertificateSigningRequestStatusPatchPtr and CertificateSigningRequestStatusPatchPtrOutput values.
// You can construct a concrete instance of `CertificateSigningRequestStatusPatchPtrInput` via:
//
//	        CertificateSigningRequestStatusPatchArgs{...}
//
//	or:
//
//	        nil
type CertificateSigningRequestStatusPatchPtrInput interface {
	pulumi.Input

	ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput
	ToCertificateSigningRequestStatusPatchPtrOutputWithContext(context.Context) CertificateSigningRequestStatusPatchPtrOutput
}

type certificateSigningRequestStatusPatchPtrType CertificateSigningRequestStatusPatchArgs

func CertificateSigningRequestStatusPatchPtr(v *CertificateSigningRequestStatusPatchArgs) CertificateSigningRequestStatusPatchPtrInput {
	return (*certificateSigningRequestStatusPatchPtrType)(v)
}

func (*certificateSigningRequestStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestStatusPatch)(nil)).Elem()
}

func (i *certificateSigningRequestStatusPatchPtrType) ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput {
	return i.ToCertificateSigningRequestStatusPatchPtrOutputWithContext(context.Background())
}

func (i *certificateSigningRequestStatusPatchPtrType) ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateSigningRequestStatusPatchPtrOutput)
}

// CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate.
type CertificateSigningRequestStatusPatchOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CertificateSigningRequestStatusPatch)(nil)).Elem()
}

func (o CertificateSigningRequestStatusPatchOutput) ToCertificateSigningRequestStatusPatchOutput() CertificateSigningRequestStatusPatchOutput {
	return o
}

func (o CertificateSigningRequestStatusPatchOutput) ToCertificateSigningRequestStatusPatchOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchOutput {
	return o
}

func (o CertificateSigningRequestStatusPatchOutput) ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput {
	return o.ToCertificateSigningRequestStatusPatchPtrOutputWithContext(context.Background())
}

func (o CertificateSigningRequestStatusPatchOutput) ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CertificateSigningRequestStatusPatch) *CertificateSigningRequestStatusPatch {
		return &v
	}).(CertificateSigningRequestStatusPatchPtrOutput)
}

// certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.
//
// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
//
// Validation requirements:
//  1. certificate must contain one or more PEM blocks.
//  2. All PEM blocks must have the "CERTIFICATE" label, contain no headers, and the encoded data
//     must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.
//  3. Non-PEM content may appear before or after the "CERTIFICATE" PEM blocks and is unvalidated,
//     to allow for explanatory text as described in section 5.2 of RFC7468.
//
// If more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.
//
// The certificate is encoded in PEM format.
//
// When serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:
//
//	base64(
//	-----BEGIN CERTIFICATE-----
//	...
//	-----END CERTIFICATE-----
//	)
func (o CertificateSigningRequestStatusPatchOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CertificateSigningRequestStatusPatch) *string { return v.Certificate }).(pulumi.StringPtrOutput)
}

// conditions applied to the request. Known conditions are "Approved", "Denied", and "Failed".
func (o CertificateSigningRequestStatusPatchOutput) Conditions() CertificateSigningRequestConditionPatchArrayOutput {
	return o.ApplyT(func(v CertificateSigningRequestStatusPatch) []CertificateSigningRequestConditionPatch {
		return v.Conditions
	}).(CertificateSigningRequestConditionPatchArrayOutput)
}

type CertificateSigningRequestStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (CertificateSigningRequestStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CertificateSigningRequestStatusPatch)(nil)).Elem()
}

func (o CertificateSigningRequestStatusPatchPtrOutput) ToCertificateSigningRequestStatusPatchPtrOutput() CertificateSigningRequestStatusPatchPtrOutput {
	return o
}

func (o CertificateSigningRequestStatusPatchPtrOutput) ToCertificateSigningRequestStatusPatchPtrOutputWithContext(ctx context.Context) CertificateSigningRequestStatusPatchPtrOutput {
	return o
}

func (o CertificateSigningRequestStatusPatchPtrOutput) Elem() CertificateSigningRequestStatusPatchOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatusPatch) CertificateSigningRequestStatusPatch {
		if v != nil {
			return *v
		}
		var ret CertificateSigningRequestStatusPatch
		return ret
	}).(CertificateSigningRequestStatusPatchOutput)
}

// certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.
//
// If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
//
// Validation requirements:
//  1. certificate must contain one or more PEM blocks.
//  2. All PEM blocks must have the "CERTIFICATE" label, contain no headers, and the encoded data
//     must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.
//  3. Non-PEM content may appear before or after the "CERTIFICATE" PEM blocks and is unvalidated,
//     to allow for explanatory text as described in section 5.2 of RFC7468.
//
// If more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.
//
// The certificate is encoded in PEM format.
//
// When serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:
//
//	base64(
//	-----BEGIN CERTIFICATE-----
//	...
//	-----END CERTIFICATE-----
//	)
func (o CertificateSigningRequestStatusPatchPtrOutput) Certificate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatusPatch) *string {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(pulumi.StringPtrOutput)
}

// conditions applied to the request. Known conditions are "Approved", "Denied", and "Failed".
func (o CertificateSigningRequestStatusPatchPtrOutput) Conditions() CertificateSigningRequestConditionPatchArrayOutput {
	return o.ApplyT(func(v *CertificateSigningRequestStatusPatch) []CertificateSigningRequestConditionPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(CertificateSigningRequestConditionPatchArrayOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestTypeInput)(nil)).Elem(), CertificateSigningRequestTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestTypeArrayInput)(nil)).Elem(), CertificateSigningRequestTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestConditionInput)(nil)).Elem(), CertificateSigningRequestConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestConditionArrayInput)(nil)).Elem(), CertificateSigningRequestConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestConditionPatchInput)(nil)).Elem(), CertificateSigningRequestConditionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestConditionPatchArrayInput)(nil)).Elem(), CertificateSigningRequestConditionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestListTypeInput)(nil)).Elem(), CertificateSigningRequestListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestPatchTypeInput)(nil)).Elem(), CertificateSigningRequestPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestSpecInput)(nil)).Elem(), CertificateSigningRequestSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestSpecPatchInput)(nil)).Elem(), CertificateSigningRequestSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestSpecPatchPtrInput)(nil)).Elem(), CertificateSigningRequestSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestStatusInput)(nil)).Elem(), CertificateSigningRequestStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestStatusPtrInput)(nil)).Elem(), CertificateSigningRequestStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestStatusPatchInput)(nil)).Elem(), CertificateSigningRequestStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateSigningRequestStatusPatchPtrInput)(nil)).Elem(), CertificateSigningRequestStatusPatchArgs{})
	pulumi.RegisterOutputType(CertificateSigningRequestTypeOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestTypeArrayOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestConditionOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestConditionArrayOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestConditionPatchOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestConditionPatchArrayOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestListTypeOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestPatchTypeOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestSpecOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestSpecPatchOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestStatusOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestStatusPtrOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestStatusPatchOutput{})
	pulumi.RegisterOutputType(CertificateSigningRequestStatusPatchPtrOutput{})
}
