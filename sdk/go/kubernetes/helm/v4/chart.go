// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v4

import (
	"context"
	"reflect"

	"errors"
	helmv3 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/helm/v3"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Chart is a component representing a collection of resources described by an arbitrary Helm Chart.
//
// The Helm Chart can be fetched from any source that is accessible to the `helm` command line. Values in the `values.yml` file can be overridden using `ChartOpts.values` (equivalent to `--set` or having multiple `values.yml` files). Objects can be transformed arbitrarily by supplying callbacks to `ChartOpts.transformations`.
//
// The `Chart` resource renders the templates from your chart and then manage them directly with the Pulumi Kubernetes provider.
//
// `Chart` does not use Tiller. The Chart specified is copied and expanded locally; the semantics are equivalent to running `helm template` and then using Pulumi to manage the resulting YAML manifests. Any values that would be retrieved in-cluster are assigned fake values, and none of Tiller's server-side validity testing is executed.
//
// You may also want to consider the `Release` resource as an alternative method for managing helm charts. For more information about the trade-offs between these options see: [Choosing the right Helm resource for your use case](https://www.pulumi.com/registry/packages/kubernetes/how-to-guides/choosing-the-right-helm-resource-for-your-use-case)
//
// ## Example Usage
// ### Local Chart Directory
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/helm/v3"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := helm.NewChart(ctx, "nginx-ingress", helm.ChartArgs{
//				Path: pulumi.String("./nginx-ingress"),
//			})
//			if err != nil {
//				return err
//			}
//
//			return nil
//		})
//	}
//
// ```
// ### Remote Chart
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/helm/v3"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := helm.NewChart(ctx, "nginx-ingress", helm.ChartArgs{
//				Chart:   pulumi.String("nginx-ingress"),
//				Version: pulumi.String("1.24.4"),
//				Fetchargs: helm.FetchArgs{
//					Repo: pulumi.String("https://charts.helm.sh/stable"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//
//			return nil
//		})
//	}
//
// ```
// ### Set Chart Values
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/helm/v3"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := helm.NewChart(ctx, "nginx-ingress", helm.ChartArgs{
//				Chart:   pulumi.String("nginx-ingress"),
//				Version: pulumi.String("1.24.4"),
//				FetchArgs: helm.FetchArgs{
//					Repo: pulumi.String("https://charts.helm.sh/stable"),
//				},
//				Values: pulumi.Map{
//					"controller": pulumi.Map{
//						"metrics": pulumi.Map{
//							"enabled": pulumi.Bool(true),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//
//			return nil
//		})
//	}
//
// ```
// ### Deploy Chart into Namespace
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/helm/v3"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := helm.NewChart(ctx, "nginx-ingress", helm.ChartArgs{
//				Chart:     pulumi.String("nginx-ingress"),
//				Version:   pulumi.String("1.24.4"),
//				Namespace: pulumi.String("test-namespace"),
//				FetchArgs: helm.FetchArgs{
//					Repo: pulumi.String("https://charts.helm.sh/stable"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//
//			return nil
//		})
//	}
//
// ```
// ### Depend on a Chart resource
// ```go
// package main
//
// import (
//
//	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/core/v1"
//	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/helm/v3"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := helm.NewChart(ctx, "nginx-ingress", helm.ChartArgs{
//				Chart:     pulumi.String("nginx-ingress"),
//				Version:   pulumi.String("1.24.4"),
//				Namespace: pulumi.String("test-namespace"),
//				FetchArgs: helm.FetchArgs{
//					Repo: pulumi.String("https://charts.helm.sh/stable"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//
//			// Create a ConfigMap depending on the Chart. The ConfigMap will not be created until after all of the Chart
//			// resources are ready. Note the use of the `Ready` attribute, which is used with `DependsOnInputs` rather than
//			// `DependsOn`. Depending on the Chart resource directly, or using `DependsOn` will not work.
//			_, err = corev1.NewConfigMap(ctx, "cm", &corev1.ConfigMapArgs{
//				Data: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//			}, pulumi.DependsOnInputs(chart.Ready))
//			if err != nil {
//				return err
//			}
//
//			return nil
//		})
//	}
//
// ```
// ### Chart with Transformations
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/helm/v3"
//	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/yaml"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := helm.NewChart(ctx, "nginx-ingress", helm.ChartArgs{
//				Chart:   pulumi.String("nginx-ingress"),
//				Version: pulumi.String("1.24.4"),
//				FetchArgs: helm.FetchArgs{
//					Repo: pulumi.String("https://charts.helm.sh/stable"),
//				},
//				Transformations: []yaml.Transformation{
//					// Make every service private to the cluster, i.e., turn all services into ClusterIP
//					// instead of LoadBalancer.
//					func(state map[string]interface{}, opts ...pulumi.ResourceOption) {
//						if state["kind"] == "Service" {
//							spec := state["spec"].(map[string]interface{})
//							spec["type"] = "ClusterIP"
//						}
//					},
//
//					// Set a resource alias for a previous name.
//					func(state map[string]interface{}, opts ...pulumi.ResourceOption) {
//						if state["kind"] == "Deployment" {
//							aliases := pulumi.Aliases([]pulumi.Alias{
//								{
//									Name: pulumi.String("oldName"),
//								},
//							})
//							opts = append(opts, aliases)
//						}
//					},
//
//					// Omit a resource from the Chart by transforming the specified resource definition
//					// to an empty List.
//					func(state map[string]interface{}, opts ...pulumi.ResourceOption) {
//						name := state["metadata"].(map[string]interface{})["name"]
//						if state["kind"] == "Pod" && name == "test" {
//							state["apiVersion"] = "core/v1"
//							state["kind"] = "List"
//						}
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//
//			return nil
//		})
//	}
//
// ```
type Chart struct {
	pulumi.ResourceState

	// Resources created by the Chart.
	Resources pulumi.ArrayOutput `pulumi:"resources"`
}

// NewChart registers a new resource with the given unique name, arguments, and options.
func NewChart(ctx *pulumi.Context,
	name string, args *ChartArgs, opts ...pulumi.ResourceOption) (*Chart, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Chart == nil {
		return nil, errors.New("invalid value for required argument 'Chart'")
	}
	opts = utilities.PkgResourceDefaultOpts(opts)
	var resource Chart
	err := ctx.RegisterRemoteComponentResource("kubernetes:helm.sh/v4:Chart", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type chartArgs struct {
	// Chart name to be installed. A path may be used.
	Chart string `pulumi:"chart"`
	// Run helm dependency update before installing the chart.
	DependencyUpdate *bool `pulumi:"dependencyUpdate"`
	// Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
	Devel *bool `pulumi:"devel"`
	// Location of public keys used for verification. Used only if `verify` is true
	Keyring *string `pulumi:"keyring"`
	// Release name.
	Name *string `pulumi:"name"`
	// Namespace for the release.
	Namespace *string `pulumi:"namespace"`
	// Specification defining the post-renderer to use.
	PostRenderer *PostRenderer `pulumi:"postRenderer"`
	// Specification defining the Helm chart repository to use.
	RepositoryOpts *helmv3.RepositoryOpts `pulumi:"repositoryOpts"`
	// An optional prefix for the auto-generated resource names. Example: A resource created with resourcePrefix="foo" would produce a resource named "foo:resourceName".
	ResourcePrefix *string `pulumi:"resourcePrefix"`
	// By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
	SkipAwait *bool `pulumi:"skipAwait"`
	// If set, no CRDs will be installed. By default, CRDs are installed if not already present.
	SkipCrds *bool `pulumi:"skipCrds"`
	// List of assets (raw yaml files). Content is read and merged with values.
	ValueYamlFiles []pulumi.AssetOrArchive `pulumi:"valueYamlFiles"`
	// Custom values set for the release.
	Values map[string]interface{} `pulumi:"values"`
	// Verify the chart's integrity.
	Verify *bool `pulumi:"verify"`
	// Specify the chart version to install. If this is not specified, the latest version is installed.
	Version *string `pulumi:"version"`
}

// The set of arguments for constructing a Chart resource.
type ChartArgs struct {
	// Chart name to be installed. A path may be used.
	Chart pulumi.StringInput
	// Run helm dependency update before installing the chart.
	DependencyUpdate pulumi.BoolPtrInput
	// Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
	Devel pulumi.BoolPtrInput
	// Location of public keys used for verification. Used only if `verify` is true
	Keyring pulumi.StringPtrInput
	// Release name.
	Name pulumi.StringPtrInput
	// Namespace for the release.
	Namespace pulumi.StringPtrInput
	// Specification defining the post-renderer to use.
	PostRenderer PostRendererPtrInput
	// Specification defining the Helm chart repository to use.
	RepositoryOpts helmv3.RepositoryOptsPtrInput
	// An optional prefix for the auto-generated resource names. Example: A resource created with resourcePrefix="foo" would produce a resource named "foo:resourceName".
	ResourcePrefix pulumi.StringPtrInput
	// By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
	SkipAwait pulumi.BoolPtrInput
	// If set, no CRDs will be installed. By default, CRDs are installed if not already present.
	SkipCrds pulumi.BoolPtrInput
	// List of assets (raw yaml files). Content is read and merged with values.
	ValueYamlFiles pulumi.AssetOrArchiveArrayInput
	// Custom values set for the release.
	Values pulumi.MapInput
	// Verify the chart's integrity.
	Verify pulumi.BoolPtrInput
	// Specify the chart version to install. If this is not specified, the latest version is installed.
	Version pulumi.StringPtrInput
}

func (ChartArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*chartArgs)(nil)).Elem()
}

type ChartInput interface {
	pulumi.Input

	ToChartOutput() ChartOutput
	ToChartOutputWithContext(ctx context.Context) ChartOutput
}

func (*Chart) ElementType() reflect.Type {
	return reflect.TypeOf((**Chart)(nil)).Elem()
}

func (i *Chart) ToChartOutput() ChartOutput {
	return i.ToChartOutputWithContext(context.Background())
}

func (i *Chart) ToChartOutputWithContext(ctx context.Context) ChartOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChartOutput)
}

// ChartArrayInput is an input type that accepts ChartArray and ChartArrayOutput values.
// You can construct a concrete instance of `ChartArrayInput` via:
//
//	ChartArray{ ChartArgs{...} }
type ChartArrayInput interface {
	pulumi.Input

	ToChartArrayOutput() ChartArrayOutput
	ToChartArrayOutputWithContext(context.Context) ChartArrayOutput
}

type ChartArray []ChartInput

func (ChartArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Chart)(nil)).Elem()
}

func (i ChartArray) ToChartArrayOutput() ChartArrayOutput {
	return i.ToChartArrayOutputWithContext(context.Background())
}

func (i ChartArray) ToChartArrayOutputWithContext(ctx context.Context) ChartArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChartArrayOutput)
}

// ChartMapInput is an input type that accepts ChartMap and ChartMapOutput values.
// You can construct a concrete instance of `ChartMapInput` via:
//
//	ChartMap{ "key": ChartArgs{...} }
type ChartMapInput interface {
	pulumi.Input

	ToChartMapOutput() ChartMapOutput
	ToChartMapOutputWithContext(context.Context) ChartMapOutput
}

type ChartMap map[string]ChartInput

func (ChartMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Chart)(nil)).Elem()
}

func (i ChartMap) ToChartMapOutput() ChartMapOutput {
	return i.ToChartMapOutputWithContext(context.Background())
}

func (i ChartMap) ToChartMapOutputWithContext(ctx context.Context) ChartMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChartMapOutput)
}

type ChartOutput struct{ *pulumi.OutputState }

func (ChartOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Chart)(nil)).Elem()
}

func (o ChartOutput) ToChartOutput() ChartOutput {
	return o
}

func (o ChartOutput) ToChartOutputWithContext(ctx context.Context) ChartOutput {
	return o
}

// Resources created by the Chart.
func (o ChartOutput) Resources() pulumi.ArrayOutput {
	return o.ApplyT(func(v *Chart) pulumi.ArrayOutput { return v.Resources }).(pulumi.ArrayOutput)
}

type ChartArrayOutput struct{ *pulumi.OutputState }

func (ChartArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Chart)(nil)).Elem()
}

func (o ChartArrayOutput) ToChartArrayOutput() ChartArrayOutput {
	return o
}

func (o ChartArrayOutput) ToChartArrayOutputWithContext(ctx context.Context) ChartArrayOutput {
	return o
}

func (o ChartArrayOutput) Index(i pulumi.IntInput) ChartOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Chart {
		return vs[0].([]*Chart)[vs[1].(int)]
	}).(ChartOutput)
}

type ChartMapOutput struct{ *pulumi.OutputState }

func (ChartMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Chart)(nil)).Elem()
}

func (o ChartMapOutput) ToChartMapOutput() ChartMapOutput {
	return o
}

func (o ChartMapOutput) ToChartMapOutputWithContext(ctx context.Context) ChartMapOutput {
	return o
}

func (o ChartMapOutput) MapIndex(k pulumi.StringInput) ChartOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Chart {
		return vs[0].(map[string]*Chart)[vs[1].(string)]
	}).(ChartOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ChartInput)(nil)).Elem(), &Chart{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChartArrayInput)(nil)).Elem(), ChartArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChartMapInput)(nil)).Elem(), ChartMap{})
	pulumi.RegisterOutputType(ChartOutput{})
	pulumi.RegisterOutputType(ChartArrayOutput{})
	pulumi.RegisterOutputType(ChartMapOutput{})
}
