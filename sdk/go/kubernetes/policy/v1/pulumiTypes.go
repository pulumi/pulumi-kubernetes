// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
type PodDisruptionBudgetType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Specification of the desired behavior of the PodDisruptionBudget.
	Spec *PodDisruptionBudgetSpec `pulumi:"spec"`
	// Most recently observed status of the PodDisruptionBudget.
	Status *PodDisruptionBudgetStatus `pulumi:"status"`
}

// PodDisruptionBudgetTypeInput is an input type that accepts PodDisruptionBudgetTypeArgs and PodDisruptionBudgetTypeOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetTypeInput` via:
//
//          PodDisruptionBudgetTypeArgs{...}
type PodDisruptionBudgetTypeInput interface {
	pulumi.Input

	ToPodDisruptionBudgetTypeOutput() PodDisruptionBudgetTypeOutput
	ToPodDisruptionBudgetTypeOutputWithContext(context.Context) PodDisruptionBudgetTypeOutput
}

// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
type PodDisruptionBudgetTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Specification of the desired behavior of the PodDisruptionBudget.
	Spec PodDisruptionBudgetSpecPtrInput `pulumi:"spec"`
	// Most recently observed status of the PodDisruptionBudget.
	Status PodDisruptionBudgetStatusPtrInput `pulumi:"status"`
}

func (PodDisruptionBudgetTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetType)(nil)).Elem()
}

func (i PodDisruptionBudgetTypeArgs) ToPodDisruptionBudgetTypeOutput() PodDisruptionBudgetTypeOutput {
	return i.ToPodDisruptionBudgetTypeOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetTypeArgs) ToPodDisruptionBudgetTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetTypeOutput)
}

// PodDisruptionBudgetTypeArrayInput is an input type that accepts PodDisruptionBudgetTypeArray and PodDisruptionBudgetTypeArrayOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetTypeArrayInput` via:
//
//          PodDisruptionBudgetTypeArray{ PodDisruptionBudgetTypeArgs{...} }
type PodDisruptionBudgetTypeArrayInput interface {
	pulumi.Input

	ToPodDisruptionBudgetTypeArrayOutput() PodDisruptionBudgetTypeArrayOutput
	ToPodDisruptionBudgetTypeArrayOutputWithContext(context.Context) PodDisruptionBudgetTypeArrayOutput
}

type PodDisruptionBudgetTypeArray []PodDisruptionBudgetTypeInput

func (PodDisruptionBudgetTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PodDisruptionBudgetType)(nil)).Elem()
}

func (i PodDisruptionBudgetTypeArray) ToPodDisruptionBudgetTypeArrayOutput() PodDisruptionBudgetTypeArrayOutput {
	return i.ToPodDisruptionBudgetTypeArrayOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetTypeArray) ToPodDisruptionBudgetTypeArrayOutputWithContext(ctx context.Context) PodDisruptionBudgetTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetTypeArrayOutput)
}

// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
type PodDisruptionBudgetTypeOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetType)(nil)).Elem()
}

func (o PodDisruptionBudgetTypeOutput) ToPodDisruptionBudgetTypeOutput() PodDisruptionBudgetTypeOutput {
	return o
}

func (o PodDisruptionBudgetTypeOutput) ToPodDisruptionBudgetTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodDisruptionBudgetTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodDisruptionBudgetTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o PodDisruptionBudgetTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Specification of the desired behavior of the PodDisruptionBudget.
func (o PodDisruptionBudgetTypeOutput) Spec() PodDisruptionBudgetSpecPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *PodDisruptionBudgetSpec { return v.Spec }).(PodDisruptionBudgetSpecPtrOutput)
}

// Most recently observed status of the PodDisruptionBudget.
func (o PodDisruptionBudgetTypeOutput) Status() PodDisruptionBudgetStatusPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *PodDisruptionBudgetStatus { return v.Status }).(PodDisruptionBudgetStatusPtrOutput)
}

type PodDisruptionBudgetTypeArrayOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PodDisruptionBudgetType)(nil)).Elem()
}

func (o PodDisruptionBudgetTypeArrayOutput) ToPodDisruptionBudgetTypeArrayOutput() PodDisruptionBudgetTypeArrayOutput {
	return o
}

func (o PodDisruptionBudgetTypeArrayOutput) ToPodDisruptionBudgetTypeArrayOutputWithContext(ctx context.Context) PodDisruptionBudgetTypeArrayOutput {
	return o
}

func (o PodDisruptionBudgetTypeArrayOutput) Index(i pulumi.IntInput) PodDisruptionBudgetTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PodDisruptionBudgetType {
		return vs[0].([]PodDisruptionBudgetType)[vs[1].(int)]
	}).(PodDisruptionBudgetTypeOutput)
}

// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
type PodDisruptionBudgetListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is a list of PodDisruptionBudgets
	Items []PodDisruptionBudgetType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// PodDisruptionBudgetListTypeInput is an input type that accepts PodDisruptionBudgetListTypeArgs and PodDisruptionBudgetListTypeOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetListTypeInput` via:
//
//          PodDisruptionBudgetListTypeArgs{...}
type PodDisruptionBudgetListTypeInput interface {
	pulumi.Input

	ToPodDisruptionBudgetListTypeOutput() PodDisruptionBudgetListTypeOutput
	ToPodDisruptionBudgetListTypeOutputWithContext(context.Context) PodDisruptionBudgetListTypeOutput
}

// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
type PodDisruptionBudgetListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is a list of PodDisruptionBudgets
	Items PodDisruptionBudgetTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (PodDisruptionBudgetListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetListType)(nil)).Elem()
}

func (i PodDisruptionBudgetListTypeArgs) ToPodDisruptionBudgetListTypeOutput() PodDisruptionBudgetListTypeOutput {
	return i.ToPodDisruptionBudgetListTypeOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetListTypeArgs) ToPodDisruptionBudgetListTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetListTypeOutput)
}

// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
type PodDisruptionBudgetListTypeOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetListType)(nil)).Elem()
}

func (o PodDisruptionBudgetListTypeOutput) ToPodDisruptionBudgetListTypeOutput() PodDisruptionBudgetListTypeOutput {
	return o
}

func (o PodDisruptionBudgetListTypeOutput) ToPodDisruptionBudgetListTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodDisruptionBudgetListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is a list of PodDisruptionBudgets
func (o PodDisruptionBudgetListTypeOutput) Items() PodDisruptionBudgetTypeArrayOutput {
	return o.ApplyT(func(v PodDisruptionBudgetListType) []PodDisruptionBudgetType { return v.Items }).(PodDisruptionBudgetTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodDisruptionBudgetListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o PodDisruptionBudgetListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
type PodDisruptionBudgetSpec struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
	MinAvailable interface{} `pulumi:"minAvailable"`
	// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
	Selector *metav1.LabelSelector `pulumi:"selector"`
}

// PodDisruptionBudgetSpecInput is an input type that accepts PodDisruptionBudgetSpecArgs and PodDisruptionBudgetSpecOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetSpecInput` via:
//
//          PodDisruptionBudgetSpecArgs{...}
type PodDisruptionBudgetSpecInput interface {
	pulumi.Input

	ToPodDisruptionBudgetSpecOutput() PodDisruptionBudgetSpecOutput
	ToPodDisruptionBudgetSpecOutputWithContext(context.Context) PodDisruptionBudgetSpecOutput
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
type PodDisruptionBudgetSpecArgs struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
	MinAvailable pulumi.Input `pulumi:"minAvailable"`
	// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
	Selector metav1.LabelSelectorPtrInput `pulumi:"selector"`
}

func (PodDisruptionBudgetSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetSpec)(nil)).Elem()
}

func (i PodDisruptionBudgetSpecArgs) ToPodDisruptionBudgetSpecOutput() PodDisruptionBudgetSpecOutput {
	return i.ToPodDisruptionBudgetSpecOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetSpecArgs) ToPodDisruptionBudgetSpecOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetSpecOutput)
}

func (i PodDisruptionBudgetSpecArgs) ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput {
	return i.ToPodDisruptionBudgetSpecPtrOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetSpecArgs) ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetSpecOutput).ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx)
}

// PodDisruptionBudgetSpecPtrInput is an input type that accepts PodDisruptionBudgetSpecArgs, PodDisruptionBudgetSpecPtr and PodDisruptionBudgetSpecPtrOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetSpecPtrInput` via:
//
//          PodDisruptionBudgetSpecArgs{...}
//
//  or:
//
//          nil
type PodDisruptionBudgetSpecPtrInput interface {
	pulumi.Input

	ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput
	ToPodDisruptionBudgetSpecPtrOutputWithContext(context.Context) PodDisruptionBudgetSpecPtrOutput
}

type podDisruptionBudgetSpecPtrType PodDisruptionBudgetSpecArgs

func PodDisruptionBudgetSpecPtr(v *PodDisruptionBudgetSpecArgs) PodDisruptionBudgetSpecPtrInput {
	return (*podDisruptionBudgetSpecPtrType)(v)
}

func (*podDisruptionBudgetSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetSpec)(nil)).Elem()
}

func (i *podDisruptionBudgetSpecPtrType) ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput {
	return i.ToPodDisruptionBudgetSpecPtrOutputWithContext(context.Background())
}

func (i *podDisruptionBudgetSpecPtrType) ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetSpecPtrOutput)
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
type PodDisruptionBudgetSpecOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetSpec)(nil)).Elem()
}

func (o PodDisruptionBudgetSpecOutput) ToPodDisruptionBudgetSpecOutput() PodDisruptionBudgetSpecOutput {
	return o
}

func (o PodDisruptionBudgetSpecOutput) ToPodDisruptionBudgetSpecOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecOutput {
	return o
}

func (o PodDisruptionBudgetSpecOutput) ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput {
	return o.ToPodDisruptionBudgetSpecPtrOutputWithContext(context.Background())
}

func (o PodDisruptionBudgetSpecOutput) ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpec) *PodDisruptionBudgetSpec {
		return &v
	}).(PodDisruptionBudgetSpecPtrOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o PodDisruptionBudgetSpecOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpec) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
func (o PodDisruptionBudgetSpecOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpec) interface{} { return v.MinAvailable }).(pulumi.AnyOutput)
}

// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
func (o PodDisruptionBudgetSpecOutput) Selector() metav1.LabelSelectorPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpec) *metav1.LabelSelector { return v.Selector }).(metav1.LabelSelectorPtrOutput)
}

type PodDisruptionBudgetSpecPtrOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetSpec)(nil)).Elem()
}

func (o PodDisruptionBudgetSpecPtrOutput) ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput {
	return o
}

func (o PodDisruptionBudgetSpecPtrOutput) ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPtrOutput {
	return o
}

func (o PodDisruptionBudgetSpecPtrOutput) Elem() PodDisruptionBudgetSpecOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpec) PodDisruptionBudgetSpec { return *v }).(PodDisruptionBudgetSpecOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o PodDisruptionBudgetSpecPtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpec) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
func (o PodDisruptionBudgetSpecPtrOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpec) interface{} {
		if v == nil {
			return nil
		}
		return v.MinAvailable
	}).(pulumi.AnyOutput)
}

// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
func (o PodDisruptionBudgetSpecPtrOutput) Selector() metav1.LabelSelectorPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpec) *metav1.LabelSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(metav1.LabelSelectorPtrOutput)
}

// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
type PodDisruptionBudgetStatus struct {
	// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
	//               the number of allowed disruptions. Therefore no disruptions are
	//               allowed and the status of the condition will be False.
	// - InsufficientPods: The number of pods are either at or below the number
	//                     required by the PodDisruptionBudget. No disruptions are
	//                     allowed and the status of the condition will be False.
	// - SufficientPods: There are more pods than required by the PodDisruptionBudget.
	//                   The condition will be True, and the number of allowed
	//                   disruptions are provided by the disruptionsAllowed property.
	Conditions []metav1.Condition `pulumi:"conditions"`
	// current number of healthy pods
	CurrentHealthy int `pulumi:"currentHealthy"`
	// minimum desired number of healthy pods
	DesiredHealthy int `pulumi:"desiredHealthy"`
	// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
	DisruptedPods map[string]string `pulumi:"disruptedPods"`
	// Number of pod disruptions that are currently allowed.
	DisruptionsAllowed int `pulumi:"disruptionsAllowed"`
	// total number of pods counted by this disruption budget
	ExpectedPods int `pulumi:"expectedPods"`
	// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
	ObservedGeneration *int `pulumi:"observedGeneration"`
}

// PodDisruptionBudgetStatusInput is an input type that accepts PodDisruptionBudgetStatusArgs and PodDisruptionBudgetStatusOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetStatusInput` via:
//
//          PodDisruptionBudgetStatusArgs{...}
type PodDisruptionBudgetStatusInput interface {
	pulumi.Input

	ToPodDisruptionBudgetStatusOutput() PodDisruptionBudgetStatusOutput
	ToPodDisruptionBudgetStatusOutputWithContext(context.Context) PodDisruptionBudgetStatusOutput
}

// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
type PodDisruptionBudgetStatusArgs struct {
	// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
	//               the number of allowed disruptions. Therefore no disruptions are
	//               allowed and the status of the condition will be False.
	// - InsufficientPods: The number of pods are either at or below the number
	//                     required by the PodDisruptionBudget. No disruptions are
	//                     allowed and the status of the condition will be False.
	// - SufficientPods: There are more pods than required by the PodDisruptionBudget.
	//                   The condition will be True, and the number of allowed
	//                   disruptions are provided by the disruptionsAllowed property.
	Conditions metav1.ConditionArrayInput `pulumi:"conditions"`
	// current number of healthy pods
	CurrentHealthy pulumi.IntInput `pulumi:"currentHealthy"`
	// minimum desired number of healthy pods
	DesiredHealthy pulumi.IntInput `pulumi:"desiredHealthy"`
	// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
	DisruptedPods pulumi.StringMapInput `pulumi:"disruptedPods"`
	// Number of pod disruptions that are currently allowed.
	DisruptionsAllowed pulumi.IntInput `pulumi:"disruptionsAllowed"`
	// total number of pods counted by this disruption budget
	ExpectedPods pulumi.IntInput `pulumi:"expectedPods"`
	// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
}

func (PodDisruptionBudgetStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetStatus)(nil)).Elem()
}

func (i PodDisruptionBudgetStatusArgs) ToPodDisruptionBudgetStatusOutput() PodDisruptionBudgetStatusOutput {
	return i.ToPodDisruptionBudgetStatusOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetStatusArgs) ToPodDisruptionBudgetStatusOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetStatusOutput)
}

func (i PodDisruptionBudgetStatusArgs) ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput {
	return i.ToPodDisruptionBudgetStatusPtrOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetStatusArgs) ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetStatusOutput).ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx)
}

// PodDisruptionBudgetStatusPtrInput is an input type that accepts PodDisruptionBudgetStatusArgs, PodDisruptionBudgetStatusPtr and PodDisruptionBudgetStatusPtrOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetStatusPtrInput` via:
//
//          PodDisruptionBudgetStatusArgs{...}
//
//  or:
//
//          nil
type PodDisruptionBudgetStatusPtrInput interface {
	pulumi.Input

	ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput
	ToPodDisruptionBudgetStatusPtrOutputWithContext(context.Context) PodDisruptionBudgetStatusPtrOutput
}

type podDisruptionBudgetStatusPtrType PodDisruptionBudgetStatusArgs

func PodDisruptionBudgetStatusPtr(v *PodDisruptionBudgetStatusArgs) PodDisruptionBudgetStatusPtrInput {
	return (*podDisruptionBudgetStatusPtrType)(v)
}

func (*podDisruptionBudgetStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetStatus)(nil)).Elem()
}

func (i *podDisruptionBudgetStatusPtrType) ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput {
	return i.ToPodDisruptionBudgetStatusPtrOutputWithContext(context.Background())
}

func (i *podDisruptionBudgetStatusPtrType) ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetStatusPtrOutput)
}

// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
type PodDisruptionBudgetStatusOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetStatus)(nil)).Elem()
}

func (o PodDisruptionBudgetStatusOutput) ToPodDisruptionBudgetStatusOutput() PodDisruptionBudgetStatusOutput {
	return o
}

func (o PodDisruptionBudgetStatusOutput) ToPodDisruptionBudgetStatusOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusOutput {
	return o
}

func (o PodDisruptionBudgetStatusOutput) ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput {
	return o.ToPodDisruptionBudgetStatusPtrOutputWithContext(context.Background())
}

func (o PodDisruptionBudgetStatusOutput) ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) *PodDisruptionBudgetStatus {
		return &v
	}).(PodDisruptionBudgetStatusPtrOutput)
}

// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
//               the number of allowed disruptions. Therefore no disruptions are
//               allowed and the status of the condition will be False.
// - InsufficientPods: The number of pods are either at or below the number
//                     required by the PodDisruptionBudget. No disruptions are
//                     allowed and the status of the condition will be False.
// - SufficientPods: There are more pods than required by the PodDisruptionBudget.
//                   The condition will be True, and the number of allowed
//                   disruptions are provided by the disruptionsAllowed property.
func (o PodDisruptionBudgetStatusOutput) Conditions() metav1.ConditionArrayOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) []metav1.Condition { return v.Conditions }).(metav1.ConditionArrayOutput)
}

// current number of healthy pods
func (o PodDisruptionBudgetStatusOutput) CurrentHealthy() pulumi.IntOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) int { return v.CurrentHealthy }).(pulumi.IntOutput)
}

// minimum desired number of healthy pods
func (o PodDisruptionBudgetStatusOutput) DesiredHealthy() pulumi.IntOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) int { return v.DesiredHealthy }).(pulumi.IntOutput)
}

// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
func (o PodDisruptionBudgetStatusOutput) DisruptedPods() pulumi.StringMapOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) map[string]string { return v.DisruptedPods }).(pulumi.StringMapOutput)
}

// Number of pod disruptions that are currently allowed.
func (o PodDisruptionBudgetStatusOutput) DisruptionsAllowed() pulumi.IntOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) int { return v.DisruptionsAllowed }).(pulumi.IntOutput)
}

// total number of pods counted by this disruption budget
func (o PodDisruptionBudgetStatusOutput) ExpectedPods() pulumi.IntOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) int { return v.ExpectedPods }).(pulumi.IntOutput)
}

// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
func (o PodDisruptionBudgetStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

type PodDisruptionBudgetStatusPtrOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetStatus)(nil)).Elem()
}

func (o PodDisruptionBudgetStatusPtrOutput) ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput {
	return o
}

func (o PodDisruptionBudgetStatusPtrOutput) ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPtrOutput {
	return o
}

func (o PodDisruptionBudgetStatusPtrOutput) Elem() PodDisruptionBudgetStatusOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) PodDisruptionBudgetStatus { return *v }).(PodDisruptionBudgetStatusOutput)
}

// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
//               the number of allowed disruptions. Therefore no disruptions are
//               allowed and the status of the condition will be False.
// - InsufficientPods: The number of pods are either at or below the number
//                     required by the PodDisruptionBudget. No disruptions are
//                     allowed and the status of the condition will be False.
// - SufficientPods: There are more pods than required by the PodDisruptionBudget.
//                   The condition will be True, and the number of allowed
//                   disruptions are provided by the disruptionsAllowed property.
func (o PodDisruptionBudgetStatusPtrOutput) Conditions() metav1.ConditionArrayOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) []metav1.Condition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(metav1.ConditionArrayOutput)
}

// current number of healthy pods
func (o PodDisruptionBudgetStatusPtrOutput) CurrentHealthy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.CurrentHealthy
	}).(pulumi.IntPtrOutput)
}

// minimum desired number of healthy pods
func (o PodDisruptionBudgetStatusPtrOutput) DesiredHealthy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.DesiredHealthy
	}).(pulumi.IntPtrOutput)
}

// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
func (o PodDisruptionBudgetStatusPtrOutput) DisruptedPods() pulumi.StringMapOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) map[string]string {
		if v == nil {
			return nil
		}
		return v.DisruptedPods
	}).(pulumi.StringMapOutput)
}

// Number of pod disruptions that are currently allowed.
func (o PodDisruptionBudgetStatusPtrOutput) DisruptionsAllowed() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.DisruptionsAllowed
	}).(pulumi.IntPtrOutput)
}

// total number of pods counted by this disruption budget
func (o PodDisruptionBudgetStatusPtrOutput) ExpectedPods() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.ExpectedPods
	}).(pulumi.IntPtrOutput)
}

// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
func (o PodDisruptionBudgetStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(PodDisruptionBudgetTypeOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetTypeArrayOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetListTypeOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetSpecOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetSpecPtrOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetStatusOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetStatusPtrOutput{})
}
