// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
type Eviction struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// DeleteOptions may be provided
	DeleteOptions *metav1.DeleteOptions `pulumi:"deleteOptions"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// ObjectMeta describes the pod that is being evicted.
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
}

// EvictionInput is an input type that accepts EvictionArgs and EvictionOutput values.
// You can construct a concrete instance of `EvictionInput` via:
//
//	EvictionArgs{...}
type EvictionInput interface {
	pulumi.Input

	ToEvictionOutput() EvictionOutput
	ToEvictionOutputWithContext(context.Context) EvictionOutput
}

// Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
type EvictionArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// DeleteOptions may be provided
	DeleteOptions metav1.DeleteOptionsPtrInput `pulumi:"deleteOptions"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// ObjectMeta describes the pod that is being evicted.
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
}

func (EvictionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Eviction)(nil)).Elem()
}

func (i EvictionArgs) ToEvictionOutput() EvictionOutput {
	return i.ToEvictionOutputWithContext(context.Background())
}

func (i EvictionArgs) ToEvictionOutputWithContext(ctx context.Context) EvictionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EvictionOutput)
}

// Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
type EvictionOutput struct{ *pulumi.OutputState }

func (EvictionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Eviction)(nil)).Elem()
}

func (o EvictionOutput) ToEvictionOutput() EvictionOutput {
	return o
}

func (o EvictionOutput) ToEvictionOutputWithContext(ctx context.Context) EvictionOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o EvictionOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Eviction) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// DeleteOptions may be provided
func (o EvictionOutput) DeleteOptions() metav1.DeleteOptionsPtrOutput {
	return o.ApplyT(func(v Eviction) *metav1.DeleteOptions { return v.DeleteOptions }).(metav1.DeleteOptionsPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o EvictionOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Eviction) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// ObjectMeta describes the pod that is being evicted.
func (o EvictionOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v Eviction) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
type EvictionPatch struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// DeleteOptions may be provided
	DeleteOptions *metav1.DeleteOptionsPatch `pulumi:"deleteOptions"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// ObjectMeta describes the pod that is being evicted.
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
}

// EvictionPatchInput is an input type that accepts EvictionPatchArgs and EvictionPatchOutput values.
// You can construct a concrete instance of `EvictionPatchInput` via:
//
//	EvictionPatchArgs{...}
type EvictionPatchInput interface {
	pulumi.Input

	ToEvictionPatchOutput() EvictionPatchOutput
	ToEvictionPatchOutputWithContext(context.Context) EvictionPatchOutput
}

// Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
type EvictionPatchArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// DeleteOptions may be provided
	DeleteOptions metav1.DeleteOptionsPatchPtrInput `pulumi:"deleteOptions"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// ObjectMeta describes the pod that is being evicted.
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
}

func (EvictionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EvictionPatch)(nil)).Elem()
}

func (i EvictionPatchArgs) ToEvictionPatchOutput() EvictionPatchOutput {
	return i.ToEvictionPatchOutputWithContext(context.Background())
}

func (i EvictionPatchArgs) ToEvictionPatchOutputWithContext(ctx context.Context) EvictionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EvictionPatchOutput)
}

// Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
type EvictionPatchOutput struct{ *pulumi.OutputState }

func (EvictionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EvictionPatch)(nil)).Elem()
}

func (o EvictionPatchOutput) ToEvictionPatchOutput() EvictionPatchOutput {
	return o
}

func (o EvictionPatchOutput) ToEvictionPatchOutputWithContext(ctx context.Context) EvictionPatchOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o EvictionPatchOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EvictionPatch) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// DeleteOptions may be provided
func (o EvictionPatchOutput) DeleteOptions() metav1.DeleteOptionsPatchPtrOutput {
	return o.ApplyT(func(v EvictionPatch) *metav1.DeleteOptionsPatch { return v.DeleteOptions }).(metav1.DeleteOptionsPatchPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o EvictionPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EvictionPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// ObjectMeta describes the pod that is being evicted.
func (o EvictionPatchOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v EvictionPatch) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
type PodDisruptionBudgetType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Specification of the desired behavior of the PodDisruptionBudget.
	Spec *PodDisruptionBudgetSpec `pulumi:"spec"`
	// Most recently observed status of the PodDisruptionBudget.
	Status *PodDisruptionBudgetStatus `pulumi:"status"`
}

// PodDisruptionBudgetTypeInput is an input type that accepts PodDisruptionBudgetTypeArgs and PodDisruptionBudgetTypeOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetTypeInput` via:
//
//	PodDisruptionBudgetTypeArgs{...}
type PodDisruptionBudgetTypeInput interface {
	pulumi.Input

	ToPodDisruptionBudgetTypeOutput() PodDisruptionBudgetTypeOutput
	ToPodDisruptionBudgetTypeOutputWithContext(context.Context) PodDisruptionBudgetTypeOutput
}

// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
type PodDisruptionBudgetTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Specification of the desired behavior of the PodDisruptionBudget.
	Spec PodDisruptionBudgetSpecPtrInput `pulumi:"spec"`
	// Most recently observed status of the PodDisruptionBudget.
	Status PodDisruptionBudgetStatusPtrInput `pulumi:"status"`
}

func (PodDisruptionBudgetTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetType)(nil)).Elem()
}

func (i PodDisruptionBudgetTypeArgs) ToPodDisruptionBudgetTypeOutput() PodDisruptionBudgetTypeOutput {
	return i.ToPodDisruptionBudgetTypeOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetTypeArgs) ToPodDisruptionBudgetTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetTypeOutput)
}

// PodDisruptionBudgetTypeArrayInput is an input type that accepts PodDisruptionBudgetTypeArray and PodDisruptionBudgetTypeArrayOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetTypeArrayInput` via:
//
//	PodDisruptionBudgetTypeArray{ PodDisruptionBudgetTypeArgs{...} }
type PodDisruptionBudgetTypeArrayInput interface {
	pulumi.Input

	ToPodDisruptionBudgetTypeArrayOutput() PodDisruptionBudgetTypeArrayOutput
	ToPodDisruptionBudgetTypeArrayOutputWithContext(context.Context) PodDisruptionBudgetTypeArrayOutput
}

type PodDisruptionBudgetTypeArray []PodDisruptionBudgetTypeInput

func (PodDisruptionBudgetTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PodDisruptionBudgetType)(nil)).Elem()
}

func (i PodDisruptionBudgetTypeArray) ToPodDisruptionBudgetTypeArrayOutput() PodDisruptionBudgetTypeArrayOutput {
	return i.ToPodDisruptionBudgetTypeArrayOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetTypeArray) ToPodDisruptionBudgetTypeArrayOutputWithContext(ctx context.Context) PodDisruptionBudgetTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetTypeArrayOutput)
}

// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
type PodDisruptionBudgetTypeOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetType)(nil)).Elem()
}

func (o PodDisruptionBudgetTypeOutput) ToPodDisruptionBudgetTypeOutput() PodDisruptionBudgetTypeOutput {
	return o
}

func (o PodDisruptionBudgetTypeOutput) ToPodDisruptionBudgetTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodDisruptionBudgetTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodDisruptionBudgetTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o PodDisruptionBudgetTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Specification of the desired behavior of the PodDisruptionBudget.
func (o PodDisruptionBudgetTypeOutput) Spec() PodDisruptionBudgetSpecPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *PodDisruptionBudgetSpec { return v.Spec }).(PodDisruptionBudgetSpecPtrOutput)
}

// Most recently observed status of the PodDisruptionBudget.
func (o PodDisruptionBudgetTypeOutput) Status() PodDisruptionBudgetStatusPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetType) *PodDisruptionBudgetStatus { return v.Status }).(PodDisruptionBudgetStatusPtrOutput)
}

type PodDisruptionBudgetTypeArrayOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PodDisruptionBudgetType)(nil)).Elem()
}

func (o PodDisruptionBudgetTypeArrayOutput) ToPodDisruptionBudgetTypeArrayOutput() PodDisruptionBudgetTypeArrayOutput {
	return o
}

func (o PodDisruptionBudgetTypeArrayOutput) ToPodDisruptionBudgetTypeArrayOutputWithContext(ctx context.Context) PodDisruptionBudgetTypeArrayOutput {
	return o
}

func (o PodDisruptionBudgetTypeArrayOutput) Index(i pulumi.IntInput) PodDisruptionBudgetTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PodDisruptionBudgetType {
		return vs[0].([]PodDisruptionBudgetType)[vs[1].(int)]
	}).(PodDisruptionBudgetTypeOutput)
}

// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
type PodDisruptionBudgetListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is a list of PodDisruptionBudgets
	Items []PodDisruptionBudgetType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// PodDisruptionBudgetListTypeInput is an input type that accepts PodDisruptionBudgetListTypeArgs and PodDisruptionBudgetListTypeOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetListTypeInput` via:
//
//	PodDisruptionBudgetListTypeArgs{...}
type PodDisruptionBudgetListTypeInput interface {
	pulumi.Input

	ToPodDisruptionBudgetListTypeOutput() PodDisruptionBudgetListTypeOutput
	ToPodDisruptionBudgetListTypeOutputWithContext(context.Context) PodDisruptionBudgetListTypeOutput
}

// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
type PodDisruptionBudgetListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Items is a list of PodDisruptionBudgets
	Items PodDisruptionBudgetTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (PodDisruptionBudgetListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetListType)(nil)).Elem()
}

func (i PodDisruptionBudgetListTypeArgs) ToPodDisruptionBudgetListTypeOutput() PodDisruptionBudgetListTypeOutput {
	return i.ToPodDisruptionBudgetListTypeOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetListTypeArgs) ToPodDisruptionBudgetListTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetListTypeOutput)
}

// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
type PodDisruptionBudgetListTypeOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetListType)(nil)).Elem()
}

func (o PodDisruptionBudgetListTypeOutput) ToPodDisruptionBudgetListTypeOutput() PodDisruptionBudgetListTypeOutput {
	return o
}

func (o PodDisruptionBudgetListTypeOutput) ToPodDisruptionBudgetListTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodDisruptionBudgetListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Items is a list of PodDisruptionBudgets
func (o PodDisruptionBudgetListTypeOutput) Items() PodDisruptionBudgetTypeArrayOutput {
	return o.ApplyT(func(v PodDisruptionBudgetListType) []PodDisruptionBudgetType { return v.Items }).(PodDisruptionBudgetTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodDisruptionBudgetListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o PodDisruptionBudgetListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
type PodDisruptionBudgetPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// Specification of the desired behavior of the PodDisruptionBudget.
	Spec *PodDisruptionBudgetSpecPatch `pulumi:"spec"`
	// Most recently observed status of the PodDisruptionBudget.
	Status *PodDisruptionBudgetStatusPatch `pulumi:"status"`
}

// PodDisruptionBudgetPatchTypeInput is an input type that accepts PodDisruptionBudgetPatchTypeArgs and PodDisruptionBudgetPatchTypeOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetPatchTypeInput` via:
//
//	PodDisruptionBudgetPatchTypeArgs{...}
type PodDisruptionBudgetPatchTypeInput interface {
	pulumi.Input

	ToPodDisruptionBudgetPatchTypeOutput() PodDisruptionBudgetPatchTypeOutput
	ToPodDisruptionBudgetPatchTypeOutputWithContext(context.Context) PodDisruptionBudgetPatchTypeOutput
}

// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
type PodDisruptionBudgetPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// Specification of the desired behavior of the PodDisruptionBudget.
	Spec PodDisruptionBudgetSpecPatchPtrInput `pulumi:"spec"`
	// Most recently observed status of the PodDisruptionBudget.
	Status PodDisruptionBudgetStatusPatchPtrInput `pulumi:"status"`
}

func (PodDisruptionBudgetPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetPatchType)(nil)).Elem()
}

func (i PodDisruptionBudgetPatchTypeArgs) ToPodDisruptionBudgetPatchTypeOutput() PodDisruptionBudgetPatchTypeOutput {
	return i.ToPodDisruptionBudgetPatchTypeOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetPatchTypeArgs) ToPodDisruptionBudgetPatchTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetPatchTypeOutput)
}

// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
type PodDisruptionBudgetPatchTypeOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetPatchType)(nil)).Elem()
}

func (o PodDisruptionBudgetPatchTypeOutput) ToPodDisruptionBudgetPatchTypeOutput() PodDisruptionBudgetPatchTypeOutput {
	return o
}

func (o PodDisruptionBudgetPatchTypeOutput) ToPodDisruptionBudgetPatchTypeOutputWithContext(ctx context.Context) PodDisruptionBudgetPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PodDisruptionBudgetPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PodDisruptionBudgetPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o PodDisruptionBudgetPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// Specification of the desired behavior of the PodDisruptionBudget.
func (o PodDisruptionBudgetPatchTypeOutput) Spec() PodDisruptionBudgetSpecPatchPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetPatchType) *PodDisruptionBudgetSpecPatch { return v.Spec }).(PodDisruptionBudgetSpecPatchPtrOutput)
}

// Most recently observed status of the PodDisruptionBudget.
func (o PodDisruptionBudgetPatchTypeOutput) Status() PodDisruptionBudgetStatusPatchPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetPatchType) *PodDisruptionBudgetStatusPatch { return v.Status }).(PodDisruptionBudgetStatusPatchPtrOutput)
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
type PodDisruptionBudgetSpec struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
	MinAvailable interface{} `pulumi:"minAvailable"`
	// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
	Selector *metav1.LabelSelector `pulumi:"selector"`
	// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type="Ready",status="True".
	//
	// Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy.
	//
	// IfHealthyBudget policy means that running pods (status.phase="Running"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.
	//
	// AlwaysAllow policy means that all running pods (status.phase="Running"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction.
	//
	// Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field.
	//
	// This field is beta-level. The eviction API uses this field when the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
	UnhealthyPodEvictionPolicy *string `pulumi:"unhealthyPodEvictionPolicy"`
}

// PodDisruptionBudgetSpecInput is an input type that accepts PodDisruptionBudgetSpecArgs and PodDisruptionBudgetSpecOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetSpecInput` via:
//
//	PodDisruptionBudgetSpecArgs{...}
type PodDisruptionBudgetSpecInput interface {
	pulumi.Input

	ToPodDisruptionBudgetSpecOutput() PodDisruptionBudgetSpecOutput
	ToPodDisruptionBudgetSpecOutputWithContext(context.Context) PodDisruptionBudgetSpecOutput
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
type PodDisruptionBudgetSpecArgs struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
	MinAvailable pulumi.Input `pulumi:"minAvailable"`
	// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
	Selector metav1.LabelSelectorPtrInput `pulumi:"selector"`
	// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type="Ready",status="True".
	//
	// Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy.
	//
	// IfHealthyBudget policy means that running pods (status.phase="Running"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.
	//
	// AlwaysAllow policy means that all running pods (status.phase="Running"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction.
	//
	// Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field.
	//
	// This field is beta-level. The eviction API uses this field when the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
	UnhealthyPodEvictionPolicy pulumi.StringPtrInput `pulumi:"unhealthyPodEvictionPolicy"`
}

func (PodDisruptionBudgetSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetSpec)(nil)).Elem()
}

func (i PodDisruptionBudgetSpecArgs) ToPodDisruptionBudgetSpecOutput() PodDisruptionBudgetSpecOutput {
	return i.ToPodDisruptionBudgetSpecOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetSpecArgs) ToPodDisruptionBudgetSpecOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetSpecOutput)
}

func (i PodDisruptionBudgetSpecArgs) ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput {
	return i.ToPodDisruptionBudgetSpecPtrOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetSpecArgs) ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetSpecOutput).ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx)
}

// PodDisruptionBudgetSpecPtrInput is an input type that accepts PodDisruptionBudgetSpecArgs, PodDisruptionBudgetSpecPtr and PodDisruptionBudgetSpecPtrOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetSpecPtrInput` via:
//
//	        PodDisruptionBudgetSpecArgs{...}
//
//	or:
//
//	        nil
type PodDisruptionBudgetSpecPtrInput interface {
	pulumi.Input

	ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput
	ToPodDisruptionBudgetSpecPtrOutputWithContext(context.Context) PodDisruptionBudgetSpecPtrOutput
}

type podDisruptionBudgetSpecPtrType PodDisruptionBudgetSpecArgs

func PodDisruptionBudgetSpecPtr(v *PodDisruptionBudgetSpecArgs) PodDisruptionBudgetSpecPtrInput {
	return (*podDisruptionBudgetSpecPtrType)(v)
}

func (*podDisruptionBudgetSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetSpec)(nil)).Elem()
}

func (i *podDisruptionBudgetSpecPtrType) ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput {
	return i.ToPodDisruptionBudgetSpecPtrOutputWithContext(context.Background())
}

func (i *podDisruptionBudgetSpecPtrType) ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetSpecPtrOutput)
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
type PodDisruptionBudgetSpecOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetSpec)(nil)).Elem()
}

func (o PodDisruptionBudgetSpecOutput) ToPodDisruptionBudgetSpecOutput() PodDisruptionBudgetSpecOutput {
	return o
}

func (o PodDisruptionBudgetSpecOutput) ToPodDisruptionBudgetSpecOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecOutput {
	return o
}

func (o PodDisruptionBudgetSpecOutput) ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput {
	return o.ToPodDisruptionBudgetSpecPtrOutputWithContext(context.Background())
}

func (o PodDisruptionBudgetSpecOutput) ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodDisruptionBudgetSpec) *PodDisruptionBudgetSpec {
		return &v
	}).(PodDisruptionBudgetSpecPtrOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o PodDisruptionBudgetSpecOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpec) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
func (o PodDisruptionBudgetSpecOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpec) interface{} { return v.MinAvailable }).(pulumi.AnyOutput)
}

// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
func (o PodDisruptionBudgetSpecOutput) Selector() metav1.LabelSelectorPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpec) *metav1.LabelSelector { return v.Selector }).(metav1.LabelSelectorPtrOutput)
}

// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type="Ready",status="True".
//
// Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy.
//
// IfHealthyBudget policy means that running pods (status.phase="Running"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.
//
// AlwaysAllow policy means that all running pods (status.phase="Running"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction.
//
// Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field.
//
// This field is beta-level. The eviction API uses this field when the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
func (o PodDisruptionBudgetSpecOutput) UnhealthyPodEvictionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpec) *string { return v.UnhealthyPodEvictionPolicy }).(pulumi.StringPtrOutput)
}

type PodDisruptionBudgetSpecPtrOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetSpec)(nil)).Elem()
}

func (o PodDisruptionBudgetSpecPtrOutput) ToPodDisruptionBudgetSpecPtrOutput() PodDisruptionBudgetSpecPtrOutput {
	return o
}

func (o PodDisruptionBudgetSpecPtrOutput) ToPodDisruptionBudgetSpecPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPtrOutput {
	return o
}

func (o PodDisruptionBudgetSpecPtrOutput) Elem() PodDisruptionBudgetSpecOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpec) PodDisruptionBudgetSpec {
		if v != nil {
			return *v
		}
		var ret PodDisruptionBudgetSpec
		return ret
	}).(PodDisruptionBudgetSpecOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o PodDisruptionBudgetSpecPtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpec) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
func (o PodDisruptionBudgetSpecPtrOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpec) interface{} {
		if v == nil {
			return nil
		}
		return v.MinAvailable
	}).(pulumi.AnyOutput)
}

// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
func (o PodDisruptionBudgetSpecPtrOutput) Selector() metav1.LabelSelectorPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpec) *metav1.LabelSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(metav1.LabelSelectorPtrOutput)
}

// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type="Ready",status="True".
//
// Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy.
//
// IfHealthyBudget policy means that running pods (status.phase="Running"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.
//
// AlwaysAllow policy means that all running pods (status.phase="Running"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction.
//
// Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field.
//
// This field is beta-level. The eviction API uses this field when the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
func (o PodDisruptionBudgetSpecPtrOutput) UnhealthyPodEvictionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpec) *string {
		if v == nil {
			return nil
		}
		return v.UnhealthyPodEvictionPolicy
	}).(pulumi.StringPtrOutput)
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
type PodDisruptionBudgetSpecPatch struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
	MinAvailable interface{} `pulumi:"minAvailable"`
	// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
	Selector *metav1.LabelSelectorPatch `pulumi:"selector"`
	// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type="Ready",status="True".
	//
	// Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy.
	//
	// IfHealthyBudget policy means that running pods (status.phase="Running"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.
	//
	// AlwaysAllow policy means that all running pods (status.phase="Running"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction.
	//
	// Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field.
	//
	// This field is beta-level. The eviction API uses this field when the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
	UnhealthyPodEvictionPolicy *string `pulumi:"unhealthyPodEvictionPolicy"`
}

// PodDisruptionBudgetSpecPatchInput is an input type that accepts PodDisruptionBudgetSpecPatchArgs and PodDisruptionBudgetSpecPatchOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetSpecPatchInput` via:
//
//	PodDisruptionBudgetSpecPatchArgs{...}
type PodDisruptionBudgetSpecPatchInput interface {
	pulumi.Input

	ToPodDisruptionBudgetSpecPatchOutput() PodDisruptionBudgetSpecPatchOutput
	ToPodDisruptionBudgetSpecPatchOutputWithContext(context.Context) PodDisruptionBudgetSpecPatchOutput
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
type PodDisruptionBudgetSpecPatchArgs struct {
	// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
	// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
	MinAvailable pulumi.Input `pulumi:"minAvailable"`
	// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
	Selector metav1.LabelSelectorPatchPtrInput `pulumi:"selector"`
	// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type="Ready",status="True".
	//
	// Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy.
	//
	// IfHealthyBudget policy means that running pods (status.phase="Running"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.
	//
	// AlwaysAllow policy means that all running pods (status.phase="Running"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction.
	//
	// Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field.
	//
	// This field is beta-level. The eviction API uses this field when the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
	UnhealthyPodEvictionPolicy pulumi.StringPtrInput `pulumi:"unhealthyPodEvictionPolicy"`
}

func (PodDisruptionBudgetSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetSpecPatch)(nil)).Elem()
}

func (i PodDisruptionBudgetSpecPatchArgs) ToPodDisruptionBudgetSpecPatchOutput() PodDisruptionBudgetSpecPatchOutput {
	return i.ToPodDisruptionBudgetSpecPatchOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetSpecPatchArgs) ToPodDisruptionBudgetSpecPatchOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetSpecPatchOutput)
}

func (i PodDisruptionBudgetSpecPatchArgs) ToPodDisruptionBudgetSpecPatchPtrOutput() PodDisruptionBudgetSpecPatchPtrOutput {
	return i.ToPodDisruptionBudgetSpecPatchPtrOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetSpecPatchArgs) ToPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetSpecPatchOutput).ToPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx)
}

// PodDisruptionBudgetSpecPatchPtrInput is an input type that accepts PodDisruptionBudgetSpecPatchArgs, PodDisruptionBudgetSpecPatchPtr and PodDisruptionBudgetSpecPatchPtrOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetSpecPatchPtrInput` via:
//
//	        PodDisruptionBudgetSpecPatchArgs{...}
//
//	or:
//
//	        nil
type PodDisruptionBudgetSpecPatchPtrInput interface {
	pulumi.Input

	ToPodDisruptionBudgetSpecPatchPtrOutput() PodDisruptionBudgetSpecPatchPtrOutput
	ToPodDisruptionBudgetSpecPatchPtrOutputWithContext(context.Context) PodDisruptionBudgetSpecPatchPtrOutput
}

type podDisruptionBudgetSpecPatchPtrType PodDisruptionBudgetSpecPatchArgs

func PodDisruptionBudgetSpecPatchPtr(v *PodDisruptionBudgetSpecPatchArgs) PodDisruptionBudgetSpecPatchPtrInput {
	return (*podDisruptionBudgetSpecPatchPtrType)(v)
}

func (*podDisruptionBudgetSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetSpecPatch)(nil)).Elem()
}

func (i *podDisruptionBudgetSpecPatchPtrType) ToPodDisruptionBudgetSpecPatchPtrOutput() PodDisruptionBudgetSpecPatchPtrOutput {
	return i.ToPodDisruptionBudgetSpecPatchPtrOutputWithContext(context.Background())
}

func (i *podDisruptionBudgetSpecPatchPtrType) ToPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetSpecPatchPtrOutput)
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
type PodDisruptionBudgetSpecPatchOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetSpecPatch)(nil)).Elem()
}

func (o PodDisruptionBudgetSpecPatchOutput) ToPodDisruptionBudgetSpecPatchOutput() PodDisruptionBudgetSpecPatchOutput {
	return o
}

func (o PodDisruptionBudgetSpecPatchOutput) ToPodDisruptionBudgetSpecPatchOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPatchOutput {
	return o
}

func (o PodDisruptionBudgetSpecPatchOutput) ToPodDisruptionBudgetSpecPatchPtrOutput() PodDisruptionBudgetSpecPatchPtrOutput {
	return o.ToPodDisruptionBudgetSpecPatchPtrOutputWithContext(context.Background())
}

func (o PodDisruptionBudgetSpecPatchOutput) ToPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodDisruptionBudgetSpecPatch) *PodDisruptionBudgetSpecPatch {
		return &v
	}).(PodDisruptionBudgetSpecPatchPtrOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o PodDisruptionBudgetSpecPatchOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpecPatch) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
func (o PodDisruptionBudgetSpecPatchOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpecPatch) interface{} { return v.MinAvailable }).(pulumi.AnyOutput)
}

// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
func (o PodDisruptionBudgetSpecPatchOutput) Selector() metav1.LabelSelectorPatchPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpecPatch) *metav1.LabelSelectorPatch { return v.Selector }).(metav1.LabelSelectorPatchPtrOutput)
}

// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type="Ready",status="True".
//
// Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy.
//
// IfHealthyBudget policy means that running pods (status.phase="Running"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.
//
// AlwaysAllow policy means that all running pods (status.phase="Running"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction.
//
// Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field.
//
// This field is beta-level. The eviction API uses this field when the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
func (o PodDisruptionBudgetSpecPatchOutput) UnhealthyPodEvictionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetSpecPatch) *string { return v.UnhealthyPodEvictionPolicy }).(pulumi.StringPtrOutput)
}

type PodDisruptionBudgetSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetSpecPatch)(nil)).Elem()
}

func (o PodDisruptionBudgetSpecPatchPtrOutput) ToPodDisruptionBudgetSpecPatchPtrOutput() PodDisruptionBudgetSpecPatchPtrOutput {
	return o
}

func (o PodDisruptionBudgetSpecPatchPtrOutput) ToPodDisruptionBudgetSpecPatchPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetSpecPatchPtrOutput {
	return o
}

func (o PodDisruptionBudgetSpecPatchPtrOutput) Elem() PodDisruptionBudgetSpecPatchOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpecPatch) PodDisruptionBudgetSpecPatch {
		if v != nil {
			return *v
		}
		var ret PodDisruptionBudgetSpecPatch
		return ret
	}).(PodDisruptionBudgetSpecPatchOutput)
}

// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
func (o PodDisruptionBudgetSpecPatchPtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpecPatch) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
func (o PodDisruptionBudgetSpecPatchPtrOutput) MinAvailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpecPatch) interface{} {
		if v == nil {
			return nil
		}
		return v.MinAvailable
	}).(pulumi.AnyOutput)
}

// Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
func (o PodDisruptionBudgetSpecPatchPtrOutput) Selector() metav1.LabelSelectorPatchPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpecPatch) *metav1.LabelSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(metav1.LabelSelectorPatchPtrOutput)
}

// UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods should be considered for eviction. Current implementation considers healthy pods, as pods that have status.conditions item with type="Ready",status="True".
//
// Valid policies are IfHealthyBudget and AlwaysAllow. If no policy is specified, the default behavior will be used, which corresponds to the IfHealthyBudget policy.
//
// IfHealthyBudget policy means that running pods (status.phase="Running"), but not yet healthy can be evicted only if the guarded application is not disrupted (status.currentHealthy is at least equal to status.desiredHealthy). Healthy pods will be subject to the PDB for eviction.
//
// AlwaysAllow policy means that all running pods (status.phase="Running"), but not yet healthy are considered disrupted and can be evicted regardless of whether the criteria in a PDB is met. This means perspective running pods of a disrupted application might not get a chance to become healthy. Healthy pods will be subject to the PDB for eviction.
//
// Additional policies may be added in the future. Clients making eviction decisions should disallow eviction of unhealthy pods if they encounter an unrecognized policy in this field.
//
// This field is beta-level. The eviction API uses this field when the feature gate PDBUnhealthyPodEvictionPolicy is enabled (enabled by default).
func (o PodDisruptionBudgetSpecPatchPtrOutput) UnhealthyPodEvictionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.UnhealthyPodEvictionPolicy
	}).(pulumi.StringPtrOutput)
}

// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
type PodDisruptionBudgetStatus struct {
	// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
	//               the number of allowed disruptions. Therefore no disruptions are
	//               allowed and the status of the condition will be False.
	// - InsufficientPods: The number of pods are either at or below the number
	//                     required by the PodDisruptionBudget. No disruptions are
	//                     allowed and the status of the condition will be False.
	// - SufficientPods: There are more pods than required by the PodDisruptionBudget.
	//                   The condition will be True, and the number of allowed
	//                   disruptions are provided by the disruptionsAllowed property.
	Conditions []metav1.Condition `pulumi:"conditions"`
	// current number of healthy pods
	CurrentHealthy int `pulumi:"currentHealthy"`
	// minimum desired number of healthy pods
	DesiredHealthy int `pulumi:"desiredHealthy"`
	// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
	DisruptedPods map[string]string `pulumi:"disruptedPods"`
	// Number of pod disruptions that are currently allowed.
	DisruptionsAllowed int `pulumi:"disruptionsAllowed"`
	// total number of pods counted by this disruption budget
	ExpectedPods int `pulumi:"expectedPods"`
	// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
	ObservedGeneration *int `pulumi:"observedGeneration"`
}

// PodDisruptionBudgetStatusInput is an input type that accepts PodDisruptionBudgetStatusArgs and PodDisruptionBudgetStatusOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetStatusInput` via:
//
//	PodDisruptionBudgetStatusArgs{...}
type PodDisruptionBudgetStatusInput interface {
	pulumi.Input

	ToPodDisruptionBudgetStatusOutput() PodDisruptionBudgetStatusOutput
	ToPodDisruptionBudgetStatusOutputWithContext(context.Context) PodDisruptionBudgetStatusOutput
}

// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
type PodDisruptionBudgetStatusArgs struct {
	// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
	//               the number of allowed disruptions. Therefore no disruptions are
	//               allowed and the status of the condition will be False.
	// - InsufficientPods: The number of pods are either at or below the number
	//                     required by the PodDisruptionBudget. No disruptions are
	//                     allowed and the status of the condition will be False.
	// - SufficientPods: There are more pods than required by the PodDisruptionBudget.
	//                   The condition will be True, and the number of allowed
	//                   disruptions are provided by the disruptionsAllowed property.
	Conditions metav1.ConditionArrayInput `pulumi:"conditions"`
	// current number of healthy pods
	CurrentHealthy pulumi.IntInput `pulumi:"currentHealthy"`
	// minimum desired number of healthy pods
	DesiredHealthy pulumi.IntInput `pulumi:"desiredHealthy"`
	// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
	DisruptedPods pulumi.StringMapInput `pulumi:"disruptedPods"`
	// Number of pod disruptions that are currently allowed.
	DisruptionsAllowed pulumi.IntInput `pulumi:"disruptionsAllowed"`
	// total number of pods counted by this disruption budget
	ExpectedPods pulumi.IntInput `pulumi:"expectedPods"`
	// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
}

func (PodDisruptionBudgetStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetStatus)(nil)).Elem()
}

func (i PodDisruptionBudgetStatusArgs) ToPodDisruptionBudgetStatusOutput() PodDisruptionBudgetStatusOutput {
	return i.ToPodDisruptionBudgetStatusOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetStatusArgs) ToPodDisruptionBudgetStatusOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetStatusOutput)
}

func (i PodDisruptionBudgetStatusArgs) ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput {
	return i.ToPodDisruptionBudgetStatusPtrOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetStatusArgs) ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetStatusOutput).ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx)
}

// PodDisruptionBudgetStatusPtrInput is an input type that accepts PodDisruptionBudgetStatusArgs, PodDisruptionBudgetStatusPtr and PodDisruptionBudgetStatusPtrOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetStatusPtrInput` via:
//
//	        PodDisruptionBudgetStatusArgs{...}
//
//	or:
//
//	        nil
type PodDisruptionBudgetStatusPtrInput interface {
	pulumi.Input

	ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput
	ToPodDisruptionBudgetStatusPtrOutputWithContext(context.Context) PodDisruptionBudgetStatusPtrOutput
}

type podDisruptionBudgetStatusPtrType PodDisruptionBudgetStatusArgs

func PodDisruptionBudgetStatusPtr(v *PodDisruptionBudgetStatusArgs) PodDisruptionBudgetStatusPtrInput {
	return (*podDisruptionBudgetStatusPtrType)(v)
}

func (*podDisruptionBudgetStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetStatus)(nil)).Elem()
}

func (i *podDisruptionBudgetStatusPtrType) ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput {
	return i.ToPodDisruptionBudgetStatusPtrOutputWithContext(context.Background())
}

func (i *podDisruptionBudgetStatusPtrType) ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetStatusPtrOutput)
}

// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
type PodDisruptionBudgetStatusOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetStatus)(nil)).Elem()
}

func (o PodDisruptionBudgetStatusOutput) ToPodDisruptionBudgetStatusOutput() PodDisruptionBudgetStatusOutput {
	return o
}

func (o PodDisruptionBudgetStatusOutput) ToPodDisruptionBudgetStatusOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusOutput {
	return o
}

func (o PodDisruptionBudgetStatusOutput) ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput {
	return o.ToPodDisruptionBudgetStatusPtrOutputWithContext(context.Background())
}

func (o PodDisruptionBudgetStatusOutput) ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodDisruptionBudgetStatus) *PodDisruptionBudgetStatus {
		return &v
	}).(PodDisruptionBudgetStatusPtrOutput)
}

// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
//
//	the number of allowed disruptions. Therefore no disruptions are
//	allowed and the status of the condition will be False.
//   - InsufficientPods: The number of pods are either at or below the number
//     required by the PodDisruptionBudget. No disruptions are
//     allowed and the status of the condition will be False.
//   - SufficientPods: There are more pods than required by the PodDisruptionBudget.
//     The condition will be True, and the number of allowed
//     disruptions are provided by the disruptionsAllowed property.
func (o PodDisruptionBudgetStatusOutput) Conditions() metav1.ConditionArrayOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) []metav1.Condition { return v.Conditions }).(metav1.ConditionArrayOutput)
}

// current number of healthy pods
func (o PodDisruptionBudgetStatusOutput) CurrentHealthy() pulumi.IntOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) int { return v.CurrentHealthy }).(pulumi.IntOutput)
}

// minimum desired number of healthy pods
func (o PodDisruptionBudgetStatusOutput) DesiredHealthy() pulumi.IntOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) int { return v.DesiredHealthy }).(pulumi.IntOutput)
}

// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
func (o PodDisruptionBudgetStatusOutput) DisruptedPods() pulumi.StringMapOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) map[string]string { return v.DisruptedPods }).(pulumi.StringMapOutput)
}

// Number of pod disruptions that are currently allowed.
func (o PodDisruptionBudgetStatusOutput) DisruptionsAllowed() pulumi.IntOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) int { return v.DisruptionsAllowed }).(pulumi.IntOutput)
}

// total number of pods counted by this disruption budget
func (o PodDisruptionBudgetStatusOutput) ExpectedPods() pulumi.IntOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) int { return v.ExpectedPods }).(pulumi.IntOutput)
}

// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
func (o PodDisruptionBudgetStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

type PodDisruptionBudgetStatusPtrOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetStatus)(nil)).Elem()
}

func (o PodDisruptionBudgetStatusPtrOutput) ToPodDisruptionBudgetStatusPtrOutput() PodDisruptionBudgetStatusPtrOutput {
	return o
}

func (o PodDisruptionBudgetStatusPtrOutput) ToPodDisruptionBudgetStatusPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPtrOutput {
	return o
}

func (o PodDisruptionBudgetStatusPtrOutput) Elem() PodDisruptionBudgetStatusOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) PodDisruptionBudgetStatus {
		if v != nil {
			return *v
		}
		var ret PodDisruptionBudgetStatus
		return ret
	}).(PodDisruptionBudgetStatusOutput)
}

// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
//
//	the number of allowed disruptions. Therefore no disruptions are
//	allowed and the status of the condition will be False.
//   - InsufficientPods: The number of pods are either at or below the number
//     required by the PodDisruptionBudget. No disruptions are
//     allowed and the status of the condition will be False.
//   - SufficientPods: There are more pods than required by the PodDisruptionBudget.
//     The condition will be True, and the number of allowed
//     disruptions are provided by the disruptionsAllowed property.
func (o PodDisruptionBudgetStatusPtrOutput) Conditions() metav1.ConditionArrayOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) []metav1.Condition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(metav1.ConditionArrayOutput)
}

// current number of healthy pods
func (o PodDisruptionBudgetStatusPtrOutput) CurrentHealthy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.CurrentHealthy
	}).(pulumi.IntPtrOutput)
}

// minimum desired number of healthy pods
func (o PodDisruptionBudgetStatusPtrOutput) DesiredHealthy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.DesiredHealthy
	}).(pulumi.IntPtrOutput)
}

// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
func (o PodDisruptionBudgetStatusPtrOutput) DisruptedPods() pulumi.StringMapOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) map[string]string {
		if v == nil {
			return nil
		}
		return v.DisruptedPods
	}).(pulumi.StringMapOutput)
}

// Number of pod disruptions that are currently allowed.
func (o PodDisruptionBudgetStatusPtrOutput) DisruptionsAllowed() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.DisruptionsAllowed
	}).(pulumi.IntPtrOutput)
}

// total number of pods counted by this disruption budget
func (o PodDisruptionBudgetStatusPtrOutput) ExpectedPods() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.ExpectedPods
	}).(pulumi.IntPtrOutput)
}

// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
func (o PodDisruptionBudgetStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
type PodDisruptionBudgetStatusPatch struct {
	// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
	//               the number of allowed disruptions. Therefore no disruptions are
	//               allowed and the status of the condition will be False.
	// - InsufficientPods: The number of pods are either at or below the number
	//                     required by the PodDisruptionBudget. No disruptions are
	//                     allowed and the status of the condition will be False.
	// - SufficientPods: There are more pods than required by the PodDisruptionBudget.
	//                   The condition will be True, and the number of allowed
	//                   disruptions are provided by the disruptionsAllowed property.
	Conditions []metav1.ConditionPatch `pulumi:"conditions"`
	// current number of healthy pods
	CurrentHealthy *int `pulumi:"currentHealthy"`
	// minimum desired number of healthy pods
	DesiredHealthy *int `pulumi:"desiredHealthy"`
	// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
	DisruptedPods map[string]string `pulumi:"disruptedPods"`
	// Number of pod disruptions that are currently allowed.
	DisruptionsAllowed *int `pulumi:"disruptionsAllowed"`
	// total number of pods counted by this disruption budget
	ExpectedPods *int `pulumi:"expectedPods"`
	// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
	ObservedGeneration *int `pulumi:"observedGeneration"`
}

// PodDisruptionBudgetStatusPatchInput is an input type that accepts PodDisruptionBudgetStatusPatchArgs and PodDisruptionBudgetStatusPatchOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetStatusPatchInput` via:
//
//	PodDisruptionBudgetStatusPatchArgs{...}
type PodDisruptionBudgetStatusPatchInput interface {
	pulumi.Input

	ToPodDisruptionBudgetStatusPatchOutput() PodDisruptionBudgetStatusPatchOutput
	ToPodDisruptionBudgetStatusPatchOutputWithContext(context.Context) PodDisruptionBudgetStatusPatchOutput
}

// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
type PodDisruptionBudgetStatusPatchArgs struct {
	// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
	//               the number of allowed disruptions. Therefore no disruptions are
	//               allowed and the status of the condition will be False.
	// - InsufficientPods: The number of pods are either at or below the number
	//                     required by the PodDisruptionBudget. No disruptions are
	//                     allowed and the status of the condition will be False.
	// - SufficientPods: There are more pods than required by the PodDisruptionBudget.
	//                   The condition will be True, and the number of allowed
	//                   disruptions are provided by the disruptionsAllowed property.
	Conditions metav1.ConditionPatchArrayInput `pulumi:"conditions"`
	// current number of healthy pods
	CurrentHealthy pulumi.IntPtrInput `pulumi:"currentHealthy"`
	// minimum desired number of healthy pods
	DesiredHealthy pulumi.IntPtrInput `pulumi:"desiredHealthy"`
	// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
	DisruptedPods pulumi.StringMapInput `pulumi:"disruptedPods"`
	// Number of pod disruptions that are currently allowed.
	DisruptionsAllowed pulumi.IntPtrInput `pulumi:"disruptionsAllowed"`
	// total number of pods counted by this disruption budget
	ExpectedPods pulumi.IntPtrInput `pulumi:"expectedPods"`
	// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
}

func (PodDisruptionBudgetStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetStatusPatch)(nil)).Elem()
}

func (i PodDisruptionBudgetStatusPatchArgs) ToPodDisruptionBudgetStatusPatchOutput() PodDisruptionBudgetStatusPatchOutput {
	return i.ToPodDisruptionBudgetStatusPatchOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetStatusPatchArgs) ToPodDisruptionBudgetStatusPatchOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetStatusPatchOutput)
}

func (i PodDisruptionBudgetStatusPatchArgs) ToPodDisruptionBudgetStatusPatchPtrOutput() PodDisruptionBudgetStatusPatchPtrOutput {
	return i.ToPodDisruptionBudgetStatusPatchPtrOutputWithContext(context.Background())
}

func (i PodDisruptionBudgetStatusPatchArgs) ToPodDisruptionBudgetStatusPatchPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetStatusPatchOutput).ToPodDisruptionBudgetStatusPatchPtrOutputWithContext(ctx)
}

// PodDisruptionBudgetStatusPatchPtrInput is an input type that accepts PodDisruptionBudgetStatusPatchArgs, PodDisruptionBudgetStatusPatchPtr and PodDisruptionBudgetStatusPatchPtrOutput values.
// You can construct a concrete instance of `PodDisruptionBudgetStatusPatchPtrInput` via:
//
//	        PodDisruptionBudgetStatusPatchArgs{...}
//
//	or:
//
//	        nil
type PodDisruptionBudgetStatusPatchPtrInput interface {
	pulumi.Input

	ToPodDisruptionBudgetStatusPatchPtrOutput() PodDisruptionBudgetStatusPatchPtrOutput
	ToPodDisruptionBudgetStatusPatchPtrOutputWithContext(context.Context) PodDisruptionBudgetStatusPatchPtrOutput
}

type podDisruptionBudgetStatusPatchPtrType PodDisruptionBudgetStatusPatchArgs

func PodDisruptionBudgetStatusPatchPtr(v *PodDisruptionBudgetStatusPatchArgs) PodDisruptionBudgetStatusPatchPtrInput {
	return (*podDisruptionBudgetStatusPatchPtrType)(v)
}

func (*podDisruptionBudgetStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetStatusPatch)(nil)).Elem()
}

func (i *podDisruptionBudgetStatusPatchPtrType) ToPodDisruptionBudgetStatusPatchPtrOutput() PodDisruptionBudgetStatusPatchPtrOutput {
	return i.ToPodDisruptionBudgetStatusPatchPtrOutputWithContext(context.Background())
}

func (i *podDisruptionBudgetStatusPatchPtrType) ToPodDisruptionBudgetStatusPatchPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PodDisruptionBudgetStatusPatchPtrOutput)
}

// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
type PodDisruptionBudgetStatusPatchOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PodDisruptionBudgetStatusPatch)(nil)).Elem()
}

func (o PodDisruptionBudgetStatusPatchOutput) ToPodDisruptionBudgetStatusPatchOutput() PodDisruptionBudgetStatusPatchOutput {
	return o
}

func (o PodDisruptionBudgetStatusPatchOutput) ToPodDisruptionBudgetStatusPatchOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPatchOutput {
	return o
}

func (o PodDisruptionBudgetStatusPatchOutput) ToPodDisruptionBudgetStatusPatchPtrOutput() PodDisruptionBudgetStatusPatchPtrOutput {
	return o.ToPodDisruptionBudgetStatusPatchPtrOutputWithContext(context.Background())
}

func (o PodDisruptionBudgetStatusPatchOutput) ToPodDisruptionBudgetStatusPatchPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PodDisruptionBudgetStatusPatch) *PodDisruptionBudgetStatusPatch {
		return &v
	}).(PodDisruptionBudgetStatusPatchPtrOutput)
}

// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
//
//	the number of allowed disruptions. Therefore no disruptions are
//	allowed and the status of the condition will be False.
//   - InsufficientPods: The number of pods are either at or below the number
//     required by the PodDisruptionBudget. No disruptions are
//     allowed and the status of the condition will be False.
//   - SufficientPods: There are more pods than required by the PodDisruptionBudget.
//     The condition will be True, and the number of allowed
//     disruptions are provided by the disruptionsAllowed property.
func (o PodDisruptionBudgetStatusPatchOutput) Conditions() metav1.ConditionPatchArrayOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatusPatch) []metav1.ConditionPatch { return v.Conditions }).(metav1.ConditionPatchArrayOutput)
}

// current number of healthy pods
func (o PodDisruptionBudgetStatusPatchOutput) CurrentHealthy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatusPatch) *int { return v.CurrentHealthy }).(pulumi.IntPtrOutput)
}

// minimum desired number of healthy pods
func (o PodDisruptionBudgetStatusPatchOutput) DesiredHealthy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatusPatch) *int { return v.DesiredHealthy }).(pulumi.IntPtrOutput)
}

// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
func (o PodDisruptionBudgetStatusPatchOutput) DisruptedPods() pulumi.StringMapOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatusPatch) map[string]string { return v.DisruptedPods }).(pulumi.StringMapOutput)
}

// Number of pod disruptions that are currently allowed.
func (o PodDisruptionBudgetStatusPatchOutput) DisruptionsAllowed() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatusPatch) *int { return v.DisruptionsAllowed }).(pulumi.IntPtrOutput)
}

// total number of pods counted by this disruption budget
func (o PodDisruptionBudgetStatusPatchOutput) ExpectedPods() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatusPatch) *int { return v.ExpectedPods }).(pulumi.IntPtrOutput)
}

// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
func (o PodDisruptionBudgetStatusPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PodDisruptionBudgetStatusPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

type PodDisruptionBudgetStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (PodDisruptionBudgetStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PodDisruptionBudgetStatusPatch)(nil)).Elem()
}

func (o PodDisruptionBudgetStatusPatchPtrOutput) ToPodDisruptionBudgetStatusPatchPtrOutput() PodDisruptionBudgetStatusPatchPtrOutput {
	return o
}

func (o PodDisruptionBudgetStatusPatchPtrOutput) ToPodDisruptionBudgetStatusPatchPtrOutputWithContext(ctx context.Context) PodDisruptionBudgetStatusPatchPtrOutput {
	return o
}

func (o PodDisruptionBudgetStatusPatchPtrOutput) Elem() PodDisruptionBudgetStatusPatchOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatusPatch) PodDisruptionBudgetStatusPatch {
		if v != nil {
			return *v
		}
		var ret PodDisruptionBudgetStatusPatch
		return ret
	}).(PodDisruptionBudgetStatusPatchOutput)
}

// Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute
//
//	the number of allowed disruptions. Therefore no disruptions are
//	allowed and the status of the condition will be False.
//   - InsufficientPods: The number of pods are either at or below the number
//     required by the PodDisruptionBudget. No disruptions are
//     allowed and the status of the condition will be False.
//   - SufficientPods: There are more pods than required by the PodDisruptionBudget.
//     The condition will be True, and the number of allowed
//     disruptions are provided by the disruptionsAllowed property.
func (o PodDisruptionBudgetStatusPatchPtrOutput) Conditions() metav1.ConditionPatchArrayOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatusPatch) []metav1.ConditionPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(metav1.ConditionPatchArrayOutput)
}

// current number of healthy pods
func (o PodDisruptionBudgetStatusPatchPtrOutput) CurrentHealthy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.CurrentHealthy
	}).(pulumi.IntPtrOutput)
}

// minimum desired number of healthy pods
func (o PodDisruptionBudgetStatusPatchPtrOutput) DesiredHealthy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.DesiredHealthy
	}).(pulumi.IntPtrOutput)
}

// DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.
func (o PodDisruptionBudgetStatusPatchPtrOutput) DisruptedPods() pulumi.StringMapOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatusPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.DisruptedPods
	}).(pulumi.StringMapOutput)
}

// Number of pod disruptions that are currently allowed.
func (o PodDisruptionBudgetStatusPatchPtrOutput) DisruptionsAllowed() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.DisruptionsAllowed
	}).(pulumi.IntPtrOutput)
}

// total number of pods counted by this disruption budget
func (o PodDisruptionBudgetStatusPatchPtrOutput) ExpectedPods() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.ExpectedPods
	}).(pulumi.IntPtrOutput)
}

// Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.
func (o PodDisruptionBudgetStatusPatchPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PodDisruptionBudgetStatusPatch) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*EvictionInput)(nil)).Elem(), EvictionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EvictionPatchInput)(nil)).Elem(), EvictionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetTypeInput)(nil)).Elem(), PodDisruptionBudgetTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetTypeArrayInput)(nil)).Elem(), PodDisruptionBudgetTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetListTypeInput)(nil)).Elem(), PodDisruptionBudgetListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetPatchTypeInput)(nil)).Elem(), PodDisruptionBudgetPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetSpecInput)(nil)).Elem(), PodDisruptionBudgetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetSpecPtrInput)(nil)).Elem(), PodDisruptionBudgetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetSpecPatchInput)(nil)).Elem(), PodDisruptionBudgetSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetSpecPatchPtrInput)(nil)).Elem(), PodDisruptionBudgetSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetStatusInput)(nil)).Elem(), PodDisruptionBudgetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetStatusPtrInput)(nil)).Elem(), PodDisruptionBudgetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetStatusPatchInput)(nil)).Elem(), PodDisruptionBudgetStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PodDisruptionBudgetStatusPatchPtrInput)(nil)).Elem(), PodDisruptionBudgetStatusPatchArgs{})
	pulumi.RegisterOutputType(EvictionOutput{})
	pulumi.RegisterOutputType(EvictionPatchOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetTypeOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetTypeArrayOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetListTypeOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetPatchTypeOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetSpecOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetSpecPtrOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetSpecPatchOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetStatusOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetStatusPtrOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetStatusPatchOutput{})
	pulumi.RegisterOutputType(PodDisruptionBudgetStatusPatchPtrOutput{})
}
