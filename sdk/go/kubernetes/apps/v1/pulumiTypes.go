// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/core/v1"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.
type ControllerRevisionType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Data is the serialized representation of the state.
	Data interface{} `pulumi:"data"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Revision indicates the revision of the state represented by Data.
	Revision int `pulumi:"revision"`
}

// ControllerRevisionTypeInput is an input type that accepts ControllerRevisionTypeArgs and ControllerRevisionTypeOutput values.
// You can construct a concrete instance of `ControllerRevisionTypeInput` via:
//
//          ControllerRevisionTypeArgs{...}
type ControllerRevisionTypeInput interface {
	pulumi.Input

	ToControllerRevisionTypeOutput() ControllerRevisionTypeOutput
	ToControllerRevisionTypeOutputWithContext(context.Context) ControllerRevisionTypeOutput
}

// ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.
type ControllerRevisionTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Data is the serialized representation of the state.
	Data pulumi.Input `pulumi:"data"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Revision indicates the revision of the state represented by Data.
	Revision pulumi.IntInput `pulumi:"revision"`
}

func (ControllerRevisionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ControllerRevisionType)(nil)).Elem()
}

func (i ControllerRevisionTypeArgs) ToControllerRevisionTypeOutput() ControllerRevisionTypeOutput {
	return i.ToControllerRevisionTypeOutputWithContext(context.Background())
}

func (i ControllerRevisionTypeArgs) ToControllerRevisionTypeOutputWithContext(ctx context.Context) ControllerRevisionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ControllerRevisionTypeOutput)
}

// ControllerRevisionTypeArrayInput is an input type that accepts ControllerRevisionTypeArray and ControllerRevisionTypeArrayOutput values.
// You can construct a concrete instance of `ControllerRevisionTypeArrayInput` via:
//
//          ControllerRevisionTypeArray{ ControllerRevisionTypeArgs{...} }
type ControllerRevisionTypeArrayInput interface {
	pulumi.Input

	ToControllerRevisionTypeArrayOutput() ControllerRevisionTypeArrayOutput
	ToControllerRevisionTypeArrayOutputWithContext(context.Context) ControllerRevisionTypeArrayOutput
}

type ControllerRevisionTypeArray []ControllerRevisionTypeInput

func (ControllerRevisionTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ControllerRevisionType)(nil)).Elem()
}

func (i ControllerRevisionTypeArray) ToControllerRevisionTypeArrayOutput() ControllerRevisionTypeArrayOutput {
	return i.ToControllerRevisionTypeArrayOutputWithContext(context.Background())
}

func (i ControllerRevisionTypeArray) ToControllerRevisionTypeArrayOutputWithContext(ctx context.Context) ControllerRevisionTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ControllerRevisionTypeArrayOutput)
}

// ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.
type ControllerRevisionTypeOutput struct{ *pulumi.OutputState }

func (ControllerRevisionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ControllerRevisionType)(nil)).Elem()
}

func (o ControllerRevisionTypeOutput) ToControllerRevisionTypeOutput() ControllerRevisionTypeOutput {
	return o
}

func (o ControllerRevisionTypeOutput) ToControllerRevisionTypeOutputWithContext(ctx context.Context) ControllerRevisionTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ControllerRevisionTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ControllerRevisionType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Data is the serialized representation of the state.
func (o ControllerRevisionTypeOutput) Data() pulumi.AnyOutput {
	return o.ApplyT(func(v ControllerRevisionType) interface{} { return v.Data }).(pulumi.AnyOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ControllerRevisionTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ControllerRevisionType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ControllerRevisionTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ControllerRevisionType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Revision indicates the revision of the state represented by Data.
func (o ControllerRevisionTypeOutput) Revision() pulumi.IntOutput {
	return o.ApplyT(func(v ControllerRevisionType) int { return v.Revision }).(pulumi.IntOutput)
}

type ControllerRevisionTypeArrayOutput struct{ *pulumi.OutputState }

func (ControllerRevisionTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ControllerRevisionType)(nil)).Elem()
}

func (o ControllerRevisionTypeArrayOutput) ToControllerRevisionTypeArrayOutput() ControllerRevisionTypeArrayOutput {
	return o
}

func (o ControllerRevisionTypeArrayOutput) ToControllerRevisionTypeArrayOutputWithContext(ctx context.Context) ControllerRevisionTypeArrayOutput {
	return o
}

func (o ControllerRevisionTypeArrayOutput) Index(i pulumi.IntInput) ControllerRevisionTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ControllerRevisionType {
		return vs[0].([]ControllerRevisionType)[vs[1].(int)]
	}).(ControllerRevisionTypeOutput)
}

// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
type ControllerRevisionListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of ControllerRevisions
	Items []ControllerRevisionType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// DaemonSet represents the configuration of a daemon set.
type DaemonSetType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// The desired behavior of this daemon set. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec *DaemonSetSpec `pulumi:"spec"`
	// The current status of this daemon set. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status *DaemonSetStatus `pulumi:"status"`
}

// DaemonSetTypeInput is an input type that accepts DaemonSetTypeArgs and DaemonSetTypeOutput values.
// You can construct a concrete instance of `DaemonSetTypeInput` via:
//
//          DaemonSetTypeArgs{...}
type DaemonSetTypeInput interface {
	pulumi.Input

	ToDaemonSetTypeOutput() DaemonSetTypeOutput
	ToDaemonSetTypeOutputWithContext(context.Context) DaemonSetTypeOutput
}

// DaemonSet represents the configuration of a daemon set.
type DaemonSetTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// The desired behavior of this daemon set. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec DaemonSetSpecPtrInput `pulumi:"spec"`
	// The current status of this daemon set. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status DaemonSetStatusPtrInput `pulumi:"status"`
}

func (DaemonSetTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetType)(nil)).Elem()
}

func (i DaemonSetTypeArgs) ToDaemonSetTypeOutput() DaemonSetTypeOutput {
	return i.ToDaemonSetTypeOutputWithContext(context.Background())
}

func (i DaemonSetTypeArgs) ToDaemonSetTypeOutputWithContext(ctx context.Context) DaemonSetTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetTypeOutput)
}

// DaemonSetTypeArrayInput is an input type that accepts DaemonSetTypeArray and DaemonSetTypeArrayOutput values.
// You can construct a concrete instance of `DaemonSetTypeArrayInput` via:
//
//          DaemonSetTypeArray{ DaemonSetTypeArgs{...} }
type DaemonSetTypeArrayInput interface {
	pulumi.Input

	ToDaemonSetTypeArrayOutput() DaemonSetTypeArrayOutput
	ToDaemonSetTypeArrayOutputWithContext(context.Context) DaemonSetTypeArrayOutput
}

type DaemonSetTypeArray []DaemonSetTypeInput

func (DaemonSetTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DaemonSetType)(nil)).Elem()
}

func (i DaemonSetTypeArray) ToDaemonSetTypeArrayOutput() DaemonSetTypeArrayOutput {
	return i.ToDaemonSetTypeArrayOutputWithContext(context.Background())
}

func (i DaemonSetTypeArray) ToDaemonSetTypeArrayOutputWithContext(ctx context.Context) DaemonSetTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetTypeArrayOutput)
}

// DaemonSet represents the configuration of a daemon set.
type DaemonSetTypeOutput struct{ *pulumi.OutputState }

func (DaemonSetTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetType)(nil)).Elem()
}

func (o DaemonSetTypeOutput) ToDaemonSetTypeOutput() DaemonSetTypeOutput {
	return o
}

func (o DaemonSetTypeOutput) ToDaemonSetTypeOutputWithContext(ctx context.Context) DaemonSetTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DaemonSetTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DaemonSetType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DaemonSetTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DaemonSetType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o DaemonSetTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v DaemonSetType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// The desired behavior of this daemon set. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o DaemonSetTypeOutput) Spec() DaemonSetSpecPtrOutput {
	return o.ApplyT(func(v DaemonSetType) *DaemonSetSpec { return v.Spec }).(DaemonSetSpecPtrOutput)
}

// The current status of this daemon set. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o DaemonSetTypeOutput) Status() DaemonSetStatusPtrOutput {
	return o.ApplyT(func(v DaemonSetType) *DaemonSetStatus { return v.Status }).(DaemonSetStatusPtrOutput)
}

type DaemonSetTypeArrayOutput struct{ *pulumi.OutputState }

func (DaemonSetTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DaemonSetType)(nil)).Elem()
}

func (o DaemonSetTypeArrayOutput) ToDaemonSetTypeArrayOutput() DaemonSetTypeArrayOutput {
	return o
}

func (o DaemonSetTypeArrayOutput) ToDaemonSetTypeArrayOutputWithContext(ctx context.Context) DaemonSetTypeArrayOutput {
	return o
}

func (o DaemonSetTypeArrayOutput) Index(i pulumi.IntInput) DaemonSetTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DaemonSetType {
		return vs[0].([]DaemonSetType)[vs[1].(int)]
	}).(DaemonSetTypeOutput)
}

// DaemonSetCondition describes the state of a DaemonSet at a certain point.
type DaemonSetCondition struct {
	// Last time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// A human readable message indicating details about the transition.
	Message *string `pulumi:"message"`
	// The reason for the condition's last transition.
	Reason *string `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// Type of DaemonSet condition.
	Type string `pulumi:"type"`
}

// DaemonSetConditionInput is an input type that accepts DaemonSetConditionArgs and DaemonSetConditionOutput values.
// You can construct a concrete instance of `DaemonSetConditionInput` via:
//
//          DaemonSetConditionArgs{...}
type DaemonSetConditionInput interface {
	pulumi.Input

	ToDaemonSetConditionOutput() DaemonSetConditionOutput
	ToDaemonSetConditionOutputWithContext(context.Context) DaemonSetConditionOutput
}

// DaemonSetCondition describes the state of a DaemonSet at a certain point.
type DaemonSetConditionArgs struct {
	// Last time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// A human readable message indicating details about the transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// The reason for the condition's last transition.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// Type of DaemonSet condition.
	Type pulumi.StringInput `pulumi:"type"`
}

func (DaemonSetConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetCondition)(nil)).Elem()
}

func (i DaemonSetConditionArgs) ToDaemonSetConditionOutput() DaemonSetConditionOutput {
	return i.ToDaemonSetConditionOutputWithContext(context.Background())
}

func (i DaemonSetConditionArgs) ToDaemonSetConditionOutputWithContext(ctx context.Context) DaemonSetConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetConditionOutput)
}

// DaemonSetConditionArrayInput is an input type that accepts DaemonSetConditionArray and DaemonSetConditionArrayOutput values.
// You can construct a concrete instance of `DaemonSetConditionArrayInput` via:
//
//          DaemonSetConditionArray{ DaemonSetConditionArgs{...} }
type DaemonSetConditionArrayInput interface {
	pulumi.Input

	ToDaemonSetConditionArrayOutput() DaemonSetConditionArrayOutput
	ToDaemonSetConditionArrayOutputWithContext(context.Context) DaemonSetConditionArrayOutput
}

type DaemonSetConditionArray []DaemonSetConditionInput

func (DaemonSetConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DaemonSetCondition)(nil)).Elem()
}

func (i DaemonSetConditionArray) ToDaemonSetConditionArrayOutput() DaemonSetConditionArrayOutput {
	return i.ToDaemonSetConditionArrayOutputWithContext(context.Background())
}

func (i DaemonSetConditionArray) ToDaemonSetConditionArrayOutputWithContext(ctx context.Context) DaemonSetConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetConditionArrayOutput)
}

// DaemonSetCondition describes the state of a DaemonSet at a certain point.
type DaemonSetConditionOutput struct{ *pulumi.OutputState }

func (DaemonSetConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetCondition)(nil)).Elem()
}

func (o DaemonSetConditionOutput) ToDaemonSetConditionOutput() DaemonSetConditionOutput {
	return o
}

func (o DaemonSetConditionOutput) ToDaemonSetConditionOutputWithContext(ctx context.Context) DaemonSetConditionOutput {
	return o
}

// Last time the condition transitioned from one status to another.
func (o DaemonSetConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DaemonSetCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// A human readable message indicating details about the transition.
func (o DaemonSetConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DaemonSetCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// The reason for the condition's last transition.
func (o DaemonSetConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DaemonSetCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Status of the condition, one of True, False, Unknown.
func (o DaemonSetConditionOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v DaemonSetCondition) string { return v.Status }).(pulumi.StringOutput)
}

// Type of DaemonSet condition.
func (o DaemonSetConditionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v DaemonSetCondition) string { return v.Type }).(pulumi.StringOutput)
}

type DaemonSetConditionArrayOutput struct{ *pulumi.OutputState }

func (DaemonSetConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DaemonSetCondition)(nil)).Elem()
}

func (o DaemonSetConditionArrayOutput) ToDaemonSetConditionArrayOutput() DaemonSetConditionArrayOutput {
	return o
}

func (o DaemonSetConditionArrayOutput) ToDaemonSetConditionArrayOutputWithContext(ctx context.Context) DaemonSetConditionArrayOutput {
	return o
}

func (o DaemonSetConditionArrayOutput) Index(i pulumi.IntInput) DaemonSetConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DaemonSetCondition {
		return vs[0].([]DaemonSetCondition)[vs[1].(int)]
	}).(DaemonSetConditionOutput)
}

// DaemonSetList is a collection of daemon sets.
type DaemonSetListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// A list of daemon sets.
	Items []DaemonSetType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// DaemonSetSpec is the specification of a daemon set.
type DaemonSetSpec struct {
	// The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).
	MinReadySeconds *int `pulumi:"minReadySeconds"`
	// The number of old history to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// A label query over pods that are managed by the daemon set. Must match in order to be controlled. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
	Selector metav1.LabelSelector `pulumi:"selector"`
	// An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template's node selector (or on every node if no node selector is specified). More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
	Template corev1.PodTemplateSpec `pulumi:"template"`
	// An update strategy to replace existing DaemonSet pods with new pods.
	UpdateStrategy *DaemonSetUpdateStrategy `pulumi:"updateStrategy"`
}

// DaemonSetSpecInput is an input type that accepts DaemonSetSpecArgs and DaemonSetSpecOutput values.
// You can construct a concrete instance of `DaemonSetSpecInput` via:
//
//          DaemonSetSpecArgs{...}
type DaemonSetSpecInput interface {
	pulumi.Input

	ToDaemonSetSpecOutput() DaemonSetSpecOutput
	ToDaemonSetSpecOutputWithContext(context.Context) DaemonSetSpecOutput
}

// DaemonSetSpec is the specification of a daemon set.
type DaemonSetSpecArgs struct {
	// The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).
	MinReadySeconds pulumi.IntPtrInput `pulumi:"minReadySeconds"`
	// The number of old history to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
	RevisionHistoryLimit pulumi.IntPtrInput `pulumi:"revisionHistoryLimit"`
	// A label query over pods that are managed by the daemon set. Must match in order to be controlled. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
	Selector metav1.LabelSelectorInput `pulumi:"selector"`
	// An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template's node selector (or on every node if no node selector is specified). More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
	Template corev1.PodTemplateSpecInput `pulumi:"template"`
	// An update strategy to replace existing DaemonSet pods with new pods.
	UpdateStrategy DaemonSetUpdateStrategyPtrInput `pulumi:"updateStrategy"`
}

func (DaemonSetSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetSpec)(nil)).Elem()
}

func (i DaemonSetSpecArgs) ToDaemonSetSpecOutput() DaemonSetSpecOutput {
	return i.ToDaemonSetSpecOutputWithContext(context.Background())
}

func (i DaemonSetSpecArgs) ToDaemonSetSpecOutputWithContext(ctx context.Context) DaemonSetSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetSpecOutput)
}

func (i DaemonSetSpecArgs) ToDaemonSetSpecPtrOutput() DaemonSetSpecPtrOutput {
	return i.ToDaemonSetSpecPtrOutputWithContext(context.Background())
}

func (i DaemonSetSpecArgs) ToDaemonSetSpecPtrOutputWithContext(ctx context.Context) DaemonSetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetSpecOutput).ToDaemonSetSpecPtrOutputWithContext(ctx)
}

// DaemonSetSpecPtrInput is an input type that accepts DaemonSetSpecArgs, DaemonSetSpecPtr and DaemonSetSpecPtrOutput values.
// You can construct a concrete instance of `DaemonSetSpecPtrInput` via:
//
//          DaemonSetSpecArgs{...}
//
//  or:
//
//          nil
type DaemonSetSpecPtrInput interface {
	pulumi.Input

	ToDaemonSetSpecPtrOutput() DaemonSetSpecPtrOutput
	ToDaemonSetSpecPtrOutputWithContext(context.Context) DaemonSetSpecPtrOutput
}

type daemonSetSpecPtrType DaemonSetSpecArgs

func DaemonSetSpecPtr(v *DaemonSetSpecArgs) DaemonSetSpecPtrInput {
	return (*daemonSetSpecPtrType)(v)
}

func (*daemonSetSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DaemonSetSpec)(nil)).Elem()
}

func (i *daemonSetSpecPtrType) ToDaemonSetSpecPtrOutput() DaemonSetSpecPtrOutput {
	return i.ToDaemonSetSpecPtrOutputWithContext(context.Background())
}

func (i *daemonSetSpecPtrType) ToDaemonSetSpecPtrOutputWithContext(ctx context.Context) DaemonSetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetSpecPtrOutput)
}

// DaemonSetSpec is the specification of a daemon set.
type DaemonSetSpecOutput struct{ *pulumi.OutputState }

func (DaemonSetSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetSpec)(nil)).Elem()
}

func (o DaemonSetSpecOutput) ToDaemonSetSpecOutput() DaemonSetSpecOutput {
	return o
}

func (o DaemonSetSpecOutput) ToDaemonSetSpecOutputWithContext(ctx context.Context) DaemonSetSpecOutput {
	return o
}

func (o DaemonSetSpecOutput) ToDaemonSetSpecPtrOutput() DaemonSetSpecPtrOutput {
	return o.ToDaemonSetSpecPtrOutputWithContext(context.Background())
}

func (o DaemonSetSpecOutput) ToDaemonSetSpecPtrOutputWithContext(ctx context.Context) DaemonSetSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DaemonSetSpec) *DaemonSetSpec {
		return &v
	}).(DaemonSetSpecPtrOutput)
}

// The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).
func (o DaemonSetSpecOutput) MinReadySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DaemonSetSpec) *int { return v.MinReadySeconds }).(pulumi.IntPtrOutput)
}

// The number of old history to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
func (o DaemonSetSpecOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DaemonSetSpec) *int { return v.RevisionHistoryLimit }).(pulumi.IntPtrOutput)
}

// A label query over pods that are managed by the daemon set. Must match in order to be controlled. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
func (o DaemonSetSpecOutput) Selector() metav1.LabelSelectorOutput {
	return o.ApplyT(func(v DaemonSetSpec) metav1.LabelSelector { return v.Selector }).(metav1.LabelSelectorOutput)
}

// An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template's node selector (or on every node if no node selector is specified). More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
func (o DaemonSetSpecOutput) Template() corev1.PodTemplateSpecOutput {
	return o.ApplyT(func(v DaemonSetSpec) corev1.PodTemplateSpec { return v.Template }).(corev1.PodTemplateSpecOutput)
}

// An update strategy to replace existing DaemonSet pods with new pods.
func (o DaemonSetSpecOutput) UpdateStrategy() DaemonSetUpdateStrategyPtrOutput {
	return o.ApplyT(func(v DaemonSetSpec) *DaemonSetUpdateStrategy { return v.UpdateStrategy }).(DaemonSetUpdateStrategyPtrOutput)
}

type DaemonSetSpecPtrOutput struct{ *pulumi.OutputState }

func (DaemonSetSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DaemonSetSpec)(nil)).Elem()
}

func (o DaemonSetSpecPtrOutput) ToDaemonSetSpecPtrOutput() DaemonSetSpecPtrOutput {
	return o
}

func (o DaemonSetSpecPtrOutput) ToDaemonSetSpecPtrOutputWithContext(ctx context.Context) DaemonSetSpecPtrOutput {
	return o
}

func (o DaemonSetSpecPtrOutput) Elem() DaemonSetSpecOutput {
	return o.ApplyT(func(v *DaemonSetSpec) DaemonSetSpec {
		if v != nil {
			return *v
		}
		var ret DaemonSetSpec
		return ret
	}).(DaemonSetSpecOutput)
}

// The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).
func (o DaemonSetSpecPtrOutput) MinReadySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetSpec) *int {
		if v == nil {
			return nil
		}
		return v.MinReadySeconds
	}).(pulumi.IntPtrOutput)
}

// The number of old history to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
func (o DaemonSetSpecPtrOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetSpec) *int {
		if v == nil {
			return nil
		}
		return v.RevisionHistoryLimit
	}).(pulumi.IntPtrOutput)
}

// A label query over pods that are managed by the daemon set. Must match in order to be controlled. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
func (o DaemonSetSpecPtrOutput) Selector() metav1.LabelSelectorPtrOutput {
	return o.ApplyT(func(v *DaemonSetSpec) *metav1.LabelSelector {
		if v == nil {
			return nil
		}
		return &v.Selector
	}).(metav1.LabelSelectorPtrOutput)
}

// An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template's node selector (or on every node if no node selector is specified). More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
func (o DaemonSetSpecPtrOutput) Template() corev1.PodTemplateSpecPtrOutput {
	return o.ApplyT(func(v *DaemonSetSpec) *corev1.PodTemplateSpec {
		if v == nil {
			return nil
		}
		return &v.Template
	}).(corev1.PodTemplateSpecPtrOutput)
}

// An update strategy to replace existing DaemonSet pods with new pods.
func (o DaemonSetSpecPtrOutput) UpdateStrategy() DaemonSetUpdateStrategyPtrOutput {
	return o.ApplyT(func(v *DaemonSetSpec) *DaemonSetUpdateStrategy {
		if v == nil {
			return nil
		}
		return v.UpdateStrategy
	}).(DaemonSetUpdateStrategyPtrOutput)
}

// DaemonSetStatus represents the current status of a daemon set.
type DaemonSetStatus struct {
	// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
	CollisionCount *int `pulumi:"collisionCount"`
	// Represents the latest available observations of a DaemonSet's current state.
	Conditions []DaemonSetCondition `pulumi:"conditions"`
	// The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
	CurrentNumberScheduled int `pulumi:"currentNumberScheduled"`
	// The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
	DesiredNumberScheduled int `pulumi:"desiredNumberScheduled"`
	// The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
	NumberAvailable *int `pulumi:"numberAvailable"`
	// The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
	NumberMisscheduled int `pulumi:"numberMisscheduled"`
	// numberReady is the number of nodes that should be running the daemon pod and have one or more of the daemon pod running with a Ready Condition.
	NumberReady int `pulumi:"numberReady"`
	// The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
	NumberUnavailable *int `pulumi:"numberUnavailable"`
	// The most recent generation observed by the daemon set controller.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// The total number of nodes that are running updated daemon pod
	UpdatedNumberScheduled *int `pulumi:"updatedNumberScheduled"`
}

// DaemonSetStatusInput is an input type that accepts DaemonSetStatusArgs and DaemonSetStatusOutput values.
// You can construct a concrete instance of `DaemonSetStatusInput` via:
//
//          DaemonSetStatusArgs{...}
type DaemonSetStatusInput interface {
	pulumi.Input

	ToDaemonSetStatusOutput() DaemonSetStatusOutput
	ToDaemonSetStatusOutputWithContext(context.Context) DaemonSetStatusOutput
}

// DaemonSetStatus represents the current status of a daemon set.
type DaemonSetStatusArgs struct {
	// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
	CollisionCount pulumi.IntPtrInput `pulumi:"collisionCount"`
	// Represents the latest available observations of a DaemonSet's current state.
	Conditions DaemonSetConditionArrayInput `pulumi:"conditions"`
	// The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
	CurrentNumberScheduled pulumi.IntInput `pulumi:"currentNumberScheduled"`
	// The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
	DesiredNumberScheduled pulumi.IntInput `pulumi:"desiredNumberScheduled"`
	// The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
	NumberAvailable pulumi.IntPtrInput `pulumi:"numberAvailable"`
	// The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
	NumberMisscheduled pulumi.IntInput `pulumi:"numberMisscheduled"`
	// numberReady is the number of nodes that should be running the daemon pod and have one or more of the daemon pod running with a Ready Condition.
	NumberReady pulumi.IntInput `pulumi:"numberReady"`
	// The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
	NumberUnavailable pulumi.IntPtrInput `pulumi:"numberUnavailable"`
	// The most recent generation observed by the daemon set controller.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// The total number of nodes that are running updated daemon pod
	UpdatedNumberScheduled pulumi.IntPtrInput `pulumi:"updatedNumberScheduled"`
}

func (DaemonSetStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetStatus)(nil)).Elem()
}

func (i DaemonSetStatusArgs) ToDaemonSetStatusOutput() DaemonSetStatusOutput {
	return i.ToDaemonSetStatusOutputWithContext(context.Background())
}

func (i DaemonSetStatusArgs) ToDaemonSetStatusOutputWithContext(ctx context.Context) DaemonSetStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetStatusOutput)
}

func (i DaemonSetStatusArgs) ToDaemonSetStatusPtrOutput() DaemonSetStatusPtrOutput {
	return i.ToDaemonSetStatusPtrOutputWithContext(context.Background())
}

func (i DaemonSetStatusArgs) ToDaemonSetStatusPtrOutputWithContext(ctx context.Context) DaemonSetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetStatusOutput).ToDaemonSetStatusPtrOutputWithContext(ctx)
}

// DaemonSetStatusPtrInput is an input type that accepts DaemonSetStatusArgs, DaemonSetStatusPtr and DaemonSetStatusPtrOutput values.
// You can construct a concrete instance of `DaemonSetStatusPtrInput` via:
//
//          DaemonSetStatusArgs{...}
//
//  or:
//
//          nil
type DaemonSetStatusPtrInput interface {
	pulumi.Input

	ToDaemonSetStatusPtrOutput() DaemonSetStatusPtrOutput
	ToDaemonSetStatusPtrOutputWithContext(context.Context) DaemonSetStatusPtrOutput
}

type daemonSetStatusPtrType DaemonSetStatusArgs

func DaemonSetStatusPtr(v *DaemonSetStatusArgs) DaemonSetStatusPtrInput {
	return (*daemonSetStatusPtrType)(v)
}

func (*daemonSetStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DaemonSetStatus)(nil)).Elem()
}

func (i *daemonSetStatusPtrType) ToDaemonSetStatusPtrOutput() DaemonSetStatusPtrOutput {
	return i.ToDaemonSetStatusPtrOutputWithContext(context.Background())
}

func (i *daemonSetStatusPtrType) ToDaemonSetStatusPtrOutputWithContext(ctx context.Context) DaemonSetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetStatusPtrOutput)
}

// DaemonSetStatus represents the current status of a daemon set.
type DaemonSetStatusOutput struct{ *pulumi.OutputState }

func (DaemonSetStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetStatus)(nil)).Elem()
}

func (o DaemonSetStatusOutput) ToDaemonSetStatusOutput() DaemonSetStatusOutput {
	return o
}

func (o DaemonSetStatusOutput) ToDaemonSetStatusOutputWithContext(ctx context.Context) DaemonSetStatusOutput {
	return o
}

func (o DaemonSetStatusOutput) ToDaemonSetStatusPtrOutput() DaemonSetStatusPtrOutput {
	return o.ToDaemonSetStatusPtrOutputWithContext(context.Background())
}

func (o DaemonSetStatusOutput) ToDaemonSetStatusPtrOutputWithContext(ctx context.Context) DaemonSetStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DaemonSetStatus) *DaemonSetStatus {
		return &v
	}).(DaemonSetStatusPtrOutput)
}

// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
func (o DaemonSetStatusOutput) CollisionCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DaemonSetStatus) *int { return v.CollisionCount }).(pulumi.IntPtrOutput)
}

// Represents the latest available observations of a DaemonSet's current state.
func (o DaemonSetStatusOutput) Conditions() DaemonSetConditionArrayOutput {
	return o.ApplyT(func(v DaemonSetStatus) []DaemonSetCondition { return v.Conditions }).(DaemonSetConditionArrayOutput)
}

// The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
func (o DaemonSetStatusOutput) CurrentNumberScheduled() pulumi.IntOutput {
	return o.ApplyT(func(v DaemonSetStatus) int { return v.CurrentNumberScheduled }).(pulumi.IntOutput)
}

// The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
func (o DaemonSetStatusOutput) DesiredNumberScheduled() pulumi.IntOutput {
	return o.ApplyT(func(v DaemonSetStatus) int { return v.DesiredNumberScheduled }).(pulumi.IntOutput)
}

// The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
func (o DaemonSetStatusOutput) NumberAvailable() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DaemonSetStatus) *int { return v.NumberAvailable }).(pulumi.IntPtrOutput)
}

// The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
func (o DaemonSetStatusOutput) NumberMisscheduled() pulumi.IntOutput {
	return o.ApplyT(func(v DaemonSetStatus) int { return v.NumberMisscheduled }).(pulumi.IntOutput)
}

// numberReady is the number of nodes that should be running the daemon pod and have one or more of the daemon pod running with a Ready Condition.
func (o DaemonSetStatusOutput) NumberReady() pulumi.IntOutput {
	return o.ApplyT(func(v DaemonSetStatus) int { return v.NumberReady }).(pulumi.IntOutput)
}

// The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
func (o DaemonSetStatusOutput) NumberUnavailable() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DaemonSetStatus) *int { return v.NumberUnavailable }).(pulumi.IntPtrOutput)
}

// The most recent generation observed by the daemon set controller.
func (o DaemonSetStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DaemonSetStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// The total number of nodes that are running updated daemon pod
func (o DaemonSetStatusOutput) UpdatedNumberScheduled() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DaemonSetStatus) *int { return v.UpdatedNumberScheduled }).(pulumi.IntPtrOutput)
}

type DaemonSetStatusPtrOutput struct{ *pulumi.OutputState }

func (DaemonSetStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DaemonSetStatus)(nil)).Elem()
}

func (o DaemonSetStatusPtrOutput) ToDaemonSetStatusPtrOutput() DaemonSetStatusPtrOutput {
	return o
}

func (o DaemonSetStatusPtrOutput) ToDaemonSetStatusPtrOutputWithContext(ctx context.Context) DaemonSetStatusPtrOutput {
	return o
}

func (o DaemonSetStatusPtrOutput) Elem() DaemonSetStatusOutput {
	return o.ApplyT(func(v *DaemonSetStatus) DaemonSetStatus {
		if v != nil {
			return *v
		}
		var ret DaemonSetStatus
		return ret
	}).(DaemonSetStatusOutput)
}

// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
func (o DaemonSetStatusPtrOutput) CollisionCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.CollisionCount
	}).(pulumi.IntPtrOutput)
}

// Represents the latest available observations of a DaemonSet's current state.
func (o DaemonSetStatusPtrOutput) Conditions() DaemonSetConditionArrayOutput {
	return o.ApplyT(func(v *DaemonSetStatus) []DaemonSetCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(DaemonSetConditionArrayOutput)
}

// The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
func (o DaemonSetStatusPtrOutput) CurrentNumberScheduled() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.CurrentNumberScheduled
	}).(pulumi.IntPtrOutput)
}

// The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
func (o DaemonSetStatusPtrOutput) DesiredNumberScheduled() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.DesiredNumberScheduled
	}).(pulumi.IntPtrOutput)
}

// The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
func (o DaemonSetStatusPtrOutput) NumberAvailable() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.NumberAvailable
	}).(pulumi.IntPtrOutput)
}

// The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
func (o DaemonSetStatusPtrOutput) NumberMisscheduled() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.NumberMisscheduled
	}).(pulumi.IntPtrOutput)
}

// numberReady is the number of nodes that should be running the daemon pod and have one or more of the daemon pod running with a Ready Condition.
func (o DaemonSetStatusPtrOutput) NumberReady() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.NumberReady
	}).(pulumi.IntPtrOutput)
}

// The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
func (o DaemonSetStatusPtrOutput) NumberUnavailable() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.NumberUnavailable
	}).(pulumi.IntPtrOutput)
}

// The most recent generation observed by the daemon set controller.
func (o DaemonSetStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// The total number of nodes that are running updated daemon pod
func (o DaemonSetStatusPtrOutput) UpdatedNumberScheduled() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DaemonSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.UpdatedNumberScheduled
	}).(pulumi.IntPtrOutput)
}

// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
type DaemonSetUpdateStrategy struct {
	// Rolling update config params. Present only if type = "RollingUpdate".
	RollingUpdate *RollingUpdateDaemonSet `pulumi:"rollingUpdate"`
	// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
	//
	// Possible enum values:
	//  - `"OnDelete"` Replace the old daemons only when it's killed
	//  - `"RollingUpdate"` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.
	Type *string `pulumi:"type"`
}

// DaemonSetUpdateStrategyInput is an input type that accepts DaemonSetUpdateStrategyArgs and DaemonSetUpdateStrategyOutput values.
// You can construct a concrete instance of `DaemonSetUpdateStrategyInput` via:
//
//          DaemonSetUpdateStrategyArgs{...}
type DaemonSetUpdateStrategyInput interface {
	pulumi.Input

	ToDaemonSetUpdateStrategyOutput() DaemonSetUpdateStrategyOutput
	ToDaemonSetUpdateStrategyOutputWithContext(context.Context) DaemonSetUpdateStrategyOutput
}

// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
type DaemonSetUpdateStrategyArgs struct {
	// Rolling update config params. Present only if type = "RollingUpdate".
	RollingUpdate RollingUpdateDaemonSetPtrInput `pulumi:"rollingUpdate"`
	// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
	//
	// Possible enum values:
	//  - `"OnDelete"` Replace the old daemons only when it's killed
	//  - `"RollingUpdate"` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (DaemonSetUpdateStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetUpdateStrategy)(nil)).Elem()
}

func (i DaemonSetUpdateStrategyArgs) ToDaemonSetUpdateStrategyOutput() DaemonSetUpdateStrategyOutput {
	return i.ToDaemonSetUpdateStrategyOutputWithContext(context.Background())
}

func (i DaemonSetUpdateStrategyArgs) ToDaemonSetUpdateStrategyOutputWithContext(ctx context.Context) DaemonSetUpdateStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetUpdateStrategyOutput)
}

func (i DaemonSetUpdateStrategyArgs) ToDaemonSetUpdateStrategyPtrOutput() DaemonSetUpdateStrategyPtrOutput {
	return i.ToDaemonSetUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i DaemonSetUpdateStrategyArgs) ToDaemonSetUpdateStrategyPtrOutputWithContext(ctx context.Context) DaemonSetUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetUpdateStrategyOutput).ToDaemonSetUpdateStrategyPtrOutputWithContext(ctx)
}

// DaemonSetUpdateStrategyPtrInput is an input type that accepts DaemonSetUpdateStrategyArgs, DaemonSetUpdateStrategyPtr and DaemonSetUpdateStrategyPtrOutput values.
// You can construct a concrete instance of `DaemonSetUpdateStrategyPtrInput` via:
//
//          DaemonSetUpdateStrategyArgs{...}
//
//  or:
//
//          nil
type DaemonSetUpdateStrategyPtrInput interface {
	pulumi.Input

	ToDaemonSetUpdateStrategyPtrOutput() DaemonSetUpdateStrategyPtrOutput
	ToDaemonSetUpdateStrategyPtrOutputWithContext(context.Context) DaemonSetUpdateStrategyPtrOutput
}

type daemonSetUpdateStrategyPtrType DaemonSetUpdateStrategyArgs

func DaemonSetUpdateStrategyPtr(v *DaemonSetUpdateStrategyArgs) DaemonSetUpdateStrategyPtrInput {
	return (*daemonSetUpdateStrategyPtrType)(v)
}

func (*daemonSetUpdateStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DaemonSetUpdateStrategy)(nil)).Elem()
}

func (i *daemonSetUpdateStrategyPtrType) ToDaemonSetUpdateStrategyPtrOutput() DaemonSetUpdateStrategyPtrOutput {
	return i.ToDaemonSetUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i *daemonSetUpdateStrategyPtrType) ToDaemonSetUpdateStrategyPtrOutputWithContext(ctx context.Context) DaemonSetUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DaemonSetUpdateStrategyPtrOutput)
}

// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
type DaemonSetUpdateStrategyOutput struct{ *pulumi.OutputState }

func (DaemonSetUpdateStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DaemonSetUpdateStrategy)(nil)).Elem()
}

func (o DaemonSetUpdateStrategyOutput) ToDaemonSetUpdateStrategyOutput() DaemonSetUpdateStrategyOutput {
	return o
}

func (o DaemonSetUpdateStrategyOutput) ToDaemonSetUpdateStrategyOutputWithContext(ctx context.Context) DaemonSetUpdateStrategyOutput {
	return o
}

func (o DaemonSetUpdateStrategyOutput) ToDaemonSetUpdateStrategyPtrOutput() DaemonSetUpdateStrategyPtrOutput {
	return o.ToDaemonSetUpdateStrategyPtrOutputWithContext(context.Background())
}

func (o DaemonSetUpdateStrategyOutput) ToDaemonSetUpdateStrategyPtrOutputWithContext(ctx context.Context) DaemonSetUpdateStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DaemonSetUpdateStrategy) *DaemonSetUpdateStrategy {
		return &v
	}).(DaemonSetUpdateStrategyPtrOutput)
}

// Rolling update config params. Present only if type = "RollingUpdate".
func (o DaemonSetUpdateStrategyOutput) RollingUpdate() RollingUpdateDaemonSetPtrOutput {
	return o.ApplyT(func(v DaemonSetUpdateStrategy) *RollingUpdateDaemonSet { return v.RollingUpdate }).(RollingUpdateDaemonSetPtrOutput)
}

// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
//
// Possible enum values:
//  - `"OnDelete"` Replace the old daemons only when it's killed
//  - `"RollingUpdate"` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.
func (o DaemonSetUpdateStrategyOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DaemonSetUpdateStrategy) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type DaemonSetUpdateStrategyPtrOutput struct{ *pulumi.OutputState }

func (DaemonSetUpdateStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DaemonSetUpdateStrategy)(nil)).Elem()
}

func (o DaemonSetUpdateStrategyPtrOutput) ToDaemonSetUpdateStrategyPtrOutput() DaemonSetUpdateStrategyPtrOutput {
	return o
}

func (o DaemonSetUpdateStrategyPtrOutput) ToDaemonSetUpdateStrategyPtrOutputWithContext(ctx context.Context) DaemonSetUpdateStrategyPtrOutput {
	return o
}

func (o DaemonSetUpdateStrategyPtrOutput) Elem() DaemonSetUpdateStrategyOutput {
	return o.ApplyT(func(v *DaemonSetUpdateStrategy) DaemonSetUpdateStrategy {
		if v != nil {
			return *v
		}
		var ret DaemonSetUpdateStrategy
		return ret
	}).(DaemonSetUpdateStrategyOutput)
}

// Rolling update config params. Present only if type = "RollingUpdate".
func (o DaemonSetUpdateStrategyPtrOutput) RollingUpdate() RollingUpdateDaemonSetPtrOutput {
	return o.ApplyT(func(v *DaemonSetUpdateStrategy) *RollingUpdateDaemonSet {
		if v == nil {
			return nil
		}
		return v.RollingUpdate
	}).(RollingUpdateDaemonSetPtrOutput)
}

// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
//
// Possible enum values:
//  - `"OnDelete"` Replace the old daemons only when it's killed
//  - `"RollingUpdate"` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.
func (o DaemonSetUpdateStrategyPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DaemonSetUpdateStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Deployment enables declarative updates for Pods and ReplicaSets.
//
// This resource waits until its status is ready before registering success
// for create/update, and populating output properties from the current state of the resource.
// The following conditions are used to determine whether the resource creation has
// succeeded or failed:
//
// 1. The Deployment has begun to be updated by the Deployment controller. If the current
//    generation of the Deployment is > 1, then this means that the current generation must
//    be different from the generation reported by the last outputs.
// 2. There exists a ReplicaSet whose revision is equal to the current revision of the
//    Deployment.
// 3. The Deployment's '.status.conditions' has a status of type 'Available' whose 'status'
//    member is set to 'True'.
// 4. If the Deployment has generation > 1, then '.status.conditions' has a status of type
//    'Progressing', whose 'status' member is set to 'True', and whose 'reason' is
//    'NewReplicaSetAvailable'. For generation <= 1, this status field does not exist,
//    because it doesn't do a rollout (i.e., it simply creates the Deployment and
//    corresponding ReplicaSet), and therefore there is no rollout to mark as 'Progressing'.
//
// If the Deployment has not reached a Ready state after 10 minutes, it will
// time out and mark the resource update as Failed. You can override the default timeout value
// by setting the 'customTimeouts' option on the resource.
type DeploymentType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Specification of the desired behavior of the Deployment.
	Spec *DeploymentSpec `pulumi:"spec"`
	// Most recently observed status of the Deployment.
	Status *DeploymentStatus `pulumi:"status"`
}

// DeploymentTypeInput is an input type that accepts DeploymentTypeArgs and DeploymentTypeOutput values.
// You can construct a concrete instance of `DeploymentTypeInput` via:
//
//          DeploymentTypeArgs{...}
type DeploymentTypeInput interface {
	pulumi.Input

	ToDeploymentTypeOutput() DeploymentTypeOutput
	ToDeploymentTypeOutputWithContext(context.Context) DeploymentTypeOutput
}

// Deployment enables declarative updates for Pods and ReplicaSets.
//
// This resource waits until its status is ready before registering success
// for create/update, and populating output properties from the current state of the resource.
// The following conditions are used to determine whether the resource creation has
// succeeded or failed:
//
// 1. The Deployment has begun to be updated by the Deployment controller. If the current
//    generation of the Deployment is > 1, then this means that the current generation must
//    be different from the generation reported by the last outputs.
// 2. There exists a ReplicaSet whose revision is equal to the current revision of the
//    Deployment.
// 3. The Deployment's '.status.conditions' has a status of type 'Available' whose 'status'
//    member is set to 'True'.
// 4. If the Deployment has generation > 1, then '.status.conditions' has a status of type
//    'Progressing', whose 'status' member is set to 'True', and whose 'reason' is
//    'NewReplicaSetAvailable'. For generation <= 1, this status field does not exist,
//    because it doesn't do a rollout (i.e., it simply creates the Deployment and
//    corresponding ReplicaSet), and therefore there is no rollout to mark as 'Progressing'.
//
// If the Deployment has not reached a Ready state after 10 minutes, it will
// time out and mark the resource update as Failed. You can override the default timeout value
// by setting the 'customTimeouts' option on the resource.
type DeploymentTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Specification of the desired behavior of the Deployment.
	Spec DeploymentSpecPtrInput `pulumi:"spec"`
	// Most recently observed status of the Deployment.
	Status DeploymentStatusPtrInput `pulumi:"status"`
}

func (DeploymentTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentType)(nil)).Elem()
}

func (i DeploymentTypeArgs) ToDeploymentTypeOutput() DeploymentTypeOutput {
	return i.ToDeploymentTypeOutputWithContext(context.Background())
}

func (i DeploymentTypeArgs) ToDeploymentTypeOutputWithContext(ctx context.Context) DeploymentTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentTypeOutput)
}

// DeploymentTypeArrayInput is an input type that accepts DeploymentTypeArray and DeploymentTypeArrayOutput values.
// You can construct a concrete instance of `DeploymentTypeArrayInput` via:
//
//          DeploymentTypeArray{ DeploymentTypeArgs{...} }
type DeploymentTypeArrayInput interface {
	pulumi.Input

	ToDeploymentTypeArrayOutput() DeploymentTypeArrayOutput
	ToDeploymentTypeArrayOutputWithContext(context.Context) DeploymentTypeArrayOutput
}

type DeploymentTypeArray []DeploymentTypeInput

func (DeploymentTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeploymentType)(nil)).Elem()
}

func (i DeploymentTypeArray) ToDeploymentTypeArrayOutput() DeploymentTypeArrayOutput {
	return i.ToDeploymentTypeArrayOutputWithContext(context.Background())
}

func (i DeploymentTypeArray) ToDeploymentTypeArrayOutputWithContext(ctx context.Context) DeploymentTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentTypeArrayOutput)
}

// Deployment enables declarative updates for Pods and ReplicaSets.
//
// This resource waits until its status is ready before registering success
// for create/update, and populating output properties from the current state of the resource.
// The following conditions are used to determine whether the resource creation has
// succeeded or failed:
//
// 1. The Deployment has begun to be updated by the Deployment controller. If the current
//    generation of the Deployment is > 1, then this means that the current generation must
//    be different from the generation reported by the last outputs.
// 2. There exists a ReplicaSet whose revision is equal to the current revision of the
//    Deployment.
// 3. The Deployment's '.status.conditions' has a status of type 'Available' whose 'status'
//    member is set to 'True'.
// 4. If the Deployment has generation > 1, then '.status.conditions' has a status of type
//    'Progressing', whose 'status' member is set to 'True', and whose 'reason' is
//    'NewReplicaSetAvailable'. For generation <= 1, this status field does not exist,
//    because it doesn't do a rollout (i.e., it simply creates the Deployment and
//    corresponding ReplicaSet), and therefore there is no rollout to mark as 'Progressing'.
//
// If the Deployment has not reached a Ready state after 10 minutes, it will
// time out and mark the resource update as Failed. You can override the default timeout value
// by setting the 'customTimeouts' option on the resource.
type DeploymentTypeOutput struct{ *pulumi.OutputState }

func (DeploymentTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentType)(nil)).Elem()
}

func (o DeploymentTypeOutput) ToDeploymentTypeOutput() DeploymentTypeOutput {
	return o
}

func (o DeploymentTypeOutput) ToDeploymentTypeOutputWithContext(ctx context.Context) DeploymentTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o DeploymentTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeploymentType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o DeploymentTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeploymentType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o DeploymentTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v DeploymentType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Specification of the desired behavior of the Deployment.
func (o DeploymentTypeOutput) Spec() DeploymentSpecPtrOutput {
	return o.ApplyT(func(v DeploymentType) *DeploymentSpec { return v.Spec }).(DeploymentSpecPtrOutput)
}

// Most recently observed status of the Deployment.
func (o DeploymentTypeOutput) Status() DeploymentStatusPtrOutput {
	return o.ApplyT(func(v DeploymentType) *DeploymentStatus { return v.Status }).(DeploymentStatusPtrOutput)
}

type DeploymentTypeArrayOutput struct{ *pulumi.OutputState }

func (DeploymentTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeploymentType)(nil)).Elem()
}

func (o DeploymentTypeArrayOutput) ToDeploymentTypeArrayOutput() DeploymentTypeArrayOutput {
	return o
}

func (o DeploymentTypeArrayOutput) ToDeploymentTypeArrayOutputWithContext(ctx context.Context) DeploymentTypeArrayOutput {
	return o
}

func (o DeploymentTypeArrayOutput) Index(i pulumi.IntInput) DeploymentTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeploymentType {
		return vs[0].([]DeploymentType)[vs[1].(int)]
	}).(DeploymentTypeOutput)
}

// DeploymentCondition describes the state of a deployment at a certain point.
type DeploymentCondition struct {
	// Last time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// The last time this condition was updated.
	LastUpdateTime *string `pulumi:"lastUpdateTime"`
	// A human readable message indicating details about the transition.
	Message *string `pulumi:"message"`
	// The reason for the condition's last transition.
	Reason *string `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// Type of deployment condition.
	Type string `pulumi:"type"`
}

// DeploymentConditionInput is an input type that accepts DeploymentConditionArgs and DeploymentConditionOutput values.
// You can construct a concrete instance of `DeploymentConditionInput` via:
//
//          DeploymentConditionArgs{...}
type DeploymentConditionInput interface {
	pulumi.Input

	ToDeploymentConditionOutput() DeploymentConditionOutput
	ToDeploymentConditionOutputWithContext(context.Context) DeploymentConditionOutput
}

// DeploymentCondition describes the state of a deployment at a certain point.
type DeploymentConditionArgs struct {
	// Last time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// The last time this condition was updated.
	LastUpdateTime pulumi.StringPtrInput `pulumi:"lastUpdateTime"`
	// A human readable message indicating details about the transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// The reason for the condition's last transition.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// Type of deployment condition.
	Type pulumi.StringInput `pulumi:"type"`
}

func (DeploymentConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentCondition)(nil)).Elem()
}

func (i DeploymentConditionArgs) ToDeploymentConditionOutput() DeploymentConditionOutput {
	return i.ToDeploymentConditionOutputWithContext(context.Background())
}

func (i DeploymentConditionArgs) ToDeploymentConditionOutputWithContext(ctx context.Context) DeploymentConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentConditionOutput)
}

// DeploymentConditionArrayInput is an input type that accepts DeploymentConditionArray and DeploymentConditionArrayOutput values.
// You can construct a concrete instance of `DeploymentConditionArrayInput` via:
//
//          DeploymentConditionArray{ DeploymentConditionArgs{...} }
type DeploymentConditionArrayInput interface {
	pulumi.Input

	ToDeploymentConditionArrayOutput() DeploymentConditionArrayOutput
	ToDeploymentConditionArrayOutputWithContext(context.Context) DeploymentConditionArrayOutput
}

type DeploymentConditionArray []DeploymentConditionInput

func (DeploymentConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeploymentCondition)(nil)).Elem()
}

func (i DeploymentConditionArray) ToDeploymentConditionArrayOutput() DeploymentConditionArrayOutput {
	return i.ToDeploymentConditionArrayOutputWithContext(context.Background())
}

func (i DeploymentConditionArray) ToDeploymentConditionArrayOutputWithContext(ctx context.Context) DeploymentConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentConditionArrayOutput)
}

// DeploymentCondition describes the state of a deployment at a certain point.
type DeploymentConditionOutput struct{ *pulumi.OutputState }

func (DeploymentConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentCondition)(nil)).Elem()
}

func (o DeploymentConditionOutput) ToDeploymentConditionOutput() DeploymentConditionOutput {
	return o
}

func (o DeploymentConditionOutput) ToDeploymentConditionOutputWithContext(ctx context.Context) DeploymentConditionOutput {
	return o
}

// Last time the condition transitioned from one status to another.
func (o DeploymentConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeploymentCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// The last time this condition was updated.
func (o DeploymentConditionOutput) LastUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeploymentCondition) *string { return v.LastUpdateTime }).(pulumi.StringPtrOutput)
}

// A human readable message indicating details about the transition.
func (o DeploymentConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeploymentCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// The reason for the condition's last transition.
func (o DeploymentConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeploymentCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Status of the condition, one of True, False, Unknown.
func (o DeploymentConditionOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v DeploymentCondition) string { return v.Status }).(pulumi.StringOutput)
}

// Type of deployment condition.
func (o DeploymentConditionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v DeploymentCondition) string { return v.Type }).(pulumi.StringOutput)
}

type DeploymentConditionArrayOutput struct{ *pulumi.OutputState }

func (DeploymentConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeploymentCondition)(nil)).Elem()
}

func (o DeploymentConditionArrayOutput) ToDeploymentConditionArrayOutput() DeploymentConditionArrayOutput {
	return o
}

func (o DeploymentConditionArrayOutput) ToDeploymentConditionArrayOutputWithContext(ctx context.Context) DeploymentConditionArrayOutput {
	return o
}

func (o DeploymentConditionArrayOutput) Index(i pulumi.IntInput) DeploymentConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeploymentCondition {
		return vs[0].([]DeploymentCondition)[vs[1].(int)]
	}).(DeploymentConditionOutput)
}

// DeploymentList is a list of Deployments.
type DeploymentListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of Deployments.
	Items []DeploymentType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata.
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// DeploymentSpec is the specification of the desired behavior of the Deployment.
type DeploymentSpec struct {
	// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
	MinReadySeconds *int `pulumi:"minReadySeconds"`
	// Indicates that the deployment is paused.
	Paused *bool `pulumi:"paused"`
	// The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
	ProgressDeadlineSeconds *int `pulumi:"progressDeadlineSeconds"`
	// Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
	Replicas *int `pulumi:"replicas"`
	// The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.
	Selector metav1.LabelSelector `pulumi:"selector"`
	// The deployment strategy to use to replace existing pods with new ones.
	Strategy *DeploymentStrategy `pulumi:"strategy"`
	// Template describes the pods that will be created.
	Template corev1.PodTemplateSpec `pulumi:"template"`
}

// DeploymentSpecInput is an input type that accepts DeploymentSpecArgs and DeploymentSpecOutput values.
// You can construct a concrete instance of `DeploymentSpecInput` via:
//
//          DeploymentSpecArgs{...}
type DeploymentSpecInput interface {
	pulumi.Input

	ToDeploymentSpecOutput() DeploymentSpecOutput
	ToDeploymentSpecOutputWithContext(context.Context) DeploymentSpecOutput
}

// DeploymentSpec is the specification of the desired behavior of the Deployment.
type DeploymentSpecArgs struct {
	// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
	MinReadySeconds pulumi.IntPtrInput `pulumi:"minReadySeconds"`
	// Indicates that the deployment is paused.
	Paused pulumi.BoolPtrInput `pulumi:"paused"`
	// The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
	ProgressDeadlineSeconds pulumi.IntPtrInput `pulumi:"progressDeadlineSeconds"`
	// Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
	Replicas pulumi.IntPtrInput `pulumi:"replicas"`
	// The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
	RevisionHistoryLimit pulumi.IntPtrInput `pulumi:"revisionHistoryLimit"`
	// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.
	Selector metav1.LabelSelectorInput `pulumi:"selector"`
	// The deployment strategy to use to replace existing pods with new ones.
	Strategy DeploymentStrategyPtrInput `pulumi:"strategy"`
	// Template describes the pods that will be created.
	Template corev1.PodTemplateSpecInput `pulumi:"template"`
}

func (DeploymentSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentSpec)(nil)).Elem()
}

func (i DeploymentSpecArgs) ToDeploymentSpecOutput() DeploymentSpecOutput {
	return i.ToDeploymentSpecOutputWithContext(context.Background())
}

func (i DeploymentSpecArgs) ToDeploymentSpecOutputWithContext(ctx context.Context) DeploymentSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentSpecOutput)
}

func (i DeploymentSpecArgs) ToDeploymentSpecPtrOutput() DeploymentSpecPtrOutput {
	return i.ToDeploymentSpecPtrOutputWithContext(context.Background())
}

func (i DeploymentSpecArgs) ToDeploymentSpecPtrOutputWithContext(ctx context.Context) DeploymentSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentSpecOutput).ToDeploymentSpecPtrOutputWithContext(ctx)
}

// DeploymentSpecPtrInput is an input type that accepts DeploymentSpecArgs, DeploymentSpecPtr and DeploymentSpecPtrOutput values.
// You can construct a concrete instance of `DeploymentSpecPtrInput` via:
//
//          DeploymentSpecArgs{...}
//
//  or:
//
//          nil
type DeploymentSpecPtrInput interface {
	pulumi.Input

	ToDeploymentSpecPtrOutput() DeploymentSpecPtrOutput
	ToDeploymentSpecPtrOutputWithContext(context.Context) DeploymentSpecPtrOutput
}

type deploymentSpecPtrType DeploymentSpecArgs

func DeploymentSpecPtr(v *DeploymentSpecArgs) DeploymentSpecPtrInput {
	return (*deploymentSpecPtrType)(v)
}

func (*deploymentSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentSpec)(nil)).Elem()
}

func (i *deploymentSpecPtrType) ToDeploymentSpecPtrOutput() DeploymentSpecPtrOutput {
	return i.ToDeploymentSpecPtrOutputWithContext(context.Background())
}

func (i *deploymentSpecPtrType) ToDeploymentSpecPtrOutputWithContext(ctx context.Context) DeploymentSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentSpecPtrOutput)
}

// DeploymentSpec is the specification of the desired behavior of the Deployment.
type DeploymentSpecOutput struct{ *pulumi.OutputState }

func (DeploymentSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentSpec)(nil)).Elem()
}

func (o DeploymentSpecOutput) ToDeploymentSpecOutput() DeploymentSpecOutput {
	return o
}

func (o DeploymentSpecOutput) ToDeploymentSpecOutputWithContext(ctx context.Context) DeploymentSpecOutput {
	return o
}

func (o DeploymentSpecOutput) ToDeploymentSpecPtrOutput() DeploymentSpecPtrOutput {
	return o.ToDeploymentSpecPtrOutputWithContext(context.Background())
}

func (o DeploymentSpecOutput) ToDeploymentSpecPtrOutputWithContext(ctx context.Context) DeploymentSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeploymentSpec) *DeploymentSpec {
		return &v
	}).(DeploymentSpecPtrOutput)
}

// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
func (o DeploymentSpecOutput) MinReadySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentSpec) *int { return v.MinReadySeconds }).(pulumi.IntPtrOutput)
}

// Indicates that the deployment is paused.
func (o DeploymentSpecOutput) Paused() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeploymentSpec) *bool { return v.Paused }).(pulumi.BoolPtrOutput)
}

// The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
func (o DeploymentSpecOutput) ProgressDeadlineSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentSpec) *int { return v.ProgressDeadlineSeconds }).(pulumi.IntPtrOutput)
}

// Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
func (o DeploymentSpecOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentSpec) *int { return v.Replicas }).(pulumi.IntPtrOutput)
}

// The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
func (o DeploymentSpecOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentSpec) *int { return v.RevisionHistoryLimit }).(pulumi.IntPtrOutput)
}

// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.
func (o DeploymentSpecOutput) Selector() metav1.LabelSelectorOutput {
	return o.ApplyT(func(v DeploymentSpec) metav1.LabelSelector { return v.Selector }).(metav1.LabelSelectorOutput)
}

// The deployment strategy to use to replace existing pods with new ones.
func (o DeploymentSpecOutput) Strategy() DeploymentStrategyPtrOutput {
	return o.ApplyT(func(v DeploymentSpec) *DeploymentStrategy { return v.Strategy }).(DeploymentStrategyPtrOutput)
}

// Template describes the pods that will be created.
func (o DeploymentSpecOutput) Template() corev1.PodTemplateSpecOutput {
	return o.ApplyT(func(v DeploymentSpec) corev1.PodTemplateSpec { return v.Template }).(corev1.PodTemplateSpecOutput)
}

type DeploymentSpecPtrOutput struct{ *pulumi.OutputState }

func (DeploymentSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentSpec)(nil)).Elem()
}

func (o DeploymentSpecPtrOutput) ToDeploymentSpecPtrOutput() DeploymentSpecPtrOutput {
	return o
}

func (o DeploymentSpecPtrOutput) ToDeploymentSpecPtrOutputWithContext(ctx context.Context) DeploymentSpecPtrOutput {
	return o
}

func (o DeploymentSpecPtrOutput) Elem() DeploymentSpecOutput {
	return o.ApplyT(func(v *DeploymentSpec) DeploymentSpec {
		if v != nil {
			return *v
		}
		var ret DeploymentSpec
		return ret
	}).(DeploymentSpecOutput)
}

// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
func (o DeploymentSpecPtrOutput) MinReadySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentSpec) *int {
		if v == nil {
			return nil
		}
		return v.MinReadySeconds
	}).(pulumi.IntPtrOutput)
}

// Indicates that the deployment is paused.
func (o DeploymentSpecPtrOutput) Paused() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DeploymentSpec) *bool {
		if v == nil {
			return nil
		}
		return v.Paused
	}).(pulumi.BoolPtrOutput)
}

// The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
func (o DeploymentSpecPtrOutput) ProgressDeadlineSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentSpec) *int {
		if v == nil {
			return nil
		}
		return v.ProgressDeadlineSeconds
	}).(pulumi.IntPtrOutput)
}

// Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
func (o DeploymentSpecPtrOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentSpec) *int {
		if v == nil {
			return nil
		}
		return v.Replicas
	}).(pulumi.IntPtrOutput)
}

// The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
func (o DeploymentSpecPtrOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentSpec) *int {
		if v == nil {
			return nil
		}
		return v.RevisionHistoryLimit
	}).(pulumi.IntPtrOutput)
}

// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.
func (o DeploymentSpecPtrOutput) Selector() metav1.LabelSelectorPtrOutput {
	return o.ApplyT(func(v *DeploymentSpec) *metav1.LabelSelector {
		if v == nil {
			return nil
		}
		return &v.Selector
	}).(metav1.LabelSelectorPtrOutput)
}

// The deployment strategy to use to replace existing pods with new ones.
func (o DeploymentSpecPtrOutput) Strategy() DeploymentStrategyPtrOutput {
	return o.ApplyT(func(v *DeploymentSpec) *DeploymentStrategy {
		if v == nil {
			return nil
		}
		return v.Strategy
	}).(DeploymentStrategyPtrOutput)
}

// Template describes the pods that will be created.
func (o DeploymentSpecPtrOutput) Template() corev1.PodTemplateSpecPtrOutput {
	return o.ApplyT(func(v *DeploymentSpec) *corev1.PodTemplateSpec {
		if v == nil {
			return nil
		}
		return &v.Template
	}).(corev1.PodTemplateSpecPtrOutput)
}

// DeploymentStatus is the most recently observed status of the Deployment.
type DeploymentStatus struct {
	// Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
	AvailableReplicas *int `pulumi:"availableReplicas"`
	// Count of hash collisions for the Deployment. The Deployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ReplicaSet.
	CollisionCount *int `pulumi:"collisionCount"`
	// Represents the latest available observations of a deployment's current state.
	Conditions []DeploymentCondition `pulumi:"conditions"`
	// The generation observed by the deployment controller.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
	ReadyReplicas *int `pulumi:"readyReplicas"`
	// Total number of non-terminated pods targeted by this deployment (their labels match the selector).
	Replicas *int `pulumi:"replicas"`
	// Total number of unavailable pods targeted by this deployment. This is the total number of pods that are still required for the deployment to have 100% available capacity. They may either be pods that are running but not yet available or pods that still have not been created.
	UnavailableReplicas *int `pulumi:"unavailableReplicas"`
	// Total number of non-terminated pods targeted by this deployment that have the desired template spec.
	UpdatedReplicas *int `pulumi:"updatedReplicas"`
}

// DeploymentStatusInput is an input type that accepts DeploymentStatusArgs and DeploymentStatusOutput values.
// You can construct a concrete instance of `DeploymentStatusInput` via:
//
//          DeploymentStatusArgs{...}
type DeploymentStatusInput interface {
	pulumi.Input

	ToDeploymentStatusOutput() DeploymentStatusOutput
	ToDeploymentStatusOutputWithContext(context.Context) DeploymentStatusOutput
}

// DeploymentStatus is the most recently observed status of the Deployment.
type DeploymentStatusArgs struct {
	// Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
	AvailableReplicas pulumi.IntPtrInput `pulumi:"availableReplicas"`
	// Count of hash collisions for the Deployment. The Deployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ReplicaSet.
	CollisionCount pulumi.IntPtrInput `pulumi:"collisionCount"`
	// Represents the latest available observations of a deployment's current state.
	Conditions DeploymentConditionArrayInput `pulumi:"conditions"`
	// The generation observed by the deployment controller.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
	ReadyReplicas pulumi.IntPtrInput `pulumi:"readyReplicas"`
	// Total number of non-terminated pods targeted by this deployment (their labels match the selector).
	Replicas pulumi.IntPtrInput `pulumi:"replicas"`
	// Total number of unavailable pods targeted by this deployment. This is the total number of pods that are still required for the deployment to have 100% available capacity. They may either be pods that are running but not yet available or pods that still have not been created.
	UnavailableReplicas pulumi.IntPtrInput `pulumi:"unavailableReplicas"`
	// Total number of non-terminated pods targeted by this deployment that have the desired template spec.
	UpdatedReplicas pulumi.IntPtrInput `pulumi:"updatedReplicas"`
}

func (DeploymentStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentStatus)(nil)).Elem()
}

func (i DeploymentStatusArgs) ToDeploymentStatusOutput() DeploymentStatusOutput {
	return i.ToDeploymentStatusOutputWithContext(context.Background())
}

func (i DeploymentStatusArgs) ToDeploymentStatusOutputWithContext(ctx context.Context) DeploymentStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentStatusOutput)
}

func (i DeploymentStatusArgs) ToDeploymentStatusPtrOutput() DeploymentStatusPtrOutput {
	return i.ToDeploymentStatusPtrOutputWithContext(context.Background())
}

func (i DeploymentStatusArgs) ToDeploymentStatusPtrOutputWithContext(ctx context.Context) DeploymentStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentStatusOutput).ToDeploymentStatusPtrOutputWithContext(ctx)
}

// DeploymentStatusPtrInput is an input type that accepts DeploymentStatusArgs, DeploymentStatusPtr and DeploymentStatusPtrOutput values.
// You can construct a concrete instance of `DeploymentStatusPtrInput` via:
//
//          DeploymentStatusArgs{...}
//
//  or:
//
//          nil
type DeploymentStatusPtrInput interface {
	pulumi.Input

	ToDeploymentStatusPtrOutput() DeploymentStatusPtrOutput
	ToDeploymentStatusPtrOutputWithContext(context.Context) DeploymentStatusPtrOutput
}

type deploymentStatusPtrType DeploymentStatusArgs

func DeploymentStatusPtr(v *DeploymentStatusArgs) DeploymentStatusPtrInput {
	return (*deploymentStatusPtrType)(v)
}

func (*deploymentStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentStatus)(nil)).Elem()
}

func (i *deploymentStatusPtrType) ToDeploymentStatusPtrOutput() DeploymentStatusPtrOutput {
	return i.ToDeploymentStatusPtrOutputWithContext(context.Background())
}

func (i *deploymentStatusPtrType) ToDeploymentStatusPtrOutputWithContext(ctx context.Context) DeploymentStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentStatusPtrOutput)
}

// DeploymentStatus is the most recently observed status of the Deployment.
type DeploymentStatusOutput struct{ *pulumi.OutputState }

func (DeploymentStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentStatus)(nil)).Elem()
}

func (o DeploymentStatusOutput) ToDeploymentStatusOutput() DeploymentStatusOutput {
	return o
}

func (o DeploymentStatusOutput) ToDeploymentStatusOutputWithContext(ctx context.Context) DeploymentStatusOutput {
	return o
}

func (o DeploymentStatusOutput) ToDeploymentStatusPtrOutput() DeploymentStatusPtrOutput {
	return o.ToDeploymentStatusPtrOutputWithContext(context.Background())
}

func (o DeploymentStatusOutput) ToDeploymentStatusPtrOutputWithContext(ctx context.Context) DeploymentStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeploymentStatus) *DeploymentStatus {
		return &v
	}).(DeploymentStatusPtrOutput)
}

// Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
func (o DeploymentStatusOutput) AvailableReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentStatus) *int { return v.AvailableReplicas }).(pulumi.IntPtrOutput)
}

// Count of hash collisions for the Deployment. The Deployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ReplicaSet.
func (o DeploymentStatusOutput) CollisionCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentStatus) *int { return v.CollisionCount }).(pulumi.IntPtrOutput)
}

// Represents the latest available observations of a deployment's current state.
func (o DeploymentStatusOutput) Conditions() DeploymentConditionArrayOutput {
	return o.ApplyT(func(v DeploymentStatus) []DeploymentCondition { return v.Conditions }).(DeploymentConditionArrayOutput)
}

// The generation observed by the deployment controller.
func (o DeploymentStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
func (o DeploymentStatusOutput) ReadyReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentStatus) *int { return v.ReadyReplicas }).(pulumi.IntPtrOutput)
}

// Total number of non-terminated pods targeted by this deployment (their labels match the selector).
func (o DeploymentStatusOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentStatus) *int { return v.Replicas }).(pulumi.IntPtrOutput)
}

// Total number of unavailable pods targeted by this deployment. This is the total number of pods that are still required for the deployment to have 100% available capacity. They may either be pods that are running but not yet available or pods that still have not been created.
func (o DeploymentStatusOutput) UnavailableReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentStatus) *int { return v.UnavailableReplicas }).(pulumi.IntPtrOutput)
}

// Total number of non-terminated pods targeted by this deployment that have the desired template spec.
func (o DeploymentStatusOutput) UpdatedReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentStatus) *int { return v.UpdatedReplicas }).(pulumi.IntPtrOutput)
}

type DeploymentStatusPtrOutput struct{ *pulumi.OutputState }

func (DeploymentStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentStatus)(nil)).Elem()
}

func (o DeploymentStatusPtrOutput) ToDeploymentStatusPtrOutput() DeploymentStatusPtrOutput {
	return o
}

func (o DeploymentStatusPtrOutput) ToDeploymentStatusPtrOutputWithContext(ctx context.Context) DeploymentStatusPtrOutput {
	return o
}

func (o DeploymentStatusPtrOutput) Elem() DeploymentStatusOutput {
	return o.ApplyT(func(v *DeploymentStatus) DeploymentStatus {
		if v != nil {
			return *v
		}
		var ret DeploymentStatus
		return ret
	}).(DeploymentStatusOutput)
}

// Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
func (o DeploymentStatusPtrOutput) AvailableReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentStatus) *int {
		if v == nil {
			return nil
		}
		return v.AvailableReplicas
	}).(pulumi.IntPtrOutput)
}

// Count of hash collisions for the Deployment. The Deployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ReplicaSet.
func (o DeploymentStatusPtrOutput) CollisionCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentStatus) *int {
		if v == nil {
			return nil
		}
		return v.CollisionCount
	}).(pulumi.IntPtrOutput)
}

// Represents the latest available observations of a deployment's current state.
func (o DeploymentStatusPtrOutput) Conditions() DeploymentConditionArrayOutput {
	return o.ApplyT(func(v *DeploymentStatus) []DeploymentCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(DeploymentConditionArrayOutput)
}

// The generation observed by the deployment controller.
func (o DeploymentStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
func (o DeploymentStatusPtrOutput) ReadyReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentStatus) *int {
		if v == nil {
			return nil
		}
		return v.ReadyReplicas
	}).(pulumi.IntPtrOutput)
}

// Total number of non-terminated pods targeted by this deployment (their labels match the selector).
func (o DeploymentStatusPtrOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentStatus) *int {
		if v == nil {
			return nil
		}
		return v.Replicas
	}).(pulumi.IntPtrOutput)
}

// Total number of unavailable pods targeted by this deployment. This is the total number of pods that are still required for the deployment to have 100% available capacity. They may either be pods that are running but not yet available or pods that still have not been created.
func (o DeploymentStatusPtrOutput) UnavailableReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentStatus) *int {
		if v == nil {
			return nil
		}
		return v.UnavailableReplicas
	}).(pulumi.IntPtrOutput)
}

// Total number of non-terminated pods targeted by this deployment that have the desired template spec.
func (o DeploymentStatusPtrOutput) UpdatedReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentStatus) *int {
		if v == nil {
			return nil
		}
		return v.UpdatedReplicas
	}).(pulumi.IntPtrOutput)
}

// DeploymentStrategy describes how to replace existing pods with new ones.
type DeploymentStrategy struct {
	// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
	RollingUpdate *RollingUpdateDeployment `pulumi:"rollingUpdate"`
	// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
	//
	// Possible enum values:
	//  - `"Recreate"` Kill all existing pods before creating new ones.
	//  - `"RollingUpdate"` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one.
	Type *string `pulumi:"type"`
}

// DeploymentStrategyInput is an input type that accepts DeploymentStrategyArgs and DeploymentStrategyOutput values.
// You can construct a concrete instance of `DeploymentStrategyInput` via:
//
//          DeploymentStrategyArgs{...}
type DeploymentStrategyInput interface {
	pulumi.Input

	ToDeploymentStrategyOutput() DeploymentStrategyOutput
	ToDeploymentStrategyOutputWithContext(context.Context) DeploymentStrategyOutput
}

// DeploymentStrategy describes how to replace existing pods with new ones.
type DeploymentStrategyArgs struct {
	// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
	RollingUpdate RollingUpdateDeploymentPtrInput `pulumi:"rollingUpdate"`
	// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
	//
	// Possible enum values:
	//  - `"Recreate"` Kill all existing pods before creating new ones.
	//  - `"RollingUpdate"` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (DeploymentStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentStrategy)(nil)).Elem()
}

func (i DeploymentStrategyArgs) ToDeploymentStrategyOutput() DeploymentStrategyOutput {
	return i.ToDeploymentStrategyOutputWithContext(context.Background())
}

func (i DeploymentStrategyArgs) ToDeploymentStrategyOutputWithContext(ctx context.Context) DeploymentStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentStrategyOutput)
}

func (i DeploymentStrategyArgs) ToDeploymentStrategyPtrOutput() DeploymentStrategyPtrOutput {
	return i.ToDeploymentStrategyPtrOutputWithContext(context.Background())
}

func (i DeploymentStrategyArgs) ToDeploymentStrategyPtrOutputWithContext(ctx context.Context) DeploymentStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentStrategyOutput).ToDeploymentStrategyPtrOutputWithContext(ctx)
}

// DeploymentStrategyPtrInput is an input type that accepts DeploymentStrategyArgs, DeploymentStrategyPtr and DeploymentStrategyPtrOutput values.
// You can construct a concrete instance of `DeploymentStrategyPtrInput` via:
//
//          DeploymentStrategyArgs{...}
//
//  or:
//
//          nil
type DeploymentStrategyPtrInput interface {
	pulumi.Input

	ToDeploymentStrategyPtrOutput() DeploymentStrategyPtrOutput
	ToDeploymentStrategyPtrOutputWithContext(context.Context) DeploymentStrategyPtrOutput
}

type deploymentStrategyPtrType DeploymentStrategyArgs

func DeploymentStrategyPtr(v *DeploymentStrategyArgs) DeploymentStrategyPtrInput {
	return (*deploymentStrategyPtrType)(v)
}

func (*deploymentStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentStrategy)(nil)).Elem()
}

func (i *deploymentStrategyPtrType) ToDeploymentStrategyPtrOutput() DeploymentStrategyPtrOutput {
	return i.ToDeploymentStrategyPtrOutputWithContext(context.Background())
}

func (i *deploymentStrategyPtrType) ToDeploymentStrategyPtrOutputWithContext(ctx context.Context) DeploymentStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentStrategyPtrOutput)
}

// DeploymentStrategy describes how to replace existing pods with new ones.
type DeploymentStrategyOutput struct{ *pulumi.OutputState }

func (DeploymentStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentStrategy)(nil)).Elem()
}

func (o DeploymentStrategyOutput) ToDeploymentStrategyOutput() DeploymentStrategyOutput {
	return o
}

func (o DeploymentStrategyOutput) ToDeploymentStrategyOutputWithContext(ctx context.Context) DeploymentStrategyOutput {
	return o
}

func (o DeploymentStrategyOutput) ToDeploymentStrategyPtrOutput() DeploymentStrategyPtrOutput {
	return o.ToDeploymentStrategyPtrOutputWithContext(context.Background())
}

func (o DeploymentStrategyOutput) ToDeploymentStrategyPtrOutputWithContext(ctx context.Context) DeploymentStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeploymentStrategy) *DeploymentStrategy {
		return &v
	}).(DeploymentStrategyPtrOutput)
}

// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
func (o DeploymentStrategyOutput) RollingUpdate() RollingUpdateDeploymentPtrOutput {
	return o.ApplyT(func(v DeploymentStrategy) *RollingUpdateDeployment { return v.RollingUpdate }).(RollingUpdateDeploymentPtrOutput)
}

// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
//
// Possible enum values:
//  - `"Recreate"` Kill all existing pods before creating new ones.
//  - `"RollingUpdate"` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one.
func (o DeploymentStrategyOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeploymentStrategy) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type DeploymentStrategyPtrOutput struct{ *pulumi.OutputState }

func (DeploymentStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentStrategy)(nil)).Elem()
}

func (o DeploymentStrategyPtrOutput) ToDeploymentStrategyPtrOutput() DeploymentStrategyPtrOutput {
	return o
}

func (o DeploymentStrategyPtrOutput) ToDeploymentStrategyPtrOutputWithContext(ctx context.Context) DeploymentStrategyPtrOutput {
	return o
}

func (o DeploymentStrategyPtrOutput) Elem() DeploymentStrategyOutput {
	return o.ApplyT(func(v *DeploymentStrategy) DeploymentStrategy {
		if v != nil {
			return *v
		}
		var ret DeploymentStrategy
		return ret
	}).(DeploymentStrategyOutput)
}

// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
func (o DeploymentStrategyPtrOutput) RollingUpdate() RollingUpdateDeploymentPtrOutput {
	return o.ApplyT(func(v *DeploymentStrategy) *RollingUpdateDeployment {
		if v == nil {
			return nil
		}
		return v.RollingUpdate
	}).(RollingUpdateDeploymentPtrOutput)
}

// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
//
// Possible enum values:
//  - `"Recreate"` Kill all existing pods before creating new ones.
//  - `"RollingUpdate"` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one.
func (o DeploymentStrategyPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
type ReplicaSetType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s) that the ReplicaSet manages. Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the specification of the desired behavior of the ReplicaSet. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec *ReplicaSetSpec `pulumi:"spec"`
	// Status is the most recently observed status of the ReplicaSet. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status *ReplicaSetStatus `pulumi:"status"`
}

// ReplicaSetTypeInput is an input type that accepts ReplicaSetTypeArgs and ReplicaSetTypeOutput values.
// You can construct a concrete instance of `ReplicaSetTypeInput` via:
//
//          ReplicaSetTypeArgs{...}
type ReplicaSetTypeInput interface {
	pulumi.Input

	ToReplicaSetTypeOutput() ReplicaSetTypeOutput
	ToReplicaSetTypeOutputWithContext(context.Context) ReplicaSetTypeOutput
}

// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
type ReplicaSetTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s) that the ReplicaSet manages. Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec defines the specification of the desired behavior of the ReplicaSet. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec ReplicaSetSpecPtrInput `pulumi:"spec"`
	// Status is the most recently observed status of the ReplicaSet. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status ReplicaSetStatusPtrInput `pulumi:"status"`
}

func (ReplicaSetTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicaSetType)(nil)).Elem()
}

func (i ReplicaSetTypeArgs) ToReplicaSetTypeOutput() ReplicaSetTypeOutput {
	return i.ToReplicaSetTypeOutputWithContext(context.Background())
}

func (i ReplicaSetTypeArgs) ToReplicaSetTypeOutputWithContext(ctx context.Context) ReplicaSetTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetTypeOutput)
}

// ReplicaSetTypeArrayInput is an input type that accepts ReplicaSetTypeArray and ReplicaSetTypeArrayOutput values.
// You can construct a concrete instance of `ReplicaSetTypeArrayInput` via:
//
//          ReplicaSetTypeArray{ ReplicaSetTypeArgs{...} }
type ReplicaSetTypeArrayInput interface {
	pulumi.Input

	ToReplicaSetTypeArrayOutput() ReplicaSetTypeArrayOutput
	ToReplicaSetTypeArrayOutputWithContext(context.Context) ReplicaSetTypeArrayOutput
}

type ReplicaSetTypeArray []ReplicaSetTypeInput

func (ReplicaSetTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicaSetType)(nil)).Elem()
}

func (i ReplicaSetTypeArray) ToReplicaSetTypeArrayOutput() ReplicaSetTypeArrayOutput {
	return i.ToReplicaSetTypeArrayOutputWithContext(context.Background())
}

func (i ReplicaSetTypeArray) ToReplicaSetTypeArrayOutputWithContext(ctx context.Context) ReplicaSetTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetTypeArrayOutput)
}

// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
type ReplicaSetTypeOutput struct{ *pulumi.OutputState }

func (ReplicaSetTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicaSetType)(nil)).Elem()
}

func (o ReplicaSetTypeOutput) ToReplicaSetTypeOutput() ReplicaSetTypeOutput {
	return o
}

func (o ReplicaSetTypeOutput) ToReplicaSetTypeOutputWithContext(ctx context.Context) ReplicaSetTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o ReplicaSetTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReplicaSetType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ReplicaSetTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReplicaSetType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s) that the ReplicaSet manages. Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o ReplicaSetTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ReplicaSetType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec defines the specification of the desired behavior of the ReplicaSet. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o ReplicaSetTypeOutput) Spec() ReplicaSetSpecPtrOutput {
	return o.ApplyT(func(v ReplicaSetType) *ReplicaSetSpec { return v.Spec }).(ReplicaSetSpecPtrOutput)
}

// Status is the most recently observed status of the ReplicaSet. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o ReplicaSetTypeOutput) Status() ReplicaSetStatusPtrOutput {
	return o.ApplyT(func(v ReplicaSetType) *ReplicaSetStatus { return v.Status }).(ReplicaSetStatusPtrOutput)
}

type ReplicaSetTypeArrayOutput struct{ *pulumi.OutputState }

func (ReplicaSetTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicaSetType)(nil)).Elem()
}

func (o ReplicaSetTypeArrayOutput) ToReplicaSetTypeArrayOutput() ReplicaSetTypeArrayOutput {
	return o
}

func (o ReplicaSetTypeArrayOutput) ToReplicaSetTypeArrayOutputWithContext(ctx context.Context) ReplicaSetTypeArrayOutput {
	return o
}

func (o ReplicaSetTypeArrayOutput) Index(i pulumi.IntInput) ReplicaSetTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReplicaSetType {
		return vs[0].([]ReplicaSetType)[vs[1].(int)]
	}).(ReplicaSetTypeOutput)
}

// ReplicaSetCondition describes the state of a replica set at a certain point.
type ReplicaSetCondition struct {
	// The last time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// A human readable message indicating details about the transition.
	Message *string `pulumi:"message"`
	// The reason for the condition's last transition.
	Reason *string `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// Type of replica set condition.
	Type string `pulumi:"type"`
}

// ReplicaSetConditionInput is an input type that accepts ReplicaSetConditionArgs and ReplicaSetConditionOutput values.
// You can construct a concrete instance of `ReplicaSetConditionInput` via:
//
//          ReplicaSetConditionArgs{...}
type ReplicaSetConditionInput interface {
	pulumi.Input

	ToReplicaSetConditionOutput() ReplicaSetConditionOutput
	ToReplicaSetConditionOutputWithContext(context.Context) ReplicaSetConditionOutput
}

// ReplicaSetCondition describes the state of a replica set at a certain point.
type ReplicaSetConditionArgs struct {
	// The last time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// A human readable message indicating details about the transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// The reason for the condition's last transition.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// Type of replica set condition.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ReplicaSetConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicaSetCondition)(nil)).Elem()
}

func (i ReplicaSetConditionArgs) ToReplicaSetConditionOutput() ReplicaSetConditionOutput {
	return i.ToReplicaSetConditionOutputWithContext(context.Background())
}

func (i ReplicaSetConditionArgs) ToReplicaSetConditionOutputWithContext(ctx context.Context) ReplicaSetConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetConditionOutput)
}

// ReplicaSetConditionArrayInput is an input type that accepts ReplicaSetConditionArray and ReplicaSetConditionArrayOutput values.
// You can construct a concrete instance of `ReplicaSetConditionArrayInput` via:
//
//          ReplicaSetConditionArray{ ReplicaSetConditionArgs{...} }
type ReplicaSetConditionArrayInput interface {
	pulumi.Input

	ToReplicaSetConditionArrayOutput() ReplicaSetConditionArrayOutput
	ToReplicaSetConditionArrayOutputWithContext(context.Context) ReplicaSetConditionArrayOutput
}

type ReplicaSetConditionArray []ReplicaSetConditionInput

func (ReplicaSetConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicaSetCondition)(nil)).Elem()
}

func (i ReplicaSetConditionArray) ToReplicaSetConditionArrayOutput() ReplicaSetConditionArrayOutput {
	return i.ToReplicaSetConditionArrayOutputWithContext(context.Background())
}

func (i ReplicaSetConditionArray) ToReplicaSetConditionArrayOutputWithContext(ctx context.Context) ReplicaSetConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetConditionArrayOutput)
}

// ReplicaSetCondition describes the state of a replica set at a certain point.
type ReplicaSetConditionOutput struct{ *pulumi.OutputState }

func (ReplicaSetConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicaSetCondition)(nil)).Elem()
}

func (o ReplicaSetConditionOutput) ToReplicaSetConditionOutput() ReplicaSetConditionOutput {
	return o
}

func (o ReplicaSetConditionOutput) ToReplicaSetConditionOutputWithContext(ctx context.Context) ReplicaSetConditionOutput {
	return o
}

// The last time the condition transitioned from one status to another.
func (o ReplicaSetConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReplicaSetCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// A human readable message indicating details about the transition.
func (o ReplicaSetConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReplicaSetCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// The reason for the condition's last transition.
func (o ReplicaSetConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReplicaSetCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Status of the condition, one of True, False, Unknown.
func (o ReplicaSetConditionOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v ReplicaSetCondition) string { return v.Status }).(pulumi.StringOutput)
}

// Type of replica set condition.
func (o ReplicaSetConditionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ReplicaSetCondition) string { return v.Type }).(pulumi.StringOutput)
}

type ReplicaSetConditionArrayOutput struct{ *pulumi.OutputState }

func (ReplicaSetConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicaSetCondition)(nil)).Elem()
}

func (o ReplicaSetConditionArrayOutput) ToReplicaSetConditionArrayOutput() ReplicaSetConditionArrayOutput {
	return o
}

func (o ReplicaSetConditionArrayOutput) ToReplicaSetConditionArrayOutputWithContext(ctx context.Context) ReplicaSetConditionArrayOutput {
	return o
}

func (o ReplicaSetConditionArrayOutput) Index(i pulumi.IntInput) ReplicaSetConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReplicaSetCondition {
		return vs[0].([]ReplicaSetCondition)[vs[1].(int)]
	}).(ReplicaSetConditionOutput)
}

// ReplicaSetList is a collection of ReplicaSets.
type ReplicaSetListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of ReplicaSets. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
	Items []ReplicaSetType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// ReplicaSetSpec is the specification of a ReplicaSet.
type ReplicaSetSpec struct {
	// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
	MinReadySeconds *int `pulumi:"minReadySeconds"`
	// Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
	Replicas *int `pulumi:"replicas"`
	// Selector is a label query over pods that should match the replica count. Label keys and values that must match in order to be controlled by this replica set. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
	Selector metav1.LabelSelector `pulumi:"selector"`
	// Template is the object that describes the pod that will be created if insufficient replicas are detected. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
	Template *corev1.PodTemplateSpec `pulumi:"template"`
}

// ReplicaSetSpecInput is an input type that accepts ReplicaSetSpecArgs and ReplicaSetSpecOutput values.
// You can construct a concrete instance of `ReplicaSetSpecInput` via:
//
//          ReplicaSetSpecArgs{...}
type ReplicaSetSpecInput interface {
	pulumi.Input

	ToReplicaSetSpecOutput() ReplicaSetSpecOutput
	ToReplicaSetSpecOutputWithContext(context.Context) ReplicaSetSpecOutput
}

// ReplicaSetSpec is the specification of a ReplicaSet.
type ReplicaSetSpecArgs struct {
	// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
	MinReadySeconds pulumi.IntPtrInput `pulumi:"minReadySeconds"`
	// Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
	Replicas pulumi.IntPtrInput `pulumi:"replicas"`
	// Selector is a label query over pods that should match the replica count. Label keys and values that must match in order to be controlled by this replica set. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
	Selector metav1.LabelSelectorInput `pulumi:"selector"`
	// Template is the object that describes the pod that will be created if insufficient replicas are detected. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
	Template corev1.PodTemplateSpecPtrInput `pulumi:"template"`
}

func (ReplicaSetSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicaSetSpec)(nil)).Elem()
}

func (i ReplicaSetSpecArgs) ToReplicaSetSpecOutput() ReplicaSetSpecOutput {
	return i.ToReplicaSetSpecOutputWithContext(context.Background())
}

func (i ReplicaSetSpecArgs) ToReplicaSetSpecOutputWithContext(ctx context.Context) ReplicaSetSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetSpecOutput)
}

func (i ReplicaSetSpecArgs) ToReplicaSetSpecPtrOutput() ReplicaSetSpecPtrOutput {
	return i.ToReplicaSetSpecPtrOutputWithContext(context.Background())
}

func (i ReplicaSetSpecArgs) ToReplicaSetSpecPtrOutputWithContext(ctx context.Context) ReplicaSetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetSpecOutput).ToReplicaSetSpecPtrOutputWithContext(ctx)
}

// ReplicaSetSpecPtrInput is an input type that accepts ReplicaSetSpecArgs, ReplicaSetSpecPtr and ReplicaSetSpecPtrOutput values.
// You can construct a concrete instance of `ReplicaSetSpecPtrInput` via:
//
//          ReplicaSetSpecArgs{...}
//
//  or:
//
//          nil
type ReplicaSetSpecPtrInput interface {
	pulumi.Input

	ToReplicaSetSpecPtrOutput() ReplicaSetSpecPtrOutput
	ToReplicaSetSpecPtrOutputWithContext(context.Context) ReplicaSetSpecPtrOutput
}

type replicaSetSpecPtrType ReplicaSetSpecArgs

func ReplicaSetSpecPtr(v *ReplicaSetSpecArgs) ReplicaSetSpecPtrInput {
	return (*replicaSetSpecPtrType)(v)
}

func (*replicaSetSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicaSetSpec)(nil)).Elem()
}

func (i *replicaSetSpecPtrType) ToReplicaSetSpecPtrOutput() ReplicaSetSpecPtrOutput {
	return i.ToReplicaSetSpecPtrOutputWithContext(context.Background())
}

func (i *replicaSetSpecPtrType) ToReplicaSetSpecPtrOutputWithContext(ctx context.Context) ReplicaSetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetSpecPtrOutput)
}

// ReplicaSetSpec is the specification of a ReplicaSet.
type ReplicaSetSpecOutput struct{ *pulumi.OutputState }

func (ReplicaSetSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicaSetSpec)(nil)).Elem()
}

func (o ReplicaSetSpecOutput) ToReplicaSetSpecOutput() ReplicaSetSpecOutput {
	return o
}

func (o ReplicaSetSpecOutput) ToReplicaSetSpecOutputWithContext(ctx context.Context) ReplicaSetSpecOutput {
	return o
}

func (o ReplicaSetSpecOutput) ToReplicaSetSpecPtrOutput() ReplicaSetSpecPtrOutput {
	return o.ToReplicaSetSpecPtrOutputWithContext(context.Background())
}

func (o ReplicaSetSpecOutput) ToReplicaSetSpecPtrOutputWithContext(ctx context.Context) ReplicaSetSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ReplicaSetSpec) *ReplicaSetSpec {
		return &v
	}).(ReplicaSetSpecPtrOutput)
}

// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
func (o ReplicaSetSpecOutput) MinReadySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ReplicaSetSpec) *int { return v.MinReadySeconds }).(pulumi.IntPtrOutput)
}

// Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
func (o ReplicaSetSpecOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ReplicaSetSpec) *int { return v.Replicas }).(pulumi.IntPtrOutput)
}

// Selector is a label query over pods that should match the replica count. Label keys and values that must match in order to be controlled by this replica set. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
func (o ReplicaSetSpecOutput) Selector() metav1.LabelSelectorOutput {
	return o.ApplyT(func(v ReplicaSetSpec) metav1.LabelSelector { return v.Selector }).(metav1.LabelSelectorOutput)
}

// Template is the object that describes the pod that will be created if insufficient replicas are detected. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
func (o ReplicaSetSpecOutput) Template() corev1.PodTemplateSpecPtrOutput {
	return o.ApplyT(func(v ReplicaSetSpec) *corev1.PodTemplateSpec { return v.Template }).(corev1.PodTemplateSpecPtrOutput)
}

type ReplicaSetSpecPtrOutput struct{ *pulumi.OutputState }

func (ReplicaSetSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicaSetSpec)(nil)).Elem()
}

func (o ReplicaSetSpecPtrOutput) ToReplicaSetSpecPtrOutput() ReplicaSetSpecPtrOutput {
	return o
}

func (o ReplicaSetSpecPtrOutput) ToReplicaSetSpecPtrOutputWithContext(ctx context.Context) ReplicaSetSpecPtrOutput {
	return o
}

func (o ReplicaSetSpecPtrOutput) Elem() ReplicaSetSpecOutput {
	return o.ApplyT(func(v *ReplicaSetSpec) ReplicaSetSpec {
		if v != nil {
			return *v
		}
		var ret ReplicaSetSpec
		return ret
	}).(ReplicaSetSpecOutput)
}

// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
func (o ReplicaSetSpecPtrOutput) MinReadySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ReplicaSetSpec) *int {
		if v == nil {
			return nil
		}
		return v.MinReadySeconds
	}).(pulumi.IntPtrOutput)
}

// Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
func (o ReplicaSetSpecPtrOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ReplicaSetSpec) *int {
		if v == nil {
			return nil
		}
		return v.Replicas
	}).(pulumi.IntPtrOutput)
}

// Selector is a label query over pods that should match the replica count. Label keys and values that must match in order to be controlled by this replica set. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
func (o ReplicaSetSpecPtrOutput) Selector() metav1.LabelSelectorPtrOutput {
	return o.ApplyT(func(v *ReplicaSetSpec) *metav1.LabelSelector {
		if v == nil {
			return nil
		}
		return &v.Selector
	}).(metav1.LabelSelectorPtrOutput)
}

// Template is the object that describes the pod that will be created if insufficient replicas are detected. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
func (o ReplicaSetSpecPtrOutput) Template() corev1.PodTemplateSpecPtrOutput {
	return o.ApplyT(func(v *ReplicaSetSpec) *corev1.PodTemplateSpec {
		if v == nil {
			return nil
		}
		return v.Template
	}).(corev1.PodTemplateSpecPtrOutput)
}

// ReplicaSetStatus represents the current status of a ReplicaSet.
type ReplicaSetStatus struct {
	// The number of available replicas (ready for at least minReadySeconds) for this replica set.
	AvailableReplicas *int `pulumi:"availableReplicas"`
	// Represents the latest available observations of a replica set's current state.
	Conditions []ReplicaSetCondition `pulumi:"conditions"`
	// The number of pods that have labels matching the labels of the pod template of the replicaset.
	FullyLabeledReplicas *int `pulumi:"fullyLabeledReplicas"`
	// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
	ReadyReplicas *int `pulumi:"readyReplicas"`
	// Replicas is the most recently oberved number of replicas. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
	Replicas int `pulumi:"replicas"`
}

// ReplicaSetStatusInput is an input type that accepts ReplicaSetStatusArgs and ReplicaSetStatusOutput values.
// You can construct a concrete instance of `ReplicaSetStatusInput` via:
//
//          ReplicaSetStatusArgs{...}
type ReplicaSetStatusInput interface {
	pulumi.Input

	ToReplicaSetStatusOutput() ReplicaSetStatusOutput
	ToReplicaSetStatusOutputWithContext(context.Context) ReplicaSetStatusOutput
}

// ReplicaSetStatus represents the current status of a ReplicaSet.
type ReplicaSetStatusArgs struct {
	// The number of available replicas (ready for at least minReadySeconds) for this replica set.
	AvailableReplicas pulumi.IntPtrInput `pulumi:"availableReplicas"`
	// Represents the latest available observations of a replica set's current state.
	Conditions ReplicaSetConditionArrayInput `pulumi:"conditions"`
	// The number of pods that have labels matching the labels of the pod template of the replicaset.
	FullyLabeledReplicas pulumi.IntPtrInput `pulumi:"fullyLabeledReplicas"`
	// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
	ReadyReplicas pulumi.IntPtrInput `pulumi:"readyReplicas"`
	// Replicas is the most recently oberved number of replicas. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
	Replicas pulumi.IntInput `pulumi:"replicas"`
}

func (ReplicaSetStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicaSetStatus)(nil)).Elem()
}

func (i ReplicaSetStatusArgs) ToReplicaSetStatusOutput() ReplicaSetStatusOutput {
	return i.ToReplicaSetStatusOutputWithContext(context.Background())
}

func (i ReplicaSetStatusArgs) ToReplicaSetStatusOutputWithContext(ctx context.Context) ReplicaSetStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetStatusOutput)
}

func (i ReplicaSetStatusArgs) ToReplicaSetStatusPtrOutput() ReplicaSetStatusPtrOutput {
	return i.ToReplicaSetStatusPtrOutputWithContext(context.Background())
}

func (i ReplicaSetStatusArgs) ToReplicaSetStatusPtrOutputWithContext(ctx context.Context) ReplicaSetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetStatusOutput).ToReplicaSetStatusPtrOutputWithContext(ctx)
}

// ReplicaSetStatusPtrInput is an input type that accepts ReplicaSetStatusArgs, ReplicaSetStatusPtr and ReplicaSetStatusPtrOutput values.
// You can construct a concrete instance of `ReplicaSetStatusPtrInput` via:
//
//          ReplicaSetStatusArgs{...}
//
//  or:
//
//          nil
type ReplicaSetStatusPtrInput interface {
	pulumi.Input

	ToReplicaSetStatusPtrOutput() ReplicaSetStatusPtrOutput
	ToReplicaSetStatusPtrOutputWithContext(context.Context) ReplicaSetStatusPtrOutput
}

type replicaSetStatusPtrType ReplicaSetStatusArgs

func ReplicaSetStatusPtr(v *ReplicaSetStatusArgs) ReplicaSetStatusPtrInput {
	return (*replicaSetStatusPtrType)(v)
}

func (*replicaSetStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicaSetStatus)(nil)).Elem()
}

func (i *replicaSetStatusPtrType) ToReplicaSetStatusPtrOutput() ReplicaSetStatusPtrOutput {
	return i.ToReplicaSetStatusPtrOutputWithContext(context.Background())
}

func (i *replicaSetStatusPtrType) ToReplicaSetStatusPtrOutputWithContext(ctx context.Context) ReplicaSetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicaSetStatusPtrOutput)
}

// ReplicaSetStatus represents the current status of a ReplicaSet.
type ReplicaSetStatusOutput struct{ *pulumi.OutputState }

func (ReplicaSetStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicaSetStatus)(nil)).Elem()
}

func (o ReplicaSetStatusOutput) ToReplicaSetStatusOutput() ReplicaSetStatusOutput {
	return o
}

func (o ReplicaSetStatusOutput) ToReplicaSetStatusOutputWithContext(ctx context.Context) ReplicaSetStatusOutput {
	return o
}

func (o ReplicaSetStatusOutput) ToReplicaSetStatusPtrOutput() ReplicaSetStatusPtrOutput {
	return o.ToReplicaSetStatusPtrOutputWithContext(context.Background())
}

func (o ReplicaSetStatusOutput) ToReplicaSetStatusPtrOutputWithContext(ctx context.Context) ReplicaSetStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ReplicaSetStatus) *ReplicaSetStatus {
		return &v
	}).(ReplicaSetStatusPtrOutput)
}

// The number of available replicas (ready for at least minReadySeconds) for this replica set.
func (o ReplicaSetStatusOutput) AvailableReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ReplicaSetStatus) *int { return v.AvailableReplicas }).(pulumi.IntPtrOutput)
}

// Represents the latest available observations of a replica set's current state.
func (o ReplicaSetStatusOutput) Conditions() ReplicaSetConditionArrayOutput {
	return o.ApplyT(func(v ReplicaSetStatus) []ReplicaSetCondition { return v.Conditions }).(ReplicaSetConditionArrayOutput)
}

// The number of pods that have labels matching the labels of the pod template of the replicaset.
func (o ReplicaSetStatusOutput) FullyLabeledReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ReplicaSetStatus) *int { return v.FullyLabeledReplicas }).(pulumi.IntPtrOutput)
}

// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
func (o ReplicaSetStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ReplicaSetStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
func (o ReplicaSetStatusOutput) ReadyReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ReplicaSetStatus) *int { return v.ReadyReplicas }).(pulumi.IntPtrOutput)
}

// Replicas is the most recently oberved number of replicas. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
func (o ReplicaSetStatusOutput) Replicas() pulumi.IntOutput {
	return o.ApplyT(func(v ReplicaSetStatus) int { return v.Replicas }).(pulumi.IntOutput)
}

type ReplicaSetStatusPtrOutput struct{ *pulumi.OutputState }

func (ReplicaSetStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicaSetStatus)(nil)).Elem()
}

func (o ReplicaSetStatusPtrOutput) ToReplicaSetStatusPtrOutput() ReplicaSetStatusPtrOutput {
	return o
}

func (o ReplicaSetStatusPtrOutput) ToReplicaSetStatusPtrOutputWithContext(ctx context.Context) ReplicaSetStatusPtrOutput {
	return o
}

func (o ReplicaSetStatusPtrOutput) Elem() ReplicaSetStatusOutput {
	return o.ApplyT(func(v *ReplicaSetStatus) ReplicaSetStatus {
		if v != nil {
			return *v
		}
		var ret ReplicaSetStatus
		return ret
	}).(ReplicaSetStatusOutput)
}

// The number of available replicas (ready for at least minReadySeconds) for this replica set.
func (o ReplicaSetStatusPtrOutput) AvailableReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ReplicaSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.AvailableReplicas
	}).(pulumi.IntPtrOutput)
}

// Represents the latest available observations of a replica set's current state.
func (o ReplicaSetStatusPtrOutput) Conditions() ReplicaSetConditionArrayOutput {
	return o.ApplyT(func(v *ReplicaSetStatus) []ReplicaSetCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(ReplicaSetConditionArrayOutput)
}

// The number of pods that have labels matching the labels of the pod template of the replicaset.
func (o ReplicaSetStatusPtrOutput) FullyLabeledReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ReplicaSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.FullyLabeledReplicas
	}).(pulumi.IntPtrOutput)
}

// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
func (o ReplicaSetStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ReplicaSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
func (o ReplicaSetStatusPtrOutput) ReadyReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ReplicaSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.ReadyReplicas
	}).(pulumi.IntPtrOutput)
}

// Replicas is the most recently oberved number of replicas. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
func (o ReplicaSetStatusPtrOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ReplicaSetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.Replicas
	}).(pulumi.IntPtrOutput)
}

// Spec to control the desired behavior of daemon set rolling update.
type RollingUpdateDaemonSet struct {
	// The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption. This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.
	MaxSurge interface{} `pulumi:"maxSurge"`
	// The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
}

// RollingUpdateDaemonSetInput is an input type that accepts RollingUpdateDaemonSetArgs and RollingUpdateDaemonSetOutput values.
// You can construct a concrete instance of `RollingUpdateDaemonSetInput` via:
//
//          RollingUpdateDaemonSetArgs{...}
type RollingUpdateDaemonSetInput interface {
	pulumi.Input

	ToRollingUpdateDaemonSetOutput() RollingUpdateDaemonSetOutput
	ToRollingUpdateDaemonSetOutputWithContext(context.Context) RollingUpdateDaemonSetOutput
}

// Spec to control the desired behavior of daemon set rolling update.
type RollingUpdateDaemonSetArgs struct {
	// The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption. This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.
	MaxSurge pulumi.Input `pulumi:"maxSurge"`
	// The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
}

func (RollingUpdateDaemonSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpdateDaemonSet)(nil)).Elem()
}

func (i RollingUpdateDaemonSetArgs) ToRollingUpdateDaemonSetOutput() RollingUpdateDaemonSetOutput {
	return i.ToRollingUpdateDaemonSetOutputWithContext(context.Background())
}

func (i RollingUpdateDaemonSetArgs) ToRollingUpdateDaemonSetOutputWithContext(ctx context.Context) RollingUpdateDaemonSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpdateDaemonSetOutput)
}

func (i RollingUpdateDaemonSetArgs) ToRollingUpdateDaemonSetPtrOutput() RollingUpdateDaemonSetPtrOutput {
	return i.ToRollingUpdateDaemonSetPtrOutputWithContext(context.Background())
}

func (i RollingUpdateDaemonSetArgs) ToRollingUpdateDaemonSetPtrOutputWithContext(ctx context.Context) RollingUpdateDaemonSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpdateDaemonSetOutput).ToRollingUpdateDaemonSetPtrOutputWithContext(ctx)
}

// RollingUpdateDaemonSetPtrInput is an input type that accepts RollingUpdateDaemonSetArgs, RollingUpdateDaemonSetPtr and RollingUpdateDaemonSetPtrOutput values.
// You can construct a concrete instance of `RollingUpdateDaemonSetPtrInput` via:
//
//          RollingUpdateDaemonSetArgs{...}
//
//  or:
//
//          nil
type RollingUpdateDaemonSetPtrInput interface {
	pulumi.Input

	ToRollingUpdateDaemonSetPtrOutput() RollingUpdateDaemonSetPtrOutput
	ToRollingUpdateDaemonSetPtrOutputWithContext(context.Context) RollingUpdateDaemonSetPtrOutput
}

type rollingUpdateDaemonSetPtrType RollingUpdateDaemonSetArgs

func RollingUpdateDaemonSetPtr(v *RollingUpdateDaemonSetArgs) RollingUpdateDaemonSetPtrInput {
	return (*rollingUpdateDaemonSetPtrType)(v)
}

func (*rollingUpdateDaemonSetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpdateDaemonSet)(nil)).Elem()
}

func (i *rollingUpdateDaemonSetPtrType) ToRollingUpdateDaemonSetPtrOutput() RollingUpdateDaemonSetPtrOutput {
	return i.ToRollingUpdateDaemonSetPtrOutputWithContext(context.Background())
}

func (i *rollingUpdateDaemonSetPtrType) ToRollingUpdateDaemonSetPtrOutputWithContext(ctx context.Context) RollingUpdateDaemonSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpdateDaemonSetPtrOutput)
}

// Spec to control the desired behavior of daemon set rolling update.
type RollingUpdateDaemonSetOutput struct{ *pulumi.OutputState }

func (RollingUpdateDaemonSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpdateDaemonSet)(nil)).Elem()
}

func (o RollingUpdateDaemonSetOutput) ToRollingUpdateDaemonSetOutput() RollingUpdateDaemonSetOutput {
	return o
}

func (o RollingUpdateDaemonSetOutput) ToRollingUpdateDaemonSetOutputWithContext(ctx context.Context) RollingUpdateDaemonSetOutput {
	return o
}

func (o RollingUpdateDaemonSetOutput) ToRollingUpdateDaemonSetPtrOutput() RollingUpdateDaemonSetPtrOutput {
	return o.ToRollingUpdateDaemonSetPtrOutputWithContext(context.Background())
}

func (o RollingUpdateDaemonSetOutput) ToRollingUpdateDaemonSetPtrOutputWithContext(ctx context.Context) RollingUpdateDaemonSetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RollingUpdateDaemonSet) *RollingUpdateDaemonSet {
		return &v
	}).(RollingUpdateDaemonSetPtrOutput)
}

// The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption. This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.
func (o RollingUpdateDaemonSetOutput) MaxSurge() pulumi.AnyOutput {
	return o.ApplyT(func(v RollingUpdateDaemonSet) interface{} { return v.MaxSurge }).(pulumi.AnyOutput)
}

// The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.
func (o RollingUpdateDaemonSetOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v RollingUpdateDaemonSet) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

type RollingUpdateDaemonSetPtrOutput struct{ *pulumi.OutputState }

func (RollingUpdateDaemonSetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpdateDaemonSet)(nil)).Elem()
}

func (o RollingUpdateDaemonSetPtrOutput) ToRollingUpdateDaemonSetPtrOutput() RollingUpdateDaemonSetPtrOutput {
	return o
}

func (o RollingUpdateDaemonSetPtrOutput) ToRollingUpdateDaemonSetPtrOutputWithContext(ctx context.Context) RollingUpdateDaemonSetPtrOutput {
	return o
}

func (o RollingUpdateDaemonSetPtrOutput) Elem() RollingUpdateDaemonSetOutput {
	return o.ApplyT(func(v *RollingUpdateDaemonSet) RollingUpdateDaemonSet {
		if v != nil {
			return *v
		}
		var ret RollingUpdateDaemonSet
		return ret
	}).(RollingUpdateDaemonSetOutput)
}

// The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption. This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.
func (o RollingUpdateDaemonSetPtrOutput) MaxSurge() pulumi.AnyOutput {
	return o.ApplyT(func(v *RollingUpdateDaemonSet) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxSurge
	}).(pulumi.AnyOutput)
}

// The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.
func (o RollingUpdateDaemonSetPtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *RollingUpdateDaemonSet) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// Spec to control the desired behavior of rolling update.
type RollingUpdateDeployment struct {
	// The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
	MaxSurge interface{} `pulumi:"maxSurge"`
	// The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
}

// RollingUpdateDeploymentInput is an input type that accepts RollingUpdateDeploymentArgs and RollingUpdateDeploymentOutput values.
// You can construct a concrete instance of `RollingUpdateDeploymentInput` via:
//
//          RollingUpdateDeploymentArgs{...}
type RollingUpdateDeploymentInput interface {
	pulumi.Input

	ToRollingUpdateDeploymentOutput() RollingUpdateDeploymentOutput
	ToRollingUpdateDeploymentOutputWithContext(context.Context) RollingUpdateDeploymentOutput
}

// Spec to control the desired behavior of rolling update.
type RollingUpdateDeploymentArgs struct {
	// The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
	MaxSurge pulumi.Input `pulumi:"maxSurge"`
	// The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
}

func (RollingUpdateDeploymentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpdateDeployment)(nil)).Elem()
}

func (i RollingUpdateDeploymentArgs) ToRollingUpdateDeploymentOutput() RollingUpdateDeploymentOutput {
	return i.ToRollingUpdateDeploymentOutputWithContext(context.Background())
}

func (i RollingUpdateDeploymentArgs) ToRollingUpdateDeploymentOutputWithContext(ctx context.Context) RollingUpdateDeploymentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpdateDeploymentOutput)
}

func (i RollingUpdateDeploymentArgs) ToRollingUpdateDeploymentPtrOutput() RollingUpdateDeploymentPtrOutput {
	return i.ToRollingUpdateDeploymentPtrOutputWithContext(context.Background())
}

func (i RollingUpdateDeploymentArgs) ToRollingUpdateDeploymentPtrOutputWithContext(ctx context.Context) RollingUpdateDeploymentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpdateDeploymentOutput).ToRollingUpdateDeploymentPtrOutputWithContext(ctx)
}

// RollingUpdateDeploymentPtrInput is an input type that accepts RollingUpdateDeploymentArgs, RollingUpdateDeploymentPtr and RollingUpdateDeploymentPtrOutput values.
// You can construct a concrete instance of `RollingUpdateDeploymentPtrInput` via:
//
//          RollingUpdateDeploymentArgs{...}
//
//  or:
//
//          nil
type RollingUpdateDeploymentPtrInput interface {
	pulumi.Input

	ToRollingUpdateDeploymentPtrOutput() RollingUpdateDeploymentPtrOutput
	ToRollingUpdateDeploymentPtrOutputWithContext(context.Context) RollingUpdateDeploymentPtrOutput
}

type rollingUpdateDeploymentPtrType RollingUpdateDeploymentArgs

func RollingUpdateDeploymentPtr(v *RollingUpdateDeploymentArgs) RollingUpdateDeploymentPtrInput {
	return (*rollingUpdateDeploymentPtrType)(v)
}

func (*rollingUpdateDeploymentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpdateDeployment)(nil)).Elem()
}

func (i *rollingUpdateDeploymentPtrType) ToRollingUpdateDeploymentPtrOutput() RollingUpdateDeploymentPtrOutput {
	return i.ToRollingUpdateDeploymentPtrOutputWithContext(context.Background())
}

func (i *rollingUpdateDeploymentPtrType) ToRollingUpdateDeploymentPtrOutputWithContext(ctx context.Context) RollingUpdateDeploymentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpdateDeploymentPtrOutput)
}

// Spec to control the desired behavior of rolling update.
type RollingUpdateDeploymentOutput struct{ *pulumi.OutputState }

func (RollingUpdateDeploymentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpdateDeployment)(nil)).Elem()
}

func (o RollingUpdateDeploymentOutput) ToRollingUpdateDeploymentOutput() RollingUpdateDeploymentOutput {
	return o
}

func (o RollingUpdateDeploymentOutput) ToRollingUpdateDeploymentOutputWithContext(ctx context.Context) RollingUpdateDeploymentOutput {
	return o
}

func (o RollingUpdateDeploymentOutput) ToRollingUpdateDeploymentPtrOutput() RollingUpdateDeploymentPtrOutput {
	return o.ToRollingUpdateDeploymentPtrOutputWithContext(context.Background())
}

func (o RollingUpdateDeploymentOutput) ToRollingUpdateDeploymentPtrOutputWithContext(ctx context.Context) RollingUpdateDeploymentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RollingUpdateDeployment) *RollingUpdateDeployment {
		return &v
	}).(RollingUpdateDeploymentPtrOutput)
}

// The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
func (o RollingUpdateDeploymentOutput) MaxSurge() pulumi.AnyOutput {
	return o.ApplyT(func(v RollingUpdateDeployment) interface{} { return v.MaxSurge }).(pulumi.AnyOutput)
}

// The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
func (o RollingUpdateDeploymentOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v RollingUpdateDeployment) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

type RollingUpdateDeploymentPtrOutput struct{ *pulumi.OutputState }

func (RollingUpdateDeploymentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpdateDeployment)(nil)).Elem()
}

func (o RollingUpdateDeploymentPtrOutput) ToRollingUpdateDeploymentPtrOutput() RollingUpdateDeploymentPtrOutput {
	return o
}

func (o RollingUpdateDeploymentPtrOutput) ToRollingUpdateDeploymentPtrOutputWithContext(ctx context.Context) RollingUpdateDeploymentPtrOutput {
	return o
}

func (o RollingUpdateDeploymentPtrOutput) Elem() RollingUpdateDeploymentOutput {
	return o.ApplyT(func(v *RollingUpdateDeployment) RollingUpdateDeployment {
		if v != nil {
			return *v
		}
		var ret RollingUpdateDeployment
		return ret
	}).(RollingUpdateDeploymentOutput)
}

// The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
func (o RollingUpdateDeploymentPtrOutput) MaxSurge() pulumi.AnyOutput {
	return o.ApplyT(func(v *RollingUpdateDeployment) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxSurge
	}).(pulumi.AnyOutput)
}

// The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
func (o RollingUpdateDeploymentPtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *RollingUpdateDeployment) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
type RollingUpdateStatefulSetStrategy struct {
	// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default value is 0.
	Partition *int `pulumi:"partition"`
}

// RollingUpdateStatefulSetStrategyInput is an input type that accepts RollingUpdateStatefulSetStrategyArgs and RollingUpdateStatefulSetStrategyOutput values.
// You can construct a concrete instance of `RollingUpdateStatefulSetStrategyInput` via:
//
//          RollingUpdateStatefulSetStrategyArgs{...}
type RollingUpdateStatefulSetStrategyInput interface {
	pulumi.Input

	ToRollingUpdateStatefulSetStrategyOutput() RollingUpdateStatefulSetStrategyOutput
	ToRollingUpdateStatefulSetStrategyOutputWithContext(context.Context) RollingUpdateStatefulSetStrategyOutput
}

// RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
type RollingUpdateStatefulSetStrategyArgs struct {
	// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default value is 0.
	Partition pulumi.IntPtrInput `pulumi:"partition"`
}

func (RollingUpdateStatefulSetStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpdateStatefulSetStrategy)(nil)).Elem()
}

func (i RollingUpdateStatefulSetStrategyArgs) ToRollingUpdateStatefulSetStrategyOutput() RollingUpdateStatefulSetStrategyOutput {
	return i.ToRollingUpdateStatefulSetStrategyOutputWithContext(context.Background())
}

func (i RollingUpdateStatefulSetStrategyArgs) ToRollingUpdateStatefulSetStrategyOutputWithContext(ctx context.Context) RollingUpdateStatefulSetStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpdateStatefulSetStrategyOutput)
}

func (i RollingUpdateStatefulSetStrategyArgs) ToRollingUpdateStatefulSetStrategyPtrOutput() RollingUpdateStatefulSetStrategyPtrOutput {
	return i.ToRollingUpdateStatefulSetStrategyPtrOutputWithContext(context.Background())
}

func (i RollingUpdateStatefulSetStrategyArgs) ToRollingUpdateStatefulSetStrategyPtrOutputWithContext(ctx context.Context) RollingUpdateStatefulSetStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpdateStatefulSetStrategyOutput).ToRollingUpdateStatefulSetStrategyPtrOutputWithContext(ctx)
}

// RollingUpdateStatefulSetStrategyPtrInput is an input type that accepts RollingUpdateStatefulSetStrategyArgs, RollingUpdateStatefulSetStrategyPtr and RollingUpdateStatefulSetStrategyPtrOutput values.
// You can construct a concrete instance of `RollingUpdateStatefulSetStrategyPtrInput` via:
//
//          RollingUpdateStatefulSetStrategyArgs{...}
//
//  or:
//
//          nil
type RollingUpdateStatefulSetStrategyPtrInput interface {
	pulumi.Input

	ToRollingUpdateStatefulSetStrategyPtrOutput() RollingUpdateStatefulSetStrategyPtrOutput
	ToRollingUpdateStatefulSetStrategyPtrOutputWithContext(context.Context) RollingUpdateStatefulSetStrategyPtrOutput
}

type rollingUpdateStatefulSetStrategyPtrType RollingUpdateStatefulSetStrategyArgs

func RollingUpdateStatefulSetStrategyPtr(v *RollingUpdateStatefulSetStrategyArgs) RollingUpdateStatefulSetStrategyPtrInput {
	return (*rollingUpdateStatefulSetStrategyPtrType)(v)
}

func (*rollingUpdateStatefulSetStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpdateStatefulSetStrategy)(nil)).Elem()
}

func (i *rollingUpdateStatefulSetStrategyPtrType) ToRollingUpdateStatefulSetStrategyPtrOutput() RollingUpdateStatefulSetStrategyPtrOutput {
	return i.ToRollingUpdateStatefulSetStrategyPtrOutputWithContext(context.Background())
}

func (i *rollingUpdateStatefulSetStrategyPtrType) ToRollingUpdateStatefulSetStrategyPtrOutputWithContext(ctx context.Context) RollingUpdateStatefulSetStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpdateStatefulSetStrategyPtrOutput)
}

// RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
type RollingUpdateStatefulSetStrategyOutput struct{ *pulumi.OutputState }

func (RollingUpdateStatefulSetStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpdateStatefulSetStrategy)(nil)).Elem()
}

func (o RollingUpdateStatefulSetStrategyOutput) ToRollingUpdateStatefulSetStrategyOutput() RollingUpdateStatefulSetStrategyOutput {
	return o
}

func (o RollingUpdateStatefulSetStrategyOutput) ToRollingUpdateStatefulSetStrategyOutputWithContext(ctx context.Context) RollingUpdateStatefulSetStrategyOutput {
	return o
}

func (o RollingUpdateStatefulSetStrategyOutput) ToRollingUpdateStatefulSetStrategyPtrOutput() RollingUpdateStatefulSetStrategyPtrOutput {
	return o.ToRollingUpdateStatefulSetStrategyPtrOutputWithContext(context.Background())
}

func (o RollingUpdateStatefulSetStrategyOutput) ToRollingUpdateStatefulSetStrategyPtrOutputWithContext(ctx context.Context) RollingUpdateStatefulSetStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RollingUpdateStatefulSetStrategy) *RollingUpdateStatefulSetStrategy {
		return &v
	}).(RollingUpdateStatefulSetStrategyPtrOutput)
}

// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default value is 0.
func (o RollingUpdateStatefulSetStrategyOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v RollingUpdateStatefulSetStrategy) *int { return v.Partition }).(pulumi.IntPtrOutput)
}

type RollingUpdateStatefulSetStrategyPtrOutput struct{ *pulumi.OutputState }

func (RollingUpdateStatefulSetStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpdateStatefulSetStrategy)(nil)).Elem()
}

func (o RollingUpdateStatefulSetStrategyPtrOutput) ToRollingUpdateStatefulSetStrategyPtrOutput() RollingUpdateStatefulSetStrategyPtrOutput {
	return o
}

func (o RollingUpdateStatefulSetStrategyPtrOutput) ToRollingUpdateStatefulSetStrategyPtrOutputWithContext(ctx context.Context) RollingUpdateStatefulSetStrategyPtrOutput {
	return o
}

func (o RollingUpdateStatefulSetStrategyPtrOutput) Elem() RollingUpdateStatefulSetStrategyOutput {
	return o.ApplyT(func(v *RollingUpdateStatefulSetStrategy) RollingUpdateStatefulSetStrategy {
		if v != nil {
			return *v
		}
		var ret RollingUpdateStatefulSetStrategy
		return ret
	}).(RollingUpdateStatefulSetStrategyOutput)
}

// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default value is 0.
func (o RollingUpdateStatefulSetStrategyPtrOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RollingUpdateStatefulSetStrategy) *int {
		if v == nil {
			return nil
		}
		return v.Partition
	}).(pulumi.IntPtrOutput)
}

// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
//  - Network: A single stable DNS and hostname.
//  - Storage: As many VolumeClaims as requested.
//    The StatefulSet guarantees that a given network identity will always map to the same storage identity.
//
// This resource waits until its status is ready before registering success
// for create/update, and populating output properties from the current state of the resource.
// The following conditions are used to determine whether the resource creation has
// succeeded or failed:
//
// 1. The value of 'spec.replicas' matches '.status.replicas', '.status.currentReplicas',
//    and '.status.readyReplicas'.
// 2. The value of '.status.updateRevision' matches '.status.currentRevision'.
//
// If the StatefulSet has not reached a Ready state after 10 minutes, it will
// time out and mark the resource update as Failed. You can override the default timeout value
// by setting the 'customTimeouts' option on the resource.
type StatefulSetType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired identities of pods in this set.
	Spec *StatefulSetSpec `pulumi:"spec"`
	// Status is the current status of Pods in this StatefulSet. This data may be out of date by some window of time.
	Status *StatefulSetStatus `pulumi:"status"`
}

// StatefulSetTypeInput is an input type that accepts StatefulSetTypeArgs and StatefulSetTypeOutput values.
// You can construct a concrete instance of `StatefulSetTypeInput` via:
//
//          StatefulSetTypeArgs{...}
type StatefulSetTypeInput interface {
	pulumi.Input

	ToStatefulSetTypeOutput() StatefulSetTypeOutput
	ToStatefulSetTypeOutputWithContext(context.Context) StatefulSetTypeOutput
}

// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
//  - Network: A single stable DNS and hostname.
//  - Storage: As many VolumeClaims as requested.
//    The StatefulSet guarantees that a given network identity will always map to the same storage identity.
//
// This resource waits until its status is ready before registering success
// for create/update, and populating output properties from the current state of the resource.
// The following conditions are used to determine whether the resource creation has
// succeeded or failed:
//
// 1. The value of 'spec.replicas' matches '.status.replicas', '.status.currentReplicas',
//    and '.status.readyReplicas'.
// 2. The value of '.status.updateRevision' matches '.status.currentRevision'.
//
// If the StatefulSet has not reached a Ready state after 10 minutes, it will
// time out and mark the resource update as Failed. You can override the default timeout value
// by setting the 'customTimeouts' option on the resource.
type StatefulSetTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Spec defines the desired identities of pods in this set.
	Spec StatefulSetSpecPtrInput `pulumi:"spec"`
	// Status is the current status of Pods in this StatefulSet. This data may be out of date by some window of time.
	Status StatefulSetStatusPtrInput `pulumi:"status"`
}

func (StatefulSetTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetType)(nil)).Elem()
}

func (i StatefulSetTypeArgs) ToStatefulSetTypeOutput() StatefulSetTypeOutput {
	return i.ToStatefulSetTypeOutputWithContext(context.Background())
}

func (i StatefulSetTypeArgs) ToStatefulSetTypeOutputWithContext(ctx context.Context) StatefulSetTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetTypeOutput)
}

// StatefulSetTypeArrayInput is an input type that accepts StatefulSetTypeArray and StatefulSetTypeArrayOutput values.
// You can construct a concrete instance of `StatefulSetTypeArrayInput` via:
//
//          StatefulSetTypeArray{ StatefulSetTypeArgs{...} }
type StatefulSetTypeArrayInput interface {
	pulumi.Input

	ToStatefulSetTypeArrayOutput() StatefulSetTypeArrayOutput
	ToStatefulSetTypeArrayOutputWithContext(context.Context) StatefulSetTypeArrayOutput
}

type StatefulSetTypeArray []StatefulSetTypeInput

func (StatefulSetTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StatefulSetType)(nil)).Elem()
}

func (i StatefulSetTypeArray) ToStatefulSetTypeArrayOutput() StatefulSetTypeArrayOutput {
	return i.ToStatefulSetTypeArrayOutputWithContext(context.Background())
}

func (i StatefulSetTypeArray) ToStatefulSetTypeArrayOutputWithContext(ctx context.Context) StatefulSetTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetTypeArrayOutput)
}

// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
//  - Network: A single stable DNS and hostname.
//  - Storage: As many VolumeClaims as requested.
//    The StatefulSet guarantees that a given network identity will always map to the same storage identity.
//
// This resource waits until its status is ready before registering success
// for create/update, and populating output properties from the current state of the resource.
// The following conditions are used to determine whether the resource creation has
// succeeded or failed:
//
// 1. The value of 'spec.replicas' matches '.status.replicas', '.status.currentReplicas',
//    and '.status.readyReplicas'.
// 2. The value of '.status.updateRevision' matches '.status.currentRevision'.
//
// If the StatefulSet has not reached a Ready state after 10 minutes, it will
// time out and mark the resource update as Failed. You can override the default timeout value
// by setting the 'customTimeouts' option on the resource.
type StatefulSetTypeOutput struct{ *pulumi.OutputState }

func (StatefulSetTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetType)(nil)).Elem()
}

func (o StatefulSetTypeOutput) ToStatefulSetTypeOutput() StatefulSetTypeOutput {
	return o
}

func (o StatefulSetTypeOutput) ToStatefulSetTypeOutputWithContext(ctx context.Context) StatefulSetTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o StatefulSetTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o StatefulSetTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o StatefulSetTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v StatefulSetType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Spec defines the desired identities of pods in this set.
func (o StatefulSetTypeOutput) Spec() StatefulSetSpecPtrOutput {
	return o.ApplyT(func(v StatefulSetType) *StatefulSetSpec { return v.Spec }).(StatefulSetSpecPtrOutput)
}

// Status is the current status of Pods in this StatefulSet. This data may be out of date by some window of time.
func (o StatefulSetTypeOutput) Status() StatefulSetStatusPtrOutput {
	return o.ApplyT(func(v StatefulSetType) *StatefulSetStatus { return v.Status }).(StatefulSetStatusPtrOutput)
}

type StatefulSetTypeArrayOutput struct{ *pulumi.OutputState }

func (StatefulSetTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StatefulSetType)(nil)).Elem()
}

func (o StatefulSetTypeArrayOutput) ToStatefulSetTypeArrayOutput() StatefulSetTypeArrayOutput {
	return o
}

func (o StatefulSetTypeArrayOutput) ToStatefulSetTypeArrayOutputWithContext(ctx context.Context) StatefulSetTypeArrayOutput {
	return o
}

func (o StatefulSetTypeArrayOutput) Index(i pulumi.IntInput) StatefulSetTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StatefulSetType {
		return vs[0].([]StatefulSetType)[vs[1].(int)]
	}).(StatefulSetTypeOutput)
}

// StatefulSetCondition describes the state of a statefulset at a certain point.
type StatefulSetCondition struct {
	// Last time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// A human readable message indicating details about the transition.
	Message *string `pulumi:"message"`
	// The reason for the condition's last transition.
	Reason *string `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// Type of statefulset condition.
	Type string `pulumi:"type"`
}

// StatefulSetConditionInput is an input type that accepts StatefulSetConditionArgs and StatefulSetConditionOutput values.
// You can construct a concrete instance of `StatefulSetConditionInput` via:
//
//          StatefulSetConditionArgs{...}
type StatefulSetConditionInput interface {
	pulumi.Input

	ToStatefulSetConditionOutput() StatefulSetConditionOutput
	ToStatefulSetConditionOutputWithContext(context.Context) StatefulSetConditionOutput
}

// StatefulSetCondition describes the state of a statefulset at a certain point.
type StatefulSetConditionArgs struct {
	// Last time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// A human readable message indicating details about the transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// The reason for the condition's last transition.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// Type of statefulset condition.
	Type pulumi.StringInput `pulumi:"type"`
}

func (StatefulSetConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetCondition)(nil)).Elem()
}

func (i StatefulSetConditionArgs) ToStatefulSetConditionOutput() StatefulSetConditionOutput {
	return i.ToStatefulSetConditionOutputWithContext(context.Background())
}

func (i StatefulSetConditionArgs) ToStatefulSetConditionOutputWithContext(ctx context.Context) StatefulSetConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetConditionOutput)
}

// StatefulSetConditionArrayInput is an input type that accepts StatefulSetConditionArray and StatefulSetConditionArrayOutput values.
// You can construct a concrete instance of `StatefulSetConditionArrayInput` via:
//
//          StatefulSetConditionArray{ StatefulSetConditionArgs{...} }
type StatefulSetConditionArrayInput interface {
	pulumi.Input

	ToStatefulSetConditionArrayOutput() StatefulSetConditionArrayOutput
	ToStatefulSetConditionArrayOutputWithContext(context.Context) StatefulSetConditionArrayOutput
}

type StatefulSetConditionArray []StatefulSetConditionInput

func (StatefulSetConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StatefulSetCondition)(nil)).Elem()
}

func (i StatefulSetConditionArray) ToStatefulSetConditionArrayOutput() StatefulSetConditionArrayOutput {
	return i.ToStatefulSetConditionArrayOutputWithContext(context.Background())
}

func (i StatefulSetConditionArray) ToStatefulSetConditionArrayOutputWithContext(ctx context.Context) StatefulSetConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetConditionArrayOutput)
}

// StatefulSetCondition describes the state of a statefulset at a certain point.
type StatefulSetConditionOutput struct{ *pulumi.OutputState }

func (StatefulSetConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetCondition)(nil)).Elem()
}

func (o StatefulSetConditionOutput) ToStatefulSetConditionOutput() StatefulSetConditionOutput {
	return o
}

func (o StatefulSetConditionOutput) ToStatefulSetConditionOutputWithContext(ctx context.Context) StatefulSetConditionOutput {
	return o
}

// Last time the condition transitioned from one status to another.
func (o StatefulSetConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// A human readable message indicating details about the transition.
func (o StatefulSetConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// The reason for the condition's last transition.
func (o StatefulSetConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Status of the condition, one of True, False, Unknown.
func (o StatefulSetConditionOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulSetCondition) string { return v.Status }).(pulumi.StringOutput)
}

// Type of statefulset condition.
func (o StatefulSetConditionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulSetCondition) string { return v.Type }).(pulumi.StringOutput)
}

type StatefulSetConditionArrayOutput struct{ *pulumi.OutputState }

func (StatefulSetConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StatefulSetCondition)(nil)).Elem()
}

func (o StatefulSetConditionArrayOutput) ToStatefulSetConditionArrayOutput() StatefulSetConditionArrayOutput {
	return o
}

func (o StatefulSetConditionArrayOutput) ToStatefulSetConditionArrayOutputWithContext(ctx context.Context) StatefulSetConditionArrayOutput {
	return o
}

func (o StatefulSetConditionArrayOutput) Index(i pulumi.IntInput) StatefulSetConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StatefulSetCondition {
		return vs[0].([]StatefulSetCondition)[vs[1].(int)]
	}).(StatefulSetConditionOutput)
}

// StatefulSetList is a collection of StatefulSets.
type StatefulSetListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Items is the list of stateful sets.
	Items []StatefulSetType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// StatefulSetPersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates.
type StatefulSetPersistentVolumeClaimRetentionPolicy struct {
	// WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.
	WhenDeleted *string `pulumi:"whenDeleted"`
	// WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.
	WhenScaled *string `pulumi:"whenScaled"`
}

// StatefulSetPersistentVolumeClaimRetentionPolicyInput is an input type that accepts StatefulSetPersistentVolumeClaimRetentionPolicyArgs and StatefulSetPersistentVolumeClaimRetentionPolicyOutput values.
// You can construct a concrete instance of `StatefulSetPersistentVolumeClaimRetentionPolicyInput` via:
//
//          StatefulSetPersistentVolumeClaimRetentionPolicyArgs{...}
type StatefulSetPersistentVolumeClaimRetentionPolicyInput interface {
	pulumi.Input

	ToStatefulSetPersistentVolumeClaimRetentionPolicyOutput() StatefulSetPersistentVolumeClaimRetentionPolicyOutput
	ToStatefulSetPersistentVolumeClaimRetentionPolicyOutputWithContext(context.Context) StatefulSetPersistentVolumeClaimRetentionPolicyOutput
}

// StatefulSetPersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates.
type StatefulSetPersistentVolumeClaimRetentionPolicyArgs struct {
	// WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.
	WhenDeleted pulumi.StringPtrInput `pulumi:"whenDeleted"`
	// WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.
	WhenScaled pulumi.StringPtrInput `pulumi:"whenScaled"`
}

func (StatefulSetPersistentVolumeClaimRetentionPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetPersistentVolumeClaimRetentionPolicy)(nil)).Elem()
}

func (i StatefulSetPersistentVolumeClaimRetentionPolicyArgs) ToStatefulSetPersistentVolumeClaimRetentionPolicyOutput() StatefulSetPersistentVolumeClaimRetentionPolicyOutput {
	return i.ToStatefulSetPersistentVolumeClaimRetentionPolicyOutputWithContext(context.Background())
}

func (i StatefulSetPersistentVolumeClaimRetentionPolicyArgs) ToStatefulSetPersistentVolumeClaimRetentionPolicyOutputWithContext(ctx context.Context) StatefulSetPersistentVolumeClaimRetentionPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetPersistentVolumeClaimRetentionPolicyOutput)
}

func (i StatefulSetPersistentVolumeClaimRetentionPolicyArgs) ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput() StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return i.ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutputWithContext(context.Background())
}

func (i StatefulSetPersistentVolumeClaimRetentionPolicyArgs) ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutputWithContext(ctx context.Context) StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetPersistentVolumeClaimRetentionPolicyOutput).ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutputWithContext(ctx)
}

// StatefulSetPersistentVolumeClaimRetentionPolicyPtrInput is an input type that accepts StatefulSetPersistentVolumeClaimRetentionPolicyArgs, StatefulSetPersistentVolumeClaimRetentionPolicyPtr and StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput values.
// You can construct a concrete instance of `StatefulSetPersistentVolumeClaimRetentionPolicyPtrInput` via:
//
//          StatefulSetPersistentVolumeClaimRetentionPolicyArgs{...}
//
//  or:
//
//          nil
type StatefulSetPersistentVolumeClaimRetentionPolicyPtrInput interface {
	pulumi.Input

	ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput() StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput
	ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutputWithContext(context.Context) StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput
}

type statefulSetPersistentVolumeClaimRetentionPolicyPtrType StatefulSetPersistentVolumeClaimRetentionPolicyArgs

func StatefulSetPersistentVolumeClaimRetentionPolicyPtr(v *StatefulSetPersistentVolumeClaimRetentionPolicyArgs) StatefulSetPersistentVolumeClaimRetentionPolicyPtrInput {
	return (*statefulSetPersistentVolumeClaimRetentionPolicyPtrType)(v)
}

func (*statefulSetPersistentVolumeClaimRetentionPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulSetPersistentVolumeClaimRetentionPolicy)(nil)).Elem()
}

func (i *statefulSetPersistentVolumeClaimRetentionPolicyPtrType) ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput() StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return i.ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutputWithContext(context.Background())
}

func (i *statefulSetPersistentVolumeClaimRetentionPolicyPtrType) ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutputWithContext(ctx context.Context) StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput)
}

// StatefulSetPersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates.
type StatefulSetPersistentVolumeClaimRetentionPolicyOutput struct{ *pulumi.OutputState }

func (StatefulSetPersistentVolumeClaimRetentionPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetPersistentVolumeClaimRetentionPolicy)(nil)).Elem()
}

func (o StatefulSetPersistentVolumeClaimRetentionPolicyOutput) ToStatefulSetPersistentVolumeClaimRetentionPolicyOutput() StatefulSetPersistentVolumeClaimRetentionPolicyOutput {
	return o
}

func (o StatefulSetPersistentVolumeClaimRetentionPolicyOutput) ToStatefulSetPersistentVolumeClaimRetentionPolicyOutputWithContext(ctx context.Context) StatefulSetPersistentVolumeClaimRetentionPolicyOutput {
	return o
}

func (o StatefulSetPersistentVolumeClaimRetentionPolicyOutput) ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput() StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return o.ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutputWithContext(context.Background())
}

func (o StatefulSetPersistentVolumeClaimRetentionPolicyOutput) ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutputWithContext(ctx context.Context) StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StatefulSetPersistentVolumeClaimRetentionPolicy) *StatefulSetPersistentVolumeClaimRetentionPolicy {
		return &v
	}).(StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput)
}

// WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.
func (o StatefulSetPersistentVolumeClaimRetentionPolicyOutput) WhenDeleted() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetPersistentVolumeClaimRetentionPolicy) *string { return v.WhenDeleted }).(pulumi.StringPtrOutput)
}

// WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.
func (o StatefulSetPersistentVolumeClaimRetentionPolicyOutput) WhenScaled() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetPersistentVolumeClaimRetentionPolicy) *string { return v.WhenScaled }).(pulumi.StringPtrOutput)
}

type StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput struct{ *pulumi.OutputState }

func (StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulSetPersistentVolumeClaimRetentionPolicy)(nil)).Elem()
}

func (o StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput) ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput() StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return o
}

func (o StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput) ToStatefulSetPersistentVolumeClaimRetentionPolicyPtrOutputWithContext(ctx context.Context) StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return o
}

func (o StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput) Elem() StatefulSetPersistentVolumeClaimRetentionPolicyOutput {
	return o.ApplyT(func(v *StatefulSetPersistentVolumeClaimRetentionPolicy) StatefulSetPersistentVolumeClaimRetentionPolicy {
		if v != nil {
			return *v
		}
		var ret StatefulSetPersistentVolumeClaimRetentionPolicy
		return ret
	}).(StatefulSetPersistentVolumeClaimRetentionPolicyOutput)
}

// WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.
func (o StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput) WhenDeleted() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulSetPersistentVolumeClaimRetentionPolicy) *string {
		if v == nil {
			return nil
		}
		return v.WhenDeleted
	}).(pulumi.StringPtrOutput)
}

// WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.
func (o StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput) WhenScaled() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulSetPersistentVolumeClaimRetentionPolicy) *string {
		if v == nil {
			return nil
		}
		return v.WhenScaled
	}).(pulumi.StringPtrOutput)
}

// A StatefulSetSpec is the specification of a StatefulSet.
type StatefulSetSpec struct {
	// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
	MinReadySeconds *int `pulumi:"minReadySeconds"`
	// persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent volume claims created from volumeClaimTemplates. By default, all persistent volume claims are created as needed and retained until manually deleted. This policy allows the lifecycle to be altered, for example by deleting persistent volume claims when their stateful set is deleted, or when their pod is scaled down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.  +optional
	PersistentVolumeClaimRetentionPolicy *StatefulSetPersistentVolumeClaimRetentionPolicy `pulumi:"persistentVolumeClaimRetentionPolicy"`
	// podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.
	//
	// Possible enum values:
	//  - `"OrderedReady"` will create pods in strictly increasing order on scale up and strictly decreasing order on scale down, progressing only when the previous pod is ready or terminated. At most one pod will be changed at any time.
	//  - `"Parallel"` will create and delete pods as soon as the stateful set replica count is changed, and will not wait for pods to be ready or complete termination.
	PodManagementPolicy *string `pulumi:"podManagementPolicy"`
	// replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.
	Replicas *int `pulumi:"replicas"`
	// revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
	Selector metav1.LabelSelector `pulumi:"selector"`
	// serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is managed by the StatefulSet controller.
	ServiceName string `pulumi:"serviceName"`
	// template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.
	Template corev1.PodTemplateSpec `pulumi:"template"`
	// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.
	UpdateStrategy *StatefulSetUpdateStrategy `pulumi:"updateStrategy"`
	// volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.
	VolumeClaimTemplates []corev1.PersistentVolumeClaimType `pulumi:"volumeClaimTemplates"`
}

// StatefulSetSpecInput is an input type that accepts StatefulSetSpecArgs and StatefulSetSpecOutput values.
// You can construct a concrete instance of `StatefulSetSpecInput` via:
//
//          StatefulSetSpecArgs{...}
type StatefulSetSpecInput interface {
	pulumi.Input

	ToStatefulSetSpecOutput() StatefulSetSpecOutput
	ToStatefulSetSpecOutputWithContext(context.Context) StatefulSetSpecOutput
}

// A StatefulSetSpec is the specification of a StatefulSet.
type StatefulSetSpecArgs struct {
	// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
	MinReadySeconds pulumi.IntPtrInput `pulumi:"minReadySeconds"`
	// persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent volume claims created from volumeClaimTemplates. By default, all persistent volume claims are created as needed and retained until manually deleted. This policy allows the lifecycle to be altered, for example by deleting persistent volume claims when their stateful set is deleted, or when their pod is scaled down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.  +optional
	PersistentVolumeClaimRetentionPolicy StatefulSetPersistentVolumeClaimRetentionPolicyPtrInput `pulumi:"persistentVolumeClaimRetentionPolicy"`
	// podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.
	//
	// Possible enum values:
	//  - `"OrderedReady"` will create pods in strictly increasing order on scale up and strictly decreasing order on scale down, progressing only when the previous pod is ready or terminated. At most one pod will be changed at any time.
	//  - `"Parallel"` will create and delete pods as soon as the stateful set replica count is changed, and will not wait for pods to be ready or complete termination.
	PodManagementPolicy pulumi.StringPtrInput `pulumi:"podManagementPolicy"`
	// replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.
	Replicas pulumi.IntPtrInput `pulumi:"replicas"`
	// revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.
	RevisionHistoryLimit pulumi.IntPtrInput `pulumi:"revisionHistoryLimit"`
	// selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
	Selector metav1.LabelSelectorInput `pulumi:"selector"`
	// serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is managed by the StatefulSet controller.
	ServiceName pulumi.StringInput `pulumi:"serviceName"`
	// template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.
	Template corev1.PodTemplateSpecInput `pulumi:"template"`
	// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.
	UpdateStrategy StatefulSetUpdateStrategyPtrInput `pulumi:"updateStrategy"`
	// volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.
	VolumeClaimTemplates corev1.PersistentVolumeClaimTypeArrayInput `pulumi:"volumeClaimTemplates"`
}

func (StatefulSetSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetSpec)(nil)).Elem()
}

func (i StatefulSetSpecArgs) ToStatefulSetSpecOutput() StatefulSetSpecOutput {
	return i.ToStatefulSetSpecOutputWithContext(context.Background())
}

func (i StatefulSetSpecArgs) ToStatefulSetSpecOutputWithContext(ctx context.Context) StatefulSetSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetSpecOutput)
}

func (i StatefulSetSpecArgs) ToStatefulSetSpecPtrOutput() StatefulSetSpecPtrOutput {
	return i.ToStatefulSetSpecPtrOutputWithContext(context.Background())
}

func (i StatefulSetSpecArgs) ToStatefulSetSpecPtrOutputWithContext(ctx context.Context) StatefulSetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetSpecOutput).ToStatefulSetSpecPtrOutputWithContext(ctx)
}

// StatefulSetSpecPtrInput is an input type that accepts StatefulSetSpecArgs, StatefulSetSpecPtr and StatefulSetSpecPtrOutput values.
// You can construct a concrete instance of `StatefulSetSpecPtrInput` via:
//
//          StatefulSetSpecArgs{...}
//
//  or:
//
//          nil
type StatefulSetSpecPtrInput interface {
	pulumi.Input

	ToStatefulSetSpecPtrOutput() StatefulSetSpecPtrOutput
	ToStatefulSetSpecPtrOutputWithContext(context.Context) StatefulSetSpecPtrOutput
}

type statefulSetSpecPtrType StatefulSetSpecArgs

func StatefulSetSpecPtr(v *StatefulSetSpecArgs) StatefulSetSpecPtrInput {
	return (*statefulSetSpecPtrType)(v)
}

func (*statefulSetSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulSetSpec)(nil)).Elem()
}

func (i *statefulSetSpecPtrType) ToStatefulSetSpecPtrOutput() StatefulSetSpecPtrOutput {
	return i.ToStatefulSetSpecPtrOutputWithContext(context.Background())
}

func (i *statefulSetSpecPtrType) ToStatefulSetSpecPtrOutputWithContext(ctx context.Context) StatefulSetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetSpecPtrOutput)
}

// A StatefulSetSpec is the specification of a StatefulSet.
type StatefulSetSpecOutput struct{ *pulumi.OutputState }

func (StatefulSetSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetSpec)(nil)).Elem()
}

func (o StatefulSetSpecOutput) ToStatefulSetSpecOutput() StatefulSetSpecOutput {
	return o
}

func (o StatefulSetSpecOutput) ToStatefulSetSpecOutputWithContext(ctx context.Context) StatefulSetSpecOutput {
	return o
}

func (o StatefulSetSpecOutput) ToStatefulSetSpecPtrOutput() StatefulSetSpecPtrOutput {
	return o.ToStatefulSetSpecPtrOutputWithContext(context.Background())
}

func (o StatefulSetSpecOutput) ToStatefulSetSpecPtrOutputWithContext(ctx context.Context) StatefulSetSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StatefulSetSpec) *StatefulSetSpec {
		return &v
	}).(StatefulSetSpecPtrOutput)
}

// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
func (o StatefulSetSpecOutput) MinReadySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulSetSpec) *int { return v.MinReadySeconds }).(pulumi.IntPtrOutput)
}

// persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent volume claims created from volumeClaimTemplates. By default, all persistent volume claims are created as needed and retained until manually deleted. This policy allows the lifecycle to be altered, for example by deleting persistent volume claims when their stateful set is deleted, or when their pod is scaled down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.  +optional
func (o StatefulSetSpecOutput) PersistentVolumeClaimRetentionPolicy() StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return o.ApplyT(func(v StatefulSetSpec) *StatefulSetPersistentVolumeClaimRetentionPolicy {
		return v.PersistentVolumeClaimRetentionPolicy
	}).(StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput)
}

// podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.
//
// Possible enum values:
//  - `"OrderedReady"` will create pods in strictly increasing order on scale up and strictly decreasing order on scale down, progressing only when the previous pod is ready or terminated. At most one pod will be changed at any time.
//  - `"Parallel"` will create and delete pods as soon as the stateful set replica count is changed, and will not wait for pods to be ready or complete termination.
func (o StatefulSetSpecOutput) PodManagementPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetSpec) *string { return v.PodManagementPolicy }).(pulumi.StringPtrOutput)
}

// replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.
func (o StatefulSetSpecOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulSetSpec) *int { return v.Replicas }).(pulumi.IntPtrOutput)
}

// revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.
func (o StatefulSetSpecOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulSetSpec) *int { return v.RevisionHistoryLimit }).(pulumi.IntPtrOutput)
}

// selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
func (o StatefulSetSpecOutput) Selector() metav1.LabelSelectorOutput {
	return o.ApplyT(func(v StatefulSetSpec) metav1.LabelSelector { return v.Selector }).(metav1.LabelSelectorOutput)
}

// serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is managed by the StatefulSet controller.
func (o StatefulSetSpecOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulSetSpec) string { return v.ServiceName }).(pulumi.StringOutput)
}

// template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.
func (o StatefulSetSpecOutput) Template() corev1.PodTemplateSpecOutput {
	return o.ApplyT(func(v StatefulSetSpec) corev1.PodTemplateSpec { return v.Template }).(corev1.PodTemplateSpecOutput)
}

// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.
func (o StatefulSetSpecOutput) UpdateStrategy() StatefulSetUpdateStrategyPtrOutput {
	return o.ApplyT(func(v StatefulSetSpec) *StatefulSetUpdateStrategy { return v.UpdateStrategy }).(StatefulSetUpdateStrategyPtrOutput)
}

// volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.
func (o StatefulSetSpecOutput) VolumeClaimTemplates() corev1.PersistentVolumeClaimTypeArrayOutput {
	return o.ApplyT(func(v StatefulSetSpec) []corev1.PersistentVolumeClaimType { return v.VolumeClaimTemplates }).(corev1.PersistentVolumeClaimTypeArrayOutput)
}

type StatefulSetSpecPtrOutput struct{ *pulumi.OutputState }

func (StatefulSetSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulSetSpec)(nil)).Elem()
}

func (o StatefulSetSpecPtrOutput) ToStatefulSetSpecPtrOutput() StatefulSetSpecPtrOutput {
	return o
}

func (o StatefulSetSpecPtrOutput) ToStatefulSetSpecPtrOutputWithContext(ctx context.Context) StatefulSetSpecPtrOutput {
	return o
}

func (o StatefulSetSpecPtrOutput) Elem() StatefulSetSpecOutput {
	return o.ApplyT(func(v *StatefulSetSpec) StatefulSetSpec {
		if v != nil {
			return *v
		}
		var ret StatefulSetSpec
		return ret
	}).(StatefulSetSpecOutput)
}

// Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
func (o StatefulSetSpecPtrOutput) MinReadySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetSpec) *int {
		if v == nil {
			return nil
		}
		return v.MinReadySeconds
	}).(pulumi.IntPtrOutput)
}

// persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent volume claims created from volumeClaimTemplates. By default, all persistent volume claims are created as needed and retained until manually deleted. This policy allows the lifecycle to be altered, for example by deleting persistent volume claims when their stateful set is deleted, or when their pod is scaled down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.  +optional
func (o StatefulSetSpecPtrOutput) PersistentVolumeClaimRetentionPolicy() StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput {
	return o.ApplyT(func(v *StatefulSetSpec) *StatefulSetPersistentVolumeClaimRetentionPolicy {
		if v == nil {
			return nil
		}
		return v.PersistentVolumeClaimRetentionPolicy
	}).(StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput)
}

// podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.
//
// Possible enum values:
//  - `"OrderedReady"` will create pods in strictly increasing order on scale up and strictly decreasing order on scale down, progressing only when the previous pod is ready or terminated. At most one pod will be changed at any time.
//  - `"Parallel"` will create and delete pods as soon as the stateful set replica count is changed, and will not wait for pods to be ready or complete termination.
func (o StatefulSetSpecPtrOutput) PodManagementPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulSetSpec) *string {
		if v == nil {
			return nil
		}
		return v.PodManagementPolicy
	}).(pulumi.StringPtrOutput)
}

// replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.
func (o StatefulSetSpecPtrOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetSpec) *int {
		if v == nil {
			return nil
		}
		return v.Replicas
	}).(pulumi.IntPtrOutput)
}

// revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.
func (o StatefulSetSpecPtrOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetSpec) *int {
		if v == nil {
			return nil
		}
		return v.RevisionHistoryLimit
	}).(pulumi.IntPtrOutput)
}

// selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
func (o StatefulSetSpecPtrOutput) Selector() metav1.LabelSelectorPtrOutput {
	return o.ApplyT(func(v *StatefulSetSpec) *metav1.LabelSelector {
		if v == nil {
			return nil
		}
		return &v.Selector
	}).(metav1.LabelSelectorPtrOutput)
}

// serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is managed by the StatefulSet controller.
func (o StatefulSetSpecPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulSetSpec) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.
func (o StatefulSetSpecPtrOutput) Template() corev1.PodTemplateSpecPtrOutput {
	return o.ApplyT(func(v *StatefulSetSpec) *corev1.PodTemplateSpec {
		if v == nil {
			return nil
		}
		return &v.Template
	}).(corev1.PodTemplateSpecPtrOutput)
}

// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.
func (o StatefulSetSpecPtrOutput) UpdateStrategy() StatefulSetUpdateStrategyPtrOutput {
	return o.ApplyT(func(v *StatefulSetSpec) *StatefulSetUpdateStrategy {
		if v == nil {
			return nil
		}
		return v.UpdateStrategy
	}).(StatefulSetUpdateStrategyPtrOutput)
}

// volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.
func (o StatefulSetSpecPtrOutput) VolumeClaimTemplates() corev1.PersistentVolumeClaimTypeArrayOutput {
	return o.ApplyT(func(v *StatefulSetSpec) []corev1.PersistentVolumeClaimType {
		if v == nil {
			return nil
		}
		return v.VolumeClaimTemplates
	}).(corev1.PersistentVolumeClaimTypeArrayOutput)
}

// StatefulSetStatus represents the current state of a StatefulSet.
type StatefulSetStatus struct {
	// Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset. This is a beta field and enabled/disabled by StatefulSetMinReadySeconds feature gate.
	AvailableReplicas int `pulumi:"availableReplicas"`
	// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
	CollisionCount *int `pulumi:"collisionCount"`
	// Represents the latest available observations of a statefulset's current state.
	Conditions []StatefulSetCondition `pulumi:"conditions"`
	// currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.
	CurrentReplicas *int `pulumi:"currentReplicas"`
	// currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).
	CurrentRevision *string `pulumi:"currentRevision"`
	// observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
	ReadyReplicas *int `pulumi:"readyReplicas"`
	// replicas is the number of Pods created by the StatefulSet controller.
	Replicas int `pulumi:"replicas"`
	// updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)
	UpdateRevision *string `pulumi:"updateRevision"`
	// updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.
	UpdatedReplicas *int `pulumi:"updatedReplicas"`
}

// StatefulSetStatusInput is an input type that accepts StatefulSetStatusArgs and StatefulSetStatusOutput values.
// You can construct a concrete instance of `StatefulSetStatusInput` via:
//
//          StatefulSetStatusArgs{...}
type StatefulSetStatusInput interface {
	pulumi.Input

	ToStatefulSetStatusOutput() StatefulSetStatusOutput
	ToStatefulSetStatusOutputWithContext(context.Context) StatefulSetStatusOutput
}

// StatefulSetStatus represents the current state of a StatefulSet.
type StatefulSetStatusArgs struct {
	// Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset. This is a beta field and enabled/disabled by StatefulSetMinReadySeconds feature gate.
	AvailableReplicas pulumi.IntInput `pulumi:"availableReplicas"`
	// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
	CollisionCount pulumi.IntPtrInput `pulumi:"collisionCount"`
	// Represents the latest available observations of a statefulset's current state.
	Conditions StatefulSetConditionArrayInput `pulumi:"conditions"`
	// currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.
	CurrentReplicas pulumi.IntPtrInput `pulumi:"currentReplicas"`
	// currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).
	CurrentRevision pulumi.StringPtrInput `pulumi:"currentRevision"`
	// observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
	ReadyReplicas pulumi.IntPtrInput `pulumi:"readyReplicas"`
	// replicas is the number of Pods created by the StatefulSet controller.
	Replicas pulumi.IntInput `pulumi:"replicas"`
	// updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)
	UpdateRevision pulumi.StringPtrInput `pulumi:"updateRevision"`
	// updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.
	UpdatedReplicas pulumi.IntPtrInput `pulumi:"updatedReplicas"`
}

func (StatefulSetStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetStatus)(nil)).Elem()
}

func (i StatefulSetStatusArgs) ToStatefulSetStatusOutput() StatefulSetStatusOutput {
	return i.ToStatefulSetStatusOutputWithContext(context.Background())
}

func (i StatefulSetStatusArgs) ToStatefulSetStatusOutputWithContext(ctx context.Context) StatefulSetStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetStatusOutput)
}

func (i StatefulSetStatusArgs) ToStatefulSetStatusPtrOutput() StatefulSetStatusPtrOutput {
	return i.ToStatefulSetStatusPtrOutputWithContext(context.Background())
}

func (i StatefulSetStatusArgs) ToStatefulSetStatusPtrOutputWithContext(ctx context.Context) StatefulSetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetStatusOutput).ToStatefulSetStatusPtrOutputWithContext(ctx)
}

// StatefulSetStatusPtrInput is an input type that accepts StatefulSetStatusArgs, StatefulSetStatusPtr and StatefulSetStatusPtrOutput values.
// You can construct a concrete instance of `StatefulSetStatusPtrInput` via:
//
//          StatefulSetStatusArgs{...}
//
//  or:
//
//          nil
type StatefulSetStatusPtrInput interface {
	pulumi.Input

	ToStatefulSetStatusPtrOutput() StatefulSetStatusPtrOutput
	ToStatefulSetStatusPtrOutputWithContext(context.Context) StatefulSetStatusPtrOutput
}

type statefulSetStatusPtrType StatefulSetStatusArgs

func StatefulSetStatusPtr(v *StatefulSetStatusArgs) StatefulSetStatusPtrInput {
	return (*statefulSetStatusPtrType)(v)
}

func (*statefulSetStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulSetStatus)(nil)).Elem()
}

func (i *statefulSetStatusPtrType) ToStatefulSetStatusPtrOutput() StatefulSetStatusPtrOutput {
	return i.ToStatefulSetStatusPtrOutputWithContext(context.Background())
}

func (i *statefulSetStatusPtrType) ToStatefulSetStatusPtrOutputWithContext(ctx context.Context) StatefulSetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetStatusPtrOutput)
}

// StatefulSetStatus represents the current state of a StatefulSet.
type StatefulSetStatusOutput struct{ *pulumi.OutputState }

func (StatefulSetStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetStatus)(nil)).Elem()
}

func (o StatefulSetStatusOutput) ToStatefulSetStatusOutput() StatefulSetStatusOutput {
	return o
}

func (o StatefulSetStatusOutput) ToStatefulSetStatusOutputWithContext(ctx context.Context) StatefulSetStatusOutput {
	return o
}

func (o StatefulSetStatusOutput) ToStatefulSetStatusPtrOutput() StatefulSetStatusPtrOutput {
	return o.ToStatefulSetStatusPtrOutputWithContext(context.Background())
}

func (o StatefulSetStatusOutput) ToStatefulSetStatusPtrOutputWithContext(ctx context.Context) StatefulSetStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StatefulSetStatus) *StatefulSetStatus {
		return &v
	}).(StatefulSetStatusPtrOutput)
}

// Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset. This is a beta field and enabled/disabled by StatefulSetMinReadySeconds feature gate.
func (o StatefulSetStatusOutput) AvailableReplicas() pulumi.IntOutput {
	return o.ApplyT(func(v StatefulSetStatus) int { return v.AvailableReplicas }).(pulumi.IntOutput)
}

// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
func (o StatefulSetStatusOutput) CollisionCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulSetStatus) *int { return v.CollisionCount }).(pulumi.IntPtrOutput)
}

// Represents the latest available observations of a statefulset's current state.
func (o StatefulSetStatusOutput) Conditions() StatefulSetConditionArrayOutput {
	return o.ApplyT(func(v StatefulSetStatus) []StatefulSetCondition { return v.Conditions }).(StatefulSetConditionArrayOutput)
}

// currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.
func (o StatefulSetStatusOutput) CurrentReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulSetStatus) *int { return v.CurrentReplicas }).(pulumi.IntPtrOutput)
}

// currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).
func (o StatefulSetStatusOutput) CurrentRevision() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetStatus) *string { return v.CurrentRevision }).(pulumi.StringPtrOutput)
}

// observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.
func (o StatefulSetStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulSetStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
func (o StatefulSetStatusOutput) ReadyReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulSetStatus) *int { return v.ReadyReplicas }).(pulumi.IntPtrOutput)
}

// replicas is the number of Pods created by the StatefulSet controller.
func (o StatefulSetStatusOutput) Replicas() pulumi.IntOutput {
	return o.ApplyT(func(v StatefulSetStatus) int { return v.Replicas }).(pulumi.IntOutput)
}

// updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)
func (o StatefulSetStatusOutput) UpdateRevision() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetStatus) *string { return v.UpdateRevision }).(pulumi.StringPtrOutput)
}

// updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.
func (o StatefulSetStatusOutput) UpdatedReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulSetStatus) *int { return v.UpdatedReplicas }).(pulumi.IntPtrOutput)
}

type StatefulSetStatusPtrOutput struct{ *pulumi.OutputState }

func (StatefulSetStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulSetStatus)(nil)).Elem()
}

func (o StatefulSetStatusPtrOutput) ToStatefulSetStatusPtrOutput() StatefulSetStatusPtrOutput {
	return o
}

func (o StatefulSetStatusPtrOutput) ToStatefulSetStatusPtrOutputWithContext(ctx context.Context) StatefulSetStatusPtrOutput {
	return o
}

func (o StatefulSetStatusPtrOutput) Elem() StatefulSetStatusOutput {
	return o.ApplyT(func(v *StatefulSetStatus) StatefulSetStatus {
		if v != nil {
			return *v
		}
		var ret StatefulSetStatus
		return ret
	}).(StatefulSetStatusOutput)
}

// Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset. This is a beta field and enabled/disabled by StatefulSetMinReadySeconds feature gate.
func (o StatefulSetStatusPtrOutput) AvailableReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.AvailableReplicas
	}).(pulumi.IntPtrOutput)
}

// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
func (o StatefulSetStatusPtrOutput) CollisionCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.CollisionCount
	}).(pulumi.IntPtrOutput)
}

// Represents the latest available observations of a statefulset's current state.
func (o StatefulSetStatusPtrOutput) Conditions() StatefulSetConditionArrayOutput {
	return o.ApplyT(func(v *StatefulSetStatus) []StatefulSetCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(StatefulSetConditionArrayOutput)
}

// currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.
func (o StatefulSetStatusPtrOutput) CurrentReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.CurrentReplicas
	}).(pulumi.IntPtrOutput)
}

// currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).
func (o StatefulSetStatusPtrOutput) CurrentRevision() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulSetStatus) *string {
		if v == nil {
			return nil
		}
		return v.CurrentRevision
	}).(pulumi.StringPtrOutput)
}

// observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.
func (o StatefulSetStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
func (o StatefulSetStatusPtrOutput) ReadyReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.ReadyReplicas
	}).(pulumi.IntPtrOutput)
}

// replicas is the number of Pods created by the StatefulSet controller.
func (o StatefulSetStatusPtrOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetStatus) *int {
		if v == nil {
			return nil
		}
		return &v.Replicas
	}).(pulumi.IntPtrOutput)
}

// updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)
func (o StatefulSetStatusPtrOutput) UpdateRevision() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulSetStatus) *string {
		if v == nil {
			return nil
		}
		return v.UpdateRevision
	}).(pulumi.StringPtrOutput)
}

// updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.
func (o StatefulSetStatusPtrOutput) UpdatedReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulSetStatus) *int {
		if v == nil {
			return nil
		}
		return v.UpdatedReplicas
	}).(pulumi.IntPtrOutput)
}

// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
type StatefulSetUpdateStrategy struct {
	// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
	RollingUpdate *RollingUpdateStatefulSetStrategy `pulumi:"rollingUpdate"`
	// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
	//
	// Possible enum values:
	//  - `"OnDelete"` triggers the legacy behavior. Version tracking and ordered rolling restarts are disabled. Pods are recreated from the StatefulSetSpec when they are manually deleted. When a scale operation is performed with this strategy,specification version indicated by the StatefulSet's currentRevision.
	//  - `"RollingUpdate"` indicates that update will be applied to all Pods in the StatefulSet with respect to the StatefulSet ordering constraints. When a scale operation is performed with this strategy, new Pods will be created from the specification version indicated by the StatefulSet's updateRevision.
	Type *string `pulumi:"type"`
}

// StatefulSetUpdateStrategyInput is an input type that accepts StatefulSetUpdateStrategyArgs and StatefulSetUpdateStrategyOutput values.
// You can construct a concrete instance of `StatefulSetUpdateStrategyInput` via:
//
//          StatefulSetUpdateStrategyArgs{...}
type StatefulSetUpdateStrategyInput interface {
	pulumi.Input

	ToStatefulSetUpdateStrategyOutput() StatefulSetUpdateStrategyOutput
	ToStatefulSetUpdateStrategyOutputWithContext(context.Context) StatefulSetUpdateStrategyOutput
}

// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
type StatefulSetUpdateStrategyArgs struct {
	// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
	RollingUpdate RollingUpdateStatefulSetStrategyPtrInput `pulumi:"rollingUpdate"`
	// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
	//
	// Possible enum values:
	//  - `"OnDelete"` triggers the legacy behavior. Version tracking and ordered rolling restarts are disabled. Pods are recreated from the StatefulSetSpec when they are manually deleted. When a scale operation is performed with this strategy,specification version indicated by the StatefulSet's currentRevision.
	//  - `"RollingUpdate"` indicates that update will be applied to all Pods in the StatefulSet with respect to the StatefulSet ordering constraints. When a scale operation is performed with this strategy, new Pods will be created from the specification version indicated by the StatefulSet's updateRevision.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (StatefulSetUpdateStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetUpdateStrategy)(nil)).Elem()
}

func (i StatefulSetUpdateStrategyArgs) ToStatefulSetUpdateStrategyOutput() StatefulSetUpdateStrategyOutput {
	return i.ToStatefulSetUpdateStrategyOutputWithContext(context.Background())
}

func (i StatefulSetUpdateStrategyArgs) ToStatefulSetUpdateStrategyOutputWithContext(ctx context.Context) StatefulSetUpdateStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetUpdateStrategyOutput)
}

func (i StatefulSetUpdateStrategyArgs) ToStatefulSetUpdateStrategyPtrOutput() StatefulSetUpdateStrategyPtrOutput {
	return i.ToStatefulSetUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i StatefulSetUpdateStrategyArgs) ToStatefulSetUpdateStrategyPtrOutputWithContext(ctx context.Context) StatefulSetUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetUpdateStrategyOutput).ToStatefulSetUpdateStrategyPtrOutputWithContext(ctx)
}

// StatefulSetUpdateStrategyPtrInput is an input type that accepts StatefulSetUpdateStrategyArgs, StatefulSetUpdateStrategyPtr and StatefulSetUpdateStrategyPtrOutput values.
// You can construct a concrete instance of `StatefulSetUpdateStrategyPtrInput` via:
//
//          StatefulSetUpdateStrategyArgs{...}
//
//  or:
//
//          nil
type StatefulSetUpdateStrategyPtrInput interface {
	pulumi.Input

	ToStatefulSetUpdateStrategyPtrOutput() StatefulSetUpdateStrategyPtrOutput
	ToStatefulSetUpdateStrategyPtrOutputWithContext(context.Context) StatefulSetUpdateStrategyPtrOutput
}

type statefulSetUpdateStrategyPtrType StatefulSetUpdateStrategyArgs

func StatefulSetUpdateStrategyPtr(v *StatefulSetUpdateStrategyArgs) StatefulSetUpdateStrategyPtrInput {
	return (*statefulSetUpdateStrategyPtrType)(v)
}

func (*statefulSetUpdateStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulSetUpdateStrategy)(nil)).Elem()
}

func (i *statefulSetUpdateStrategyPtrType) ToStatefulSetUpdateStrategyPtrOutput() StatefulSetUpdateStrategyPtrOutput {
	return i.ToStatefulSetUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i *statefulSetUpdateStrategyPtrType) ToStatefulSetUpdateStrategyPtrOutputWithContext(ctx context.Context) StatefulSetUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulSetUpdateStrategyPtrOutput)
}

// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
type StatefulSetUpdateStrategyOutput struct{ *pulumi.OutputState }

func (StatefulSetUpdateStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulSetUpdateStrategy)(nil)).Elem()
}

func (o StatefulSetUpdateStrategyOutput) ToStatefulSetUpdateStrategyOutput() StatefulSetUpdateStrategyOutput {
	return o
}

func (o StatefulSetUpdateStrategyOutput) ToStatefulSetUpdateStrategyOutputWithContext(ctx context.Context) StatefulSetUpdateStrategyOutput {
	return o
}

func (o StatefulSetUpdateStrategyOutput) ToStatefulSetUpdateStrategyPtrOutput() StatefulSetUpdateStrategyPtrOutput {
	return o.ToStatefulSetUpdateStrategyPtrOutputWithContext(context.Background())
}

func (o StatefulSetUpdateStrategyOutput) ToStatefulSetUpdateStrategyPtrOutputWithContext(ctx context.Context) StatefulSetUpdateStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StatefulSetUpdateStrategy) *StatefulSetUpdateStrategy {
		return &v
	}).(StatefulSetUpdateStrategyPtrOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
func (o StatefulSetUpdateStrategyOutput) RollingUpdate() RollingUpdateStatefulSetStrategyPtrOutput {
	return o.ApplyT(func(v StatefulSetUpdateStrategy) *RollingUpdateStatefulSetStrategy { return v.RollingUpdate }).(RollingUpdateStatefulSetStrategyPtrOutput)
}

// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
//
// Possible enum values:
//  - `"OnDelete"` triggers the legacy behavior. Version tracking and ordered rolling restarts are disabled. Pods are recreated from the StatefulSetSpec when they are manually deleted. When a scale operation is performed with this strategy,specification version indicated by the StatefulSet's currentRevision.
//  - `"RollingUpdate"` indicates that update will be applied to all Pods in the StatefulSet with respect to the StatefulSet ordering constraints. When a scale operation is performed with this strategy, new Pods will be created from the specification version indicated by the StatefulSet's updateRevision.
func (o StatefulSetUpdateStrategyOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulSetUpdateStrategy) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type StatefulSetUpdateStrategyPtrOutput struct{ *pulumi.OutputState }

func (StatefulSetUpdateStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulSetUpdateStrategy)(nil)).Elem()
}

func (o StatefulSetUpdateStrategyPtrOutput) ToStatefulSetUpdateStrategyPtrOutput() StatefulSetUpdateStrategyPtrOutput {
	return o
}

func (o StatefulSetUpdateStrategyPtrOutput) ToStatefulSetUpdateStrategyPtrOutputWithContext(ctx context.Context) StatefulSetUpdateStrategyPtrOutput {
	return o
}

func (o StatefulSetUpdateStrategyPtrOutput) Elem() StatefulSetUpdateStrategyOutput {
	return o.ApplyT(func(v *StatefulSetUpdateStrategy) StatefulSetUpdateStrategy {
		if v != nil {
			return *v
		}
		var ret StatefulSetUpdateStrategy
		return ret
	}).(StatefulSetUpdateStrategyOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
func (o StatefulSetUpdateStrategyPtrOutput) RollingUpdate() RollingUpdateStatefulSetStrategyPtrOutput {
	return o.ApplyT(func(v *StatefulSetUpdateStrategy) *RollingUpdateStatefulSetStrategy {
		if v == nil {
			return nil
		}
		return v.RollingUpdate
	}).(RollingUpdateStatefulSetStrategyPtrOutput)
}

// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
//
// Possible enum values:
//  - `"OnDelete"` triggers the legacy behavior. Version tracking and ordered rolling restarts are disabled. Pods are recreated from the StatefulSetSpec when they are manually deleted. When a scale operation is performed with this strategy,specification version indicated by the StatefulSet's currentRevision.
//  - `"RollingUpdate"` indicates that update will be applied to all Pods in the StatefulSet with respect to the StatefulSet ordering constraints. When a scale operation is performed with this strategy, new Pods will be created from the specification version indicated by the StatefulSet's updateRevision.
func (o StatefulSetUpdateStrategyPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulSetUpdateStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ControllerRevisionTypeInput)(nil)).Elem(), ControllerRevisionTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ControllerRevisionTypeArrayInput)(nil)).Elem(), ControllerRevisionTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetTypeInput)(nil)).Elem(), DaemonSetTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetTypeArrayInput)(nil)).Elem(), DaemonSetTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetConditionInput)(nil)).Elem(), DaemonSetConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetConditionArrayInput)(nil)).Elem(), DaemonSetConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetSpecInput)(nil)).Elem(), DaemonSetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetSpecPtrInput)(nil)).Elem(), DaemonSetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetStatusInput)(nil)).Elem(), DaemonSetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetStatusPtrInput)(nil)).Elem(), DaemonSetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetUpdateStrategyInput)(nil)).Elem(), DaemonSetUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DaemonSetUpdateStrategyPtrInput)(nil)).Elem(), DaemonSetUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentTypeInput)(nil)).Elem(), DeploymentTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentTypeArrayInput)(nil)).Elem(), DeploymentTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentConditionInput)(nil)).Elem(), DeploymentConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentConditionArrayInput)(nil)).Elem(), DeploymentConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentSpecInput)(nil)).Elem(), DeploymentSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentSpecPtrInput)(nil)).Elem(), DeploymentSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentStatusInput)(nil)).Elem(), DeploymentStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentStatusPtrInput)(nil)).Elem(), DeploymentStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentStrategyInput)(nil)).Elem(), DeploymentStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeploymentStrategyPtrInput)(nil)).Elem(), DeploymentStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaSetTypeInput)(nil)).Elem(), ReplicaSetTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaSetTypeArrayInput)(nil)).Elem(), ReplicaSetTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaSetConditionInput)(nil)).Elem(), ReplicaSetConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaSetConditionArrayInput)(nil)).Elem(), ReplicaSetConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaSetSpecInput)(nil)).Elem(), ReplicaSetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaSetSpecPtrInput)(nil)).Elem(), ReplicaSetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaSetStatusInput)(nil)).Elem(), ReplicaSetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicaSetStatusPtrInput)(nil)).Elem(), ReplicaSetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RollingUpdateDaemonSetInput)(nil)).Elem(), RollingUpdateDaemonSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RollingUpdateDaemonSetPtrInput)(nil)).Elem(), RollingUpdateDaemonSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RollingUpdateDeploymentInput)(nil)).Elem(), RollingUpdateDeploymentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RollingUpdateDeploymentPtrInput)(nil)).Elem(), RollingUpdateDeploymentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RollingUpdateStatefulSetStrategyInput)(nil)).Elem(), RollingUpdateStatefulSetStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RollingUpdateStatefulSetStrategyPtrInput)(nil)).Elem(), RollingUpdateStatefulSetStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetTypeInput)(nil)).Elem(), StatefulSetTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetTypeArrayInput)(nil)).Elem(), StatefulSetTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetConditionInput)(nil)).Elem(), StatefulSetConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetConditionArrayInput)(nil)).Elem(), StatefulSetConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetPersistentVolumeClaimRetentionPolicyInput)(nil)).Elem(), StatefulSetPersistentVolumeClaimRetentionPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetPersistentVolumeClaimRetentionPolicyPtrInput)(nil)).Elem(), StatefulSetPersistentVolumeClaimRetentionPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetSpecInput)(nil)).Elem(), StatefulSetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetSpecPtrInput)(nil)).Elem(), StatefulSetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetStatusInput)(nil)).Elem(), StatefulSetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetStatusPtrInput)(nil)).Elem(), StatefulSetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetUpdateStrategyInput)(nil)).Elem(), StatefulSetUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatefulSetUpdateStrategyPtrInput)(nil)).Elem(), StatefulSetUpdateStrategyArgs{})
	pulumi.RegisterOutputType(ControllerRevisionTypeOutput{})
	pulumi.RegisterOutputType(ControllerRevisionTypeArrayOutput{})
	pulumi.RegisterOutputType(DaemonSetTypeOutput{})
	pulumi.RegisterOutputType(DaemonSetTypeArrayOutput{})
	pulumi.RegisterOutputType(DaemonSetConditionOutput{})
	pulumi.RegisterOutputType(DaemonSetConditionArrayOutput{})
	pulumi.RegisterOutputType(DaemonSetSpecOutput{})
	pulumi.RegisterOutputType(DaemonSetSpecPtrOutput{})
	pulumi.RegisterOutputType(DaemonSetStatusOutput{})
	pulumi.RegisterOutputType(DaemonSetStatusPtrOutput{})
	pulumi.RegisterOutputType(DaemonSetUpdateStrategyOutput{})
	pulumi.RegisterOutputType(DaemonSetUpdateStrategyPtrOutput{})
	pulumi.RegisterOutputType(DeploymentTypeOutput{})
	pulumi.RegisterOutputType(DeploymentTypeArrayOutput{})
	pulumi.RegisterOutputType(DeploymentConditionOutput{})
	pulumi.RegisterOutputType(DeploymentConditionArrayOutput{})
	pulumi.RegisterOutputType(DeploymentSpecOutput{})
	pulumi.RegisterOutputType(DeploymentSpecPtrOutput{})
	pulumi.RegisterOutputType(DeploymentStatusOutput{})
	pulumi.RegisterOutputType(DeploymentStatusPtrOutput{})
	pulumi.RegisterOutputType(DeploymentStrategyOutput{})
	pulumi.RegisterOutputType(DeploymentStrategyPtrOutput{})
	pulumi.RegisterOutputType(ReplicaSetTypeOutput{})
	pulumi.RegisterOutputType(ReplicaSetTypeArrayOutput{})
	pulumi.RegisterOutputType(ReplicaSetConditionOutput{})
	pulumi.RegisterOutputType(ReplicaSetConditionArrayOutput{})
	pulumi.RegisterOutputType(ReplicaSetSpecOutput{})
	pulumi.RegisterOutputType(ReplicaSetSpecPtrOutput{})
	pulumi.RegisterOutputType(ReplicaSetStatusOutput{})
	pulumi.RegisterOutputType(ReplicaSetStatusPtrOutput{})
	pulumi.RegisterOutputType(RollingUpdateDaemonSetOutput{})
	pulumi.RegisterOutputType(RollingUpdateDaemonSetPtrOutput{})
	pulumi.RegisterOutputType(RollingUpdateDeploymentOutput{})
	pulumi.RegisterOutputType(RollingUpdateDeploymentPtrOutput{})
	pulumi.RegisterOutputType(RollingUpdateStatefulSetStrategyOutput{})
	pulumi.RegisterOutputType(RollingUpdateStatefulSetStrategyPtrOutput{})
	pulumi.RegisterOutputType(StatefulSetTypeOutput{})
	pulumi.RegisterOutputType(StatefulSetTypeArrayOutput{})
	pulumi.RegisterOutputType(StatefulSetConditionOutput{})
	pulumi.RegisterOutputType(StatefulSetConditionArrayOutput{})
	pulumi.RegisterOutputType(StatefulSetPersistentVolumeClaimRetentionPolicyOutput{})
	pulumi.RegisterOutputType(StatefulSetPersistentVolumeClaimRetentionPolicyPtrOutput{})
	pulumi.RegisterOutputType(StatefulSetSpecOutput{})
	pulumi.RegisterOutputType(StatefulSetSpecPtrOutput{})
	pulumi.RegisterOutputType(StatefulSetStatusOutput{})
	pulumi.RegisterOutputType(StatefulSetStatusPtrOutput{})
	pulumi.RegisterOutputType(StatefulSetUpdateStrategyOutput{})
	pulumi.RegisterOutputType(StatefulSetUpdateStrategyPtrOutput{})
}
