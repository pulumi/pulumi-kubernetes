// Code generated by pulumigen DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta2

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// ExemptPriorityLevelConfiguration describes the configurable aspects of the handling of exempt requests. In the mandatory exempt configuration object the values in the fields here can be modified by authorized users, unlike the rest of the `spec`.
type ExemptPriorityLevelConfiguration struct {
	// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
	//
	// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
	LendablePercent *int `pulumi:"lendablePercent"`
	// `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
	//
	// NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
	//
	// Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
	NominalConcurrencyShares *int `pulumi:"nominalConcurrencyShares"`
}

// ExemptPriorityLevelConfigurationInput is an input type that accepts ExemptPriorityLevelConfigurationArgs and ExemptPriorityLevelConfigurationOutput values.
// You can construct a concrete instance of `ExemptPriorityLevelConfigurationInput` via:
//
//	ExemptPriorityLevelConfigurationArgs{...}
type ExemptPriorityLevelConfigurationInput interface {
	pulumi.Input

	ToExemptPriorityLevelConfigurationOutput() ExemptPriorityLevelConfigurationOutput
	ToExemptPriorityLevelConfigurationOutputWithContext(context.Context) ExemptPriorityLevelConfigurationOutput
}

// ExemptPriorityLevelConfiguration describes the configurable aspects of the handling of exempt requests. In the mandatory exempt configuration object the values in the fields here can be modified by authorized users, unlike the rest of the `spec`.
type ExemptPriorityLevelConfigurationArgs struct {
	// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
	//
	// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
	LendablePercent pulumi.IntPtrInput `pulumi:"lendablePercent"`
	// `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
	//
	// NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
	//
	// Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
	NominalConcurrencyShares pulumi.IntPtrInput `pulumi:"nominalConcurrencyShares"`
}

func (ExemptPriorityLevelConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExemptPriorityLevelConfiguration)(nil)).Elem()
}

func (i ExemptPriorityLevelConfigurationArgs) ToExemptPriorityLevelConfigurationOutput() ExemptPriorityLevelConfigurationOutput {
	return i.ToExemptPriorityLevelConfigurationOutputWithContext(context.Background())
}

func (i ExemptPriorityLevelConfigurationArgs) ToExemptPriorityLevelConfigurationOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemptPriorityLevelConfigurationOutput)
}

func (i ExemptPriorityLevelConfigurationArgs) ToExemptPriorityLevelConfigurationPtrOutput() ExemptPriorityLevelConfigurationPtrOutput {
	return i.ToExemptPriorityLevelConfigurationPtrOutputWithContext(context.Background())
}

func (i ExemptPriorityLevelConfigurationArgs) ToExemptPriorityLevelConfigurationPtrOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemptPriorityLevelConfigurationOutput).ToExemptPriorityLevelConfigurationPtrOutputWithContext(ctx)
}

// ExemptPriorityLevelConfigurationPtrInput is an input type that accepts ExemptPriorityLevelConfigurationArgs, ExemptPriorityLevelConfigurationPtr and ExemptPriorityLevelConfigurationPtrOutput values.
// You can construct a concrete instance of `ExemptPriorityLevelConfigurationPtrInput` via:
//
//	        ExemptPriorityLevelConfigurationArgs{...}
//
//	or:
//
//	        nil
type ExemptPriorityLevelConfigurationPtrInput interface {
	pulumi.Input

	ToExemptPriorityLevelConfigurationPtrOutput() ExemptPriorityLevelConfigurationPtrOutput
	ToExemptPriorityLevelConfigurationPtrOutputWithContext(context.Context) ExemptPriorityLevelConfigurationPtrOutput
}

type exemptPriorityLevelConfigurationPtrType ExemptPriorityLevelConfigurationArgs

func ExemptPriorityLevelConfigurationPtr(v *ExemptPriorityLevelConfigurationArgs) ExemptPriorityLevelConfigurationPtrInput {
	return (*exemptPriorityLevelConfigurationPtrType)(v)
}

func (*exemptPriorityLevelConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ExemptPriorityLevelConfiguration)(nil)).Elem()
}

func (i *exemptPriorityLevelConfigurationPtrType) ToExemptPriorityLevelConfigurationPtrOutput() ExemptPriorityLevelConfigurationPtrOutput {
	return i.ToExemptPriorityLevelConfigurationPtrOutputWithContext(context.Background())
}

func (i *exemptPriorityLevelConfigurationPtrType) ToExemptPriorityLevelConfigurationPtrOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemptPriorityLevelConfigurationPtrOutput)
}

// ExemptPriorityLevelConfiguration describes the configurable aspects of the handling of exempt requests. In the mandatory exempt configuration object the values in the fields here can be modified by authorized users, unlike the rest of the `spec`.
type ExemptPriorityLevelConfigurationOutput struct{ *pulumi.OutputState }

func (ExemptPriorityLevelConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExemptPriorityLevelConfiguration)(nil)).Elem()
}

func (o ExemptPriorityLevelConfigurationOutput) ToExemptPriorityLevelConfigurationOutput() ExemptPriorityLevelConfigurationOutput {
	return o
}

func (o ExemptPriorityLevelConfigurationOutput) ToExemptPriorityLevelConfigurationOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationOutput {
	return o
}

func (o ExemptPriorityLevelConfigurationOutput) ToExemptPriorityLevelConfigurationPtrOutput() ExemptPriorityLevelConfigurationPtrOutput {
	return o.ToExemptPriorityLevelConfigurationPtrOutputWithContext(context.Background())
}

func (o ExemptPriorityLevelConfigurationOutput) ToExemptPriorityLevelConfigurationPtrOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ExemptPriorityLevelConfiguration) *ExemptPriorityLevelConfiguration {
		return &v
	}).(ExemptPriorityLevelConfigurationPtrOutput)
}

// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
//
// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
func (o ExemptPriorityLevelConfigurationOutput) LendablePercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ExemptPriorityLevelConfiguration) *int { return v.LendablePercent }).(pulumi.IntPtrOutput)
}

// `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
//
// NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
//
// Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
func (o ExemptPriorityLevelConfigurationOutput) NominalConcurrencyShares() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ExemptPriorityLevelConfiguration) *int { return v.NominalConcurrencyShares }).(pulumi.IntPtrOutput)
}

type ExemptPriorityLevelConfigurationPtrOutput struct{ *pulumi.OutputState }

func (ExemptPriorityLevelConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ExemptPriorityLevelConfiguration)(nil)).Elem()
}

func (o ExemptPriorityLevelConfigurationPtrOutput) ToExemptPriorityLevelConfigurationPtrOutput() ExemptPriorityLevelConfigurationPtrOutput {
	return o
}

func (o ExemptPriorityLevelConfigurationPtrOutput) ToExemptPriorityLevelConfigurationPtrOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPtrOutput {
	return o
}

func (o ExemptPriorityLevelConfigurationPtrOutput) Elem() ExemptPriorityLevelConfigurationOutput {
	return o.ApplyT(func(v *ExemptPriorityLevelConfiguration) ExemptPriorityLevelConfiguration {
		if v != nil {
			return *v
		}
		var ret ExemptPriorityLevelConfiguration
		return ret
	}).(ExemptPriorityLevelConfigurationOutput)
}

// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
//
// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
func (o ExemptPriorityLevelConfigurationPtrOutput) LendablePercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ExemptPriorityLevelConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.LendablePercent
	}).(pulumi.IntPtrOutput)
}

// `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
//
// NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
//
// Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
func (o ExemptPriorityLevelConfigurationPtrOutput) NominalConcurrencyShares() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ExemptPriorityLevelConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.NominalConcurrencyShares
	}).(pulumi.IntPtrOutput)
}

// ExemptPriorityLevelConfiguration describes the configurable aspects of the handling of exempt requests. In the mandatory exempt configuration object the values in the fields here can be modified by authorized users, unlike the rest of the `spec`.
type ExemptPriorityLevelConfigurationPatch struct {
	// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
	//
	// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
	LendablePercent *int `pulumi:"lendablePercent"`
	// `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
	//
	// NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
	//
	// Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
	NominalConcurrencyShares *int `pulumi:"nominalConcurrencyShares"`
}

// ExemptPriorityLevelConfigurationPatchInput is an input type that accepts ExemptPriorityLevelConfigurationPatchArgs and ExemptPriorityLevelConfigurationPatchOutput values.
// You can construct a concrete instance of `ExemptPriorityLevelConfigurationPatchInput` via:
//
//	ExemptPriorityLevelConfigurationPatchArgs{...}
type ExemptPriorityLevelConfigurationPatchInput interface {
	pulumi.Input

	ToExemptPriorityLevelConfigurationPatchOutput() ExemptPriorityLevelConfigurationPatchOutput
	ToExemptPriorityLevelConfigurationPatchOutputWithContext(context.Context) ExemptPriorityLevelConfigurationPatchOutput
}

// ExemptPriorityLevelConfiguration describes the configurable aspects of the handling of exempt requests. In the mandatory exempt configuration object the values in the fields here can be modified by authorized users, unlike the rest of the `spec`.
type ExemptPriorityLevelConfigurationPatchArgs struct {
	// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
	//
	// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
	LendablePercent pulumi.IntPtrInput `pulumi:"lendablePercent"`
	// `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
	//
	// NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
	//
	// Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
	NominalConcurrencyShares pulumi.IntPtrInput `pulumi:"nominalConcurrencyShares"`
}

func (ExemptPriorityLevelConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExemptPriorityLevelConfigurationPatch)(nil)).Elem()
}

func (i ExemptPriorityLevelConfigurationPatchArgs) ToExemptPriorityLevelConfigurationPatchOutput() ExemptPriorityLevelConfigurationPatchOutput {
	return i.ToExemptPriorityLevelConfigurationPatchOutputWithContext(context.Background())
}

func (i ExemptPriorityLevelConfigurationPatchArgs) ToExemptPriorityLevelConfigurationPatchOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemptPriorityLevelConfigurationPatchOutput)
}

func (i ExemptPriorityLevelConfigurationPatchArgs) ToExemptPriorityLevelConfigurationPatchPtrOutput() ExemptPriorityLevelConfigurationPatchPtrOutput {
	return i.ToExemptPriorityLevelConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i ExemptPriorityLevelConfigurationPatchArgs) ToExemptPriorityLevelConfigurationPatchPtrOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemptPriorityLevelConfigurationPatchOutput).ToExemptPriorityLevelConfigurationPatchPtrOutputWithContext(ctx)
}

// ExemptPriorityLevelConfigurationPatchPtrInput is an input type that accepts ExemptPriorityLevelConfigurationPatchArgs, ExemptPriorityLevelConfigurationPatchPtr and ExemptPriorityLevelConfigurationPatchPtrOutput values.
// You can construct a concrete instance of `ExemptPriorityLevelConfigurationPatchPtrInput` via:
//
//	        ExemptPriorityLevelConfigurationPatchArgs{...}
//
//	or:
//
//	        nil
type ExemptPriorityLevelConfigurationPatchPtrInput interface {
	pulumi.Input

	ToExemptPriorityLevelConfigurationPatchPtrOutput() ExemptPriorityLevelConfigurationPatchPtrOutput
	ToExemptPriorityLevelConfigurationPatchPtrOutputWithContext(context.Context) ExemptPriorityLevelConfigurationPatchPtrOutput
}

type exemptPriorityLevelConfigurationPatchPtrType ExemptPriorityLevelConfigurationPatchArgs

func ExemptPriorityLevelConfigurationPatchPtr(v *ExemptPriorityLevelConfigurationPatchArgs) ExemptPriorityLevelConfigurationPatchPtrInput {
	return (*exemptPriorityLevelConfigurationPatchPtrType)(v)
}

func (*exemptPriorityLevelConfigurationPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ExemptPriorityLevelConfigurationPatch)(nil)).Elem()
}

func (i *exemptPriorityLevelConfigurationPatchPtrType) ToExemptPriorityLevelConfigurationPatchPtrOutput() ExemptPriorityLevelConfigurationPatchPtrOutput {
	return i.ToExemptPriorityLevelConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i *exemptPriorityLevelConfigurationPatchPtrType) ToExemptPriorityLevelConfigurationPatchPtrOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemptPriorityLevelConfigurationPatchPtrOutput)
}

// ExemptPriorityLevelConfiguration describes the configurable aspects of the handling of exempt requests. In the mandatory exempt configuration object the values in the fields here can be modified by authorized users, unlike the rest of the `spec`.
type ExemptPriorityLevelConfigurationPatchOutput struct{ *pulumi.OutputState }

func (ExemptPriorityLevelConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExemptPriorityLevelConfigurationPatch)(nil)).Elem()
}

func (o ExemptPriorityLevelConfigurationPatchOutput) ToExemptPriorityLevelConfigurationPatchOutput() ExemptPriorityLevelConfigurationPatchOutput {
	return o
}

func (o ExemptPriorityLevelConfigurationPatchOutput) ToExemptPriorityLevelConfigurationPatchOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPatchOutput {
	return o
}

func (o ExemptPriorityLevelConfigurationPatchOutput) ToExemptPriorityLevelConfigurationPatchPtrOutput() ExemptPriorityLevelConfigurationPatchPtrOutput {
	return o.ToExemptPriorityLevelConfigurationPatchPtrOutputWithContext(context.Background())
}

func (o ExemptPriorityLevelConfigurationPatchOutput) ToExemptPriorityLevelConfigurationPatchPtrOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ExemptPriorityLevelConfigurationPatch) *ExemptPriorityLevelConfigurationPatch {
		return &v
	}).(ExemptPriorityLevelConfigurationPatchPtrOutput)
}

// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
//
// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
func (o ExemptPriorityLevelConfigurationPatchOutput) LendablePercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ExemptPriorityLevelConfigurationPatch) *int { return v.LendablePercent }).(pulumi.IntPtrOutput)
}

// `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
//
// NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
//
// Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
func (o ExemptPriorityLevelConfigurationPatchOutput) NominalConcurrencyShares() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ExemptPriorityLevelConfigurationPatch) *int { return v.NominalConcurrencyShares }).(pulumi.IntPtrOutput)
}

type ExemptPriorityLevelConfigurationPatchPtrOutput struct{ *pulumi.OutputState }

func (ExemptPriorityLevelConfigurationPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ExemptPriorityLevelConfigurationPatch)(nil)).Elem()
}

func (o ExemptPriorityLevelConfigurationPatchPtrOutput) ToExemptPriorityLevelConfigurationPatchPtrOutput() ExemptPriorityLevelConfigurationPatchPtrOutput {
	return o
}

func (o ExemptPriorityLevelConfigurationPatchPtrOutput) ToExemptPriorityLevelConfigurationPatchPtrOutputWithContext(ctx context.Context) ExemptPriorityLevelConfigurationPatchPtrOutput {
	return o
}

func (o ExemptPriorityLevelConfigurationPatchPtrOutput) Elem() ExemptPriorityLevelConfigurationPatchOutput {
	return o.ApplyT(func(v *ExemptPriorityLevelConfigurationPatch) ExemptPriorityLevelConfigurationPatch {
		if v != nil {
			return *v
		}
		var ret ExemptPriorityLevelConfigurationPatch
		return ret
	}).(ExemptPriorityLevelConfigurationPatchOutput)
}

// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels.  This value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
//
// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
func (o ExemptPriorityLevelConfigurationPatchPtrOutput) LendablePercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ExemptPriorityLevelConfigurationPatch) *int {
		if v == nil {
			return nil
		}
		return v.LendablePercent
	}).(pulumi.IntPtrOutput)
}

// `nominalConcurrencyShares` (NCS) contributes to the computation of the NominalConcurrencyLimit (NominalCL) of this level. This is the number of execution seats nominally reserved for this priority level. This DOES NOT limit the dispatching from this priority level but affects the other priority levels through the borrowing mechanism. The server's concurrency limit (ServerCL) is divided among all the priority levels in proportion to their NCS values:
//
// NominalCL(i)  = ceil( ServerCL * NCS(i) / sum_ncs ) sum_ncs = sum[priority level k] NCS(k)
//
// Bigger numbers mean a larger nominal concurrency limit, at the expense of every other priority level. This field has a default value of zero.
func (o ExemptPriorityLevelConfigurationPatchPtrOutput) NominalConcurrencyShares() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ExemptPriorityLevelConfigurationPatch) *int {
		if v == nil {
			return nil
		}
		return v.NominalConcurrencyShares
	}).(pulumi.IntPtrOutput)
}

// FlowDistinguisherMethod specifies the method of a flow distinguisher.
type FlowDistinguisherMethod struct {
	// `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required.
	Type string `pulumi:"type"`
}

// FlowDistinguisherMethodInput is an input type that accepts FlowDistinguisherMethodArgs and FlowDistinguisherMethodOutput values.
// You can construct a concrete instance of `FlowDistinguisherMethodInput` via:
//
//	FlowDistinguisherMethodArgs{...}
type FlowDistinguisherMethodInput interface {
	pulumi.Input

	ToFlowDistinguisherMethodOutput() FlowDistinguisherMethodOutput
	ToFlowDistinguisherMethodOutputWithContext(context.Context) FlowDistinguisherMethodOutput
}

// FlowDistinguisherMethod specifies the method of a flow distinguisher.
type FlowDistinguisherMethodArgs struct {
	// `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required.
	Type pulumi.StringInput `pulumi:"type"`
}

func (FlowDistinguisherMethodArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowDistinguisherMethod)(nil)).Elem()
}

func (i FlowDistinguisherMethodArgs) ToFlowDistinguisherMethodOutput() FlowDistinguisherMethodOutput {
	return i.ToFlowDistinguisherMethodOutputWithContext(context.Background())
}

func (i FlowDistinguisherMethodArgs) ToFlowDistinguisherMethodOutputWithContext(ctx context.Context) FlowDistinguisherMethodOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowDistinguisherMethodOutput)
}

func (i FlowDistinguisherMethodArgs) ToFlowDistinguisherMethodPtrOutput() FlowDistinguisherMethodPtrOutput {
	return i.ToFlowDistinguisherMethodPtrOutputWithContext(context.Background())
}

func (i FlowDistinguisherMethodArgs) ToFlowDistinguisherMethodPtrOutputWithContext(ctx context.Context) FlowDistinguisherMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowDistinguisherMethodOutput).ToFlowDistinguisherMethodPtrOutputWithContext(ctx)
}

// FlowDistinguisherMethodPtrInput is an input type that accepts FlowDistinguisherMethodArgs, FlowDistinguisherMethodPtr and FlowDistinguisherMethodPtrOutput values.
// You can construct a concrete instance of `FlowDistinguisherMethodPtrInput` via:
//
//	        FlowDistinguisherMethodArgs{...}
//
//	or:
//
//	        nil
type FlowDistinguisherMethodPtrInput interface {
	pulumi.Input

	ToFlowDistinguisherMethodPtrOutput() FlowDistinguisherMethodPtrOutput
	ToFlowDistinguisherMethodPtrOutputWithContext(context.Context) FlowDistinguisherMethodPtrOutput
}

type flowDistinguisherMethodPtrType FlowDistinguisherMethodArgs

func FlowDistinguisherMethodPtr(v *FlowDistinguisherMethodArgs) FlowDistinguisherMethodPtrInput {
	return (*flowDistinguisherMethodPtrType)(v)
}

func (*flowDistinguisherMethodPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowDistinguisherMethod)(nil)).Elem()
}

func (i *flowDistinguisherMethodPtrType) ToFlowDistinguisherMethodPtrOutput() FlowDistinguisherMethodPtrOutput {
	return i.ToFlowDistinguisherMethodPtrOutputWithContext(context.Background())
}

func (i *flowDistinguisherMethodPtrType) ToFlowDistinguisherMethodPtrOutputWithContext(ctx context.Context) FlowDistinguisherMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowDistinguisherMethodPtrOutput)
}

// FlowDistinguisherMethod specifies the method of a flow distinguisher.
type FlowDistinguisherMethodOutput struct{ *pulumi.OutputState }

func (FlowDistinguisherMethodOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowDistinguisherMethod)(nil)).Elem()
}

func (o FlowDistinguisherMethodOutput) ToFlowDistinguisherMethodOutput() FlowDistinguisherMethodOutput {
	return o
}

func (o FlowDistinguisherMethodOutput) ToFlowDistinguisherMethodOutputWithContext(ctx context.Context) FlowDistinguisherMethodOutput {
	return o
}

func (o FlowDistinguisherMethodOutput) ToFlowDistinguisherMethodPtrOutput() FlowDistinguisherMethodPtrOutput {
	return o.ToFlowDistinguisherMethodPtrOutputWithContext(context.Background())
}

func (o FlowDistinguisherMethodOutput) ToFlowDistinguisherMethodPtrOutputWithContext(ctx context.Context) FlowDistinguisherMethodPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FlowDistinguisherMethod) *FlowDistinguisherMethod {
		return &v
	}).(FlowDistinguisherMethodPtrOutput)
}

// `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required.
func (o FlowDistinguisherMethodOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v FlowDistinguisherMethod) string { return v.Type }).(pulumi.StringOutput)
}

type FlowDistinguisherMethodPtrOutput struct{ *pulumi.OutputState }

func (FlowDistinguisherMethodPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowDistinguisherMethod)(nil)).Elem()
}

func (o FlowDistinguisherMethodPtrOutput) ToFlowDistinguisherMethodPtrOutput() FlowDistinguisherMethodPtrOutput {
	return o
}

func (o FlowDistinguisherMethodPtrOutput) ToFlowDistinguisherMethodPtrOutputWithContext(ctx context.Context) FlowDistinguisherMethodPtrOutput {
	return o
}

func (o FlowDistinguisherMethodPtrOutput) Elem() FlowDistinguisherMethodOutput {
	return o.ApplyT(func(v *FlowDistinguisherMethod) FlowDistinguisherMethod {
		if v != nil {
			return *v
		}
		var ret FlowDistinguisherMethod
		return ret
	}).(FlowDistinguisherMethodOutput)
}

// `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required.
func (o FlowDistinguisherMethodPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FlowDistinguisherMethod) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// FlowDistinguisherMethod specifies the method of a flow distinguisher.
type FlowDistinguisherMethodPatch struct {
	// `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required.
	Type *string `pulumi:"type"`
}

// FlowDistinguisherMethodPatchInput is an input type that accepts FlowDistinguisherMethodPatchArgs and FlowDistinguisherMethodPatchOutput values.
// You can construct a concrete instance of `FlowDistinguisherMethodPatchInput` via:
//
//	FlowDistinguisherMethodPatchArgs{...}
type FlowDistinguisherMethodPatchInput interface {
	pulumi.Input

	ToFlowDistinguisherMethodPatchOutput() FlowDistinguisherMethodPatchOutput
	ToFlowDistinguisherMethodPatchOutputWithContext(context.Context) FlowDistinguisherMethodPatchOutput
}

// FlowDistinguisherMethod specifies the method of a flow distinguisher.
type FlowDistinguisherMethodPatchArgs struct {
	// `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (FlowDistinguisherMethodPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowDistinguisherMethodPatch)(nil)).Elem()
}

func (i FlowDistinguisherMethodPatchArgs) ToFlowDistinguisherMethodPatchOutput() FlowDistinguisherMethodPatchOutput {
	return i.ToFlowDistinguisherMethodPatchOutputWithContext(context.Background())
}

func (i FlowDistinguisherMethodPatchArgs) ToFlowDistinguisherMethodPatchOutputWithContext(ctx context.Context) FlowDistinguisherMethodPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowDistinguisherMethodPatchOutput)
}

func (i FlowDistinguisherMethodPatchArgs) ToFlowDistinguisherMethodPatchPtrOutput() FlowDistinguisherMethodPatchPtrOutput {
	return i.ToFlowDistinguisherMethodPatchPtrOutputWithContext(context.Background())
}

func (i FlowDistinguisherMethodPatchArgs) ToFlowDistinguisherMethodPatchPtrOutputWithContext(ctx context.Context) FlowDistinguisherMethodPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowDistinguisherMethodPatchOutput).ToFlowDistinguisherMethodPatchPtrOutputWithContext(ctx)
}

// FlowDistinguisherMethodPatchPtrInput is an input type that accepts FlowDistinguisherMethodPatchArgs, FlowDistinguisherMethodPatchPtr and FlowDistinguisherMethodPatchPtrOutput values.
// You can construct a concrete instance of `FlowDistinguisherMethodPatchPtrInput` via:
//
//	        FlowDistinguisherMethodPatchArgs{...}
//
//	or:
//
//	        nil
type FlowDistinguisherMethodPatchPtrInput interface {
	pulumi.Input

	ToFlowDistinguisherMethodPatchPtrOutput() FlowDistinguisherMethodPatchPtrOutput
	ToFlowDistinguisherMethodPatchPtrOutputWithContext(context.Context) FlowDistinguisherMethodPatchPtrOutput
}

type flowDistinguisherMethodPatchPtrType FlowDistinguisherMethodPatchArgs

func FlowDistinguisherMethodPatchPtr(v *FlowDistinguisherMethodPatchArgs) FlowDistinguisherMethodPatchPtrInput {
	return (*flowDistinguisherMethodPatchPtrType)(v)
}

func (*flowDistinguisherMethodPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowDistinguisherMethodPatch)(nil)).Elem()
}

func (i *flowDistinguisherMethodPatchPtrType) ToFlowDistinguisherMethodPatchPtrOutput() FlowDistinguisherMethodPatchPtrOutput {
	return i.ToFlowDistinguisherMethodPatchPtrOutputWithContext(context.Background())
}

func (i *flowDistinguisherMethodPatchPtrType) ToFlowDistinguisherMethodPatchPtrOutputWithContext(ctx context.Context) FlowDistinguisherMethodPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowDistinguisherMethodPatchPtrOutput)
}

// FlowDistinguisherMethod specifies the method of a flow distinguisher.
type FlowDistinguisherMethodPatchOutput struct{ *pulumi.OutputState }

func (FlowDistinguisherMethodPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowDistinguisherMethodPatch)(nil)).Elem()
}

func (o FlowDistinguisherMethodPatchOutput) ToFlowDistinguisherMethodPatchOutput() FlowDistinguisherMethodPatchOutput {
	return o
}

func (o FlowDistinguisherMethodPatchOutput) ToFlowDistinguisherMethodPatchOutputWithContext(ctx context.Context) FlowDistinguisherMethodPatchOutput {
	return o
}

func (o FlowDistinguisherMethodPatchOutput) ToFlowDistinguisherMethodPatchPtrOutput() FlowDistinguisherMethodPatchPtrOutput {
	return o.ToFlowDistinguisherMethodPatchPtrOutputWithContext(context.Background())
}

func (o FlowDistinguisherMethodPatchOutput) ToFlowDistinguisherMethodPatchPtrOutputWithContext(ctx context.Context) FlowDistinguisherMethodPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FlowDistinguisherMethodPatch) *FlowDistinguisherMethodPatch {
		return &v
	}).(FlowDistinguisherMethodPatchPtrOutput)
}

// `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required.
func (o FlowDistinguisherMethodPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowDistinguisherMethodPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type FlowDistinguisherMethodPatchPtrOutput struct{ *pulumi.OutputState }

func (FlowDistinguisherMethodPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowDistinguisherMethodPatch)(nil)).Elem()
}

func (o FlowDistinguisherMethodPatchPtrOutput) ToFlowDistinguisherMethodPatchPtrOutput() FlowDistinguisherMethodPatchPtrOutput {
	return o
}

func (o FlowDistinguisherMethodPatchPtrOutput) ToFlowDistinguisherMethodPatchPtrOutputWithContext(ctx context.Context) FlowDistinguisherMethodPatchPtrOutput {
	return o
}

func (o FlowDistinguisherMethodPatchPtrOutput) Elem() FlowDistinguisherMethodPatchOutput {
	return o.ApplyT(func(v *FlowDistinguisherMethodPatch) FlowDistinguisherMethodPatch {
		if v != nil {
			return *v
		}
		var ret FlowDistinguisherMethodPatch
		return ret
	}).(FlowDistinguisherMethodPatchOutput)
}

// `type` is the type of flow distinguisher method The supported types are "ByUser" and "ByNamespace". Required.
func (o FlowDistinguisherMethodPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FlowDistinguisherMethodPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a "flow distinguisher".
type FlowSchemaType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// `spec` is the specification of the desired behavior of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec *FlowSchemaSpec `pulumi:"spec"`
	// `status` is the current status of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status *FlowSchemaStatus `pulumi:"status"`
}

// FlowSchemaTypeInput is an input type that accepts FlowSchemaTypeArgs and FlowSchemaTypeOutput values.
// You can construct a concrete instance of `FlowSchemaTypeInput` via:
//
//	FlowSchemaTypeArgs{...}
type FlowSchemaTypeInput interface {
	pulumi.Input

	ToFlowSchemaTypeOutput() FlowSchemaTypeOutput
	ToFlowSchemaTypeOutputWithContext(context.Context) FlowSchemaTypeOutput
}

// FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a "flow distinguisher".
type FlowSchemaTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// `spec` is the specification of the desired behavior of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec FlowSchemaSpecPtrInput `pulumi:"spec"`
	// `status` is the current status of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status FlowSchemaStatusPtrInput `pulumi:"status"`
}

func (FlowSchemaTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaType)(nil)).Elem()
}

func (i FlowSchemaTypeArgs) ToFlowSchemaTypeOutput() FlowSchemaTypeOutput {
	return i.ToFlowSchemaTypeOutputWithContext(context.Background())
}

func (i FlowSchemaTypeArgs) ToFlowSchemaTypeOutputWithContext(ctx context.Context) FlowSchemaTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaTypeOutput)
}

// FlowSchemaTypeArrayInput is an input type that accepts FlowSchemaTypeArray and FlowSchemaTypeArrayOutput values.
// You can construct a concrete instance of `FlowSchemaTypeArrayInput` via:
//
//	FlowSchemaTypeArray{ FlowSchemaTypeArgs{...} }
type FlowSchemaTypeArrayInput interface {
	pulumi.Input

	ToFlowSchemaTypeArrayOutput() FlowSchemaTypeArrayOutput
	ToFlowSchemaTypeArrayOutputWithContext(context.Context) FlowSchemaTypeArrayOutput
}

type FlowSchemaTypeArray []FlowSchemaTypeInput

func (FlowSchemaTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FlowSchemaType)(nil)).Elem()
}

func (i FlowSchemaTypeArray) ToFlowSchemaTypeArrayOutput() FlowSchemaTypeArrayOutput {
	return i.ToFlowSchemaTypeArrayOutputWithContext(context.Background())
}

func (i FlowSchemaTypeArray) ToFlowSchemaTypeArrayOutputWithContext(ctx context.Context) FlowSchemaTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaTypeArrayOutput)
}

// FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a "flow distinguisher".
type FlowSchemaTypeOutput struct{ *pulumi.OutputState }

func (FlowSchemaTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaType)(nil)).Elem()
}

func (o FlowSchemaTypeOutput) ToFlowSchemaTypeOutput() FlowSchemaTypeOutput {
	return o
}

func (o FlowSchemaTypeOutput) ToFlowSchemaTypeOutputWithContext(ctx context.Context) FlowSchemaTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o FlowSchemaTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o FlowSchemaTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o FlowSchemaTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v FlowSchemaType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// `spec` is the specification of the desired behavior of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o FlowSchemaTypeOutput) Spec() FlowSchemaSpecPtrOutput {
	return o.ApplyT(func(v FlowSchemaType) *FlowSchemaSpec { return v.Spec }).(FlowSchemaSpecPtrOutput)
}

// `status` is the current status of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o FlowSchemaTypeOutput) Status() FlowSchemaStatusPtrOutput {
	return o.ApplyT(func(v FlowSchemaType) *FlowSchemaStatus { return v.Status }).(FlowSchemaStatusPtrOutput)
}

type FlowSchemaTypeArrayOutput struct{ *pulumi.OutputState }

func (FlowSchemaTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FlowSchemaType)(nil)).Elem()
}

func (o FlowSchemaTypeArrayOutput) ToFlowSchemaTypeArrayOutput() FlowSchemaTypeArrayOutput {
	return o
}

func (o FlowSchemaTypeArrayOutput) ToFlowSchemaTypeArrayOutputWithContext(ctx context.Context) FlowSchemaTypeArrayOutput {
	return o
}

func (o FlowSchemaTypeArrayOutput) Index(i pulumi.IntInput) FlowSchemaTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FlowSchemaType {
		return vs[0].([]FlowSchemaType)[vs[1].(int)]
	}).(FlowSchemaTypeOutput)
}

// FlowSchemaCondition describes conditions for a FlowSchema.
type FlowSchemaCondition struct {
	// `lastTransitionTime` is the last time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// `message` is a human-readable message indicating details about last transition.
	Message *string `pulumi:"message"`
	// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
	Reason *string `pulumi:"reason"`
	// `status` is the status of the condition. Can be True, False, Unknown. Required.
	Status *string `pulumi:"status"`
	// `type` is the type of the condition. Required.
	Type *string `pulumi:"type"`
}

// FlowSchemaConditionInput is an input type that accepts FlowSchemaConditionArgs and FlowSchemaConditionOutput values.
// You can construct a concrete instance of `FlowSchemaConditionInput` via:
//
//	FlowSchemaConditionArgs{...}
type FlowSchemaConditionInput interface {
	pulumi.Input

	ToFlowSchemaConditionOutput() FlowSchemaConditionOutput
	ToFlowSchemaConditionOutputWithContext(context.Context) FlowSchemaConditionOutput
}

// FlowSchemaCondition describes conditions for a FlowSchema.
type FlowSchemaConditionArgs struct {
	// `lastTransitionTime` is the last time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// `message` is a human-readable message indicating details about last transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// `status` is the status of the condition. Can be True, False, Unknown. Required.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// `type` is the type of the condition. Required.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (FlowSchemaConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaCondition)(nil)).Elem()
}

func (i FlowSchemaConditionArgs) ToFlowSchemaConditionOutput() FlowSchemaConditionOutput {
	return i.ToFlowSchemaConditionOutputWithContext(context.Background())
}

func (i FlowSchemaConditionArgs) ToFlowSchemaConditionOutputWithContext(ctx context.Context) FlowSchemaConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaConditionOutput)
}

// FlowSchemaConditionArrayInput is an input type that accepts FlowSchemaConditionArray and FlowSchemaConditionArrayOutput values.
// You can construct a concrete instance of `FlowSchemaConditionArrayInput` via:
//
//	FlowSchemaConditionArray{ FlowSchemaConditionArgs{...} }
type FlowSchemaConditionArrayInput interface {
	pulumi.Input

	ToFlowSchemaConditionArrayOutput() FlowSchemaConditionArrayOutput
	ToFlowSchemaConditionArrayOutputWithContext(context.Context) FlowSchemaConditionArrayOutput
}

type FlowSchemaConditionArray []FlowSchemaConditionInput

func (FlowSchemaConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FlowSchemaCondition)(nil)).Elem()
}

func (i FlowSchemaConditionArray) ToFlowSchemaConditionArrayOutput() FlowSchemaConditionArrayOutput {
	return i.ToFlowSchemaConditionArrayOutputWithContext(context.Background())
}

func (i FlowSchemaConditionArray) ToFlowSchemaConditionArrayOutputWithContext(ctx context.Context) FlowSchemaConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaConditionArrayOutput)
}

// FlowSchemaCondition describes conditions for a FlowSchema.
type FlowSchemaConditionOutput struct{ *pulumi.OutputState }

func (FlowSchemaConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaCondition)(nil)).Elem()
}

func (o FlowSchemaConditionOutput) ToFlowSchemaConditionOutput() FlowSchemaConditionOutput {
	return o
}

func (o FlowSchemaConditionOutput) ToFlowSchemaConditionOutputWithContext(ctx context.Context) FlowSchemaConditionOutput {
	return o
}

// `lastTransitionTime` is the last time the condition transitioned from one status to another.
func (o FlowSchemaConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// `message` is a human-readable message indicating details about last transition.
func (o FlowSchemaConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
func (o FlowSchemaConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// `status` is the status of the condition. Can be True, False, Unknown. Required.
func (o FlowSchemaConditionOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaCondition) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// `type` is the type of the condition. Required.
func (o FlowSchemaConditionOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaCondition) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type FlowSchemaConditionArrayOutput struct{ *pulumi.OutputState }

func (FlowSchemaConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FlowSchemaCondition)(nil)).Elem()
}

func (o FlowSchemaConditionArrayOutput) ToFlowSchemaConditionArrayOutput() FlowSchemaConditionArrayOutput {
	return o
}

func (o FlowSchemaConditionArrayOutput) ToFlowSchemaConditionArrayOutputWithContext(ctx context.Context) FlowSchemaConditionArrayOutput {
	return o
}

func (o FlowSchemaConditionArrayOutput) Index(i pulumi.IntInput) FlowSchemaConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FlowSchemaCondition {
		return vs[0].([]FlowSchemaCondition)[vs[1].(int)]
	}).(FlowSchemaConditionOutput)
}

// FlowSchemaCondition describes conditions for a FlowSchema.
type FlowSchemaConditionPatch struct {
	// `lastTransitionTime` is the last time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// `message` is a human-readable message indicating details about last transition.
	Message *string `pulumi:"message"`
	// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
	Reason *string `pulumi:"reason"`
	// `status` is the status of the condition. Can be True, False, Unknown. Required.
	Status *string `pulumi:"status"`
	// `type` is the type of the condition. Required.
	Type *string `pulumi:"type"`
}

// FlowSchemaConditionPatchInput is an input type that accepts FlowSchemaConditionPatchArgs and FlowSchemaConditionPatchOutput values.
// You can construct a concrete instance of `FlowSchemaConditionPatchInput` via:
//
//	FlowSchemaConditionPatchArgs{...}
type FlowSchemaConditionPatchInput interface {
	pulumi.Input

	ToFlowSchemaConditionPatchOutput() FlowSchemaConditionPatchOutput
	ToFlowSchemaConditionPatchOutputWithContext(context.Context) FlowSchemaConditionPatchOutput
}

// FlowSchemaCondition describes conditions for a FlowSchema.
type FlowSchemaConditionPatchArgs struct {
	// `lastTransitionTime` is the last time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// `message` is a human-readable message indicating details about last transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// `status` is the status of the condition. Can be True, False, Unknown. Required.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// `type` is the type of the condition. Required.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (FlowSchemaConditionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaConditionPatch)(nil)).Elem()
}

func (i FlowSchemaConditionPatchArgs) ToFlowSchemaConditionPatchOutput() FlowSchemaConditionPatchOutput {
	return i.ToFlowSchemaConditionPatchOutputWithContext(context.Background())
}

func (i FlowSchemaConditionPatchArgs) ToFlowSchemaConditionPatchOutputWithContext(ctx context.Context) FlowSchemaConditionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaConditionPatchOutput)
}

// FlowSchemaConditionPatchArrayInput is an input type that accepts FlowSchemaConditionPatchArray and FlowSchemaConditionPatchArrayOutput values.
// You can construct a concrete instance of `FlowSchemaConditionPatchArrayInput` via:
//
//	FlowSchemaConditionPatchArray{ FlowSchemaConditionPatchArgs{...} }
type FlowSchemaConditionPatchArrayInput interface {
	pulumi.Input

	ToFlowSchemaConditionPatchArrayOutput() FlowSchemaConditionPatchArrayOutput
	ToFlowSchemaConditionPatchArrayOutputWithContext(context.Context) FlowSchemaConditionPatchArrayOutput
}

type FlowSchemaConditionPatchArray []FlowSchemaConditionPatchInput

func (FlowSchemaConditionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FlowSchemaConditionPatch)(nil)).Elem()
}

func (i FlowSchemaConditionPatchArray) ToFlowSchemaConditionPatchArrayOutput() FlowSchemaConditionPatchArrayOutput {
	return i.ToFlowSchemaConditionPatchArrayOutputWithContext(context.Background())
}

func (i FlowSchemaConditionPatchArray) ToFlowSchemaConditionPatchArrayOutputWithContext(ctx context.Context) FlowSchemaConditionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaConditionPatchArrayOutput)
}

// FlowSchemaCondition describes conditions for a FlowSchema.
type FlowSchemaConditionPatchOutput struct{ *pulumi.OutputState }

func (FlowSchemaConditionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaConditionPatch)(nil)).Elem()
}

func (o FlowSchemaConditionPatchOutput) ToFlowSchemaConditionPatchOutput() FlowSchemaConditionPatchOutput {
	return o
}

func (o FlowSchemaConditionPatchOutput) ToFlowSchemaConditionPatchOutputWithContext(ctx context.Context) FlowSchemaConditionPatchOutput {
	return o
}

// `lastTransitionTime` is the last time the condition transitioned from one status to another.
func (o FlowSchemaConditionPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaConditionPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// `message` is a human-readable message indicating details about last transition.
func (o FlowSchemaConditionPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaConditionPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
func (o FlowSchemaConditionPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaConditionPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// `status` is the status of the condition. Can be True, False, Unknown. Required.
func (o FlowSchemaConditionPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaConditionPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// `type` is the type of the condition. Required.
func (o FlowSchemaConditionPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaConditionPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type FlowSchemaConditionPatchArrayOutput struct{ *pulumi.OutputState }

func (FlowSchemaConditionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FlowSchemaConditionPatch)(nil)).Elem()
}

func (o FlowSchemaConditionPatchArrayOutput) ToFlowSchemaConditionPatchArrayOutput() FlowSchemaConditionPatchArrayOutput {
	return o
}

func (o FlowSchemaConditionPatchArrayOutput) ToFlowSchemaConditionPatchArrayOutputWithContext(ctx context.Context) FlowSchemaConditionPatchArrayOutput {
	return o
}

func (o FlowSchemaConditionPatchArrayOutput) Index(i pulumi.IntInput) FlowSchemaConditionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FlowSchemaConditionPatch {
		return vs[0].([]FlowSchemaConditionPatch)[vs[1].(int)]
	}).(FlowSchemaConditionPatchOutput)
}

// FlowSchemaList is a list of FlowSchema objects.
type FlowSchemaListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// `items` is a list of FlowSchemas.
	Items []FlowSchemaType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// `metadata` is the standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// FlowSchemaListTypeInput is an input type that accepts FlowSchemaListTypeArgs and FlowSchemaListTypeOutput values.
// You can construct a concrete instance of `FlowSchemaListTypeInput` via:
//
//	FlowSchemaListTypeArgs{...}
type FlowSchemaListTypeInput interface {
	pulumi.Input

	ToFlowSchemaListTypeOutput() FlowSchemaListTypeOutput
	ToFlowSchemaListTypeOutputWithContext(context.Context) FlowSchemaListTypeOutput
}

// FlowSchemaList is a list of FlowSchema objects.
type FlowSchemaListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// `items` is a list of FlowSchemas.
	Items FlowSchemaTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// `metadata` is the standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (FlowSchemaListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaListType)(nil)).Elem()
}

func (i FlowSchemaListTypeArgs) ToFlowSchemaListTypeOutput() FlowSchemaListTypeOutput {
	return i.ToFlowSchemaListTypeOutputWithContext(context.Background())
}

func (i FlowSchemaListTypeArgs) ToFlowSchemaListTypeOutputWithContext(ctx context.Context) FlowSchemaListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaListTypeOutput)
}

// FlowSchemaList is a list of FlowSchema objects.
type FlowSchemaListTypeOutput struct{ *pulumi.OutputState }

func (FlowSchemaListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaListType)(nil)).Elem()
}

func (o FlowSchemaListTypeOutput) ToFlowSchemaListTypeOutput() FlowSchemaListTypeOutput {
	return o
}

func (o FlowSchemaListTypeOutput) ToFlowSchemaListTypeOutputWithContext(ctx context.Context) FlowSchemaListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o FlowSchemaListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// `items` is a list of FlowSchemas.
func (o FlowSchemaListTypeOutput) Items() FlowSchemaTypeArrayOutput {
	return o.ApplyT(func(v FlowSchemaListType) []FlowSchemaType { return v.Items }).(FlowSchemaTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o FlowSchemaListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// `metadata` is the standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o FlowSchemaListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v FlowSchemaListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a "flow distinguisher".
type FlowSchemaPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// `spec` is the specification of the desired behavior of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec *FlowSchemaSpecPatch `pulumi:"spec"`
	// `status` is the current status of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status *FlowSchemaStatusPatch `pulumi:"status"`
}

// FlowSchemaPatchTypeInput is an input type that accepts FlowSchemaPatchTypeArgs and FlowSchemaPatchTypeOutput values.
// You can construct a concrete instance of `FlowSchemaPatchTypeInput` via:
//
//	FlowSchemaPatchTypeArgs{...}
type FlowSchemaPatchTypeInput interface {
	pulumi.Input

	ToFlowSchemaPatchTypeOutput() FlowSchemaPatchTypeOutput
	ToFlowSchemaPatchTypeOutputWithContext(context.Context) FlowSchemaPatchTypeOutput
}

// FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a "flow distinguisher".
type FlowSchemaPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// `spec` is the specification of the desired behavior of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec FlowSchemaSpecPatchPtrInput `pulumi:"spec"`
	// `status` is the current status of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status FlowSchemaStatusPatchPtrInput `pulumi:"status"`
}

func (FlowSchemaPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaPatchType)(nil)).Elem()
}

func (i FlowSchemaPatchTypeArgs) ToFlowSchemaPatchTypeOutput() FlowSchemaPatchTypeOutput {
	return i.ToFlowSchemaPatchTypeOutputWithContext(context.Background())
}

func (i FlowSchemaPatchTypeArgs) ToFlowSchemaPatchTypeOutputWithContext(ctx context.Context) FlowSchemaPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaPatchTypeOutput)
}

// FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a "flow distinguisher".
type FlowSchemaPatchTypeOutput struct{ *pulumi.OutputState }

func (FlowSchemaPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaPatchType)(nil)).Elem()
}

func (o FlowSchemaPatchTypeOutput) ToFlowSchemaPatchTypeOutput() FlowSchemaPatchTypeOutput {
	return o
}

func (o FlowSchemaPatchTypeOutput) ToFlowSchemaPatchTypeOutputWithContext(ctx context.Context) FlowSchemaPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o FlowSchemaPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o FlowSchemaPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FlowSchemaPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o FlowSchemaPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v FlowSchemaPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// `spec` is the specification of the desired behavior of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o FlowSchemaPatchTypeOutput) Spec() FlowSchemaSpecPatchPtrOutput {
	return o.ApplyT(func(v FlowSchemaPatchType) *FlowSchemaSpecPatch { return v.Spec }).(FlowSchemaSpecPatchPtrOutput)
}

// `status` is the current status of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o FlowSchemaPatchTypeOutput) Status() FlowSchemaStatusPatchPtrOutput {
	return o.ApplyT(func(v FlowSchemaPatchType) *FlowSchemaStatusPatch { return v.Status }).(FlowSchemaStatusPatchPtrOutput)
}

// FlowSchemaSpec describes how the FlowSchema's specification looks like.
type FlowSchemaSpec struct {
	// `distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.
	DistinguisherMethod *FlowDistinguisherMethod `pulumi:"distinguisherMethod"`
	// `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default.
	MatchingPrecedence *int `pulumi:"matchingPrecedence"`
	// `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid in its status. Required.
	PriorityLevelConfiguration PriorityLevelConfigurationReference `pulumi:"priorityLevelConfiguration"`
	// `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema.
	Rules []PolicyRulesWithSubjects `pulumi:"rules"`
}

// FlowSchemaSpecInput is an input type that accepts FlowSchemaSpecArgs and FlowSchemaSpecOutput values.
// You can construct a concrete instance of `FlowSchemaSpecInput` via:
//
//	FlowSchemaSpecArgs{...}
type FlowSchemaSpecInput interface {
	pulumi.Input

	ToFlowSchemaSpecOutput() FlowSchemaSpecOutput
	ToFlowSchemaSpecOutputWithContext(context.Context) FlowSchemaSpecOutput
}

// FlowSchemaSpec describes how the FlowSchema's specification looks like.
type FlowSchemaSpecArgs struct {
	// `distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.
	DistinguisherMethod FlowDistinguisherMethodPtrInput `pulumi:"distinguisherMethod"`
	// `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default.
	MatchingPrecedence pulumi.IntPtrInput `pulumi:"matchingPrecedence"`
	// `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid in its status. Required.
	PriorityLevelConfiguration PriorityLevelConfigurationReferenceInput `pulumi:"priorityLevelConfiguration"`
	// `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema.
	Rules PolicyRulesWithSubjectsArrayInput `pulumi:"rules"`
}

func (FlowSchemaSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaSpec)(nil)).Elem()
}

func (i FlowSchemaSpecArgs) ToFlowSchemaSpecOutput() FlowSchemaSpecOutput {
	return i.ToFlowSchemaSpecOutputWithContext(context.Background())
}

func (i FlowSchemaSpecArgs) ToFlowSchemaSpecOutputWithContext(ctx context.Context) FlowSchemaSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaSpecOutput)
}

func (i FlowSchemaSpecArgs) ToFlowSchemaSpecPtrOutput() FlowSchemaSpecPtrOutput {
	return i.ToFlowSchemaSpecPtrOutputWithContext(context.Background())
}

func (i FlowSchemaSpecArgs) ToFlowSchemaSpecPtrOutputWithContext(ctx context.Context) FlowSchemaSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaSpecOutput).ToFlowSchemaSpecPtrOutputWithContext(ctx)
}

// FlowSchemaSpecPtrInput is an input type that accepts FlowSchemaSpecArgs, FlowSchemaSpecPtr and FlowSchemaSpecPtrOutput values.
// You can construct a concrete instance of `FlowSchemaSpecPtrInput` via:
//
//	        FlowSchemaSpecArgs{...}
//
//	or:
//
//	        nil
type FlowSchemaSpecPtrInput interface {
	pulumi.Input

	ToFlowSchemaSpecPtrOutput() FlowSchemaSpecPtrOutput
	ToFlowSchemaSpecPtrOutputWithContext(context.Context) FlowSchemaSpecPtrOutput
}

type flowSchemaSpecPtrType FlowSchemaSpecArgs

func FlowSchemaSpecPtr(v *FlowSchemaSpecArgs) FlowSchemaSpecPtrInput {
	return (*flowSchemaSpecPtrType)(v)
}

func (*flowSchemaSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowSchemaSpec)(nil)).Elem()
}

func (i *flowSchemaSpecPtrType) ToFlowSchemaSpecPtrOutput() FlowSchemaSpecPtrOutput {
	return i.ToFlowSchemaSpecPtrOutputWithContext(context.Background())
}

func (i *flowSchemaSpecPtrType) ToFlowSchemaSpecPtrOutputWithContext(ctx context.Context) FlowSchemaSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaSpecPtrOutput)
}

// FlowSchemaSpec describes how the FlowSchema's specification looks like.
type FlowSchemaSpecOutput struct{ *pulumi.OutputState }

func (FlowSchemaSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaSpec)(nil)).Elem()
}

func (o FlowSchemaSpecOutput) ToFlowSchemaSpecOutput() FlowSchemaSpecOutput {
	return o
}

func (o FlowSchemaSpecOutput) ToFlowSchemaSpecOutputWithContext(ctx context.Context) FlowSchemaSpecOutput {
	return o
}

func (o FlowSchemaSpecOutput) ToFlowSchemaSpecPtrOutput() FlowSchemaSpecPtrOutput {
	return o.ToFlowSchemaSpecPtrOutputWithContext(context.Background())
}

func (o FlowSchemaSpecOutput) ToFlowSchemaSpecPtrOutputWithContext(ctx context.Context) FlowSchemaSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FlowSchemaSpec) *FlowSchemaSpec {
		return &v
	}).(FlowSchemaSpecPtrOutput)
}

// `distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.
func (o FlowSchemaSpecOutput) DistinguisherMethod() FlowDistinguisherMethodPtrOutput {
	return o.ApplyT(func(v FlowSchemaSpec) *FlowDistinguisherMethod { return v.DistinguisherMethod }).(FlowDistinguisherMethodPtrOutput)
}

// `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default.
func (o FlowSchemaSpecOutput) MatchingPrecedence() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FlowSchemaSpec) *int { return v.MatchingPrecedence }).(pulumi.IntPtrOutput)
}

// `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid in its status. Required.
func (o FlowSchemaSpecOutput) PriorityLevelConfiguration() PriorityLevelConfigurationReferenceOutput {
	return o.ApplyT(func(v FlowSchemaSpec) PriorityLevelConfigurationReference { return v.PriorityLevelConfiguration }).(PriorityLevelConfigurationReferenceOutput)
}

// `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema.
func (o FlowSchemaSpecOutput) Rules() PolicyRulesWithSubjectsArrayOutput {
	return o.ApplyT(func(v FlowSchemaSpec) []PolicyRulesWithSubjects { return v.Rules }).(PolicyRulesWithSubjectsArrayOutput)
}

type FlowSchemaSpecPtrOutput struct{ *pulumi.OutputState }

func (FlowSchemaSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowSchemaSpec)(nil)).Elem()
}

func (o FlowSchemaSpecPtrOutput) ToFlowSchemaSpecPtrOutput() FlowSchemaSpecPtrOutput {
	return o
}

func (o FlowSchemaSpecPtrOutput) ToFlowSchemaSpecPtrOutputWithContext(ctx context.Context) FlowSchemaSpecPtrOutput {
	return o
}

func (o FlowSchemaSpecPtrOutput) Elem() FlowSchemaSpecOutput {
	return o.ApplyT(func(v *FlowSchemaSpec) FlowSchemaSpec {
		if v != nil {
			return *v
		}
		var ret FlowSchemaSpec
		return ret
	}).(FlowSchemaSpecOutput)
}

// `distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.
func (o FlowSchemaSpecPtrOutput) DistinguisherMethod() FlowDistinguisherMethodPtrOutput {
	return o.ApplyT(func(v *FlowSchemaSpec) *FlowDistinguisherMethod {
		if v == nil {
			return nil
		}
		return v.DistinguisherMethod
	}).(FlowDistinguisherMethodPtrOutput)
}

// `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default.
func (o FlowSchemaSpecPtrOutput) MatchingPrecedence() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FlowSchemaSpec) *int {
		if v == nil {
			return nil
		}
		return v.MatchingPrecedence
	}).(pulumi.IntPtrOutput)
}

// `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid in its status. Required.
func (o FlowSchemaSpecPtrOutput) PriorityLevelConfiguration() PriorityLevelConfigurationReferencePtrOutput {
	return o.ApplyT(func(v *FlowSchemaSpec) *PriorityLevelConfigurationReference {
		if v == nil {
			return nil
		}
		return &v.PriorityLevelConfiguration
	}).(PriorityLevelConfigurationReferencePtrOutput)
}

// `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema.
func (o FlowSchemaSpecPtrOutput) Rules() PolicyRulesWithSubjectsArrayOutput {
	return o.ApplyT(func(v *FlowSchemaSpec) []PolicyRulesWithSubjects {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(PolicyRulesWithSubjectsArrayOutput)
}

// FlowSchemaSpec describes how the FlowSchema's specification looks like.
type FlowSchemaSpecPatch struct {
	// `distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.
	DistinguisherMethod *FlowDistinguisherMethodPatch `pulumi:"distinguisherMethod"`
	// `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default.
	MatchingPrecedence *int `pulumi:"matchingPrecedence"`
	// `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid in its status. Required.
	PriorityLevelConfiguration *PriorityLevelConfigurationReferencePatch `pulumi:"priorityLevelConfiguration"`
	// `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema.
	Rules []PolicyRulesWithSubjectsPatch `pulumi:"rules"`
}

// FlowSchemaSpecPatchInput is an input type that accepts FlowSchemaSpecPatchArgs and FlowSchemaSpecPatchOutput values.
// You can construct a concrete instance of `FlowSchemaSpecPatchInput` via:
//
//	FlowSchemaSpecPatchArgs{...}
type FlowSchemaSpecPatchInput interface {
	pulumi.Input

	ToFlowSchemaSpecPatchOutput() FlowSchemaSpecPatchOutput
	ToFlowSchemaSpecPatchOutputWithContext(context.Context) FlowSchemaSpecPatchOutput
}

// FlowSchemaSpec describes how the FlowSchema's specification looks like.
type FlowSchemaSpecPatchArgs struct {
	// `distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.
	DistinguisherMethod FlowDistinguisherMethodPatchPtrInput `pulumi:"distinguisherMethod"`
	// `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default.
	MatchingPrecedence pulumi.IntPtrInput `pulumi:"matchingPrecedence"`
	// `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid in its status. Required.
	PriorityLevelConfiguration PriorityLevelConfigurationReferencePatchPtrInput `pulumi:"priorityLevelConfiguration"`
	// `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema.
	Rules PolicyRulesWithSubjectsPatchArrayInput `pulumi:"rules"`
}

func (FlowSchemaSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaSpecPatch)(nil)).Elem()
}

func (i FlowSchemaSpecPatchArgs) ToFlowSchemaSpecPatchOutput() FlowSchemaSpecPatchOutput {
	return i.ToFlowSchemaSpecPatchOutputWithContext(context.Background())
}

func (i FlowSchemaSpecPatchArgs) ToFlowSchemaSpecPatchOutputWithContext(ctx context.Context) FlowSchemaSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaSpecPatchOutput)
}

func (i FlowSchemaSpecPatchArgs) ToFlowSchemaSpecPatchPtrOutput() FlowSchemaSpecPatchPtrOutput {
	return i.ToFlowSchemaSpecPatchPtrOutputWithContext(context.Background())
}

func (i FlowSchemaSpecPatchArgs) ToFlowSchemaSpecPatchPtrOutputWithContext(ctx context.Context) FlowSchemaSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaSpecPatchOutput).ToFlowSchemaSpecPatchPtrOutputWithContext(ctx)
}

// FlowSchemaSpecPatchPtrInput is an input type that accepts FlowSchemaSpecPatchArgs, FlowSchemaSpecPatchPtr and FlowSchemaSpecPatchPtrOutput values.
// You can construct a concrete instance of `FlowSchemaSpecPatchPtrInput` via:
//
//	        FlowSchemaSpecPatchArgs{...}
//
//	or:
//
//	        nil
type FlowSchemaSpecPatchPtrInput interface {
	pulumi.Input

	ToFlowSchemaSpecPatchPtrOutput() FlowSchemaSpecPatchPtrOutput
	ToFlowSchemaSpecPatchPtrOutputWithContext(context.Context) FlowSchemaSpecPatchPtrOutput
}

type flowSchemaSpecPatchPtrType FlowSchemaSpecPatchArgs

func FlowSchemaSpecPatchPtr(v *FlowSchemaSpecPatchArgs) FlowSchemaSpecPatchPtrInput {
	return (*flowSchemaSpecPatchPtrType)(v)
}

func (*flowSchemaSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowSchemaSpecPatch)(nil)).Elem()
}

func (i *flowSchemaSpecPatchPtrType) ToFlowSchemaSpecPatchPtrOutput() FlowSchemaSpecPatchPtrOutput {
	return i.ToFlowSchemaSpecPatchPtrOutputWithContext(context.Background())
}

func (i *flowSchemaSpecPatchPtrType) ToFlowSchemaSpecPatchPtrOutputWithContext(ctx context.Context) FlowSchemaSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaSpecPatchPtrOutput)
}

// FlowSchemaSpec describes how the FlowSchema's specification looks like.
type FlowSchemaSpecPatchOutput struct{ *pulumi.OutputState }

func (FlowSchemaSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaSpecPatch)(nil)).Elem()
}

func (o FlowSchemaSpecPatchOutput) ToFlowSchemaSpecPatchOutput() FlowSchemaSpecPatchOutput {
	return o
}

func (o FlowSchemaSpecPatchOutput) ToFlowSchemaSpecPatchOutputWithContext(ctx context.Context) FlowSchemaSpecPatchOutput {
	return o
}

func (o FlowSchemaSpecPatchOutput) ToFlowSchemaSpecPatchPtrOutput() FlowSchemaSpecPatchPtrOutput {
	return o.ToFlowSchemaSpecPatchPtrOutputWithContext(context.Background())
}

func (o FlowSchemaSpecPatchOutput) ToFlowSchemaSpecPatchPtrOutputWithContext(ctx context.Context) FlowSchemaSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FlowSchemaSpecPatch) *FlowSchemaSpecPatch {
		return &v
	}).(FlowSchemaSpecPatchPtrOutput)
}

// `distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.
func (o FlowSchemaSpecPatchOutput) DistinguisherMethod() FlowDistinguisherMethodPatchPtrOutput {
	return o.ApplyT(func(v FlowSchemaSpecPatch) *FlowDistinguisherMethodPatch { return v.DistinguisherMethod }).(FlowDistinguisherMethodPatchPtrOutput)
}

// `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default.
func (o FlowSchemaSpecPatchOutput) MatchingPrecedence() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FlowSchemaSpecPatch) *int { return v.MatchingPrecedence }).(pulumi.IntPtrOutput)
}

// `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid in its status. Required.
func (o FlowSchemaSpecPatchOutput) PriorityLevelConfiguration() PriorityLevelConfigurationReferencePatchPtrOutput {
	return o.ApplyT(func(v FlowSchemaSpecPatch) *PriorityLevelConfigurationReferencePatch {
		return v.PriorityLevelConfiguration
	}).(PriorityLevelConfigurationReferencePatchPtrOutput)
}

// `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema.
func (o FlowSchemaSpecPatchOutput) Rules() PolicyRulesWithSubjectsPatchArrayOutput {
	return o.ApplyT(func(v FlowSchemaSpecPatch) []PolicyRulesWithSubjectsPatch { return v.Rules }).(PolicyRulesWithSubjectsPatchArrayOutput)
}

type FlowSchemaSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (FlowSchemaSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowSchemaSpecPatch)(nil)).Elem()
}

func (o FlowSchemaSpecPatchPtrOutput) ToFlowSchemaSpecPatchPtrOutput() FlowSchemaSpecPatchPtrOutput {
	return o
}

func (o FlowSchemaSpecPatchPtrOutput) ToFlowSchemaSpecPatchPtrOutputWithContext(ctx context.Context) FlowSchemaSpecPatchPtrOutput {
	return o
}

func (o FlowSchemaSpecPatchPtrOutput) Elem() FlowSchemaSpecPatchOutput {
	return o.ApplyT(func(v *FlowSchemaSpecPatch) FlowSchemaSpecPatch {
		if v != nil {
			return *v
		}
		var ret FlowSchemaSpecPatch
		return ret
	}).(FlowSchemaSpecPatchOutput)
}

// `distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.
func (o FlowSchemaSpecPatchPtrOutput) DistinguisherMethod() FlowDistinguisherMethodPatchPtrOutput {
	return o.ApplyT(func(v *FlowSchemaSpecPatch) *FlowDistinguisherMethodPatch {
		if v == nil {
			return nil
		}
		return v.DistinguisherMethod
	}).(FlowDistinguisherMethodPatchPtrOutput)
}

// `matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default.
func (o FlowSchemaSpecPatchPtrOutput) MatchingPrecedence() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FlowSchemaSpecPatch) *int {
		if v == nil {
			return nil
		}
		return v.MatchingPrecedence
	}).(pulumi.IntPtrOutput)
}

// `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid in its status. Required.
func (o FlowSchemaSpecPatchPtrOutput) PriorityLevelConfiguration() PriorityLevelConfigurationReferencePatchPtrOutput {
	return o.ApplyT(func(v *FlowSchemaSpecPatch) *PriorityLevelConfigurationReferencePatch {
		if v == nil {
			return nil
		}
		return v.PriorityLevelConfiguration
	}).(PriorityLevelConfigurationReferencePatchPtrOutput)
}

// `rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema.
func (o FlowSchemaSpecPatchPtrOutput) Rules() PolicyRulesWithSubjectsPatchArrayOutput {
	return o.ApplyT(func(v *FlowSchemaSpecPatch) []PolicyRulesWithSubjectsPatch {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(PolicyRulesWithSubjectsPatchArrayOutput)
}

// FlowSchemaStatus represents the current state of a FlowSchema.
type FlowSchemaStatus struct {
	// `conditions` is a list of the current states of FlowSchema.
	Conditions []FlowSchemaCondition `pulumi:"conditions"`
}

// FlowSchemaStatusInput is an input type that accepts FlowSchemaStatusArgs and FlowSchemaStatusOutput values.
// You can construct a concrete instance of `FlowSchemaStatusInput` via:
//
//	FlowSchemaStatusArgs{...}
type FlowSchemaStatusInput interface {
	pulumi.Input

	ToFlowSchemaStatusOutput() FlowSchemaStatusOutput
	ToFlowSchemaStatusOutputWithContext(context.Context) FlowSchemaStatusOutput
}

// FlowSchemaStatus represents the current state of a FlowSchema.
type FlowSchemaStatusArgs struct {
	// `conditions` is a list of the current states of FlowSchema.
	Conditions FlowSchemaConditionArrayInput `pulumi:"conditions"`
}

func (FlowSchemaStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaStatus)(nil)).Elem()
}

func (i FlowSchemaStatusArgs) ToFlowSchemaStatusOutput() FlowSchemaStatusOutput {
	return i.ToFlowSchemaStatusOutputWithContext(context.Background())
}

func (i FlowSchemaStatusArgs) ToFlowSchemaStatusOutputWithContext(ctx context.Context) FlowSchemaStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaStatusOutput)
}

func (i FlowSchemaStatusArgs) ToFlowSchemaStatusPtrOutput() FlowSchemaStatusPtrOutput {
	return i.ToFlowSchemaStatusPtrOutputWithContext(context.Background())
}

func (i FlowSchemaStatusArgs) ToFlowSchemaStatusPtrOutputWithContext(ctx context.Context) FlowSchemaStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaStatusOutput).ToFlowSchemaStatusPtrOutputWithContext(ctx)
}

// FlowSchemaStatusPtrInput is an input type that accepts FlowSchemaStatusArgs, FlowSchemaStatusPtr and FlowSchemaStatusPtrOutput values.
// You can construct a concrete instance of `FlowSchemaStatusPtrInput` via:
//
//	        FlowSchemaStatusArgs{...}
//
//	or:
//
//	        nil
type FlowSchemaStatusPtrInput interface {
	pulumi.Input

	ToFlowSchemaStatusPtrOutput() FlowSchemaStatusPtrOutput
	ToFlowSchemaStatusPtrOutputWithContext(context.Context) FlowSchemaStatusPtrOutput
}

type flowSchemaStatusPtrType FlowSchemaStatusArgs

func FlowSchemaStatusPtr(v *FlowSchemaStatusArgs) FlowSchemaStatusPtrInput {
	return (*flowSchemaStatusPtrType)(v)
}

func (*flowSchemaStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowSchemaStatus)(nil)).Elem()
}

func (i *flowSchemaStatusPtrType) ToFlowSchemaStatusPtrOutput() FlowSchemaStatusPtrOutput {
	return i.ToFlowSchemaStatusPtrOutputWithContext(context.Background())
}

func (i *flowSchemaStatusPtrType) ToFlowSchemaStatusPtrOutputWithContext(ctx context.Context) FlowSchemaStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaStatusPtrOutput)
}

// FlowSchemaStatus represents the current state of a FlowSchema.
type FlowSchemaStatusOutput struct{ *pulumi.OutputState }

func (FlowSchemaStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaStatus)(nil)).Elem()
}

func (o FlowSchemaStatusOutput) ToFlowSchemaStatusOutput() FlowSchemaStatusOutput {
	return o
}

func (o FlowSchemaStatusOutput) ToFlowSchemaStatusOutputWithContext(ctx context.Context) FlowSchemaStatusOutput {
	return o
}

func (o FlowSchemaStatusOutput) ToFlowSchemaStatusPtrOutput() FlowSchemaStatusPtrOutput {
	return o.ToFlowSchemaStatusPtrOutputWithContext(context.Background())
}

func (o FlowSchemaStatusOutput) ToFlowSchemaStatusPtrOutputWithContext(ctx context.Context) FlowSchemaStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FlowSchemaStatus) *FlowSchemaStatus {
		return &v
	}).(FlowSchemaStatusPtrOutput)
}

// `conditions` is a list of the current states of FlowSchema.
func (o FlowSchemaStatusOutput) Conditions() FlowSchemaConditionArrayOutput {
	return o.ApplyT(func(v FlowSchemaStatus) []FlowSchemaCondition { return v.Conditions }).(FlowSchemaConditionArrayOutput)
}

type FlowSchemaStatusPtrOutput struct{ *pulumi.OutputState }

func (FlowSchemaStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowSchemaStatus)(nil)).Elem()
}

func (o FlowSchemaStatusPtrOutput) ToFlowSchemaStatusPtrOutput() FlowSchemaStatusPtrOutput {
	return o
}

func (o FlowSchemaStatusPtrOutput) ToFlowSchemaStatusPtrOutputWithContext(ctx context.Context) FlowSchemaStatusPtrOutput {
	return o
}

func (o FlowSchemaStatusPtrOutput) Elem() FlowSchemaStatusOutput {
	return o.ApplyT(func(v *FlowSchemaStatus) FlowSchemaStatus {
		if v != nil {
			return *v
		}
		var ret FlowSchemaStatus
		return ret
	}).(FlowSchemaStatusOutput)
}

// `conditions` is a list of the current states of FlowSchema.
func (o FlowSchemaStatusPtrOutput) Conditions() FlowSchemaConditionArrayOutput {
	return o.ApplyT(func(v *FlowSchemaStatus) []FlowSchemaCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(FlowSchemaConditionArrayOutput)
}

// FlowSchemaStatus represents the current state of a FlowSchema.
type FlowSchemaStatusPatch struct {
	// `conditions` is a list of the current states of FlowSchema.
	Conditions []FlowSchemaConditionPatch `pulumi:"conditions"`
}

// FlowSchemaStatusPatchInput is an input type that accepts FlowSchemaStatusPatchArgs and FlowSchemaStatusPatchOutput values.
// You can construct a concrete instance of `FlowSchemaStatusPatchInput` via:
//
//	FlowSchemaStatusPatchArgs{...}
type FlowSchemaStatusPatchInput interface {
	pulumi.Input

	ToFlowSchemaStatusPatchOutput() FlowSchemaStatusPatchOutput
	ToFlowSchemaStatusPatchOutputWithContext(context.Context) FlowSchemaStatusPatchOutput
}

// FlowSchemaStatus represents the current state of a FlowSchema.
type FlowSchemaStatusPatchArgs struct {
	// `conditions` is a list of the current states of FlowSchema.
	Conditions FlowSchemaConditionPatchArrayInput `pulumi:"conditions"`
}

func (FlowSchemaStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaStatusPatch)(nil)).Elem()
}

func (i FlowSchemaStatusPatchArgs) ToFlowSchemaStatusPatchOutput() FlowSchemaStatusPatchOutput {
	return i.ToFlowSchemaStatusPatchOutputWithContext(context.Background())
}

func (i FlowSchemaStatusPatchArgs) ToFlowSchemaStatusPatchOutputWithContext(ctx context.Context) FlowSchemaStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaStatusPatchOutput)
}

func (i FlowSchemaStatusPatchArgs) ToFlowSchemaStatusPatchPtrOutput() FlowSchemaStatusPatchPtrOutput {
	return i.ToFlowSchemaStatusPatchPtrOutputWithContext(context.Background())
}

func (i FlowSchemaStatusPatchArgs) ToFlowSchemaStatusPatchPtrOutputWithContext(ctx context.Context) FlowSchemaStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaStatusPatchOutput).ToFlowSchemaStatusPatchPtrOutputWithContext(ctx)
}

// FlowSchemaStatusPatchPtrInput is an input type that accepts FlowSchemaStatusPatchArgs, FlowSchemaStatusPatchPtr and FlowSchemaStatusPatchPtrOutput values.
// You can construct a concrete instance of `FlowSchemaStatusPatchPtrInput` via:
//
//	        FlowSchemaStatusPatchArgs{...}
//
//	or:
//
//	        nil
type FlowSchemaStatusPatchPtrInput interface {
	pulumi.Input

	ToFlowSchemaStatusPatchPtrOutput() FlowSchemaStatusPatchPtrOutput
	ToFlowSchemaStatusPatchPtrOutputWithContext(context.Context) FlowSchemaStatusPatchPtrOutput
}

type flowSchemaStatusPatchPtrType FlowSchemaStatusPatchArgs

func FlowSchemaStatusPatchPtr(v *FlowSchemaStatusPatchArgs) FlowSchemaStatusPatchPtrInput {
	return (*flowSchemaStatusPatchPtrType)(v)
}

func (*flowSchemaStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowSchemaStatusPatch)(nil)).Elem()
}

func (i *flowSchemaStatusPatchPtrType) ToFlowSchemaStatusPatchPtrOutput() FlowSchemaStatusPatchPtrOutput {
	return i.ToFlowSchemaStatusPatchPtrOutputWithContext(context.Background())
}

func (i *flowSchemaStatusPatchPtrType) ToFlowSchemaStatusPatchPtrOutputWithContext(ctx context.Context) FlowSchemaStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlowSchemaStatusPatchPtrOutput)
}

// FlowSchemaStatus represents the current state of a FlowSchema.
type FlowSchemaStatusPatchOutput struct{ *pulumi.OutputState }

func (FlowSchemaStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlowSchemaStatusPatch)(nil)).Elem()
}

func (o FlowSchemaStatusPatchOutput) ToFlowSchemaStatusPatchOutput() FlowSchemaStatusPatchOutput {
	return o
}

func (o FlowSchemaStatusPatchOutput) ToFlowSchemaStatusPatchOutputWithContext(ctx context.Context) FlowSchemaStatusPatchOutput {
	return o
}

func (o FlowSchemaStatusPatchOutput) ToFlowSchemaStatusPatchPtrOutput() FlowSchemaStatusPatchPtrOutput {
	return o.ToFlowSchemaStatusPatchPtrOutputWithContext(context.Background())
}

func (o FlowSchemaStatusPatchOutput) ToFlowSchemaStatusPatchPtrOutputWithContext(ctx context.Context) FlowSchemaStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FlowSchemaStatusPatch) *FlowSchemaStatusPatch {
		return &v
	}).(FlowSchemaStatusPatchPtrOutput)
}

// `conditions` is a list of the current states of FlowSchema.
func (o FlowSchemaStatusPatchOutput) Conditions() FlowSchemaConditionPatchArrayOutput {
	return o.ApplyT(func(v FlowSchemaStatusPatch) []FlowSchemaConditionPatch { return v.Conditions }).(FlowSchemaConditionPatchArrayOutput)
}

type FlowSchemaStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (FlowSchemaStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FlowSchemaStatusPatch)(nil)).Elem()
}

func (o FlowSchemaStatusPatchPtrOutput) ToFlowSchemaStatusPatchPtrOutput() FlowSchemaStatusPatchPtrOutput {
	return o
}

func (o FlowSchemaStatusPatchPtrOutput) ToFlowSchemaStatusPatchPtrOutputWithContext(ctx context.Context) FlowSchemaStatusPatchPtrOutput {
	return o
}

func (o FlowSchemaStatusPatchPtrOutput) Elem() FlowSchemaStatusPatchOutput {
	return o.ApplyT(func(v *FlowSchemaStatusPatch) FlowSchemaStatusPatch {
		if v != nil {
			return *v
		}
		var ret FlowSchemaStatusPatch
		return ret
	}).(FlowSchemaStatusPatchOutput)
}

// `conditions` is a list of the current states of FlowSchema.
func (o FlowSchemaStatusPatchPtrOutput) Conditions() FlowSchemaConditionPatchArrayOutput {
	return o.ApplyT(func(v *FlowSchemaStatusPatch) []FlowSchemaConditionPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(FlowSchemaConditionPatchArrayOutput)
}

// GroupSubject holds detailed information for group-kind subject.
type GroupSubject struct {
	// name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required.
	Name string `pulumi:"name"`
}

// GroupSubjectInput is an input type that accepts GroupSubjectArgs and GroupSubjectOutput values.
// You can construct a concrete instance of `GroupSubjectInput` via:
//
//	GroupSubjectArgs{...}
type GroupSubjectInput interface {
	pulumi.Input

	ToGroupSubjectOutput() GroupSubjectOutput
	ToGroupSubjectOutputWithContext(context.Context) GroupSubjectOutput
}

// GroupSubject holds detailed information for group-kind subject.
type GroupSubjectArgs struct {
	// name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required.
	Name pulumi.StringInput `pulumi:"name"`
}

func (GroupSubjectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupSubject)(nil)).Elem()
}

func (i GroupSubjectArgs) ToGroupSubjectOutput() GroupSubjectOutput {
	return i.ToGroupSubjectOutputWithContext(context.Background())
}

func (i GroupSubjectArgs) ToGroupSubjectOutputWithContext(ctx context.Context) GroupSubjectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupSubjectOutput)
}

func (i GroupSubjectArgs) ToGroupSubjectPtrOutput() GroupSubjectPtrOutput {
	return i.ToGroupSubjectPtrOutputWithContext(context.Background())
}

func (i GroupSubjectArgs) ToGroupSubjectPtrOutputWithContext(ctx context.Context) GroupSubjectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupSubjectOutput).ToGroupSubjectPtrOutputWithContext(ctx)
}

// GroupSubjectPtrInput is an input type that accepts GroupSubjectArgs, GroupSubjectPtr and GroupSubjectPtrOutput values.
// You can construct a concrete instance of `GroupSubjectPtrInput` via:
//
//	        GroupSubjectArgs{...}
//
//	or:
//
//	        nil
type GroupSubjectPtrInput interface {
	pulumi.Input

	ToGroupSubjectPtrOutput() GroupSubjectPtrOutput
	ToGroupSubjectPtrOutputWithContext(context.Context) GroupSubjectPtrOutput
}

type groupSubjectPtrType GroupSubjectArgs

func GroupSubjectPtr(v *GroupSubjectArgs) GroupSubjectPtrInput {
	return (*groupSubjectPtrType)(v)
}

func (*groupSubjectPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupSubject)(nil)).Elem()
}

func (i *groupSubjectPtrType) ToGroupSubjectPtrOutput() GroupSubjectPtrOutput {
	return i.ToGroupSubjectPtrOutputWithContext(context.Background())
}

func (i *groupSubjectPtrType) ToGroupSubjectPtrOutputWithContext(ctx context.Context) GroupSubjectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupSubjectPtrOutput)
}

// GroupSubject holds detailed information for group-kind subject.
type GroupSubjectOutput struct{ *pulumi.OutputState }

func (GroupSubjectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupSubject)(nil)).Elem()
}

func (o GroupSubjectOutput) ToGroupSubjectOutput() GroupSubjectOutput {
	return o
}

func (o GroupSubjectOutput) ToGroupSubjectOutputWithContext(ctx context.Context) GroupSubjectOutput {
	return o
}

func (o GroupSubjectOutput) ToGroupSubjectPtrOutput() GroupSubjectPtrOutput {
	return o.ToGroupSubjectPtrOutputWithContext(context.Background())
}

func (o GroupSubjectOutput) ToGroupSubjectPtrOutputWithContext(ctx context.Context) GroupSubjectPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GroupSubject) *GroupSubject {
		return &v
	}).(GroupSubjectPtrOutput)
}

// name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required.
func (o GroupSubjectOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GroupSubject) string { return v.Name }).(pulumi.StringOutput)
}

type GroupSubjectPtrOutput struct{ *pulumi.OutputState }

func (GroupSubjectPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupSubject)(nil)).Elem()
}

func (o GroupSubjectPtrOutput) ToGroupSubjectPtrOutput() GroupSubjectPtrOutput {
	return o
}

func (o GroupSubjectPtrOutput) ToGroupSubjectPtrOutputWithContext(ctx context.Context) GroupSubjectPtrOutput {
	return o
}

func (o GroupSubjectPtrOutput) Elem() GroupSubjectOutput {
	return o.ApplyT(func(v *GroupSubject) GroupSubject {
		if v != nil {
			return *v
		}
		var ret GroupSubject
		return ret
	}).(GroupSubjectOutput)
}

// name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required.
func (o GroupSubjectPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GroupSubject) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// GroupSubject holds detailed information for group-kind subject.
type GroupSubjectPatch struct {
	// name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required.
	Name *string `pulumi:"name"`
}

// GroupSubjectPatchInput is an input type that accepts GroupSubjectPatchArgs and GroupSubjectPatchOutput values.
// You can construct a concrete instance of `GroupSubjectPatchInput` via:
//
//	GroupSubjectPatchArgs{...}
type GroupSubjectPatchInput interface {
	pulumi.Input

	ToGroupSubjectPatchOutput() GroupSubjectPatchOutput
	ToGroupSubjectPatchOutputWithContext(context.Context) GroupSubjectPatchOutput
}

// GroupSubject holds detailed information for group-kind subject.
type GroupSubjectPatchArgs struct {
	// name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (GroupSubjectPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupSubjectPatch)(nil)).Elem()
}

func (i GroupSubjectPatchArgs) ToGroupSubjectPatchOutput() GroupSubjectPatchOutput {
	return i.ToGroupSubjectPatchOutputWithContext(context.Background())
}

func (i GroupSubjectPatchArgs) ToGroupSubjectPatchOutputWithContext(ctx context.Context) GroupSubjectPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupSubjectPatchOutput)
}

func (i GroupSubjectPatchArgs) ToGroupSubjectPatchPtrOutput() GroupSubjectPatchPtrOutput {
	return i.ToGroupSubjectPatchPtrOutputWithContext(context.Background())
}

func (i GroupSubjectPatchArgs) ToGroupSubjectPatchPtrOutputWithContext(ctx context.Context) GroupSubjectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupSubjectPatchOutput).ToGroupSubjectPatchPtrOutputWithContext(ctx)
}

// GroupSubjectPatchPtrInput is an input type that accepts GroupSubjectPatchArgs, GroupSubjectPatchPtr and GroupSubjectPatchPtrOutput values.
// You can construct a concrete instance of `GroupSubjectPatchPtrInput` via:
//
//	        GroupSubjectPatchArgs{...}
//
//	or:
//
//	        nil
type GroupSubjectPatchPtrInput interface {
	pulumi.Input

	ToGroupSubjectPatchPtrOutput() GroupSubjectPatchPtrOutput
	ToGroupSubjectPatchPtrOutputWithContext(context.Context) GroupSubjectPatchPtrOutput
}

type groupSubjectPatchPtrType GroupSubjectPatchArgs

func GroupSubjectPatchPtr(v *GroupSubjectPatchArgs) GroupSubjectPatchPtrInput {
	return (*groupSubjectPatchPtrType)(v)
}

func (*groupSubjectPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupSubjectPatch)(nil)).Elem()
}

func (i *groupSubjectPatchPtrType) ToGroupSubjectPatchPtrOutput() GroupSubjectPatchPtrOutput {
	return i.ToGroupSubjectPatchPtrOutputWithContext(context.Background())
}

func (i *groupSubjectPatchPtrType) ToGroupSubjectPatchPtrOutputWithContext(ctx context.Context) GroupSubjectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupSubjectPatchPtrOutput)
}

// GroupSubject holds detailed information for group-kind subject.
type GroupSubjectPatchOutput struct{ *pulumi.OutputState }

func (GroupSubjectPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupSubjectPatch)(nil)).Elem()
}

func (o GroupSubjectPatchOutput) ToGroupSubjectPatchOutput() GroupSubjectPatchOutput {
	return o
}

func (o GroupSubjectPatchOutput) ToGroupSubjectPatchOutputWithContext(ctx context.Context) GroupSubjectPatchOutput {
	return o
}

func (o GroupSubjectPatchOutput) ToGroupSubjectPatchPtrOutput() GroupSubjectPatchPtrOutput {
	return o.ToGroupSubjectPatchPtrOutputWithContext(context.Background())
}

func (o GroupSubjectPatchOutput) ToGroupSubjectPatchPtrOutputWithContext(ctx context.Context) GroupSubjectPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GroupSubjectPatch) *GroupSubjectPatch {
		return &v
	}).(GroupSubjectPatchPtrOutput)
}

// name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required.
func (o GroupSubjectPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupSubjectPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type GroupSubjectPatchPtrOutput struct{ *pulumi.OutputState }

func (GroupSubjectPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupSubjectPatch)(nil)).Elem()
}

func (o GroupSubjectPatchPtrOutput) ToGroupSubjectPatchPtrOutput() GroupSubjectPatchPtrOutput {
	return o
}

func (o GroupSubjectPatchPtrOutput) ToGroupSubjectPatchPtrOutputWithContext(ctx context.Context) GroupSubjectPatchPtrOutput {
	return o
}

func (o GroupSubjectPatchPtrOutput) Elem() GroupSubjectPatchOutput {
	return o.ApplyT(func(v *GroupSubjectPatch) GroupSubjectPatch {
		if v != nil {
			return *v
		}
		var ret GroupSubjectPatch
		return ret
	}).(GroupSubjectPatchOutput)
}

// name is the user group that matches, or "*" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required.
func (o GroupSubjectPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GroupSubjectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// LimitResponse defines how to handle requests that can not be executed right now.
type LimitResponse struct {
	// `queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `"Queue"`.
	Queuing *QueuingConfiguration `pulumi:"queuing"`
	// `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required.
	Type string `pulumi:"type"`
}

// LimitResponseInput is an input type that accepts LimitResponseArgs and LimitResponseOutput values.
// You can construct a concrete instance of `LimitResponseInput` via:
//
//	LimitResponseArgs{...}
type LimitResponseInput interface {
	pulumi.Input

	ToLimitResponseOutput() LimitResponseOutput
	ToLimitResponseOutputWithContext(context.Context) LimitResponseOutput
}

// LimitResponse defines how to handle requests that can not be executed right now.
type LimitResponseArgs struct {
	// `queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `"Queue"`.
	Queuing QueuingConfigurationPtrInput `pulumi:"queuing"`
	// `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required.
	Type pulumi.StringInput `pulumi:"type"`
}

func (LimitResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LimitResponse)(nil)).Elem()
}

func (i LimitResponseArgs) ToLimitResponseOutput() LimitResponseOutput {
	return i.ToLimitResponseOutputWithContext(context.Background())
}

func (i LimitResponseArgs) ToLimitResponseOutputWithContext(ctx context.Context) LimitResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitResponseOutput)
}

func (i LimitResponseArgs) ToLimitResponsePtrOutput() LimitResponsePtrOutput {
	return i.ToLimitResponsePtrOutputWithContext(context.Background())
}

func (i LimitResponseArgs) ToLimitResponsePtrOutputWithContext(ctx context.Context) LimitResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitResponseOutput).ToLimitResponsePtrOutputWithContext(ctx)
}

// LimitResponsePtrInput is an input type that accepts LimitResponseArgs, LimitResponsePtr and LimitResponsePtrOutput values.
// You can construct a concrete instance of `LimitResponsePtrInput` via:
//
//	        LimitResponseArgs{...}
//
//	or:
//
//	        nil
type LimitResponsePtrInput interface {
	pulumi.Input

	ToLimitResponsePtrOutput() LimitResponsePtrOutput
	ToLimitResponsePtrOutputWithContext(context.Context) LimitResponsePtrOutput
}

type limitResponsePtrType LimitResponseArgs

func LimitResponsePtr(v *LimitResponseArgs) LimitResponsePtrInput {
	return (*limitResponsePtrType)(v)
}

func (*limitResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LimitResponse)(nil)).Elem()
}

func (i *limitResponsePtrType) ToLimitResponsePtrOutput() LimitResponsePtrOutput {
	return i.ToLimitResponsePtrOutputWithContext(context.Background())
}

func (i *limitResponsePtrType) ToLimitResponsePtrOutputWithContext(ctx context.Context) LimitResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitResponsePtrOutput)
}

// LimitResponse defines how to handle requests that can not be executed right now.
type LimitResponseOutput struct{ *pulumi.OutputState }

func (LimitResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LimitResponse)(nil)).Elem()
}

func (o LimitResponseOutput) ToLimitResponseOutput() LimitResponseOutput {
	return o
}

func (o LimitResponseOutput) ToLimitResponseOutputWithContext(ctx context.Context) LimitResponseOutput {
	return o
}

func (o LimitResponseOutput) ToLimitResponsePtrOutput() LimitResponsePtrOutput {
	return o.ToLimitResponsePtrOutputWithContext(context.Background())
}

func (o LimitResponseOutput) ToLimitResponsePtrOutputWithContext(ctx context.Context) LimitResponsePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LimitResponse) *LimitResponse {
		return &v
	}).(LimitResponsePtrOutput)
}

// `queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `"Queue"`.
func (o LimitResponseOutput) Queuing() QueuingConfigurationPtrOutput {
	return o.ApplyT(func(v LimitResponse) *QueuingConfiguration { return v.Queuing }).(QueuingConfigurationPtrOutput)
}

// `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required.
func (o LimitResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v LimitResponse) string { return v.Type }).(pulumi.StringOutput)
}

type LimitResponsePtrOutput struct{ *pulumi.OutputState }

func (LimitResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LimitResponse)(nil)).Elem()
}

func (o LimitResponsePtrOutput) ToLimitResponsePtrOutput() LimitResponsePtrOutput {
	return o
}

func (o LimitResponsePtrOutput) ToLimitResponsePtrOutputWithContext(ctx context.Context) LimitResponsePtrOutput {
	return o
}

func (o LimitResponsePtrOutput) Elem() LimitResponseOutput {
	return o.ApplyT(func(v *LimitResponse) LimitResponse {
		if v != nil {
			return *v
		}
		var ret LimitResponse
		return ret
	}).(LimitResponseOutput)
}

// `queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `"Queue"`.
func (o LimitResponsePtrOutput) Queuing() QueuingConfigurationPtrOutput {
	return o.ApplyT(func(v *LimitResponse) *QueuingConfiguration {
		if v == nil {
			return nil
		}
		return v.Queuing
	}).(QueuingConfigurationPtrOutput)
}

// `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required.
func (o LimitResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LimitResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// LimitResponse defines how to handle requests that can not be executed right now.
type LimitResponsePatch struct {
	// `queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `"Queue"`.
	Queuing *QueuingConfigurationPatch `pulumi:"queuing"`
	// `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required.
	Type *string `pulumi:"type"`
}

// LimitResponsePatchInput is an input type that accepts LimitResponsePatchArgs and LimitResponsePatchOutput values.
// You can construct a concrete instance of `LimitResponsePatchInput` via:
//
//	LimitResponsePatchArgs{...}
type LimitResponsePatchInput interface {
	pulumi.Input

	ToLimitResponsePatchOutput() LimitResponsePatchOutput
	ToLimitResponsePatchOutputWithContext(context.Context) LimitResponsePatchOutput
}

// LimitResponse defines how to handle requests that can not be executed right now.
type LimitResponsePatchArgs struct {
	// `queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `"Queue"`.
	Queuing QueuingConfigurationPatchPtrInput `pulumi:"queuing"`
	// `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (LimitResponsePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LimitResponsePatch)(nil)).Elem()
}

func (i LimitResponsePatchArgs) ToLimitResponsePatchOutput() LimitResponsePatchOutput {
	return i.ToLimitResponsePatchOutputWithContext(context.Background())
}

func (i LimitResponsePatchArgs) ToLimitResponsePatchOutputWithContext(ctx context.Context) LimitResponsePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitResponsePatchOutput)
}

func (i LimitResponsePatchArgs) ToLimitResponsePatchPtrOutput() LimitResponsePatchPtrOutput {
	return i.ToLimitResponsePatchPtrOutputWithContext(context.Background())
}

func (i LimitResponsePatchArgs) ToLimitResponsePatchPtrOutputWithContext(ctx context.Context) LimitResponsePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitResponsePatchOutput).ToLimitResponsePatchPtrOutputWithContext(ctx)
}

// LimitResponsePatchPtrInput is an input type that accepts LimitResponsePatchArgs, LimitResponsePatchPtr and LimitResponsePatchPtrOutput values.
// You can construct a concrete instance of `LimitResponsePatchPtrInput` via:
//
//	        LimitResponsePatchArgs{...}
//
//	or:
//
//	        nil
type LimitResponsePatchPtrInput interface {
	pulumi.Input

	ToLimitResponsePatchPtrOutput() LimitResponsePatchPtrOutput
	ToLimitResponsePatchPtrOutputWithContext(context.Context) LimitResponsePatchPtrOutput
}

type limitResponsePatchPtrType LimitResponsePatchArgs

func LimitResponsePatchPtr(v *LimitResponsePatchArgs) LimitResponsePatchPtrInput {
	return (*limitResponsePatchPtrType)(v)
}

func (*limitResponsePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LimitResponsePatch)(nil)).Elem()
}

func (i *limitResponsePatchPtrType) ToLimitResponsePatchPtrOutput() LimitResponsePatchPtrOutput {
	return i.ToLimitResponsePatchPtrOutputWithContext(context.Background())
}

func (i *limitResponsePatchPtrType) ToLimitResponsePatchPtrOutputWithContext(ctx context.Context) LimitResponsePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitResponsePatchPtrOutput)
}

// LimitResponse defines how to handle requests that can not be executed right now.
type LimitResponsePatchOutput struct{ *pulumi.OutputState }

func (LimitResponsePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LimitResponsePatch)(nil)).Elem()
}

func (o LimitResponsePatchOutput) ToLimitResponsePatchOutput() LimitResponsePatchOutput {
	return o
}

func (o LimitResponsePatchOutput) ToLimitResponsePatchOutputWithContext(ctx context.Context) LimitResponsePatchOutput {
	return o
}

func (o LimitResponsePatchOutput) ToLimitResponsePatchPtrOutput() LimitResponsePatchPtrOutput {
	return o.ToLimitResponsePatchPtrOutputWithContext(context.Background())
}

func (o LimitResponsePatchOutput) ToLimitResponsePatchPtrOutputWithContext(ctx context.Context) LimitResponsePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LimitResponsePatch) *LimitResponsePatch {
		return &v
	}).(LimitResponsePatchPtrOutput)
}

// `queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `"Queue"`.
func (o LimitResponsePatchOutput) Queuing() QueuingConfigurationPatchPtrOutput {
	return o.ApplyT(func(v LimitResponsePatch) *QueuingConfigurationPatch { return v.Queuing }).(QueuingConfigurationPatchPtrOutput)
}

// `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required.
func (o LimitResponsePatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LimitResponsePatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type LimitResponsePatchPtrOutput struct{ *pulumi.OutputState }

func (LimitResponsePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LimitResponsePatch)(nil)).Elem()
}

func (o LimitResponsePatchPtrOutput) ToLimitResponsePatchPtrOutput() LimitResponsePatchPtrOutput {
	return o
}

func (o LimitResponsePatchPtrOutput) ToLimitResponsePatchPtrOutputWithContext(ctx context.Context) LimitResponsePatchPtrOutput {
	return o
}

func (o LimitResponsePatchPtrOutput) Elem() LimitResponsePatchOutput {
	return o.ApplyT(func(v *LimitResponsePatch) LimitResponsePatch {
		if v != nil {
			return *v
		}
		var ret LimitResponsePatch
		return ret
	}).(LimitResponsePatchOutput)
}

// `queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `"Queue"`.
func (o LimitResponsePatchPtrOutput) Queuing() QueuingConfigurationPatchPtrOutput {
	return o.ApplyT(func(v *LimitResponsePatch) *QueuingConfigurationPatch {
		if v == nil {
			return nil
		}
		return v.Queuing
	}).(QueuingConfigurationPatchPtrOutput)
}

// `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. "Reject" means that requests that can not be executed upon arrival are rejected. Required.
func (o LimitResponsePatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LimitResponsePatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to limits. It addresses two issues:
//   - How are requests for this priority level limited?
//   - What should be done with requests that exceed the limit?
type LimitedPriorityLevelConfiguration struct {
	// `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the number of requests of this priority level that may be exeucting at a given time.  ACS must be a positive number. The server's concurrency limit (SCL) is divided among the concurrency-controlled priority levels in proportion to their assured concurrency shares. This produces the assured concurrency value (ACV) --- the number of requests that may be executing at a time --- for each such priority level:
	//
	//             ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
	//
	// bigger numbers of ACS mean more reserved concurrent requests (at the expense of every other PL). This field has a default value of 30.
	AssuredConcurrencyShares *int `pulumi:"assuredConcurrencyShares"`
	// `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
	//
	// BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
	//
	// The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
	BorrowingLimitPercent *int `pulumi:"borrowingLimitPercent"`
	// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
	//
	// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
	LendablePercent *int `pulumi:"lendablePercent"`
	// `limitResponse` indicates what to do with requests that can not be executed right now
	LimitResponse *LimitResponse `pulumi:"limitResponse"`
}

// LimitedPriorityLevelConfigurationInput is an input type that accepts LimitedPriorityLevelConfigurationArgs and LimitedPriorityLevelConfigurationOutput values.
// You can construct a concrete instance of `LimitedPriorityLevelConfigurationInput` via:
//
//	LimitedPriorityLevelConfigurationArgs{...}
type LimitedPriorityLevelConfigurationInput interface {
	pulumi.Input

	ToLimitedPriorityLevelConfigurationOutput() LimitedPriorityLevelConfigurationOutput
	ToLimitedPriorityLevelConfigurationOutputWithContext(context.Context) LimitedPriorityLevelConfigurationOutput
}

// LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to limits. It addresses two issues:
//   - How are requests for this priority level limited?
//   - What should be done with requests that exceed the limit?
type LimitedPriorityLevelConfigurationArgs struct {
	// `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the number of requests of this priority level that may be exeucting at a given time.  ACS must be a positive number. The server's concurrency limit (SCL) is divided among the concurrency-controlled priority levels in proportion to their assured concurrency shares. This produces the assured concurrency value (ACV) --- the number of requests that may be executing at a time --- for each such priority level:
	//
	//             ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
	//
	// bigger numbers of ACS mean more reserved concurrent requests (at the expense of every other PL). This field has a default value of 30.
	AssuredConcurrencyShares pulumi.IntPtrInput `pulumi:"assuredConcurrencyShares"`
	// `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
	//
	// BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
	//
	// The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
	BorrowingLimitPercent pulumi.IntPtrInput `pulumi:"borrowingLimitPercent"`
	// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
	//
	// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
	LendablePercent pulumi.IntPtrInput `pulumi:"lendablePercent"`
	// `limitResponse` indicates what to do with requests that can not be executed right now
	LimitResponse LimitResponsePtrInput `pulumi:"limitResponse"`
}

func (LimitedPriorityLevelConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LimitedPriorityLevelConfiguration)(nil)).Elem()
}

func (i LimitedPriorityLevelConfigurationArgs) ToLimitedPriorityLevelConfigurationOutput() LimitedPriorityLevelConfigurationOutput {
	return i.ToLimitedPriorityLevelConfigurationOutputWithContext(context.Background())
}

func (i LimitedPriorityLevelConfigurationArgs) ToLimitedPriorityLevelConfigurationOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitedPriorityLevelConfigurationOutput)
}

func (i LimitedPriorityLevelConfigurationArgs) ToLimitedPriorityLevelConfigurationPtrOutput() LimitedPriorityLevelConfigurationPtrOutput {
	return i.ToLimitedPriorityLevelConfigurationPtrOutputWithContext(context.Background())
}

func (i LimitedPriorityLevelConfigurationArgs) ToLimitedPriorityLevelConfigurationPtrOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitedPriorityLevelConfigurationOutput).ToLimitedPriorityLevelConfigurationPtrOutputWithContext(ctx)
}

// LimitedPriorityLevelConfigurationPtrInput is an input type that accepts LimitedPriorityLevelConfigurationArgs, LimitedPriorityLevelConfigurationPtr and LimitedPriorityLevelConfigurationPtrOutput values.
// You can construct a concrete instance of `LimitedPriorityLevelConfigurationPtrInput` via:
//
//	        LimitedPriorityLevelConfigurationArgs{...}
//
//	or:
//
//	        nil
type LimitedPriorityLevelConfigurationPtrInput interface {
	pulumi.Input

	ToLimitedPriorityLevelConfigurationPtrOutput() LimitedPriorityLevelConfigurationPtrOutput
	ToLimitedPriorityLevelConfigurationPtrOutputWithContext(context.Context) LimitedPriorityLevelConfigurationPtrOutput
}

type limitedPriorityLevelConfigurationPtrType LimitedPriorityLevelConfigurationArgs

func LimitedPriorityLevelConfigurationPtr(v *LimitedPriorityLevelConfigurationArgs) LimitedPriorityLevelConfigurationPtrInput {
	return (*limitedPriorityLevelConfigurationPtrType)(v)
}

func (*limitedPriorityLevelConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LimitedPriorityLevelConfiguration)(nil)).Elem()
}

func (i *limitedPriorityLevelConfigurationPtrType) ToLimitedPriorityLevelConfigurationPtrOutput() LimitedPriorityLevelConfigurationPtrOutput {
	return i.ToLimitedPriorityLevelConfigurationPtrOutputWithContext(context.Background())
}

func (i *limitedPriorityLevelConfigurationPtrType) ToLimitedPriorityLevelConfigurationPtrOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitedPriorityLevelConfigurationPtrOutput)
}

// LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to limits. It addresses two issues:
//   - How are requests for this priority level limited?
//   - What should be done with requests that exceed the limit?
type LimitedPriorityLevelConfigurationOutput struct{ *pulumi.OutputState }

func (LimitedPriorityLevelConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LimitedPriorityLevelConfiguration)(nil)).Elem()
}

func (o LimitedPriorityLevelConfigurationOutput) ToLimitedPriorityLevelConfigurationOutput() LimitedPriorityLevelConfigurationOutput {
	return o
}

func (o LimitedPriorityLevelConfigurationOutput) ToLimitedPriorityLevelConfigurationOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationOutput {
	return o
}

func (o LimitedPriorityLevelConfigurationOutput) ToLimitedPriorityLevelConfigurationPtrOutput() LimitedPriorityLevelConfigurationPtrOutput {
	return o.ToLimitedPriorityLevelConfigurationPtrOutputWithContext(context.Background())
}

func (o LimitedPriorityLevelConfigurationOutput) ToLimitedPriorityLevelConfigurationPtrOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LimitedPriorityLevelConfiguration) *LimitedPriorityLevelConfiguration {
		return &v
	}).(LimitedPriorityLevelConfigurationPtrOutput)
}

// `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the number of requests of this priority level that may be exeucting at a given time.  ACS must be a positive number. The server's concurrency limit (SCL) is divided among the concurrency-controlled priority levels in proportion to their assured concurrency shares. This produces the assured concurrency value (ACV) --- the number of requests that may be executing at a time --- for each such priority level:
//
//	ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
//
// bigger numbers of ACS mean more reserved concurrent requests (at the expense of every other PL). This field has a default value of 30.
func (o LimitedPriorityLevelConfigurationOutput) AssuredConcurrencyShares() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LimitedPriorityLevelConfiguration) *int { return v.AssuredConcurrencyShares }).(pulumi.IntPtrOutput)
}

// `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
//
// BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
//
// The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
func (o LimitedPriorityLevelConfigurationOutput) BorrowingLimitPercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LimitedPriorityLevelConfiguration) *int { return v.BorrowingLimitPercent }).(pulumi.IntPtrOutput)
}

// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
//
// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
func (o LimitedPriorityLevelConfigurationOutput) LendablePercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LimitedPriorityLevelConfiguration) *int { return v.LendablePercent }).(pulumi.IntPtrOutput)
}

// `limitResponse` indicates what to do with requests that can not be executed right now
func (o LimitedPriorityLevelConfigurationOutput) LimitResponse() LimitResponsePtrOutput {
	return o.ApplyT(func(v LimitedPriorityLevelConfiguration) *LimitResponse { return v.LimitResponse }).(LimitResponsePtrOutput)
}

type LimitedPriorityLevelConfigurationPtrOutput struct{ *pulumi.OutputState }

func (LimitedPriorityLevelConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LimitedPriorityLevelConfiguration)(nil)).Elem()
}

func (o LimitedPriorityLevelConfigurationPtrOutput) ToLimitedPriorityLevelConfigurationPtrOutput() LimitedPriorityLevelConfigurationPtrOutput {
	return o
}

func (o LimitedPriorityLevelConfigurationPtrOutput) ToLimitedPriorityLevelConfigurationPtrOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPtrOutput {
	return o
}

func (o LimitedPriorityLevelConfigurationPtrOutput) Elem() LimitedPriorityLevelConfigurationOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfiguration) LimitedPriorityLevelConfiguration {
		if v != nil {
			return *v
		}
		var ret LimitedPriorityLevelConfiguration
		return ret
	}).(LimitedPriorityLevelConfigurationOutput)
}

// `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the number of requests of this priority level that may be exeucting at a given time.  ACS must be a positive number. The server's concurrency limit (SCL) is divided among the concurrency-controlled priority levels in proportion to their assured concurrency shares. This produces the assured concurrency value (ACV) --- the number of requests that may be executing at a time --- for each such priority level:
//
//	ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
//
// bigger numbers of ACS mean more reserved concurrent requests (at the expense of every other PL). This field has a default value of 30.
func (o LimitedPriorityLevelConfigurationPtrOutput) AssuredConcurrencyShares() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.AssuredConcurrencyShares
	}).(pulumi.IntPtrOutput)
}

// `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
//
// BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
//
// The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
func (o LimitedPriorityLevelConfigurationPtrOutput) BorrowingLimitPercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.BorrowingLimitPercent
	}).(pulumi.IntPtrOutput)
}

// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
//
// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
func (o LimitedPriorityLevelConfigurationPtrOutput) LendablePercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.LendablePercent
	}).(pulumi.IntPtrOutput)
}

// `limitResponse` indicates what to do with requests that can not be executed right now
func (o LimitedPriorityLevelConfigurationPtrOutput) LimitResponse() LimitResponsePtrOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfiguration) *LimitResponse {
		if v == nil {
			return nil
		}
		return v.LimitResponse
	}).(LimitResponsePtrOutput)
}

// LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to limits. It addresses two issues:
//   - How are requests for this priority level limited?
//   - What should be done with requests that exceed the limit?
type LimitedPriorityLevelConfigurationPatch struct {
	// `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the number of requests of this priority level that may be exeucting at a given time.  ACS must be a positive number. The server's concurrency limit (SCL) is divided among the concurrency-controlled priority levels in proportion to their assured concurrency shares. This produces the assured concurrency value (ACV) --- the number of requests that may be executing at a time --- for each such priority level:
	//
	//             ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
	//
	// bigger numbers of ACS mean more reserved concurrent requests (at the expense of every other PL). This field has a default value of 30.
	AssuredConcurrencyShares *int `pulumi:"assuredConcurrencyShares"`
	// `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
	//
	// BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
	//
	// The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
	BorrowingLimitPercent *int `pulumi:"borrowingLimitPercent"`
	// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
	//
	// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
	LendablePercent *int `pulumi:"lendablePercent"`
	// `limitResponse` indicates what to do with requests that can not be executed right now
	LimitResponse *LimitResponsePatch `pulumi:"limitResponse"`
}

// LimitedPriorityLevelConfigurationPatchInput is an input type that accepts LimitedPriorityLevelConfigurationPatchArgs and LimitedPriorityLevelConfigurationPatchOutput values.
// You can construct a concrete instance of `LimitedPriorityLevelConfigurationPatchInput` via:
//
//	LimitedPriorityLevelConfigurationPatchArgs{...}
type LimitedPriorityLevelConfigurationPatchInput interface {
	pulumi.Input

	ToLimitedPriorityLevelConfigurationPatchOutput() LimitedPriorityLevelConfigurationPatchOutput
	ToLimitedPriorityLevelConfigurationPatchOutputWithContext(context.Context) LimitedPriorityLevelConfigurationPatchOutput
}

// LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to limits. It addresses two issues:
//   - How are requests for this priority level limited?
//   - What should be done with requests that exceed the limit?
type LimitedPriorityLevelConfigurationPatchArgs struct {
	// `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the number of requests of this priority level that may be exeucting at a given time.  ACS must be a positive number. The server's concurrency limit (SCL) is divided among the concurrency-controlled priority levels in proportion to their assured concurrency shares. This produces the assured concurrency value (ACV) --- the number of requests that may be executing at a time --- for each such priority level:
	//
	//             ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
	//
	// bigger numbers of ACS mean more reserved concurrent requests (at the expense of every other PL). This field has a default value of 30.
	AssuredConcurrencyShares pulumi.IntPtrInput `pulumi:"assuredConcurrencyShares"`
	// `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
	//
	// BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
	//
	// The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
	BorrowingLimitPercent pulumi.IntPtrInput `pulumi:"borrowingLimitPercent"`
	// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
	//
	// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
	LendablePercent pulumi.IntPtrInput `pulumi:"lendablePercent"`
	// `limitResponse` indicates what to do with requests that can not be executed right now
	LimitResponse LimitResponsePatchPtrInput `pulumi:"limitResponse"`
}

func (LimitedPriorityLevelConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LimitedPriorityLevelConfigurationPatch)(nil)).Elem()
}

func (i LimitedPriorityLevelConfigurationPatchArgs) ToLimitedPriorityLevelConfigurationPatchOutput() LimitedPriorityLevelConfigurationPatchOutput {
	return i.ToLimitedPriorityLevelConfigurationPatchOutputWithContext(context.Background())
}

func (i LimitedPriorityLevelConfigurationPatchArgs) ToLimitedPriorityLevelConfigurationPatchOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitedPriorityLevelConfigurationPatchOutput)
}

func (i LimitedPriorityLevelConfigurationPatchArgs) ToLimitedPriorityLevelConfigurationPatchPtrOutput() LimitedPriorityLevelConfigurationPatchPtrOutput {
	return i.ToLimitedPriorityLevelConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i LimitedPriorityLevelConfigurationPatchArgs) ToLimitedPriorityLevelConfigurationPatchPtrOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitedPriorityLevelConfigurationPatchOutput).ToLimitedPriorityLevelConfigurationPatchPtrOutputWithContext(ctx)
}

// LimitedPriorityLevelConfigurationPatchPtrInput is an input type that accepts LimitedPriorityLevelConfigurationPatchArgs, LimitedPriorityLevelConfigurationPatchPtr and LimitedPriorityLevelConfigurationPatchPtrOutput values.
// You can construct a concrete instance of `LimitedPriorityLevelConfigurationPatchPtrInput` via:
//
//	        LimitedPriorityLevelConfigurationPatchArgs{...}
//
//	or:
//
//	        nil
type LimitedPriorityLevelConfigurationPatchPtrInput interface {
	pulumi.Input

	ToLimitedPriorityLevelConfigurationPatchPtrOutput() LimitedPriorityLevelConfigurationPatchPtrOutput
	ToLimitedPriorityLevelConfigurationPatchPtrOutputWithContext(context.Context) LimitedPriorityLevelConfigurationPatchPtrOutput
}

type limitedPriorityLevelConfigurationPatchPtrType LimitedPriorityLevelConfigurationPatchArgs

func LimitedPriorityLevelConfigurationPatchPtr(v *LimitedPriorityLevelConfigurationPatchArgs) LimitedPriorityLevelConfigurationPatchPtrInput {
	return (*limitedPriorityLevelConfigurationPatchPtrType)(v)
}

func (*limitedPriorityLevelConfigurationPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LimitedPriorityLevelConfigurationPatch)(nil)).Elem()
}

func (i *limitedPriorityLevelConfigurationPatchPtrType) ToLimitedPriorityLevelConfigurationPatchPtrOutput() LimitedPriorityLevelConfigurationPatchPtrOutput {
	return i.ToLimitedPriorityLevelConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i *limitedPriorityLevelConfigurationPatchPtrType) ToLimitedPriorityLevelConfigurationPatchPtrOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LimitedPriorityLevelConfigurationPatchPtrOutput)
}

// LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to limits. It addresses two issues:
//   - How are requests for this priority level limited?
//   - What should be done with requests that exceed the limit?
type LimitedPriorityLevelConfigurationPatchOutput struct{ *pulumi.OutputState }

func (LimitedPriorityLevelConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LimitedPriorityLevelConfigurationPatch)(nil)).Elem()
}

func (o LimitedPriorityLevelConfigurationPatchOutput) ToLimitedPriorityLevelConfigurationPatchOutput() LimitedPriorityLevelConfigurationPatchOutput {
	return o
}

func (o LimitedPriorityLevelConfigurationPatchOutput) ToLimitedPriorityLevelConfigurationPatchOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPatchOutput {
	return o
}

func (o LimitedPriorityLevelConfigurationPatchOutput) ToLimitedPriorityLevelConfigurationPatchPtrOutput() LimitedPriorityLevelConfigurationPatchPtrOutput {
	return o.ToLimitedPriorityLevelConfigurationPatchPtrOutputWithContext(context.Background())
}

func (o LimitedPriorityLevelConfigurationPatchOutput) ToLimitedPriorityLevelConfigurationPatchPtrOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LimitedPriorityLevelConfigurationPatch) *LimitedPriorityLevelConfigurationPatch {
		return &v
	}).(LimitedPriorityLevelConfigurationPatchPtrOutput)
}

// `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the number of requests of this priority level that may be exeucting at a given time.  ACS must be a positive number. The server's concurrency limit (SCL) is divided among the concurrency-controlled priority levels in proportion to their assured concurrency shares. This produces the assured concurrency value (ACV) --- the number of requests that may be executing at a time --- for each such priority level:
//
//	ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
//
// bigger numbers of ACS mean more reserved concurrent requests (at the expense of every other PL). This field has a default value of 30.
func (o LimitedPriorityLevelConfigurationPatchOutput) AssuredConcurrencyShares() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LimitedPriorityLevelConfigurationPatch) *int { return v.AssuredConcurrencyShares }).(pulumi.IntPtrOutput)
}

// `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
//
// BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
//
// The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
func (o LimitedPriorityLevelConfigurationPatchOutput) BorrowingLimitPercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LimitedPriorityLevelConfigurationPatch) *int { return v.BorrowingLimitPercent }).(pulumi.IntPtrOutput)
}

// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
//
// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
func (o LimitedPriorityLevelConfigurationPatchOutput) LendablePercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LimitedPriorityLevelConfigurationPatch) *int { return v.LendablePercent }).(pulumi.IntPtrOutput)
}

// `limitResponse` indicates what to do with requests that can not be executed right now
func (o LimitedPriorityLevelConfigurationPatchOutput) LimitResponse() LimitResponsePatchPtrOutput {
	return o.ApplyT(func(v LimitedPriorityLevelConfigurationPatch) *LimitResponsePatch { return v.LimitResponse }).(LimitResponsePatchPtrOutput)
}

type LimitedPriorityLevelConfigurationPatchPtrOutput struct{ *pulumi.OutputState }

func (LimitedPriorityLevelConfigurationPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LimitedPriorityLevelConfigurationPatch)(nil)).Elem()
}

func (o LimitedPriorityLevelConfigurationPatchPtrOutput) ToLimitedPriorityLevelConfigurationPatchPtrOutput() LimitedPriorityLevelConfigurationPatchPtrOutput {
	return o
}

func (o LimitedPriorityLevelConfigurationPatchPtrOutput) ToLimitedPriorityLevelConfigurationPatchPtrOutputWithContext(ctx context.Context) LimitedPriorityLevelConfigurationPatchPtrOutput {
	return o
}

func (o LimitedPriorityLevelConfigurationPatchPtrOutput) Elem() LimitedPriorityLevelConfigurationPatchOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfigurationPatch) LimitedPriorityLevelConfigurationPatch {
		if v != nil {
			return *v
		}
		var ret LimitedPriorityLevelConfigurationPatch
		return ret
	}).(LimitedPriorityLevelConfigurationPatchOutput)
}

// `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the number of requests of this priority level that may be exeucting at a given time.  ACS must be a positive number. The server's concurrency limit (SCL) is divided among the concurrency-controlled priority levels in proportion to their assured concurrency shares. This produces the assured concurrency value (ACV) --- the number of requests that may be executing at a time --- for each such priority level:
//
//	ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
//
// bigger numbers of ACS mean more reserved concurrent requests (at the expense of every other PL). This field has a default value of 30.
func (o LimitedPriorityLevelConfigurationPatchPtrOutput) AssuredConcurrencyShares() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfigurationPatch) *int {
		if v == nil {
			return nil
		}
		return v.AssuredConcurrencyShares
	}).(pulumi.IntPtrOutput)
}

// `borrowingLimitPercent`, if present, configures a limit on how many seats this priority level can borrow from other priority levels. The limit is known as this level's BorrowingConcurrencyLimit (BorrowingCL) and is a limit on the total number of seats that this level may borrow at any one time. This field holds the ratio of that limit to the level's nominal concurrency limit. When this field is non-nil, it must hold a non-negative integer and the limit is calculated as follows.
//
// BorrowingCL(i) = round( NominalCL(i) * borrowingLimitPercent(i)/100.0 )
//
// The value of this field can be more than 100, implying that this priority level can borrow a number of seats that is greater than its own nominal concurrency limit (NominalCL). When this field is left `nil`, the limit is effectively infinite.
func (o LimitedPriorityLevelConfigurationPatchPtrOutput) BorrowingLimitPercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfigurationPatch) *int {
		if v == nil {
			return nil
		}
		return v.BorrowingLimitPercent
	}).(pulumi.IntPtrOutput)
}

// `lendablePercent` prescribes the fraction of the level's NominalCL that can be borrowed by other priority levels. The value of this field must be between 0 and 100, inclusive, and it defaults to 0. The number of seats that other levels can borrow from this level, known as this level's LendableConcurrencyLimit (LendableCL), is defined as follows.
//
// LendableCL(i) = round( NominalCL(i) * lendablePercent(i)/100.0 )
func (o LimitedPriorityLevelConfigurationPatchPtrOutput) LendablePercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfigurationPatch) *int {
		if v == nil {
			return nil
		}
		return v.LendablePercent
	}).(pulumi.IntPtrOutput)
}

// `limitResponse` indicates what to do with requests that can not be executed right now
func (o LimitedPriorityLevelConfigurationPatchPtrOutput) LimitResponse() LimitResponsePatchPtrOutput {
	return o.ApplyT(func(v *LimitedPriorityLevelConfigurationPatch) *LimitResponsePatch {
		if v == nil {
			return nil
		}
		return v.LimitResponse
	}).(LimitResponsePatchPtrOutput)
}

// NonResourcePolicyRule is a predicate that matches non-resource requests according to their verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only if both (a) at least one member of verbs matches the request and (b) at least one member of nonResourceURLs matches the request.
type NonResourcePolicyRule struct {
	// `nonResourceURLs` is a set of url prefixes that a user should have access to and may not be empty. For example:
	//   - "/healthz" is legal
	//   - "/hea*" is illegal
	//   - "/hea" is legal but matches nothing
	//   - "/hea/*" also matches nothing
	//   - "/healthz/*" matches all per-component health checks.
	//     "*" matches all non-resource urls. if it is present, it must be the only entry. Required.
	NonResourceURLs []string `pulumi:"nonResourceURLs"`
	// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it is present, it must be the only entry. Required.
	Verbs []string `pulumi:"verbs"`
}

// NonResourcePolicyRuleInput is an input type that accepts NonResourcePolicyRuleArgs and NonResourcePolicyRuleOutput values.
// You can construct a concrete instance of `NonResourcePolicyRuleInput` via:
//
//	NonResourcePolicyRuleArgs{...}
type NonResourcePolicyRuleInput interface {
	pulumi.Input

	ToNonResourcePolicyRuleOutput() NonResourcePolicyRuleOutput
	ToNonResourcePolicyRuleOutputWithContext(context.Context) NonResourcePolicyRuleOutput
}

// NonResourcePolicyRule is a predicate that matches non-resource requests according to their verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only if both (a) at least one member of verbs matches the request and (b) at least one member of nonResourceURLs matches the request.
type NonResourcePolicyRuleArgs struct {
	// `nonResourceURLs` is a set of url prefixes that a user should have access to and may not be empty. For example:
	//   - "/healthz" is legal
	//   - "/hea*" is illegal
	//   - "/hea" is legal but matches nothing
	//   - "/hea/*" also matches nothing
	//   - "/healthz/*" matches all per-component health checks.
	//     "*" matches all non-resource urls. if it is present, it must be the only entry. Required.
	NonResourceURLs pulumi.StringArrayInput `pulumi:"nonResourceURLs"`
	// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it is present, it must be the only entry. Required.
	Verbs pulumi.StringArrayInput `pulumi:"verbs"`
}

func (NonResourcePolicyRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NonResourcePolicyRule)(nil)).Elem()
}

func (i NonResourcePolicyRuleArgs) ToNonResourcePolicyRuleOutput() NonResourcePolicyRuleOutput {
	return i.ToNonResourcePolicyRuleOutputWithContext(context.Background())
}

func (i NonResourcePolicyRuleArgs) ToNonResourcePolicyRuleOutputWithContext(ctx context.Context) NonResourcePolicyRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NonResourcePolicyRuleOutput)
}

// NonResourcePolicyRuleArrayInput is an input type that accepts NonResourcePolicyRuleArray and NonResourcePolicyRuleArrayOutput values.
// You can construct a concrete instance of `NonResourcePolicyRuleArrayInput` via:
//
//	NonResourcePolicyRuleArray{ NonResourcePolicyRuleArgs{...} }
type NonResourcePolicyRuleArrayInput interface {
	pulumi.Input

	ToNonResourcePolicyRuleArrayOutput() NonResourcePolicyRuleArrayOutput
	ToNonResourcePolicyRuleArrayOutputWithContext(context.Context) NonResourcePolicyRuleArrayOutput
}

type NonResourcePolicyRuleArray []NonResourcePolicyRuleInput

func (NonResourcePolicyRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NonResourcePolicyRule)(nil)).Elem()
}

func (i NonResourcePolicyRuleArray) ToNonResourcePolicyRuleArrayOutput() NonResourcePolicyRuleArrayOutput {
	return i.ToNonResourcePolicyRuleArrayOutputWithContext(context.Background())
}

func (i NonResourcePolicyRuleArray) ToNonResourcePolicyRuleArrayOutputWithContext(ctx context.Context) NonResourcePolicyRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NonResourcePolicyRuleArrayOutput)
}

// NonResourcePolicyRule is a predicate that matches non-resource requests according to their verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only if both (a) at least one member of verbs matches the request and (b) at least one member of nonResourceURLs matches the request.
type NonResourcePolicyRuleOutput struct{ *pulumi.OutputState }

func (NonResourcePolicyRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NonResourcePolicyRule)(nil)).Elem()
}

func (o NonResourcePolicyRuleOutput) ToNonResourcePolicyRuleOutput() NonResourcePolicyRuleOutput {
	return o
}

func (o NonResourcePolicyRuleOutput) ToNonResourcePolicyRuleOutputWithContext(ctx context.Context) NonResourcePolicyRuleOutput {
	return o
}

// `nonResourceURLs` is a set of url prefixes that a user should have access to and may not be empty. For example:
//   - "/healthz" is legal
//   - "/hea*" is illegal
//   - "/hea" is legal but matches nothing
//   - "/hea/*" also matches nothing
//   - "/healthz/*" matches all per-component health checks.
//     "*" matches all non-resource urls. if it is present, it must be the only entry. Required.
func (o NonResourcePolicyRuleOutput) NonResourceURLs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NonResourcePolicyRule) []string { return v.NonResourceURLs }).(pulumi.StringArrayOutput)
}

// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it is present, it must be the only entry. Required.
func (o NonResourcePolicyRuleOutput) Verbs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NonResourcePolicyRule) []string { return v.Verbs }).(pulumi.StringArrayOutput)
}

type NonResourcePolicyRuleArrayOutput struct{ *pulumi.OutputState }

func (NonResourcePolicyRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NonResourcePolicyRule)(nil)).Elem()
}

func (o NonResourcePolicyRuleArrayOutput) ToNonResourcePolicyRuleArrayOutput() NonResourcePolicyRuleArrayOutput {
	return o
}

func (o NonResourcePolicyRuleArrayOutput) ToNonResourcePolicyRuleArrayOutputWithContext(ctx context.Context) NonResourcePolicyRuleArrayOutput {
	return o
}

func (o NonResourcePolicyRuleArrayOutput) Index(i pulumi.IntInput) NonResourcePolicyRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NonResourcePolicyRule {
		return vs[0].([]NonResourcePolicyRule)[vs[1].(int)]
	}).(NonResourcePolicyRuleOutput)
}

// NonResourcePolicyRule is a predicate that matches non-resource requests according to their verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only if both (a) at least one member of verbs matches the request and (b) at least one member of nonResourceURLs matches the request.
type NonResourcePolicyRulePatch struct {
	// `nonResourceURLs` is a set of url prefixes that a user should have access to and may not be empty. For example:
	//   - "/healthz" is legal
	//   - "/hea*" is illegal
	//   - "/hea" is legal but matches nothing
	//   - "/hea/*" also matches nothing
	//   - "/healthz/*" matches all per-component health checks.
	//     "*" matches all non-resource urls. if it is present, it must be the only entry. Required.
	NonResourceURLs []string `pulumi:"nonResourceURLs"`
	// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it is present, it must be the only entry. Required.
	Verbs []string `pulumi:"verbs"`
}

// NonResourcePolicyRulePatchInput is an input type that accepts NonResourcePolicyRulePatchArgs and NonResourcePolicyRulePatchOutput values.
// You can construct a concrete instance of `NonResourcePolicyRulePatchInput` via:
//
//	NonResourcePolicyRulePatchArgs{...}
type NonResourcePolicyRulePatchInput interface {
	pulumi.Input

	ToNonResourcePolicyRulePatchOutput() NonResourcePolicyRulePatchOutput
	ToNonResourcePolicyRulePatchOutputWithContext(context.Context) NonResourcePolicyRulePatchOutput
}

// NonResourcePolicyRule is a predicate that matches non-resource requests according to their verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only if both (a) at least one member of verbs matches the request and (b) at least one member of nonResourceURLs matches the request.
type NonResourcePolicyRulePatchArgs struct {
	// `nonResourceURLs` is a set of url prefixes that a user should have access to and may not be empty. For example:
	//   - "/healthz" is legal
	//   - "/hea*" is illegal
	//   - "/hea" is legal but matches nothing
	//   - "/hea/*" also matches nothing
	//   - "/healthz/*" matches all per-component health checks.
	//     "*" matches all non-resource urls. if it is present, it must be the only entry. Required.
	NonResourceURLs pulumi.StringArrayInput `pulumi:"nonResourceURLs"`
	// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it is present, it must be the only entry. Required.
	Verbs pulumi.StringArrayInput `pulumi:"verbs"`
}

func (NonResourcePolicyRulePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NonResourcePolicyRulePatch)(nil)).Elem()
}

func (i NonResourcePolicyRulePatchArgs) ToNonResourcePolicyRulePatchOutput() NonResourcePolicyRulePatchOutput {
	return i.ToNonResourcePolicyRulePatchOutputWithContext(context.Background())
}

func (i NonResourcePolicyRulePatchArgs) ToNonResourcePolicyRulePatchOutputWithContext(ctx context.Context) NonResourcePolicyRulePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NonResourcePolicyRulePatchOutput)
}

// NonResourcePolicyRulePatchArrayInput is an input type that accepts NonResourcePolicyRulePatchArray and NonResourcePolicyRulePatchArrayOutput values.
// You can construct a concrete instance of `NonResourcePolicyRulePatchArrayInput` via:
//
//	NonResourcePolicyRulePatchArray{ NonResourcePolicyRulePatchArgs{...} }
type NonResourcePolicyRulePatchArrayInput interface {
	pulumi.Input

	ToNonResourcePolicyRulePatchArrayOutput() NonResourcePolicyRulePatchArrayOutput
	ToNonResourcePolicyRulePatchArrayOutputWithContext(context.Context) NonResourcePolicyRulePatchArrayOutput
}

type NonResourcePolicyRulePatchArray []NonResourcePolicyRulePatchInput

func (NonResourcePolicyRulePatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NonResourcePolicyRulePatch)(nil)).Elem()
}

func (i NonResourcePolicyRulePatchArray) ToNonResourcePolicyRulePatchArrayOutput() NonResourcePolicyRulePatchArrayOutput {
	return i.ToNonResourcePolicyRulePatchArrayOutputWithContext(context.Background())
}

func (i NonResourcePolicyRulePatchArray) ToNonResourcePolicyRulePatchArrayOutputWithContext(ctx context.Context) NonResourcePolicyRulePatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NonResourcePolicyRulePatchArrayOutput)
}

// NonResourcePolicyRule is a predicate that matches non-resource requests according to their verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only if both (a) at least one member of verbs matches the request and (b) at least one member of nonResourceURLs matches the request.
type NonResourcePolicyRulePatchOutput struct{ *pulumi.OutputState }

func (NonResourcePolicyRulePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NonResourcePolicyRulePatch)(nil)).Elem()
}

func (o NonResourcePolicyRulePatchOutput) ToNonResourcePolicyRulePatchOutput() NonResourcePolicyRulePatchOutput {
	return o
}

func (o NonResourcePolicyRulePatchOutput) ToNonResourcePolicyRulePatchOutputWithContext(ctx context.Context) NonResourcePolicyRulePatchOutput {
	return o
}

// `nonResourceURLs` is a set of url prefixes that a user should have access to and may not be empty. For example:
//   - "/healthz" is legal
//   - "/hea*" is illegal
//   - "/hea" is legal but matches nothing
//   - "/hea/*" also matches nothing
//   - "/healthz/*" matches all per-component health checks.
//     "*" matches all non-resource urls. if it is present, it must be the only entry. Required.
func (o NonResourcePolicyRulePatchOutput) NonResourceURLs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NonResourcePolicyRulePatch) []string { return v.NonResourceURLs }).(pulumi.StringArrayOutput)
}

// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it is present, it must be the only entry. Required.
func (o NonResourcePolicyRulePatchOutput) Verbs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NonResourcePolicyRulePatch) []string { return v.Verbs }).(pulumi.StringArrayOutput)
}

type NonResourcePolicyRulePatchArrayOutput struct{ *pulumi.OutputState }

func (NonResourcePolicyRulePatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NonResourcePolicyRulePatch)(nil)).Elem()
}

func (o NonResourcePolicyRulePatchArrayOutput) ToNonResourcePolicyRulePatchArrayOutput() NonResourcePolicyRulePatchArrayOutput {
	return o
}

func (o NonResourcePolicyRulePatchArrayOutput) ToNonResourcePolicyRulePatchArrayOutputWithContext(ctx context.Context) NonResourcePolicyRulePatchArrayOutput {
	return o
}

func (o NonResourcePolicyRulePatchArrayOutput) Index(i pulumi.IntInput) NonResourcePolicyRulePatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NonResourcePolicyRulePatch {
		return vs[0].([]NonResourcePolicyRulePatch)[vs[1].(int)]
	}).(NonResourcePolicyRulePatchOutput)
}

// PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least one member of subjects matches the request and (b) at least one member of resourceRules or nonResourceRules matches the request.
type PolicyRulesWithSubjects struct {
	// `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests according to their verb and the target non-resource URL.
	NonResourceRules []NonResourcePolicyRule `pulumi:"nonResourceRules"`
	// `resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty.
	ResourceRules []ResourcePolicyRule `pulumi:"resourceRules"`
	// subjects is the list of normal user, serviceaccount, or group that this rule cares about. There must be at least one member in this slice. A slice that includes both the system:authenticated and system:unauthenticated user groups matches every request. Required.
	Subjects []Subject `pulumi:"subjects"`
}

// PolicyRulesWithSubjectsInput is an input type that accepts PolicyRulesWithSubjectsArgs and PolicyRulesWithSubjectsOutput values.
// You can construct a concrete instance of `PolicyRulesWithSubjectsInput` via:
//
//	PolicyRulesWithSubjectsArgs{...}
type PolicyRulesWithSubjectsInput interface {
	pulumi.Input

	ToPolicyRulesWithSubjectsOutput() PolicyRulesWithSubjectsOutput
	ToPolicyRulesWithSubjectsOutputWithContext(context.Context) PolicyRulesWithSubjectsOutput
}

// PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least one member of subjects matches the request and (b) at least one member of resourceRules or nonResourceRules matches the request.
type PolicyRulesWithSubjectsArgs struct {
	// `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests according to their verb and the target non-resource URL.
	NonResourceRules NonResourcePolicyRuleArrayInput `pulumi:"nonResourceRules"`
	// `resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty.
	ResourceRules ResourcePolicyRuleArrayInput `pulumi:"resourceRules"`
	// subjects is the list of normal user, serviceaccount, or group that this rule cares about. There must be at least one member in this slice. A slice that includes both the system:authenticated and system:unauthenticated user groups matches every request. Required.
	Subjects SubjectArrayInput `pulumi:"subjects"`
}

func (PolicyRulesWithSubjectsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PolicyRulesWithSubjects)(nil)).Elem()
}

func (i PolicyRulesWithSubjectsArgs) ToPolicyRulesWithSubjectsOutput() PolicyRulesWithSubjectsOutput {
	return i.ToPolicyRulesWithSubjectsOutputWithContext(context.Background())
}

func (i PolicyRulesWithSubjectsArgs) ToPolicyRulesWithSubjectsOutputWithContext(ctx context.Context) PolicyRulesWithSubjectsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyRulesWithSubjectsOutput)
}

// PolicyRulesWithSubjectsArrayInput is an input type that accepts PolicyRulesWithSubjectsArray and PolicyRulesWithSubjectsArrayOutput values.
// You can construct a concrete instance of `PolicyRulesWithSubjectsArrayInput` via:
//
//	PolicyRulesWithSubjectsArray{ PolicyRulesWithSubjectsArgs{...} }
type PolicyRulesWithSubjectsArrayInput interface {
	pulumi.Input

	ToPolicyRulesWithSubjectsArrayOutput() PolicyRulesWithSubjectsArrayOutput
	ToPolicyRulesWithSubjectsArrayOutputWithContext(context.Context) PolicyRulesWithSubjectsArrayOutput
}

type PolicyRulesWithSubjectsArray []PolicyRulesWithSubjectsInput

func (PolicyRulesWithSubjectsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PolicyRulesWithSubjects)(nil)).Elem()
}

func (i PolicyRulesWithSubjectsArray) ToPolicyRulesWithSubjectsArrayOutput() PolicyRulesWithSubjectsArrayOutput {
	return i.ToPolicyRulesWithSubjectsArrayOutputWithContext(context.Background())
}

func (i PolicyRulesWithSubjectsArray) ToPolicyRulesWithSubjectsArrayOutputWithContext(ctx context.Context) PolicyRulesWithSubjectsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyRulesWithSubjectsArrayOutput)
}

// PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least one member of subjects matches the request and (b) at least one member of resourceRules or nonResourceRules matches the request.
type PolicyRulesWithSubjectsOutput struct{ *pulumi.OutputState }

func (PolicyRulesWithSubjectsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PolicyRulesWithSubjects)(nil)).Elem()
}

func (o PolicyRulesWithSubjectsOutput) ToPolicyRulesWithSubjectsOutput() PolicyRulesWithSubjectsOutput {
	return o
}

func (o PolicyRulesWithSubjectsOutput) ToPolicyRulesWithSubjectsOutputWithContext(ctx context.Context) PolicyRulesWithSubjectsOutput {
	return o
}

// `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests according to their verb and the target non-resource URL.
func (o PolicyRulesWithSubjectsOutput) NonResourceRules() NonResourcePolicyRuleArrayOutput {
	return o.ApplyT(func(v PolicyRulesWithSubjects) []NonResourcePolicyRule { return v.NonResourceRules }).(NonResourcePolicyRuleArrayOutput)
}

// `resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty.
func (o PolicyRulesWithSubjectsOutput) ResourceRules() ResourcePolicyRuleArrayOutput {
	return o.ApplyT(func(v PolicyRulesWithSubjects) []ResourcePolicyRule { return v.ResourceRules }).(ResourcePolicyRuleArrayOutput)
}

// subjects is the list of normal user, serviceaccount, or group that this rule cares about. There must be at least one member in this slice. A slice that includes both the system:authenticated and system:unauthenticated user groups matches every request. Required.
func (o PolicyRulesWithSubjectsOutput) Subjects() SubjectArrayOutput {
	return o.ApplyT(func(v PolicyRulesWithSubjects) []Subject { return v.Subjects }).(SubjectArrayOutput)
}

type PolicyRulesWithSubjectsArrayOutput struct{ *pulumi.OutputState }

func (PolicyRulesWithSubjectsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PolicyRulesWithSubjects)(nil)).Elem()
}

func (o PolicyRulesWithSubjectsArrayOutput) ToPolicyRulesWithSubjectsArrayOutput() PolicyRulesWithSubjectsArrayOutput {
	return o
}

func (o PolicyRulesWithSubjectsArrayOutput) ToPolicyRulesWithSubjectsArrayOutputWithContext(ctx context.Context) PolicyRulesWithSubjectsArrayOutput {
	return o
}

func (o PolicyRulesWithSubjectsArrayOutput) Index(i pulumi.IntInput) PolicyRulesWithSubjectsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PolicyRulesWithSubjects {
		return vs[0].([]PolicyRulesWithSubjects)[vs[1].(int)]
	}).(PolicyRulesWithSubjectsOutput)
}

// PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least one member of subjects matches the request and (b) at least one member of resourceRules or nonResourceRules matches the request.
type PolicyRulesWithSubjectsPatch struct {
	// `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests according to their verb and the target non-resource URL.
	NonResourceRules []NonResourcePolicyRulePatch `pulumi:"nonResourceRules"`
	// `resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty.
	ResourceRules []ResourcePolicyRulePatch `pulumi:"resourceRules"`
	// subjects is the list of normal user, serviceaccount, or group that this rule cares about. There must be at least one member in this slice. A slice that includes both the system:authenticated and system:unauthenticated user groups matches every request. Required.
	Subjects []SubjectPatch `pulumi:"subjects"`
}

// PolicyRulesWithSubjectsPatchInput is an input type that accepts PolicyRulesWithSubjectsPatchArgs and PolicyRulesWithSubjectsPatchOutput values.
// You can construct a concrete instance of `PolicyRulesWithSubjectsPatchInput` via:
//
//	PolicyRulesWithSubjectsPatchArgs{...}
type PolicyRulesWithSubjectsPatchInput interface {
	pulumi.Input

	ToPolicyRulesWithSubjectsPatchOutput() PolicyRulesWithSubjectsPatchOutput
	ToPolicyRulesWithSubjectsPatchOutputWithContext(context.Context) PolicyRulesWithSubjectsPatchOutput
}

// PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least one member of subjects matches the request and (b) at least one member of resourceRules or nonResourceRules matches the request.
type PolicyRulesWithSubjectsPatchArgs struct {
	// `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests according to their verb and the target non-resource URL.
	NonResourceRules NonResourcePolicyRulePatchArrayInput `pulumi:"nonResourceRules"`
	// `resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty.
	ResourceRules ResourcePolicyRulePatchArrayInput `pulumi:"resourceRules"`
	// subjects is the list of normal user, serviceaccount, or group that this rule cares about. There must be at least one member in this slice. A slice that includes both the system:authenticated and system:unauthenticated user groups matches every request. Required.
	Subjects SubjectPatchArrayInput `pulumi:"subjects"`
}

func (PolicyRulesWithSubjectsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PolicyRulesWithSubjectsPatch)(nil)).Elem()
}

func (i PolicyRulesWithSubjectsPatchArgs) ToPolicyRulesWithSubjectsPatchOutput() PolicyRulesWithSubjectsPatchOutput {
	return i.ToPolicyRulesWithSubjectsPatchOutputWithContext(context.Background())
}

func (i PolicyRulesWithSubjectsPatchArgs) ToPolicyRulesWithSubjectsPatchOutputWithContext(ctx context.Context) PolicyRulesWithSubjectsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyRulesWithSubjectsPatchOutput)
}

// PolicyRulesWithSubjectsPatchArrayInput is an input type that accepts PolicyRulesWithSubjectsPatchArray and PolicyRulesWithSubjectsPatchArrayOutput values.
// You can construct a concrete instance of `PolicyRulesWithSubjectsPatchArrayInput` via:
//
//	PolicyRulesWithSubjectsPatchArray{ PolicyRulesWithSubjectsPatchArgs{...} }
type PolicyRulesWithSubjectsPatchArrayInput interface {
	pulumi.Input

	ToPolicyRulesWithSubjectsPatchArrayOutput() PolicyRulesWithSubjectsPatchArrayOutput
	ToPolicyRulesWithSubjectsPatchArrayOutputWithContext(context.Context) PolicyRulesWithSubjectsPatchArrayOutput
}

type PolicyRulesWithSubjectsPatchArray []PolicyRulesWithSubjectsPatchInput

func (PolicyRulesWithSubjectsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PolicyRulesWithSubjectsPatch)(nil)).Elem()
}

func (i PolicyRulesWithSubjectsPatchArray) ToPolicyRulesWithSubjectsPatchArrayOutput() PolicyRulesWithSubjectsPatchArrayOutput {
	return i.ToPolicyRulesWithSubjectsPatchArrayOutputWithContext(context.Background())
}

func (i PolicyRulesWithSubjectsPatchArray) ToPolicyRulesWithSubjectsPatchArrayOutputWithContext(ctx context.Context) PolicyRulesWithSubjectsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyRulesWithSubjectsPatchArrayOutput)
}

// PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least one member of subjects matches the request and (b) at least one member of resourceRules or nonResourceRules matches the request.
type PolicyRulesWithSubjectsPatchOutput struct{ *pulumi.OutputState }

func (PolicyRulesWithSubjectsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PolicyRulesWithSubjectsPatch)(nil)).Elem()
}

func (o PolicyRulesWithSubjectsPatchOutput) ToPolicyRulesWithSubjectsPatchOutput() PolicyRulesWithSubjectsPatchOutput {
	return o
}

func (o PolicyRulesWithSubjectsPatchOutput) ToPolicyRulesWithSubjectsPatchOutputWithContext(ctx context.Context) PolicyRulesWithSubjectsPatchOutput {
	return o
}

// `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests according to their verb and the target non-resource URL.
func (o PolicyRulesWithSubjectsPatchOutput) NonResourceRules() NonResourcePolicyRulePatchArrayOutput {
	return o.ApplyT(func(v PolicyRulesWithSubjectsPatch) []NonResourcePolicyRulePatch { return v.NonResourceRules }).(NonResourcePolicyRulePatchArrayOutput)
}

// `resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty.
func (o PolicyRulesWithSubjectsPatchOutput) ResourceRules() ResourcePolicyRulePatchArrayOutput {
	return o.ApplyT(func(v PolicyRulesWithSubjectsPatch) []ResourcePolicyRulePatch { return v.ResourceRules }).(ResourcePolicyRulePatchArrayOutput)
}

// subjects is the list of normal user, serviceaccount, or group that this rule cares about. There must be at least one member in this slice. A slice that includes both the system:authenticated and system:unauthenticated user groups matches every request. Required.
func (o PolicyRulesWithSubjectsPatchOutput) Subjects() SubjectPatchArrayOutput {
	return o.ApplyT(func(v PolicyRulesWithSubjectsPatch) []SubjectPatch { return v.Subjects }).(SubjectPatchArrayOutput)
}

type PolicyRulesWithSubjectsPatchArrayOutput struct{ *pulumi.OutputState }

func (PolicyRulesWithSubjectsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PolicyRulesWithSubjectsPatch)(nil)).Elem()
}

func (o PolicyRulesWithSubjectsPatchArrayOutput) ToPolicyRulesWithSubjectsPatchArrayOutput() PolicyRulesWithSubjectsPatchArrayOutput {
	return o
}

func (o PolicyRulesWithSubjectsPatchArrayOutput) ToPolicyRulesWithSubjectsPatchArrayOutputWithContext(ctx context.Context) PolicyRulesWithSubjectsPatchArrayOutput {
	return o
}

func (o PolicyRulesWithSubjectsPatchArrayOutput) Index(i pulumi.IntInput) PolicyRulesWithSubjectsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PolicyRulesWithSubjectsPatch {
		return vs[0].([]PolicyRulesWithSubjectsPatch)[vs[1].(int)]
	}).(PolicyRulesWithSubjectsPatchOutput)
}

// PriorityLevelConfiguration represents the configuration of a priority level.
type PriorityLevelConfigurationType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// `spec` is the specification of the desired behavior of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec *PriorityLevelConfigurationSpec `pulumi:"spec"`
	// `status` is the current status of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status *PriorityLevelConfigurationStatus `pulumi:"status"`
}

// PriorityLevelConfigurationTypeInput is an input type that accepts PriorityLevelConfigurationTypeArgs and PriorityLevelConfigurationTypeOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationTypeInput` via:
//
//	PriorityLevelConfigurationTypeArgs{...}
type PriorityLevelConfigurationTypeInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationTypeOutput() PriorityLevelConfigurationTypeOutput
	ToPriorityLevelConfigurationTypeOutputWithContext(context.Context) PriorityLevelConfigurationTypeOutput
}

// PriorityLevelConfiguration represents the configuration of a priority level.
type PriorityLevelConfigurationTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// `spec` is the specification of the desired behavior of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec PriorityLevelConfigurationSpecPtrInput `pulumi:"spec"`
	// `status` is the current status of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status PriorityLevelConfigurationStatusPtrInput `pulumi:"status"`
}

func (PriorityLevelConfigurationTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationType)(nil)).Elem()
}

func (i PriorityLevelConfigurationTypeArgs) ToPriorityLevelConfigurationTypeOutput() PriorityLevelConfigurationTypeOutput {
	return i.ToPriorityLevelConfigurationTypeOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationTypeArgs) ToPriorityLevelConfigurationTypeOutputWithContext(ctx context.Context) PriorityLevelConfigurationTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationTypeOutput)
}

// PriorityLevelConfigurationTypeArrayInput is an input type that accepts PriorityLevelConfigurationTypeArray and PriorityLevelConfigurationTypeArrayOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationTypeArrayInput` via:
//
//	PriorityLevelConfigurationTypeArray{ PriorityLevelConfigurationTypeArgs{...} }
type PriorityLevelConfigurationTypeArrayInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationTypeArrayOutput() PriorityLevelConfigurationTypeArrayOutput
	ToPriorityLevelConfigurationTypeArrayOutputWithContext(context.Context) PriorityLevelConfigurationTypeArrayOutput
}

type PriorityLevelConfigurationTypeArray []PriorityLevelConfigurationTypeInput

func (PriorityLevelConfigurationTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PriorityLevelConfigurationType)(nil)).Elem()
}

func (i PriorityLevelConfigurationTypeArray) ToPriorityLevelConfigurationTypeArrayOutput() PriorityLevelConfigurationTypeArrayOutput {
	return i.ToPriorityLevelConfigurationTypeArrayOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationTypeArray) ToPriorityLevelConfigurationTypeArrayOutputWithContext(ctx context.Context) PriorityLevelConfigurationTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationTypeArrayOutput)
}

// PriorityLevelConfiguration represents the configuration of a priority level.
type PriorityLevelConfigurationTypeOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationType)(nil)).Elem()
}

func (o PriorityLevelConfigurationTypeOutput) ToPriorityLevelConfigurationTypeOutput() PriorityLevelConfigurationTypeOutput {
	return o
}

func (o PriorityLevelConfigurationTypeOutput) ToPriorityLevelConfigurationTypeOutputWithContext(ctx context.Context) PriorityLevelConfigurationTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PriorityLevelConfigurationTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PriorityLevelConfigurationTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o PriorityLevelConfigurationTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// `spec` is the specification of the desired behavior of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o PriorityLevelConfigurationTypeOutput) Spec() PriorityLevelConfigurationSpecPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationType) *PriorityLevelConfigurationSpec { return v.Spec }).(PriorityLevelConfigurationSpecPtrOutput)
}

// `status` is the current status of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o PriorityLevelConfigurationTypeOutput) Status() PriorityLevelConfigurationStatusPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationType) *PriorityLevelConfigurationStatus { return v.Status }).(PriorityLevelConfigurationStatusPtrOutput)
}

type PriorityLevelConfigurationTypeArrayOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PriorityLevelConfigurationType)(nil)).Elem()
}

func (o PriorityLevelConfigurationTypeArrayOutput) ToPriorityLevelConfigurationTypeArrayOutput() PriorityLevelConfigurationTypeArrayOutput {
	return o
}

func (o PriorityLevelConfigurationTypeArrayOutput) ToPriorityLevelConfigurationTypeArrayOutputWithContext(ctx context.Context) PriorityLevelConfigurationTypeArrayOutput {
	return o
}

func (o PriorityLevelConfigurationTypeArrayOutput) Index(i pulumi.IntInput) PriorityLevelConfigurationTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PriorityLevelConfigurationType {
		return vs[0].([]PriorityLevelConfigurationType)[vs[1].(int)]
	}).(PriorityLevelConfigurationTypeOutput)
}

// PriorityLevelConfigurationCondition defines the condition of priority level.
type PriorityLevelConfigurationCondition struct {
	// `lastTransitionTime` is the last time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// `message` is a human-readable message indicating details about last transition.
	Message *string `pulumi:"message"`
	// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
	Reason *string `pulumi:"reason"`
	// `status` is the status of the condition. Can be True, False, Unknown. Required.
	Status *string `pulumi:"status"`
	// `type` is the type of the condition. Required.
	Type *string `pulumi:"type"`
}

// PriorityLevelConfigurationConditionInput is an input type that accepts PriorityLevelConfigurationConditionArgs and PriorityLevelConfigurationConditionOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationConditionInput` via:
//
//	PriorityLevelConfigurationConditionArgs{...}
type PriorityLevelConfigurationConditionInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationConditionOutput() PriorityLevelConfigurationConditionOutput
	ToPriorityLevelConfigurationConditionOutputWithContext(context.Context) PriorityLevelConfigurationConditionOutput
}

// PriorityLevelConfigurationCondition defines the condition of priority level.
type PriorityLevelConfigurationConditionArgs struct {
	// `lastTransitionTime` is the last time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// `message` is a human-readable message indicating details about last transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// `status` is the status of the condition. Can be True, False, Unknown. Required.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// `type` is the type of the condition. Required.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (PriorityLevelConfigurationConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationCondition)(nil)).Elem()
}

func (i PriorityLevelConfigurationConditionArgs) ToPriorityLevelConfigurationConditionOutput() PriorityLevelConfigurationConditionOutput {
	return i.ToPriorityLevelConfigurationConditionOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationConditionArgs) ToPriorityLevelConfigurationConditionOutputWithContext(ctx context.Context) PriorityLevelConfigurationConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationConditionOutput)
}

// PriorityLevelConfigurationConditionArrayInput is an input type that accepts PriorityLevelConfigurationConditionArray and PriorityLevelConfigurationConditionArrayOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationConditionArrayInput` via:
//
//	PriorityLevelConfigurationConditionArray{ PriorityLevelConfigurationConditionArgs{...} }
type PriorityLevelConfigurationConditionArrayInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationConditionArrayOutput() PriorityLevelConfigurationConditionArrayOutput
	ToPriorityLevelConfigurationConditionArrayOutputWithContext(context.Context) PriorityLevelConfigurationConditionArrayOutput
}

type PriorityLevelConfigurationConditionArray []PriorityLevelConfigurationConditionInput

func (PriorityLevelConfigurationConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PriorityLevelConfigurationCondition)(nil)).Elem()
}

func (i PriorityLevelConfigurationConditionArray) ToPriorityLevelConfigurationConditionArrayOutput() PriorityLevelConfigurationConditionArrayOutput {
	return i.ToPriorityLevelConfigurationConditionArrayOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationConditionArray) ToPriorityLevelConfigurationConditionArrayOutputWithContext(ctx context.Context) PriorityLevelConfigurationConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationConditionArrayOutput)
}

// PriorityLevelConfigurationCondition defines the condition of priority level.
type PriorityLevelConfigurationConditionOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationCondition)(nil)).Elem()
}

func (o PriorityLevelConfigurationConditionOutput) ToPriorityLevelConfigurationConditionOutput() PriorityLevelConfigurationConditionOutput {
	return o
}

func (o PriorityLevelConfigurationConditionOutput) ToPriorityLevelConfigurationConditionOutputWithContext(ctx context.Context) PriorityLevelConfigurationConditionOutput {
	return o
}

// `lastTransitionTime` is the last time the condition transitioned from one status to another.
func (o PriorityLevelConfigurationConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// `message` is a human-readable message indicating details about last transition.
func (o PriorityLevelConfigurationConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
func (o PriorityLevelConfigurationConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// `status` is the status of the condition. Can be True, False, Unknown. Required.
func (o PriorityLevelConfigurationConditionOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationCondition) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// `type` is the type of the condition. Required.
func (o PriorityLevelConfigurationConditionOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationCondition) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type PriorityLevelConfigurationConditionArrayOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PriorityLevelConfigurationCondition)(nil)).Elem()
}

func (o PriorityLevelConfigurationConditionArrayOutput) ToPriorityLevelConfigurationConditionArrayOutput() PriorityLevelConfigurationConditionArrayOutput {
	return o
}

func (o PriorityLevelConfigurationConditionArrayOutput) ToPriorityLevelConfigurationConditionArrayOutputWithContext(ctx context.Context) PriorityLevelConfigurationConditionArrayOutput {
	return o
}

func (o PriorityLevelConfigurationConditionArrayOutput) Index(i pulumi.IntInput) PriorityLevelConfigurationConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PriorityLevelConfigurationCondition {
		return vs[0].([]PriorityLevelConfigurationCondition)[vs[1].(int)]
	}).(PriorityLevelConfigurationConditionOutput)
}

// PriorityLevelConfigurationCondition defines the condition of priority level.
type PriorityLevelConfigurationConditionPatch struct {
	// `lastTransitionTime` is the last time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// `message` is a human-readable message indicating details about last transition.
	Message *string `pulumi:"message"`
	// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
	Reason *string `pulumi:"reason"`
	// `status` is the status of the condition. Can be True, False, Unknown. Required.
	Status *string `pulumi:"status"`
	// `type` is the type of the condition. Required.
	Type *string `pulumi:"type"`
}

// PriorityLevelConfigurationConditionPatchInput is an input type that accepts PriorityLevelConfigurationConditionPatchArgs and PriorityLevelConfigurationConditionPatchOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationConditionPatchInput` via:
//
//	PriorityLevelConfigurationConditionPatchArgs{...}
type PriorityLevelConfigurationConditionPatchInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationConditionPatchOutput() PriorityLevelConfigurationConditionPatchOutput
	ToPriorityLevelConfigurationConditionPatchOutputWithContext(context.Context) PriorityLevelConfigurationConditionPatchOutput
}

// PriorityLevelConfigurationCondition defines the condition of priority level.
type PriorityLevelConfigurationConditionPatchArgs struct {
	// `lastTransitionTime` is the last time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// `message` is a human-readable message indicating details about last transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// `status` is the status of the condition. Can be True, False, Unknown. Required.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// `type` is the type of the condition. Required.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (PriorityLevelConfigurationConditionPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationConditionPatch)(nil)).Elem()
}

func (i PriorityLevelConfigurationConditionPatchArgs) ToPriorityLevelConfigurationConditionPatchOutput() PriorityLevelConfigurationConditionPatchOutput {
	return i.ToPriorityLevelConfigurationConditionPatchOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationConditionPatchArgs) ToPriorityLevelConfigurationConditionPatchOutputWithContext(ctx context.Context) PriorityLevelConfigurationConditionPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationConditionPatchOutput)
}

// PriorityLevelConfigurationConditionPatchArrayInput is an input type that accepts PriorityLevelConfigurationConditionPatchArray and PriorityLevelConfigurationConditionPatchArrayOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationConditionPatchArrayInput` via:
//
//	PriorityLevelConfigurationConditionPatchArray{ PriorityLevelConfigurationConditionPatchArgs{...} }
type PriorityLevelConfigurationConditionPatchArrayInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationConditionPatchArrayOutput() PriorityLevelConfigurationConditionPatchArrayOutput
	ToPriorityLevelConfigurationConditionPatchArrayOutputWithContext(context.Context) PriorityLevelConfigurationConditionPatchArrayOutput
}

type PriorityLevelConfigurationConditionPatchArray []PriorityLevelConfigurationConditionPatchInput

func (PriorityLevelConfigurationConditionPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PriorityLevelConfigurationConditionPatch)(nil)).Elem()
}

func (i PriorityLevelConfigurationConditionPatchArray) ToPriorityLevelConfigurationConditionPatchArrayOutput() PriorityLevelConfigurationConditionPatchArrayOutput {
	return i.ToPriorityLevelConfigurationConditionPatchArrayOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationConditionPatchArray) ToPriorityLevelConfigurationConditionPatchArrayOutputWithContext(ctx context.Context) PriorityLevelConfigurationConditionPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationConditionPatchArrayOutput)
}

// PriorityLevelConfigurationCondition defines the condition of priority level.
type PriorityLevelConfigurationConditionPatchOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationConditionPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationConditionPatch)(nil)).Elem()
}

func (o PriorityLevelConfigurationConditionPatchOutput) ToPriorityLevelConfigurationConditionPatchOutput() PriorityLevelConfigurationConditionPatchOutput {
	return o
}

func (o PriorityLevelConfigurationConditionPatchOutput) ToPriorityLevelConfigurationConditionPatchOutputWithContext(ctx context.Context) PriorityLevelConfigurationConditionPatchOutput {
	return o
}

// `lastTransitionTime` is the last time the condition transitioned from one status to another.
func (o PriorityLevelConfigurationConditionPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationConditionPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// `message` is a human-readable message indicating details about last transition.
func (o PriorityLevelConfigurationConditionPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationConditionPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
func (o PriorityLevelConfigurationConditionPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationConditionPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// `status` is the status of the condition. Can be True, False, Unknown. Required.
func (o PriorityLevelConfigurationConditionPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationConditionPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// `type` is the type of the condition. Required.
func (o PriorityLevelConfigurationConditionPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationConditionPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type PriorityLevelConfigurationConditionPatchArrayOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationConditionPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PriorityLevelConfigurationConditionPatch)(nil)).Elem()
}

func (o PriorityLevelConfigurationConditionPatchArrayOutput) ToPriorityLevelConfigurationConditionPatchArrayOutput() PriorityLevelConfigurationConditionPatchArrayOutput {
	return o
}

func (o PriorityLevelConfigurationConditionPatchArrayOutput) ToPriorityLevelConfigurationConditionPatchArrayOutputWithContext(ctx context.Context) PriorityLevelConfigurationConditionPatchArrayOutput {
	return o
}

func (o PriorityLevelConfigurationConditionPatchArrayOutput) Index(i pulumi.IntInput) PriorityLevelConfigurationConditionPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PriorityLevelConfigurationConditionPatch {
		return vs[0].([]PriorityLevelConfigurationConditionPatch)[vs[1].(int)]
	}).(PriorityLevelConfigurationConditionPatchOutput)
}

// PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects.
type PriorityLevelConfigurationListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// `items` is a list of request-priorities.
	Items []PriorityLevelConfigurationType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// PriorityLevelConfigurationListTypeInput is an input type that accepts PriorityLevelConfigurationListTypeArgs and PriorityLevelConfigurationListTypeOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationListTypeInput` via:
//
//	PriorityLevelConfigurationListTypeArgs{...}
type PriorityLevelConfigurationListTypeInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationListTypeOutput() PriorityLevelConfigurationListTypeOutput
	ToPriorityLevelConfigurationListTypeOutputWithContext(context.Context) PriorityLevelConfigurationListTypeOutput
}

// PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects.
type PriorityLevelConfigurationListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// `items` is a list of request-priorities.
	Items PriorityLevelConfigurationTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (PriorityLevelConfigurationListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationListType)(nil)).Elem()
}

func (i PriorityLevelConfigurationListTypeArgs) ToPriorityLevelConfigurationListTypeOutput() PriorityLevelConfigurationListTypeOutput {
	return i.ToPriorityLevelConfigurationListTypeOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationListTypeArgs) ToPriorityLevelConfigurationListTypeOutputWithContext(ctx context.Context) PriorityLevelConfigurationListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationListTypeOutput)
}

// PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects.
type PriorityLevelConfigurationListTypeOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationListType)(nil)).Elem()
}

func (o PriorityLevelConfigurationListTypeOutput) ToPriorityLevelConfigurationListTypeOutput() PriorityLevelConfigurationListTypeOutput {
	return o
}

func (o PriorityLevelConfigurationListTypeOutput) ToPriorityLevelConfigurationListTypeOutputWithContext(ctx context.Context) PriorityLevelConfigurationListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PriorityLevelConfigurationListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// `items` is a list of request-priorities.
func (o PriorityLevelConfigurationListTypeOutput) Items() PriorityLevelConfigurationTypeArrayOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationListType) []PriorityLevelConfigurationType { return v.Items }).(PriorityLevelConfigurationTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PriorityLevelConfigurationListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o PriorityLevelConfigurationListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// PriorityLevelConfiguration represents the configuration of a priority level.
type PriorityLevelConfigurationPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	// `spec` is the specification of the desired behavior of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec *PriorityLevelConfigurationSpecPatch `pulumi:"spec"`
	// `status` is the current status of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status *PriorityLevelConfigurationStatusPatch `pulumi:"status"`
}

// PriorityLevelConfigurationPatchTypeInput is an input type that accepts PriorityLevelConfigurationPatchTypeArgs and PriorityLevelConfigurationPatchTypeOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationPatchTypeInput` via:
//
//	PriorityLevelConfigurationPatchTypeArgs{...}
type PriorityLevelConfigurationPatchTypeInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationPatchTypeOutput() PriorityLevelConfigurationPatchTypeOutput
	ToPriorityLevelConfigurationPatchTypeOutputWithContext(context.Context) PriorityLevelConfigurationPatchTypeOutput
}

// PriorityLevelConfiguration represents the configuration of a priority level.
type PriorityLevelConfigurationPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	// `spec` is the specification of the desired behavior of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec PriorityLevelConfigurationSpecPatchPtrInput `pulumi:"spec"`
	// `status` is the current status of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status PriorityLevelConfigurationStatusPatchPtrInput `pulumi:"status"`
}

func (PriorityLevelConfigurationPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationPatchType)(nil)).Elem()
}

func (i PriorityLevelConfigurationPatchTypeArgs) ToPriorityLevelConfigurationPatchTypeOutput() PriorityLevelConfigurationPatchTypeOutput {
	return i.ToPriorityLevelConfigurationPatchTypeOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationPatchTypeArgs) ToPriorityLevelConfigurationPatchTypeOutputWithContext(ctx context.Context) PriorityLevelConfigurationPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationPatchTypeOutput)
}

// PriorityLevelConfiguration represents the configuration of a priority level.
type PriorityLevelConfigurationPatchTypeOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationPatchType)(nil)).Elem()
}

func (o PriorityLevelConfigurationPatchTypeOutput) ToPriorityLevelConfigurationPatchTypeOutput() PriorityLevelConfigurationPatchTypeOutput {
	return o
}

func (o PriorityLevelConfigurationPatchTypeOutput) ToPriorityLevelConfigurationPatchTypeOutputWithContext(ctx context.Context) PriorityLevelConfigurationPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o PriorityLevelConfigurationPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PriorityLevelConfigurationPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// `metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o PriorityLevelConfigurationPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

// `spec` is the specification of the desired behavior of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o PriorityLevelConfigurationPatchTypeOutput) Spec() PriorityLevelConfigurationSpecPatchPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationPatchType) *PriorityLevelConfigurationSpecPatch { return v.Spec }).(PriorityLevelConfigurationSpecPatchPtrOutput)
}

// `status` is the current status of a "request-priority". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o PriorityLevelConfigurationPatchTypeOutput) Status() PriorityLevelConfigurationStatusPatchPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationPatchType) *PriorityLevelConfigurationStatusPatch { return v.Status }).(PriorityLevelConfigurationStatusPatchPtrOutput)
}

// PriorityLevelConfigurationReference contains information that points to the "request-priority" being used.
type PriorityLevelConfigurationReference struct {
	// `name` is the name of the priority level configuration being referenced Required.
	Name string `pulumi:"name"`
}

// PriorityLevelConfigurationReferenceInput is an input type that accepts PriorityLevelConfigurationReferenceArgs and PriorityLevelConfigurationReferenceOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationReferenceInput` via:
//
//	PriorityLevelConfigurationReferenceArgs{...}
type PriorityLevelConfigurationReferenceInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationReferenceOutput() PriorityLevelConfigurationReferenceOutput
	ToPriorityLevelConfigurationReferenceOutputWithContext(context.Context) PriorityLevelConfigurationReferenceOutput
}

// PriorityLevelConfigurationReference contains information that points to the "request-priority" being used.
type PriorityLevelConfigurationReferenceArgs struct {
	// `name` is the name of the priority level configuration being referenced Required.
	Name pulumi.StringInput `pulumi:"name"`
}

func (PriorityLevelConfigurationReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationReference)(nil)).Elem()
}

func (i PriorityLevelConfigurationReferenceArgs) ToPriorityLevelConfigurationReferenceOutput() PriorityLevelConfigurationReferenceOutput {
	return i.ToPriorityLevelConfigurationReferenceOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationReferenceArgs) ToPriorityLevelConfigurationReferenceOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationReferenceOutput)
}

func (i PriorityLevelConfigurationReferenceArgs) ToPriorityLevelConfigurationReferencePtrOutput() PriorityLevelConfigurationReferencePtrOutput {
	return i.ToPriorityLevelConfigurationReferencePtrOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationReferenceArgs) ToPriorityLevelConfigurationReferencePtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationReferenceOutput).ToPriorityLevelConfigurationReferencePtrOutputWithContext(ctx)
}

// PriorityLevelConfigurationReferencePtrInput is an input type that accepts PriorityLevelConfigurationReferenceArgs, PriorityLevelConfigurationReferencePtr and PriorityLevelConfigurationReferencePtrOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationReferencePtrInput` via:
//
//	        PriorityLevelConfigurationReferenceArgs{...}
//
//	or:
//
//	        nil
type PriorityLevelConfigurationReferencePtrInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationReferencePtrOutput() PriorityLevelConfigurationReferencePtrOutput
	ToPriorityLevelConfigurationReferencePtrOutputWithContext(context.Context) PriorityLevelConfigurationReferencePtrOutput
}

type priorityLevelConfigurationReferencePtrType PriorityLevelConfigurationReferenceArgs

func PriorityLevelConfigurationReferencePtr(v *PriorityLevelConfigurationReferenceArgs) PriorityLevelConfigurationReferencePtrInput {
	return (*priorityLevelConfigurationReferencePtrType)(v)
}

func (*priorityLevelConfigurationReferencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationReference)(nil)).Elem()
}

func (i *priorityLevelConfigurationReferencePtrType) ToPriorityLevelConfigurationReferencePtrOutput() PriorityLevelConfigurationReferencePtrOutput {
	return i.ToPriorityLevelConfigurationReferencePtrOutputWithContext(context.Background())
}

func (i *priorityLevelConfigurationReferencePtrType) ToPriorityLevelConfigurationReferencePtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationReferencePtrOutput)
}

// PriorityLevelConfigurationReference contains information that points to the "request-priority" being used.
type PriorityLevelConfigurationReferenceOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationReference)(nil)).Elem()
}

func (o PriorityLevelConfigurationReferenceOutput) ToPriorityLevelConfigurationReferenceOutput() PriorityLevelConfigurationReferenceOutput {
	return o
}

func (o PriorityLevelConfigurationReferenceOutput) ToPriorityLevelConfigurationReferenceOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferenceOutput {
	return o
}

func (o PriorityLevelConfigurationReferenceOutput) ToPriorityLevelConfigurationReferencePtrOutput() PriorityLevelConfigurationReferencePtrOutput {
	return o.ToPriorityLevelConfigurationReferencePtrOutputWithContext(context.Background())
}

func (o PriorityLevelConfigurationReferenceOutput) ToPriorityLevelConfigurationReferencePtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PriorityLevelConfigurationReference) *PriorityLevelConfigurationReference {
		return &v
	}).(PriorityLevelConfigurationReferencePtrOutput)
}

// `name` is the name of the priority level configuration being referenced Required.
func (o PriorityLevelConfigurationReferenceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationReference) string { return v.Name }).(pulumi.StringOutput)
}

type PriorityLevelConfigurationReferencePtrOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationReferencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationReference)(nil)).Elem()
}

func (o PriorityLevelConfigurationReferencePtrOutput) ToPriorityLevelConfigurationReferencePtrOutput() PriorityLevelConfigurationReferencePtrOutput {
	return o
}

func (o PriorityLevelConfigurationReferencePtrOutput) ToPriorityLevelConfigurationReferencePtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePtrOutput {
	return o
}

func (o PriorityLevelConfigurationReferencePtrOutput) Elem() PriorityLevelConfigurationReferenceOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationReference) PriorityLevelConfigurationReference {
		if v != nil {
			return *v
		}
		var ret PriorityLevelConfigurationReference
		return ret
	}).(PriorityLevelConfigurationReferenceOutput)
}

// `name` is the name of the priority level configuration being referenced Required.
func (o PriorityLevelConfigurationReferencePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationReference) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// PriorityLevelConfigurationReference contains information that points to the "request-priority" being used.
type PriorityLevelConfigurationReferencePatch struct {
	// `name` is the name of the priority level configuration being referenced Required.
	Name *string `pulumi:"name"`
}

// PriorityLevelConfigurationReferencePatchInput is an input type that accepts PriorityLevelConfigurationReferencePatchArgs and PriorityLevelConfigurationReferencePatchOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationReferencePatchInput` via:
//
//	PriorityLevelConfigurationReferencePatchArgs{...}
type PriorityLevelConfigurationReferencePatchInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationReferencePatchOutput() PriorityLevelConfigurationReferencePatchOutput
	ToPriorityLevelConfigurationReferencePatchOutputWithContext(context.Context) PriorityLevelConfigurationReferencePatchOutput
}

// PriorityLevelConfigurationReference contains information that points to the "request-priority" being used.
type PriorityLevelConfigurationReferencePatchArgs struct {
	// `name` is the name of the priority level configuration being referenced Required.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (PriorityLevelConfigurationReferencePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationReferencePatch)(nil)).Elem()
}

func (i PriorityLevelConfigurationReferencePatchArgs) ToPriorityLevelConfigurationReferencePatchOutput() PriorityLevelConfigurationReferencePatchOutput {
	return i.ToPriorityLevelConfigurationReferencePatchOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationReferencePatchArgs) ToPriorityLevelConfigurationReferencePatchOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationReferencePatchOutput)
}

func (i PriorityLevelConfigurationReferencePatchArgs) ToPriorityLevelConfigurationReferencePatchPtrOutput() PriorityLevelConfigurationReferencePatchPtrOutput {
	return i.ToPriorityLevelConfigurationReferencePatchPtrOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationReferencePatchArgs) ToPriorityLevelConfigurationReferencePatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationReferencePatchOutput).ToPriorityLevelConfigurationReferencePatchPtrOutputWithContext(ctx)
}

// PriorityLevelConfigurationReferencePatchPtrInput is an input type that accepts PriorityLevelConfigurationReferencePatchArgs, PriorityLevelConfigurationReferencePatchPtr and PriorityLevelConfigurationReferencePatchPtrOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationReferencePatchPtrInput` via:
//
//	        PriorityLevelConfigurationReferencePatchArgs{...}
//
//	or:
//
//	        nil
type PriorityLevelConfigurationReferencePatchPtrInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationReferencePatchPtrOutput() PriorityLevelConfigurationReferencePatchPtrOutput
	ToPriorityLevelConfigurationReferencePatchPtrOutputWithContext(context.Context) PriorityLevelConfigurationReferencePatchPtrOutput
}

type priorityLevelConfigurationReferencePatchPtrType PriorityLevelConfigurationReferencePatchArgs

func PriorityLevelConfigurationReferencePatchPtr(v *PriorityLevelConfigurationReferencePatchArgs) PriorityLevelConfigurationReferencePatchPtrInput {
	return (*priorityLevelConfigurationReferencePatchPtrType)(v)
}

func (*priorityLevelConfigurationReferencePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationReferencePatch)(nil)).Elem()
}

func (i *priorityLevelConfigurationReferencePatchPtrType) ToPriorityLevelConfigurationReferencePatchPtrOutput() PriorityLevelConfigurationReferencePatchPtrOutput {
	return i.ToPriorityLevelConfigurationReferencePatchPtrOutputWithContext(context.Background())
}

func (i *priorityLevelConfigurationReferencePatchPtrType) ToPriorityLevelConfigurationReferencePatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationReferencePatchPtrOutput)
}

// PriorityLevelConfigurationReference contains information that points to the "request-priority" being used.
type PriorityLevelConfigurationReferencePatchOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationReferencePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationReferencePatch)(nil)).Elem()
}

func (o PriorityLevelConfigurationReferencePatchOutput) ToPriorityLevelConfigurationReferencePatchOutput() PriorityLevelConfigurationReferencePatchOutput {
	return o
}

func (o PriorityLevelConfigurationReferencePatchOutput) ToPriorityLevelConfigurationReferencePatchOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePatchOutput {
	return o
}

func (o PriorityLevelConfigurationReferencePatchOutput) ToPriorityLevelConfigurationReferencePatchPtrOutput() PriorityLevelConfigurationReferencePatchPtrOutput {
	return o.ToPriorityLevelConfigurationReferencePatchPtrOutputWithContext(context.Background())
}

func (o PriorityLevelConfigurationReferencePatchOutput) ToPriorityLevelConfigurationReferencePatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PriorityLevelConfigurationReferencePatch) *PriorityLevelConfigurationReferencePatch {
		return &v
	}).(PriorityLevelConfigurationReferencePatchPtrOutput)
}

// `name` is the name of the priority level configuration being referenced Required.
func (o PriorityLevelConfigurationReferencePatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationReferencePatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type PriorityLevelConfigurationReferencePatchPtrOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationReferencePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationReferencePatch)(nil)).Elem()
}

func (o PriorityLevelConfigurationReferencePatchPtrOutput) ToPriorityLevelConfigurationReferencePatchPtrOutput() PriorityLevelConfigurationReferencePatchPtrOutput {
	return o
}

func (o PriorityLevelConfigurationReferencePatchPtrOutput) ToPriorityLevelConfigurationReferencePatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationReferencePatchPtrOutput {
	return o
}

func (o PriorityLevelConfigurationReferencePatchPtrOutput) Elem() PriorityLevelConfigurationReferencePatchOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationReferencePatch) PriorityLevelConfigurationReferencePatch {
		if v != nil {
			return *v
		}
		var ret PriorityLevelConfigurationReferencePatch
		return ret
	}).(PriorityLevelConfigurationReferencePatchOutput)
}

// `name` is the name of the priority level configuration being referenced Required.
func (o PriorityLevelConfigurationReferencePatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationReferencePatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// PriorityLevelConfigurationSpec specifies the configuration of a priority level.
type PriorityLevelConfigurationSpec struct {
	// `exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `"Limited"`. This field MAY be non-empty if `type` is `"Exempt"`. If empty and `type` is `"Exempt"` then the default values for `ExemptPriorityLevelConfiguration` apply.
	Exempt *ExemptPriorityLevelConfiguration `pulumi:"exempt"`
	// `limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `"Limited"`.
	Limited *LimitedPriorityLevelConfiguration `pulumi:"limited"`
	// `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required.
	Type string `pulumi:"type"`
}

// PriorityLevelConfigurationSpecInput is an input type that accepts PriorityLevelConfigurationSpecArgs and PriorityLevelConfigurationSpecOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationSpecInput` via:
//
//	PriorityLevelConfigurationSpecArgs{...}
type PriorityLevelConfigurationSpecInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationSpecOutput() PriorityLevelConfigurationSpecOutput
	ToPriorityLevelConfigurationSpecOutputWithContext(context.Context) PriorityLevelConfigurationSpecOutput
}

// PriorityLevelConfigurationSpec specifies the configuration of a priority level.
type PriorityLevelConfigurationSpecArgs struct {
	// `exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `"Limited"`. This field MAY be non-empty if `type` is `"Exempt"`. If empty and `type` is `"Exempt"` then the default values for `ExemptPriorityLevelConfiguration` apply.
	Exempt ExemptPriorityLevelConfigurationPtrInput `pulumi:"exempt"`
	// `limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `"Limited"`.
	Limited LimitedPriorityLevelConfigurationPtrInput `pulumi:"limited"`
	// `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required.
	Type pulumi.StringInput `pulumi:"type"`
}

func (PriorityLevelConfigurationSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationSpec)(nil)).Elem()
}

func (i PriorityLevelConfigurationSpecArgs) ToPriorityLevelConfigurationSpecOutput() PriorityLevelConfigurationSpecOutput {
	return i.ToPriorityLevelConfigurationSpecOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationSpecArgs) ToPriorityLevelConfigurationSpecOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationSpecOutput)
}

func (i PriorityLevelConfigurationSpecArgs) ToPriorityLevelConfigurationSpecPtrOutput() PriorityLevelConfigurationSpecPtrOutput {
	return i.ToPriorityLevelConfigurationSpecPtrOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationSpecArgs) ToPriorityLevelConfigurationSpecPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationSpecOutput).ToPriorityLevelConfigurationSpecPtrOutputWithContext(ctx)
}

// PriorityLevelConfigurationSpecPtrInput is an input type that accepts PriorityLevelConfigurationSpecArgs, PriorityLevelConfigurationSpecPtr and PriorityLevelConfigurationSpecPtrOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationSpecPtrInput` via:
//
//	        PriorityLevelConfigurationSpecArgs{...}
//
//	or:
//
//	        nil
type PriorityLevelConfigurationSpecPtrInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationSpecPtrOutput() PriorityLevelConfigurationSpecPtrOutput
	ToPriorityLevelConfigurationSpecPtrOutputWithContext(context.Context) PriorityLevelConfigurationSpecPtrOutput
}

type priorityLevelConfigurationSpecPtrType PriorityLevelConfigurationSpecArgs

func PriorityLevelConfigurationSpecPtr(v *PriorityLevelConfigurationSpecArgs) PriorityLevelConfigurationSpecPtrInput {
	return (*priorityLevelConfigurationSpecPtrType)(v)
}

func (*priorityLevelConfigurationSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationSpec)(nil)).Elem()
}

func (i *priorityLevelConfigurationSpecPtrType) ToPriorityLevelConfigurationSpecPtrOutput() PriorityLevelConfigurationSpecPtrOutput {
	return i.ToPriorityLevelConfigurationSpecPtrOutputWithContext(context.Background())
}

func (i *priorityLevelConfigurationSpecPtrType) ToPriorityLevelConfigurationSpecPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationSpecPtrOutput)
}

// PriorityLevelConfigurationSpec specifies the configuration of a priority level.
type PriorityLevelConfigurationSpecOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationSpec)(nil)).Elem()
}

func (o PriorityLevelConfigurationSpecOutput) ToPriorityLevelConfigurationSpecOutput() PriorityLevelConfigurationSpecOutput {
	return o
}

func (o PriorityLevelConfigurationSpecOutput) ToPriorityLevelConfigurationSpecOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecOutput {
	return o
}

func (o PriorityLevelConfigurationSpecOutput) ToPriorityLevelConfigurationSpecPtrOutput() PriorityLevelConfigurationSpecPtrOutput {
	return o.ToPriorityLevelConfigurationSpecPtrOutputWithContext(context.Background())
}

func (o PriorityLevelConfigurationSpecOutput) ToPriorityLevelConfigurationSpecPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PriorityLevelConfigurationSpec) *PriorityLevelConfigurationSpec {
		return &v
	}).(PriorityLevelConfigurationSpecPtrOutput)
}

// `exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `"Limited"`. This field MAY be non-empty if `type` is `"Exempt"`. If empty and `type` is `"Exempt"` then the default values for `ExemptPriorityLevelConfiguration` apply.
func (o PriorityLevelConfigurationSpecOutput) Exempt() ExemptPriorityLevelConfigurationPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationSpec) *ExemptPriorityLevelConfiguration { return v.Exempt }).(ExemptPriorityLevelConfigurationPtrOutput)
}

// `limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `"Limited"`.
func (o PriorityLevelConfigurationSpecOutput) Limited() LimitedPriorityLevelConfigurationPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationSpec) *LimitedPriorityLevelConfiguration { return v.Limited }).(LimitedPriorityLevelConfigurationPtrOutput)
}

// `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required.
func (o PriorityLevelConfigurationSpecOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationSpec) string { return v.Type }).(pulumi.StringOutput)
}

type PriorityLevelConfigurationSpecPtrOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationSpec)(nil)).Elem()
}

func (o PriorityLevelConfigurationSpecPtrOutput) ToPriorityLevelConfigurationSpecPtrOutput() PriorityLevelConfigurationSpecPtrOutput {
	return o
}

func (o PriorityLevelConfigurationSpecPtrOutput) ToPriorityLevelConfigurationSpecPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPtrOutput {
	return o
}

func (o PriorityLevelConfigurationSpecPtrOutput) Elem() PriorityLevelConfigurationSpecOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationSpec) PriorityLevelConfigurationSpec {
		if v != nil {
			return *v
		}
		var ret PriorityLevelConfigurationSpec
		return ret
	}).(PriorityLevelConfigurationSpecOutput)
}

// `exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `"Limited"`. This field MAY be non-empty if `type` is `"Exempt"`. If empty and `type` is `"Exempt"` then the default values for `ExemptPriorityLevelConfiguration` apply.
func (o PriorityLevelConfigurationSpecPtrOutput) Exempt() ExemptPriorityLevelConfigurationPtrOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationSpec) *ExemptPriorityLevelConfiguration {
		if v == nil {
			return nil
		}
		return v.Exempt
	}).(ExemptPriorityLevelConfigurationPtrOutput)
}

// `limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `"Limited"`.
func (o PriorityLevelConfigurationSpecPtrOutput) Limited() LimitedPriorityLevelConfigurationPtrOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationSpec) *LimitedPriorityLevelConfiguration {
		if v == nil {
			return nil
		}
		return v.Limited
	}).(LimitedPriorityLevelConfigurationPtrOutput)
}

// `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required.
func (o PriorityLevelConfigurationSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// PriorityLevelConfigurationSpec specifies the configuration of a priority level.
type PriorityLevelConfigurationSpecPatch struct {
	// `exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `"Limited"`. This field MAY be non-empty if `type` is `"Exempt"`. If empty and `type` is `"Exempt"` then the default values for `ExemptPriorityLevelConfiguration` apply.
	Exempt *ExemptPriorityLevelConfigurationPatch `pulumi:"exempt"`
	// `limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `"Limited"`.
	Limited *LimitedPriorityLevelConfigurationPatch `pulumi:"limited"`
	// `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required.
	Type *string `pulumi:"type"`
}

// PriorityLevelConfigurationSpecPatchInput is an input type that accepts PriorityLevelConfigurationSpecPatchArgs and PriorityLevelConfigurationSpecPatchOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationSpecPatchInput` via:
//
//	PriorityLevelConfigurationSpecPatchArgs{...}
type PriorityLevelConfigurationSpecPatchInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationSpecPatchOutput() PriorityLevelConfigurationSpecPatchOutput
	ToPriorityLevelConfigurationSpecPatchOutputWithContext(context.Context) PriorityLevelConfigurationSpecPatchOutput
}

// PriorityLevelConfigurationSpec specifies the configuration of a priority level.
type PriorityLevelConfigurationSpecPatchArgs struct {
	// `exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `"Limited"`. This field MAY be non-empty if `type` is `"Exempt"`. If empty and `type` is `"Exempt"` then the default values for `ExemptPriorityLevelConfiguration` apply.
	Exempt ExemptPriorityLevelConfigurationPatchPtrInput `pulumi:"exempt"`
	// `limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `"Limited"`.
	Limited LimitedPriorityLevelConfigurationPatchPtrInput `pulumi:"limited"`
	// `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (PriorityLevelConfigurationSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationSpecPatch)(nil)).Elem()
}

func (i PriorityLevelConfigurationSpecPatchArgs) ToPriorityLevelConfigurationSpecPatchOutput() PriorityLevelConfigurationSpecPatchOutput {
	return i.ToPriorityLevelConfigurationSpecPatchOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationSpecPatchArgs) ToPriorityLevelConfigurationSpecPatchOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationSpecPatchOutput)
}

func (i PriorityLevelConfigurationSpecPatchArgs) ToPriorityLevelConfigurationSpecPatchPtrOutput() PriorityLevelConfigurationSpecPatchPtrOutput {
	return i.ToPriorityLevelConfigurationSpecPatchPtrOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationSpecPatchArgs) ToPriorityLevelConfigurationSpecPatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationSpecPatchOutput).ToPriorityLevelConfigurationSpecPatchPtrOutputWithContext(ctx)
}

// PriorityLevelConfigurationSpecPatchPtrInput is an input type that accepts PriorityLevelConfigurationSpecPatchArgs, PriorityLevelConfigurationSpecPatchPtr and PriorityLevelConfigurationSpecPatchPtrOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationSpecPatchPtrInput` via:
//
//	        PriorityLevelConfigurationSpecPatchArgs{...}
//
//	or:
//
//	        nil
type PriorityLevelConfigurationSpecPatchPtrInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationSpecPatchPtrOutput() PriorityLevelConfigurationSpecPatchPtrOutput
	ToPriorityLevelConfigurationSpecPatchPtrOutputWithContext(context.Context) PriorityLevelConfigurationSpecPatchPtrOutput
}

type priorityLevelConfigurationSpecPatchPtrType PriorityLevelConfigurationSpecPatchArgs

func PriorityLevelConfigurationSpecPatchPtr(v *PriorityLevelConfigurationSpecPatchArgs) PriorityLevelConfigurationSpecPatchPtrInput {
	return (*priorityLevelConfigurationSpecPatchPtrType)(v)
}

func (*priorityLevelConfigurationSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationSpecPatch)(nil)).Elem()
}

func (i *priorityLevelConfigurationSpecPatchPtrType) ToPriorityLevelConfigurationSpecPatchPtrOutput() PriorityLevelConfigurationSpecPatchPtrOutput {
	return i.ToPriorityLevelConfigurationSpecPatchPtrOutputWithContext(context.Background())
}

func (i *priorityLevelConfigurationSpecPatchPtrType) ToPriorityLevelConfigurationSpecPatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationSpecPatchPtrOutput)
}

// PriorityLevelConfigurationSpec specifies the configuration of a priority level.
type PriorityLevelConfigurationSpecPatchOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationSpecPatch)(nil)).Elem()
}

func (o PriorityLevelConfigurationSpecPatchOutput) ToPriorityLevelConfigurationSpecPatchOutput() PriorityLevelConfigurationSpecPatchOutput {
	return o
}

func (o PriorityLevelConfigurationSpecPatchOutput) ToPriorityLevelConfigurationSpecPatchOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPatchOutput {
	return o
}

func (o PriorityLevelConfigurationSpecPatchOutput) ToPriorityLevelConfigurationSpecPatchPtrOutput() PriorityLevelConfigurationSpecPatchPtrOutput {
	return o.ToPriorityLevelConfigurationSpecPatchPtrOutputWithContext(context.Background())
}

func (o PriorityLevelConfigurationSpecPatchOutput) ToPriorityLevelConfigurationSpecPatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PriorityLevelConfigurationSpecPatch) *PriorityLevelConfigurationSpecPatch {
		return &v
	}).(PriorityLevelConfigurationSpecPatchPtrOutput)
}

// `exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `"Limited"`. This field MAY be non-empty if `type` is `"Exempt"`. If empty and `type` is `"Exempt"` then the default values for `ExemptPriorityLevelConfiguration` apply.
func (o PriorityLevelConfigurationSpecPatchOutput) Exempt() ExemptPriorityLevelConfigurationPatchPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationSpecPatch) *ExemptPriorityLevelConfigurationPatch { return v.Exempt }).(ExemptPriorityLevelConfigurationPatchPtrOutput)
}

// `limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `"Limited"`.
func (o PriorityLevelConfigurationSpecPatchOutput) Limited() LimitedPriorityLevelConfigurationPatchPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationSpecPatch) *LimitedPriorityLevelConfigurationPatch { return v.Limited }).(LimitedPriorityLevelConfigurationPatchPtrOutput)
}

// `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required.
func (o PriorityLevelConfigurationSpecPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationSpecPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type PriorityLevelConfigurationSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationSpecPatch)(nil)).Elem()
}

func (o PriorityLevelConfigurationSpecPatchPtrOutput) ToPriorityLevelConfigurationSpecPatchPtrOutput() PriorityLevelConfigurationSpecPatchPtrOutput {
	return o
}

func (o PriorityLevelConfigurationSpecPatchPtrOutput) ToPriorityLevelConfigurationSpecPatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationSpecPatchPtrOutput {
	return o
}

func (o PriorityLevelConfigurationSpecPatchPtrOutput) Elem() PriorityLevelConfigurationSpecPatchOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationSpecPatch) PriorityLevelConfigurationSpecPatch {
		if v != nil {
			return *v
		}
		var ret PriorityLevelConfigurationSpecPatch
		return ret
	}).(PriorityLevelConfigurationSpecPatchOutput)
}

// `exempt` specifies how requests are handled for an exempt priority level. This field MUST be empty if `type` is `"Limited"`. This field MAY be non-empty if `type` is `"Exempt"`. If empty and `type` is `"Exempt"` then the default values for `ExemptPriorityLevelConfiguration` apply.
func (o PriorityLevelConfigurationSpecPatchPtrOutput) Exempt() ExemptPriorityLevelConfigurationPatchPtrOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationSpecPatch) *ExemptPriorityLevelConfigurationPatch {
		if v == nil {
			return nil
		}
		return v.Exempt
	}).(ExemptPriorityLevelConfigurationPatchPtrOutput)
}

// `limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `"Limited"`.
func (o PriorityLevelConfigurationSpecPatchPtrOutput) Limited() LimitedPriorityLevelConfigurationPatchPtrOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationSpecPatch) *LimitedPriorityLevelConfigurationPatch {
		if v == nil {
			return nil
		}
		return v.Limited
	}).(LimitedPriorityLevelConfigurationPatchPtrOutput)
}

// `type` indicates whether this priority level is subject to limitation on request execution.  A value of `"Exempt"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `"Limited"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required.
func (o PriorityLevelConfigurationSpecPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// PriorityLevelConfigurationStatus represents the current state of a "request-priority".
type PriorityLevelConfigurationStatus struct {
	// `conditions` is the current state of "request-priority".
	Conditions []PriorityLevelConfigurationCondition `pulumi:"conditions"`
}

// PriorityLevelConfigurationStatusInput is an input type that accepts PriorityLevelConfigurationStatusArgs and PriorityLevelConfigurationStatusOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationStatusInput` via:
//
//	PriorityLevelConfigurationStatusArgs{...}
type PriorityLevelConfigurationStatusInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationStatusOutput() PriorityLevelConfigurationStatusOutput
	ToPriorityLevelConfigurationStatusOutputWithContext(context.Context) PriorityLevelConfigurationStatusOutput
}

// PriorityLevelConfigurationStatus represents the current state of a "request-priority".
type PriorityLevelConfigurationStatusArgs struct {
	// `conditions` is the current state of "request-priority".
	Conditions PriorityLevelConfigurationConditionArrayInput `pulumi:"conditions"`
}

func (PriorityLevelConfigurationStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationStatus)(nil)).Elem()
}

func (i PriorityLevelConfigurationStatusArgs) ToPriorityLevelConfigurationStatusOutput() PriorityLevelConfigurationStatusOutput {
	return i.ToPriorityLevelConfigurationStatusOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationStatusArgs) ToPriorityLevelConfigurationStatusOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationStatusOutput)
}

func (i PriorityLevelConfigurationStatusArgs) ToPriorityLevelConfigurationStatusPtrOutput() PriorityLevelConfigurationStatusPtrOutput {
	return i.ToPriorityLevelConfigurationStatusPtrOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationStatusArgs) ToPriorityLevelConfigurationStatusPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationStatusOutput).ToPriorityLevelConfigurationStatusPtrOutputWithContext(ctx)
}

// PriorityLevelConfigurationStatusPtrInput is an input type that accepts PriorityLevelConfigurationStatusArgs, PriorityLevelConfigurationStatusPtr and PriorityLevelConfigurationStatusPtrOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationStatusPtrInput` via:
//
//	        PriorityLevelConfigurationStatusArgs{...}
//
//	or:
//
//	        nil
type PriorityLevelConfigurationStatusPtrInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationStatusPtrOutput() PriorityLevelConfigurationStatusPtrOutput
	ToPriorityLevelConfigurationStatusPtrOutputWithContext(context.Context) PriorityLevelConfigurationStatusPtrOutput
}

type priorityLevelConfigurationStatusPtrType PriorityLevelConfigurationStatusArgs

func PriorityLevelConfigurationStatusPtr(v *PriorityLevelConfigurationStatusArgs) PriorityLevelConfigurationStatusPtrInput {
	return (*priorityLevelConfigurationStatusPtrType)(v)
}

func (*priorityLevelConfigurationStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationStatus)(nil)).Elem()
}

func (i *priorityLevelConfigurationStatusPtrType) ToPriorityLevelConfigurationStatusPtrOutput() PriorityLevelConfigurationStatusPtrOutput {
	return i.ToPriorityLevelConfigurationStatusPtrOutputWithContext(context.Background())
}

func (i *priorityLevelConfigurationStatusPtrType) ToPriorityLevelConfigurationStatusPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationStatusPtrOutput)
}

// PriorityLevelConfigurationStatus represents the current state of a "request-priority".
type PriorityLevelConfigurationStatusOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationStatus)(nil)).Elem()
}

func (o PriorityLevelConfigurationStatusOutput) ToPriorityLevelConfigurationStatusOutput() PriorityLevelConfigurationStatusOutput {
	return o
}

func (o PriorityLevelConfigurationStatusOutput) ToPriorityLevelConfigurationStatusOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusOutput {
	return o
}

func (o PriorityLevelConfigurationStatusOutput) ToPriorityLevelConfigurationStatusPtrOutput() PriorityLevelConfigurationStatusPtrOutput {
	return o.ToPriorityLevelConfigurationStatusPtrOutputWithContext(context.Background())
}

func (o PriorityLevelConfigurationStatusOutput) ToPriorityLevelConfigurationStatusPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PriorityLevelConfigurationStatus) *PriorityLevelConfigurationStatus {
		return &v
	}).(PriorityLevelConfigurationStatusPtrOutput)
}

// `conditions` is the current state of "request-priority".
func (o PriorityLevelConfigurationStatusOutput) Conditions() PriorityLevelConfigurationConditionArrayOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationStatus) []PriorityLevelConfigurationCondition { return v.Conditions }).(PriorityLevelConfigurationConditionArrayOutput)
}

type PriorityLevelConfigurationStatusPtrOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationStatus)(nil)).Elem()
}

func (o PriorityLevelConfigurationStatusPtrOutput) ToPriorityLevelConfigurationStatusPtrOutput() PriorityLevelConfigurationStatusPtrOutput {
	return o
}

func (o PriorityLevelConfigurationStatusPtrOutput) ToPriorityLevelConfigurationStatusPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPtrOutput {
	return o
}

func (o PriorityLevelConfigurationStatusPtrOutput) Elem() PriorityLevelConfigurationStatusOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationStatus) PriorityLevelConfigurationStatus {
		if v != nil {
			return *v
		}
		var ret PriorityLevelConfigurationStatus
		return ret
	}).(PriorityLevelConfigurationStatusOutput)
}

// `conditions` is the current state of "request-priority".
func (o PriorityLevelConfigurationStatusPtrOutput) Conditions() PriorityLevelConfigurationConditionArrayOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationStatus) []PriorityLevelConfigurationCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(PriorityLevelConfigurationConditionArrayOutput)
}

// PriorityLevelConfigurationStatus represents the current state of a "request-priority".
type PriorityLevelConfigurationStatusPatch struct {
	// `conditions` is the current state of "request-priority".
	Conditions []PriorityLevelConfigurationConditionPatch `pulumi:"conditions"`
}

// PriorityLevelConfigurationStatusPatchInput is an input type that accepts PriorityLevelConfigurationStatusPatchArgs and PriorityLevelConfigurationStatusPatchOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationStatusPatchInput` via:
//
//	PriorityLevelConfigurationStatusPatchArgs{...}
type PriorityLevelConfigurationStatusPatchInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationStatusPatchOutput() PriorityLevelConfigurationStatusPatchOutput
	ToPriorityLevelConfigurationStatusPatchOutputWithContext(context.Context) PriorityLevelConfigurationStatusPatchOutput
}

// PriorityLevelConfigurationStatus represents the current state of a "request-priority".
type PriorityLevelConfigurationStatusPatchArgs struct {
	// `conditions` is the current state of "request-priority".
	Conditions PriorityLevelConfigurationConditionPatchArrayInput `pulumi:"conditions"`
}

func (PriorityLevelConfigurationStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationStatusPatch)(nil)).Elem()
}

func (i PriorityLevelConfigurationStatusPatchArgs) ToPriorityLevelConfigurationStatusPatchOutput() PriorityLevelConfigurationStatusPatchOutput {
	return i.ToPriorityLevelConfigurationStatusPatchOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationStatusPatchArgs) ToPriorityLevelConfigurationStatusPatchOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationStatusPatchOutput)
}

func (i PriorityLevelConfigurationStatusPatchArgs) ToPriorityLevelConfigurationStatusPatchPtrOutput() PriorityLevelConfigurationStatusPatchPtrOutput {
	return i.ToPriorityLevelConfigurationStatusPatchPtrOutputWithContext(context.Background())
}

func (i PriorityLevelConfigurationStatusPatchArgs) ToPriorityLevelConfigurationStatusPatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationStatusPatchOutput).ToPriorityLevelConfigurationStatusPatchPtrOutputWithContext(ctx)
}

// PriorityLevelConfigurationStatusPatchPtrInput is an input type that accepts PriorityLevelConfigurationStatusPatchArgs, PriorityLevelConfigurationStatusPatchPtr and PriorityLevelConfigurationStatusPatchPtrOutput values.
// You can construct a concrete instance of `PriorityLevelConfigurationStatusPatchPtrInput` via:
//
//	        PriorityLevelConfigurationStatusPatchArgs{...}
//
//	or:
//
//	        nil
type PriorityLevelConfigurationStatusPatchPtrInput interface {
	pulumi.Input

	ToPriorityLevelConfigurationStatusPatchPtrOutput() PriorityLevelConfigurationStatusPatchPtrOutput
	ToPriorityLevelConfigurationStatusPatchPtrOutputWithContext(context.Context) PriorityLevelConfigurationStatusPatchPtrOutput
}

type priorityLevelConfigurationStatusPatchPtrType PriorityLevelConfigurationStatusPatchArgs

func PriorityLevelConfigurationStatusPatchPtr(v *PriorityLevelConfigurationStatusPatchArgs) PriorityLevelConfigurationStatusPatchPtrInput {
	return (*priorityLevelConfigurationStatusPatchPtrType)(v)
}

func (*priorityLevelConfigurationStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationStatusPatch)(nil)).Elem()
}

func (i *priorityLevelConfigurationStatusPatchPtrType) ToPriorityLevelConfigurationStatusPatchPtrOutput() PriorityLevelConfigurationStatusPatchPtrOutput {
	return i.ToPriorityLevelConfigurationStatusPatchPtrOutputWithContext(context.Background())
}

func (i *priorityLevelConfigurationStatusPatchPtrType) ToPriorityLevelConfigurationStatusPatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PriorityLevelConfigurationStatusPatchPtrOutput)
}

// PriorityLevelConfigurationStatus represents the current state of a "request-priority".
type PriorityLevelConfigurationStatusPatchOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PriorityLevelConfigurationStatusPatch)(nil)).Elem()
}

func (o PriorityLevelConfigurationStatusPatchOutput) ToPriorityLevelConfigurationStatusPatchOutput() PriorityLevelConfigurationStatusPatchOutput {
	return o
}

func (o PriorityLevelConfigurationStatusPatchOutput) ToPriorityLevelConfigurationStatusPatchOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPatchOutput {
	return o
}

func (o PriorityLevelConfigurationStatusPatchOutput) ToPriorityLevelConfigurationStatusPatchPtrOutput() PriorityLevelConfigurationStatusPatchPtrOutput {
	return o.ToPriorityLevelConfigurationStatusPatchPtrOutputWithContext(context.Background())
}

func (o PriorityLevelConfigurationStatusPatchOutput) ToPriorityLevelConfigurationStatusPatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PriorityLevelConfigurationStatusPatch) *PriorityLevelConfigurationStatusPatch {
		return &v
	}).(PriorityLevelConfigurationStatusPatchPtrOutput)
}

// `conditions` is the current state of "request-priority".
func (o PriorityLevelConfigurationStatusPatchOutput) Conditions() PriorityLevelConfigurationConditionPatchArrayOutput {
	return o.ApplyT(func(v PriorityLevelConfigurationStatusPatch) []PriorityLevelConfigurationConditionPatch {
		return v.Conditions
	}).(PriorityLevelConfigurationConditionPatchArrayOutput)
}

type PriorityLevelConfigurationStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (PriorityLevelConfigurationStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PriorityLevelConfigurationStatusPatch)(nil)).Elem()
}

func (o PriorityLevelConfigurationStatusPatchPtrOutput) ToPriorityLevelConfigurationStatusPatchPtrOutput() PriorityLevelConfigurationStatusPatchPtrOutput {
	return o
}

func (o PriorityLevelConfigurationStatusPatchPtrOutput) ToPriorityLevelConfigurationStatusPatchPtrOutputWithContext(ctx context.Context) PriorityLevelConfigurationStatusPatchPtrOutput {
	return o
}

func (o PriorityLevelConfigurationStatusPatchPtrOutput) Elem() PriorityLevelConfigurationStatusPatchOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationStatusPatch) PriorityLevelConfigurationStatusPatch {
		if v != nil {
			return *v
		}
		var ret PriorityLevelConfigurationStatusPatch
		return ret
	}).(PriorityLevelConfigurationStatusPatchOutput)
}

// `conditions` is the current state of "request-priority".
func (o PriorityLevelConfigurationStatusPatchPtrOutput) Conditions() PriorityLevelConfigurationConditionPatchArrayOutput {
	return o.ApplyT(func(v *PriorityLevelConfigurationStatusPatch) []PriorityLevelConfigurationConditionPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(PriorityLevelConfigurationConditionPatchArrayOutput)
}

// QueuingConfiguration holds the configuration parameters for queuing
type QueuingConfiguration struct {
	// `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8.
	HandSize *int `pulumi:"handSize"`
	// `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50.
	QueueLengthLimit *int `pulumi:"queueLengthLimit"`
	// `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64.
	Queues *int `pulumi:"queues"`
}

// QueuingConfigurationInput is an input type that accepts QueuingConfigurationArgs and QueuingConfigurationOutput values.
// You can construct a concrete instance of `QueuingConfigurationInput` via:
//
//	QueuingConfigurationArgs{...}
type QueuingConfigurationInput interface {
	pulumi.Input

	ToQueuingConfigurationOutput() QueuingConfigurationOutput
	ToQueuingConfigurationOutputWithContext(context.Context) QueuingConfigurationOutput
}

// QueuingConfiguration holds the configuration parameters for queuing
type QueuingConfigurationArgs struct {
	// `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8.
	HandSize pulumi.IntPtrInput `pulumi:"handSize"`
	// `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50.
	QueueLengthLimit pulumi.IntPtrInput `pulumi:"queueLengthLimit"`
	// `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64.
	Queues pulumi.IntPtrInput `pulumi:"queues"`
}

func (QueuingConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*QueuingConfiguration)(nil)).Elem()
}

func (i QueuingConfigurationArgs) ToQueuingConfigurationOutput() QueuingConfigurationOutput {
	return i.ToQueuingConfigurationOutputWithContext(context.Background())
}

func (i QueuingConfigurationArgs) ToQueuingConfigurationOutputWithContext(ctx context.Context) QueuingConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QueuingConfigurationOutput)
}

func (i QueuingConfigurationArgs) ToQueuingConfigurationPtrOutput() QueuingConfigurationPtrOutput {
	return i.ToQueuingConfigurationPtrOutputWithContext(context.Background())
}

func (i QueuingConfigurationArgs) ToQueuingConfigurationPtrOutputWithContext(ctx context.Context) QueuingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QueuingConfigurationOutput).ToQueuingConfigurationPtrOutputWithContext(ctx)
}

// QueuingConfigurationPtrInput is an input type that accepts QueuingConfigurationArgs, QueuingConfigurationPtr and QueuingConfigurationPtrOutput values.
// You can construct a concrete instance of `QueuingConfigurationPtrInput` via:
//
//	        QueuingConfigurationArgs{...}
//
//	or:
//
//	        nil
type QueuingConfigurationPtrInput interface {
	pulumi.Input

	ToQueuingConfigurationPtrOutput() QueuingConfigurationPtrOutput
	ToQueuingConfigurationPtrOutputWithContext(context.Context) QueuingConfigurationPtrOutput
}

type queuingConfigurationPtrType QueuingConfigurationArgs

func QueuingConfigurationPtr(v *QueuingConfigurationArgs) QueuingConfigurationPtrInput {
	return (*queuingConfigurationPtrType)(v)
}

func (*queuingConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**QueuingConfiguration)(nil)).Elem()
}

func (i *queuingConfigurationPtrType) ToQueuingConfigurationPtrOutput() QueuingConfigurationPtrOutput {
	return i.ToQueuingConfigurationPtrOutputWithContext(context.Background())
}

func (i *queuingConfigurationPtrType) ToQueuingConfigurationPtrOutputWithContext(ctx context.Context) QueuingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QueuingConfigurationPtrOutput)
}

// QueuingConfiguration holds the configuration parameters for queuing
type QueuingConfigurationOutput struct{ *pulumi.OutputState }

func (QueuingConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*QueuingConfiguration)(nil)).Elem()
}

func (o QueuingConfigurationOutput) ToQueuingConfigurationOutput() QueuingConfigurationOutput {
	return o
}

func (o QueuingConfigurationOutput) ToQueuingConfigurationOutputWithContext(ctx context.Context) QueuingConfigurationOutput {
	return o
}

func (o QueuingConfigurationOutput) ToQueuingConfigurationPtrOutput() QueuingConfigurationPtrOutput {
	return o.ToQueuingConfigurationPtrOutputWithContext(context.Background())
}

func (o QueuingConfigurationOutput) ToQueuingConfigurationPtrOutputWithContext(ctx context.Context) QueuingConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v QueuingConfiguration) *QueuingConfiguration {
		return &v
	}).(QueuingConfigurationPtrOutput)
}

// `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8.
func (o QueuingConfigurationOutput) HandSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v QueuingConfiguration) *int { return v.HandSize }).(pulumi.IntPtrOutput)
}

// `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50.
func (o QueuingConfigurationOutput) QueueLengthLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v QueuingConfiguration) *int { return v.QueueLengthLimit }).(pulumi.IntPtrOutput)
}

// `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64.
func (o QueuingConfigurationOutput) Queues() pulumi.IntPtrOutput {
	return o.ApplyT(func(v QueuingConfiguration) *int { return v.Queues }).(pulumi.IntPtrOutput)
}

type QueuingConfigurationPtrOutput struct{ *pulumi.OutputState }

func (QueuingConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**QueuingConfiguration)(nil)).Elem()
}

func (o QueuingConfigurationPtrOutput) ToQueuingConfigurationPtrOutput() QueuingConfigurationPtrOutput {
	return o
}

func (o QueuingConfigurationPtrOutput) ToQueuingConfigurationPtrOutputWithContext(ctx context.Context) QueuingConfigurationPtrOutput {
	return o
}

func (o QueuingConfigurationPtrOutput) Elem() QueuingConfigurationOutput {
	return o.ApplyT(func(v *QueuingConfiguration) QueuingConfiguration {
		if v != nil {
			return *v
		}
		var ret QueuingConfiguration
		return ret
	}).(QueuingConfigurationOutput)
}

// `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8.
func (o QueuingConfigurationPtrOutput) HandSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *QueuingConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.HandSize
	}).(pulumi.IntPtrOutput)
}

// `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50.
func (o QueuingConfigurationPtrOutput) QueueLengthLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *QueuingConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.QueueLengthLimit
	}).(pulumi.IntPtrOutput)
}

// `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64.
func (o QueuingConfigurationPtrOutput) Queues() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *QueuingConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.Queues
	}).(pulumi.IntPtrOutput)
}

// QueuingConfiguration holds the configuration parameters for queuing
type QueuingConfigurationPatch struct {
	// `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8.
	HandSize *int `pulumi:"handSize"`
	// `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50.
	QueueLengthLimit *int `pulumi:"queueLengthLimit"`
	// `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64.
	Queues *int `pulumi:"queues"`
}

// QueuingConfigurationPatchInput is an input type that accepts QueuingConfigurationPatchArgs and QueuingConfigurationPatchOutput values.
// You can construct a concrete instance of `QueuingConfigurationPatchInput` via:
//
//	QueuingConfigurationPatchArgs{...}
type QueuingConfigurationPatchInput interface {
	pulumi.Input

	ToQueuingConfigurationPatchOutput() QueuingConfigurationPatchOutput
	ToQueuingConfigurationPatchOutputWithContext(context.Context) QueuingConfigurationPatchOutput
}

// QueuingConfiguration holds the configuration parameters for queuing
type QueuingConfigurationPatchArgs struct {
	// `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8.
	HandSize pulumi.IntPtrInput `pulumi:"handSize"`
	// `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50.
	QueueLengthLimit pulumi.IntPtrInput `pulumi:"queueLengthLimit"`
	// `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64.
	Queues pulumi.IntPtrInput `pulumi:"queues"`
}

func (QueuingConfigurationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*QueuingConfigurationPatch)(nil)).Elem()
}

func (i QueuingConfigurationPatchArgs) ToQueuingConfigurationPatchOutput() QueuingConfigurationPatchOutput {
	return i.ToQueuingConfigurationPatchOutputWithContext(context.Background())
}

func (i QueuingConfigurationPatchArgs) ToQueuingConfigurationPatchOutputWithContext(ctx context.Context) QueuingConfigurationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QueuingConfigurationPatchOutput)
}

func (i QueuingConfigurationPatchArgs) ToQueuingConfigurationPatchPtrOutput() QueuingConfigurationPatchPtrOutput {
	return i.ToQueuingConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i QueuingConfigurationPatchArgs) ToQueuingConfigurationPatchPtrOutputWithContext(ctx context.Context) QueuingConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QueuingConfigurationPatchOutput).ToQueuingConfigurationPatchPtrOutputWithContext(ctx)
}

// QueuingConfigurationPatchPtrInput is an input type that accepts QueuingConfigurationPatchArgs, QueuingConfigurationPatchPtr and QueuingConfigurationPatchPtrOutput values.
// You can construct a concrete instance of `QueuingConfigurationPatchPtrInput` via:
//
//	        QueuingConfigurationPatchArgs{...}
//
//	or:
//
//	        nil
type QueuingConfigurationPatchPtrInput interface {
	pulumi.Input

	ToQueuingConfigurationPatchPtrOutput() QueuingConfigurationPatchPtrOutput
	ToQueuingConfigurationPatchPtrOutputWithContext(context.Context) QueuingConfigurationPatchPtrOutput
}

type queuingConfigurationPatchPtrType QueuingConfigurationPatchArgs

func QueuingConfigurationPatchPtr(v *QueuingConfigurationPatchArgs) QueuingConfigurationPatchPtrInput {
	return (*queuingConfigurationPatchPtrType)(v)
}

func (*queuingConfigurationPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**QueuingConfigurationPatch)(nil)).Elem()
}

func (i *queuingConfigurationPatchPtrType) ToQueuingConfigurationPatchPtrOutput() QueuingConfigurationPatchPtrOutput {
	return i.ToQueuingConfigurationPatchPtrOutputWithContext(context.Background())
}

func (i *queuingConfigurationPatchPtrType) ToQueuingConfigurationPatchPtrOutputWithContext(ctx context.Context) QueuingConfigurationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QueuingConfigurationPatchPtrOutput)
}

// QueuingConfiguration holds the configuration parameters for queuing
type QueuingConfigurationPatchOutput struct{ *pulumi.OutputState }

func (QueuingConfigurationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*QueuingConfigurationPatch)(nil)).Elem()
}

func (o QueuingConfigurationPatchOutput) ToQueuingConfigurationPatchOutput() QueuingConfigurationPatchOutput {
	return o
}

func (o QueuingConfigurationPatchOutput) ToQueuingConfigurationPatchOutputWithContext(ctx context.Context) QueuingConfigurationPatchOutput {
	return o
}

func (o QueuingConfigurationPatchOutput) ToQueuingConfigurationPatchPtrOutput() QueuingConfigurationPatchPtrOutput {
	return o.ToQueuingConfigurationPatchPtrOutputWithContext(context.Background())
}

func (o QueuingConfigurationPatchOutput) ToQueuingConfigurationPatchPtrOutputWithContext(ctx context.Context) QueuingConfigurationPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v QueuingConfigurationPatch) *QueuingConfigurationPatch {
		return &v
	}).(QueuingConfigurationPatchPtrOutput)
}

// `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8.
func (o QueuingConfigurationPatchOutput) HandSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v QueuingConfigurationPatch) *int { return v.HandSize }).(pulumi.IntPtrOutput)
}

// `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50.
func (o QueuingConfigurationPatchOutput) QueueLengthLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v QueuingConfigurationPatch) *int { return v.QueueLengthLimit }).(pulumi.IntPtrOutput)
}

// `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64.
func (o QueuingConfigurationPatchOutput) Queues() pulumi.IntPtrOutput {
	return o.ApplyT(func(v QueuingConfigurationPatch) *int { return v.Queues }).(pulumi.IntPtrOutput)
}

type QueuingConfigurationPatchPtrOutput struct{ *pulumi.OutputState }

func (QueuingConfigurationPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**QueuingConfigurationPatch)(nil)).Elem()
}

func (o QueuingConfigurationPatchPtrOutput) ToQueuingConfigurationPatchPtrOutput() QueuingConfigurationPatchPtrOutput {
	return o
}

func (o QueuingConfigurationPatchPtrOutput) ToQueuingConfigurationPatchPtrOutputWithContext(ctx context.Context) QueuingConfigurationPatchPtrOutput {
	return o
}

func (o QueuingConfigurationPatchPtrOutput) Elem() QueuingConfigurationPatchOutput {
	return o.ApplyT(func(v *QueuingConfigurationPatch) QueuingConfigurationPatch {
		if v != nil {
			return *v
		}
		var ret QueuingConfigurationPatch
		return ret
	}).(QueuingConfigurationPatchOutput)
}

// `handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8.
func (o QueuingConfigurationPatchPtrOutput) HandSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *QueuingConfigurationPatch) *int {
		if v == nil {
			return nil
		}
		return v.HandSize
	}).(pulumi.IntPtrOutput)
}

// `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50.
func (o QueuingConfigurationPatchPtrOutput) QueueLengthLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *QueuingConfigurationPatch) *int {
		if v == nil {
			return nil
		}
		return v.QueueLengthLimit
	}).(pulumi.IntPtrOutput)
}

// `queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64.
func (o QueuingConfigurationPatchPtrOutput) Queues() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *QueuingConfigurationPatch) *int {
		if v == nil {
			return nil
		}
		return v.Queues
	}).(pulumi.IntPtrOutput)
}

// ResourcePolicyRule is a predicate that matches some resource requests, testing the request's verb and the target resource. A ResourcePolicyRule matches a resource request if and only if: (a) at least one member of verbs matches the request, (b) at least one member of apiGroups matches the request, (c) at least one member of resources matches the request, and (d) either (d1) the request does not specify a namespace (i.e., `Namespace==""`) and clusterScope is true or (d2) the request specifies a namespace and least one member of namespaces matches the request's namespace.
type ResourcePolicyRule struct {
	// `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API groups and, if present, must be the only entry. Required.
	ApiGroups []string `pulumi:"apiGroups"`
	// `clusterScope` indicates whether to match requests that do not specify a namespace (which happens either because the resource is not namespaced or the request targets all namespaces). If this field is omitted or false then the `namespaces` field must contain a non-empty list.
	ClusterScope *bool `pulumi:"clusterScope"`
	// `namespaces` is a list of target namespaces that restricts matches.  A request that specifies a target namespace matches only if either (a) this list contains that target namespace or (b) this list contains "*".  Note that "*" matches any specified namespace but does not match a request that _does not specify_ a namespace (see the `clusterScope` field for that). This list may be empty, but only if `clusterScope` is true.
	Namespaces []string `pulumi:"namespaces"`
	// `resources` is a list of matching resources (i.e., lowercase and plural) with, if desired, subresource.  For example, [ "services", "nodes/status" ].  This list may not be empty. "*" matches all resources and, if present, must be the only entry. Required.
	Resources []string `pulumi:"resources"`
	// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if present, must be the only entry. Required.
	Verbs []string `pulumi:"verbs"`
}

// ResourcePolicyRuleInput is an input type that accepts ResourcePolicyRuleArgs and ResourcePolicyRuleOutput values.
// You can construct a concrete instance of `ResourcePolicyRuleInput` via:
//
//	ResourcePolicyRuleArgs{...}
type ResourcePolicyRuleInput interface {
	pulumi.Input

	ToResourcePolicyRuleOutput() ResourcePolicyRuleOutput
	ToResourcePolicyRuleOutputWithContext(context.Context) ResourcePolicyRuleOutput
}

// ResourcePolicyRule is a predicate that matches some resource requests, testing the request's verb and the target resource. A ResourcePolicyRule matches a resource request if and only if: (a) at least one member of verbs matches the request, (b) at least one member of apiGroups matches the request, (c) at least one member of resources matches the request, and (d) either (d1) the request does not specify a namespace (i.e., `Namespace==""`) and clusterScope is true or (d2) the request specifies a namespace and least one member of namespaces matches the request's namespace.
type ResourcePolicyRuleArgs struct {
	// `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API groups and, if present, must be the only entry. Required.
	ApiGroups pulumi.StringArrayInput `pulumi:"apiGroups"`
	// `clusterScope` indicates whether to match requests that do not specify a namespace (which happens either because the resource is not namespaced or the request targets all namespaces). If this field is omitted or false then the `namespaces` field must contain a non-empty list.
	ClusterScope pulumi.BoolPtrInput `pulumi:"clusterScope"`
	// `namespaces` is a list of target namespaces that restricts matches.  A request that specifies a target namespace matches only if either (a) this list contains that target namespace or (b) this list contains "*".  Note that "*" matches any specified namespace but does not match a request that _does not specify_ a namespace (see the `clusterScope` field for that). This list may be empty, but only if `clusterScope` is true.
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// `resources` is a list of matching resources (i.e., lowercase and plural) with, if desired, subresource.  For example, [ "services", "nodes/status" ].  This list may not be empty. "*" matches all resources and, if present, must be the only entry. Required.
	Resources pulumi.StringArrayInput `pulumi:"resources"`
	// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if present, must be the only entry. Required.
	Verbs pulumi.StringArrayInput `pulumi:"verbs"`
}

func (ResourcePolicyRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePolicyRule)(nil)).Elem()
}

func (i ResourcePolicyRuleArgs) ToResourcePolicyRuleOutput() ResourcePolicyRuleOutput {
	return i.ToResourcePolicyRuleOutputWithContext(context.Background())
}

func (i ResourcePolicyRuleArgs) ToResourcePolicyRuleOutputWithContext(ctx context.Context) ResourcePolicyRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePolicyRuleOutput)
}

// ResourcePolicyRuleArrayInput is an input type that accepts ResourcePolicyRuleArray and ResourcePolicyRuleArrayOutput values.
// You can construct a concrete instance of `ResourcePolicyRuleArrayInput` via:
//
//	ResourcePolicyRuleArray{ ResourcePolicyRuleArgs{...} }
type ResourcePolicyRuleArrayInput interface {
	pulumi.Input

	ToResourcePolicyRuleArrayOutput() ResourcePolicyRuleArrayOutput
	ToResourcePolicyRuleArrayOutputWithContext(context.Context) ResourcePolicyRuleArrayOutput
}

type ResourcePolicyRuleArray []ResourcePolicyRuleInput

func (ResourcePolicyRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourcePolicyRule)(nil)).Elem()
}

func (i ResourcePolicyRuleArray) ToResourcePolicyRuleArrayOutput() ResourcePolicyRuleArrayOutput {
	return i.ToResourcePolicyRuleArrayOutputWithContext(context.Background())
}

func (i ResourcePolicyRuleArray) ToResourcePolicyRuleArrayOutputWithContext(ctx context.Context) ResourcePolicyRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePolicyRuleArrayOutput)
}

// ResourcePolicyRule is a predicate that matches some resource requests, testing the request's verb and the target resource. A ResourcePolicyRule matches a resource request if and only if: (a) at least one member of verbs matches the request, (b) at least one member of apiGroups matches the request, (c) at least one member of resources matches the request, and (d) either (d1) the request does not specify a namespace (i.e., `Namespace==""`) and clusterScope is true or (d2) the request specifies a namespace and least one member of namespaces matches the request's namespace.
type ResourcePolicyRuleOutput struct{ *pulumi.OutputState }

func (ResourcePolicyRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePolicyRule)(nil)).Elem()
}

func (o ResourcePolicyRuleOutput) ToResourcePolicyRuleOutput() ResourcePolicyRuleOutput {
	return o
}

func (o ResourcePolicyRuleOutput) ToResourcePolicyRuleOutputWithContext(ctx context.Context) ResourcePolicyRuleOutput {
	return o
}

// `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API groups and, if present, must be the only entry. Required.
func (o ResourcePolicyRuleOutput) ApiGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourcePolicyRule) []string { return v.ApiGroups }).(pulumi.StringArrayOutput)
}

// `clusterScope` indicates whether to match requests that do not specify a namespace (which happens either because the resource is not namespaced or the request targets all namespaces). If this field is omitted or false then the `namespaces` field must contain a non-empty list.
func (o ResourcePolicyRuleOutput) ClusterScope() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourcePolicyRule) *bool { return v.ClusterScope }).(pulumi.BoolPtrOutput)
}

// `namespaces` is a list of target namespaces that restricts matches.  A request that specifies a target namespace matches only if either (a) this list contains that target namespace or (b) this list contains "*".  Note that "*" matches any specified namespace but does not match a request that _does not specify_ a namespace (see the `clusterScope` field for that). This list may be empty, but only if `clusterScope` is true.
func (o ResourcePolicyRuleOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourcePolicyRule) []string { return v.Namespaces }).(pulumi.StringArrayOutput)
}

// `resources` is a list of matching resources (i.e., lowercase and plural) with, if desired, subresource.  For example, [ "services", "nodes/status" ].  This list may not be empty. "*" matches all resources and, if present, must be the only entry. Required.
func (o ResourcePolicyRuleOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourcePolicyRule) []string { return v.Resources }).(pulumi.StringArrayOutput)
}

// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if present, must be the only entry. Required.
func (o ResourcePolicyRuleOutput) Verbs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourcePolicyRule) []string { return v.Verbs }).(pulumi.StringArrayOutput)
}

type ResourcePolicyRuleArrayOutput struct{ *pulumi.OutputState }

func (ResourcePolicyRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourcePolicyRule)(nil)).Elem()
}

func (o ResourcePolicyRuleArrayOutput) ToResourcePolicyRuleArrayOutput() ResourcePolicyRuleArrayOutput {
	return o
}

func (o ResourcePolicyRuleArrayOutput) ToResourcePolicyRuleArrayOutputWithContext(ctx context.Context) ResourcePolicyRuleArrayOutput {
	return o
}

func (o ResourcePolicyRuleArrayOutput) Index(i pulumi.IntInput) ResourcePolicyRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourcePolicyRule {
		return vs[0].([]ResourcePolicyRule)[vs[1].(int)]
	}).(ResourcePolicyRuleOutput)
}

// ResourcePolicyRule is a predicate that matches some resource requests, testing the request's verb and the target resource. A ResourcePolicyRule matches a resource request if and only if: (a) at least one member of verbs matches the request, (b) at least one member of apiGroups matches the request, (c) at least one member of resources matches the request, and (d) either (d1) the request does not specify a namespace (i.e., `Namespace==""`) and clusterScope is true or (d2) the request specifies a namespace and least one member of namespaces matches the request's namespace.
type ResourcePolicyRulePatch struct {
	// `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API groups and, if present, must be the only entry. Required.
	ApiGroups []string `pulumi:"apiGroups"`
	// `clusterScope` indicates whether to match requests that do not specify a namespace (which happens either because the resource is not namespaced or the request targets all namespaces). If this field is omitted or false then the `namespaces` field must contain a non-empty list.
	ClusterScope *bool `pulumi:"clusterScope"`
	// `namespaces` is a list of target namespaces that restricts matches.  A request that specifies a target namespace matches only if either (a) this list contains that target namespace or (b) this list contains "*".  Note that "*" matches any specified namespace but does not match a request that _does not specify_ a namespace (see the `clusterScope` field for that). This list may be empty, but only if `clusterScope` is true.
	Namespaces []string `pulumi:"namespaces"`
	// `resources` is a list of matching resources (i.e., lowercase and plural) with, if desired, subresource.  For example, [ "services", "nodes/status" ].  This list may not be empty. "*" matches all resources and, if present, must be the only entry. Required.
	Resources []string `pulumi:"resources"`
	// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if present, must be the only entry. Required.
	Verbs []string `pulumi:"verbs"`
}

// ResourcePolicyRulePatchInput is an input type that accepts ResourcePolicyRulePatchArgs and ResourcePolicyRulePatchOutput values.
// You can construct a concrete instance of `ResourcePolicyRulePatchInput` via:
//
//	ResourcePolicyRulePatchArgs{...}
type ResourcePolicyRulePatchInput interface {
	pulumi.Input

	ToResourcePolicyRulePatchOutput() ResourcePolicyRulePatchOutput
	ToResourcePolicyRulePatchOutputWithContext(context.Context) ResourcePolicyRulePatchOutput
}

// ResourcePolicyRule is a predicate that matches some resource requests, testing the request's verb and the target resource. A ResourcePolicyRule matches a resource request if and only if: (a) at least one member of verbs matches the request, (b) at least one member of apiGroups matches the request, (c) at least one member of resources matches the request, and (d) either (d1) the request does not specify a namespace (i.e., `Namespace==""`) and clusterScope is true or (d2) the request specifies a namespace and least one member of namespaces matches the request's namespace.
type ResourcePolicyRulePatchArgs struct {
	// `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API groups and, if present, must be the only entry. Required.
	ApiGroups pulumi.StringArrayInput `pulumi:"apiGroups"`
	// `clusterScope` indicates whether to match requests that do not specify a namespace (which happens either because the resource is not namespaced or the request targets all namespaces). If this field is omitted or false then the `namespaces` field must contain a non-empty list.
	ClusterScope pulumi.BoolPtrInput `pulumi:"clusterScope"`
	// `namespaces` is a list of target namespaces that restricts matches.  A request that specifies a target namespace matches only if either (a) this list contains that target namespace or (b) this list contains "*".  Note that "*" matches any specified namespace but does not match a request that _does not specify_ a namespace (see the `clusterScope` field for that). This list may be empty, but only if `clusterScope` is true.
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// `resources` is a list of matching resources (i.e., lowercase and plural) with, if desired, subresource.  For example, [ "services", "nodes/status" ].  This list may not be empty. "*" matches all resources and, if present, must be the only entry. Required.
	Resources pulumi.StringArrayInput `pulumi:"resources"`
	// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if present, must be the only entry. Required.
	Verbs pulumi.StringArrayInput `pulumi:"verbs"`
}

func (ResourcePolicyRulePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePolicyRulePatch)(nil)).Elem()
}

func (i ResourcePolicyRulePatchArgs) ToResourcePolicyRulePatchOutput() ResourcePolicyRulePatchOutput {
	return i.ToResourcePolicyRulePatchOutputWithContext(context.Background())
}

func (i ResourcePolicyRulePatchArgs) ToResourcePolicyRulePatchOutputWithContext(ctx context.Context) ResourcePolicyRulePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePolicyRulePatchOutput)
}

// ResourcePolicyRulePatchArrayInput is an input type that accepts ResourcePolicyRulePatchArray and ResourcePolicyRulePatchArrayOutput values.
// You can construct a concrete instance of `ResourcePolicyRulePatchArrayInput` via:
//
//	ResourcePolicyRulePatchArray{ ResourcePolicyRulePatchArgs{...} }
type ResourcePolicyRulePatchArrayInput interface {
	pulumi.Input

	ToResourcePolicyRulePatchArrayOutput() ResourcePolicyRulePatchArrayOutput
	ToResourcePolicyRulePatchArrayOutputWithContext(context.Context) ResourcePolicyRulePatchArrayOutput
}

type ResourcePolicyRulePatchArray []ResourcePolicyRulePatchInput

func (ResourcePolicyRulePatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourcePolicyRulePatch)(nil)).Elem()
}

func (i ResourcePolicyRulePatchArray) ToResourcePolicyRulePatchArrayOutput() ResourcePolicyRulePatchArrayOutput {
	return i.ToResourcePolicyRulePatchArrayOutputWithContext(context.Background())
}

func (i ResourcePolicyRulePatchArray) ToResourcePolicyRulePatchArrayOutputWithContext(ctx context.Context) ResourcePolicyRulePatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePolicyRulePatchArrayOutput)
}

// ResourcePolicyRule is a predicate that matches some resource requests, testing the request's verb and the target resource. A ResourcePolicyRule matches a resource request if and only if: (a) at least one member of verbs matches the request, (b) at least one member of apiGroups matches the request, (c) at least one member of resources matches the request, and (d) either (d1) the request does not specify a namespace (i.e., `Namespace==""`) and clusterScope is true or (d2) the request specifies a namespace and least one member of namespaces matches the request's namespace.
type ResourcePolicyRulePatchOutput struct{ *pulumi.OutputState }

func (ResourcePolicyRulePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourcePolicyRulePatch)(nil)).Elem()
}

func (o ResourcePolicyRulePatchOutput) ToResourcePolicyRulePatchOutput() ResourcePolicyRulePatchOutput {
	return o
}

func (o ResourcePolicyRulePatchOutput) ToResourcePolicyRulePatchOutputWithContext(ctx context.Context) ResourcePolicyRulePatchOutput {
	return o
}

// `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API groups and, if present, must be the only entry. Required.
func (o ResourcePolicyRulePatchOutput) ApiGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourcePolicyRulePatch) []string { return v.ApiGroups }).(pulumi.StringArrayOutput)
}

// `clusterScope` indicates whether to match requests that do not specify a namespace (which happens either because the resource is not namespaced or the request targets all namespaces). If this field is omitted or false then the `namespaces` field must contain a non-empty list.
func (o ResourcePolicyRulePatchOutput) ClusterScope() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ResourcePolicyRulePatch) *bool { return v.ClusterScope }).(pulumi.BoolPtrOutput)
}

// `namespaces` is a list of target namespaces that restricts matches.  A request that specifies a target namespace matches only if either (a) this list contains that target namespace or (b) this list contains "*".  Note that "*" matches any specified namespace but does not match a request that _does not specify_ a namespace (see the `clusterScope` field for that). This list may be empty, but only if `clusterScope` is true.
func (o ResourcePolicyRulePatchOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourcePolicyRulePatch) []string { return v.Namespaces }).(pulumi.StringArrayOutput)
}

// `resources` is a list of matching resources (i.e., lowercase and plural) with, if desired, subresource.  For example, [ "services", "nodes/status" ].  This list may not be empty. "*" matches all resources and, if present, must be the only entry. Required.
func (o ResourcePolicyRulePatchOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourcePolicyRulePatch) []string { return v.Resources }).(pulumi.StringArrayOutput)
}

// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if present, must be the only entry. Required.
func (o ResourcePolicyRulePatchOutput) Verbs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ResourcePolicyRulePatch) []string { return v.Verbs }).(pulumi.StringArrayOutput)
}

type ResourcePolicyRulePatchArrayOutput struct{ *pulumi.OutputState }

func (ResourcePolicyRulePatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourcePolicyRulePatch)(nil)).Elem()
}

func (o ResourcePolicyRulePatchArrayOutput) ToResourcePolicyRulePatchArrayOutput() ResourcePolicyRulePatchArrayOutput {
	return o
}

func (o ResourcePolicyRulePatchArrayOutput) ToResourcePolicyRulePatchArrayOutputWithContext(ctx context.Context) ResourcePolicyRulePatchArrayOutput {
	return o
}

func (o ResourcePolicyRulePatchArrayOutput) Index(i pulumi.IntInput) ResourcePolicyRulePatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourcePolicyRulePatch {
		return vs[0].([]ResourcePolicyRulePatch)[vs[1].(int)]
	}).(ResourcePolicyRulePatchOutput)
}

// ServiceAccountSubject holds detailed information for service-account-kind subject.
type ServiceAccountSubject struct {
	// `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required.
	Name string `pulumi:"name"`
	// `namespace` is the namespace of matching ServiceAccount objects. Required.
	Namespace string `pulumi:"namespace"`
}

// ServiceAccountSubjectInput is an input type that accepts ServiceAccountSubjectArgs and ServiceAccountSubjectOutput values.
// You can construct a concrete instance of `ServiceAccountSubjectInput` via:
//
//	ServiceAccountSubjectArgs{...}
type ServiceAccountSubjectInput interface {
	pulumi.Input

	ToServiceAccountSubjectOutput() ServiceAccountSubjectOutput
	ToServiceAccountSubjectOutputWithContext(context.Context) ServiceAccountSubjectOutput
}

// ServiceAccountSubject holds detailed information for service-account-kind subject.
type ServiceAccountSubjectArgs struct {
	// `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required.
	Name pulumi.StringInput `pulumi:"name"`
	// `namespace` is the namespace of matching ServiceAccount objects. Required.
	Namespace pulumi.StringInput `pulumi:"namespace"`
}

func (ServiceAccountSubjectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccountSubject)(nil)).Elem()
}

func (i ServiceAccountSubjectArgs) ToServiceAccountSubjectOutput() ServiceAccountSubjectOutput {
	return i.ToServiceAccountSubjectOutputWithContext(context.Background())
}

func (i ServiceAccountSubjectArgs) ToServiceAccountSubjectOutputWithContext(ctx context.Context) ServiceAccountSubjectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountSubjectOutput)
}

func (i ServiceAccountSubjectArgs) ToServiceAccountSubjectPtrOutput() ServiceAccountSubjectPtrOutput {
	return i.ToServiceAccountSubjectPtrOutputWithContext(context.Background())
}

func (i ServiceAccountSubjectArgs) ToServiceAccountSubjectPtrOutputWithContext(ctx context.Context) ServiceAccountSubjectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountSubjectOutput).ToServiceAccountSubjectPtrOutputWithContext(ctx)
}

// ServiceAccountSubjectPtrInput is an input type that accepts ServiceAccountSubjectArgs, ServiceAccountSubjectPtr and ServiceAccountSubjectPtrOutput values.
// You can construct a concrete instance of `ServiceAccountSubjectPtrInput` via:
//
//	        ServiceAccountSubjectArgs{...}
//
//	or:
//
//	        nil
type ServiceAccountSubjectPtrInput interface {
	pulumi.Input

	ToServiceAccountSubjectPtrOutput() ServiceAccountSubjectPtrOutput
	ToServiceAccountSubjectPtrOutputWithContext(context.Context) ServiceAccountSubjectPtrOutput
}

type serviceAccountSubjectPtrType ServiceAccountSubjectArgs

func ServiceAccountSubjectPtr(v *ServiceAccountSubjectArgs) ServiceAccountSubjectPtrInput {
	return (*serviceAccountSubjectPtrType)(v)
}

func (*serviceAccountSubjectPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccountSubject)(nil)).Elem()
}

func (i *serviceAccountSubjectPtrType) ToServiceAccountSubjectPtrOutput() ServiceAccountSubjectPtrOutput {
	return i.ToServiceAccountSubjectPtrOutputWithContext(context.Background())
}

func (i *serviceAccountSubjectPtrType) ToServiceAccountSubjectPtrOutputWithContext(ctx context.Context) ServiceAccountSubjectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountSubjectPtrOutput)
}

// ServiceAccountSubject holds detailed information for service-account-kind subject.
type ServiceAccountSubjectOutput struct{ *pulumi.OutputState }

func (ServiceAccountSubjectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccountSubject)(nil)).Elem()
}

func (o ServiceAccountSubjectOutput) ToServiceAccountSubjectOutput() ServiceAccountSubjectOutput {
	return o
}

func (o ServiceAccountSubjectOutput) ToServiceAccountSubjectOutputWithContext(ctx context.Context) ServiceAccountSubjectOutput {
	return o
}

func (o ServiceAccountSubjectOutput) ToServiceAccountSubjectPtrOutput() ServiceAccountSubjectPtrOutput {
	return o.ToServiceAccountSubjectPtrOutputWithContext(context.Background())
}

func (o ServiceAccountSubjectOutput) ToServiceAccountSubjectPtrOutputWithContext(ctx context.Context) ServiceAccountSubjectPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServiceAccountSubject) *ServiceAccountSubject {
		return &v
	}).(ServiceAccountSubjectPtrOutput)
}

// `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required.
func (o ServiceAccountSubjectOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceAccountSubject) string { return v.Name }).(pulumi.StringOutput)
}

// `namespace` is the namespace of matching ServiceAccount objects. Required.
func (o ServiceAccountSubjectOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceAccountSubject) string { return v.Namespace }).(pulumi.StringOutput)
}

type ServiceAccountSubjectPtrOutput struct{ *pulumi.OutputState }

func (ServiceAccountSubjectPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccountSubject)(nil)).Elem()
}

func (o ServiceAccountSubjectPtrOutput) ToServiceAccountSubjectPtrOutput() ServiceAccountSubjectPtrOutput {
	return o
}

func (o ServiceAccountSubjectPtrOutput) ToServiceAccountSubjectPtrOutputWithContext(ctx context.Context) ServiceAccountSubjectPtrOutput {
	return o
}

func (o ServiceAccountSubjectPtrOutput) Elem() ServiceAccountSubjectOutput {
	return o.ApplyT(func(v *ServiceAccountSubject) ServiceAccountSubject {
		if v != nil {
			return *v
		}
		var ret ServiceAccountSubject
		return ret
	}).(ServiceAccountSubjectOutput)
}

// `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required.
func (o ServiceAccountSubjectPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAccountSubject) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// `namespace` is the namespace of matching ServiceAccount objects. Required.
func (o ServiceAccountSubjectPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAccountSubject) *string {
		if v == nil {
			return nil
		}
		return &v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ServiceAccountSubject holds detailed information for service-account-kind subject.
type ServiceAccountSubjectPatch struct {
	// `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required.
	Name *string `pulumi:"name"`
	// `namespace` is the namespace of matching ServiceAccount objects. Required.
	Namespace *string `pulumi:"namespace"`
}

// ServiceAccountSubjectPatchInput is an input type that accepts ServiceAccountSubjectPatchArgs and ServiceAccountSubjectPatchOutput values.
// You can construct a concrete instance of `ServiceAccountSubjectPatchInput` via:
//
//	ServiceAccountSubjectPatchArgs{...}
type ServiceAccountSubjectPatchInput interface {
	pulumi.Input

	ToServiceAccountSubjectPatchOutput() ServiceAccountSubjectPatchOutput
	ToServiceAccountSubjectPatchOutputWithContext(context.Context) ServiceAccountSubjectPatchOutput
}

// ServiceAccountSubject holds detailed information for service-account-kind subject.
type ServiceAccountSubjectPatchArgs struct {
	// `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// `namespace` is the namespace of matching ServiceAccount objects. Required.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (ServiceAccountSubjectPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccountSubjectPatch)(nil)).Elem()
}

func (i ServiceAccountSubjectPatchArgs) ToServiceAccountSubjectPatchOutput() ServiceAccountSubjectPatchOutput {
	return i.ToServiceAccountSubjectPatchOutputWithContext(context.Background())
}

func (i ServiceAccountSubjectPatchArgs) ToServiceAccountSubjectPatchOutputWithContext(ctx context.Context) ServiceAccountSubjectPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountSubjectPatchOutput)
}

func (i ServiceAccountSubjectPatchArgs) ToServiceAccountSubjectPatchPtrOutput() ServiceAccountSubjectPatchPtrOutput {
	return i.ToServiceAccountSubjectPatchPtrOutputWithContext(context.Background())
}

func (i ServiceAccountSubjectPatchArgs) ToServiceAccountSubjectPatchPtrOutputWithContext(ctx context.Context) ServiceAccountSubjectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountSubjectPatchOutput).ToServiceAccountSubjectPatchPtrOutputWithContext(ctx)
}

// ServiceAccountSubjectPatchPtrInput is an input type that accepts ServiceAccountSubjectPatchArgs, ServiceAccountSubjectPatchPtr and ServiceAccountSubjectPatchPtrOutput values.
// You can construct a concrete instance of `ServiceAccountSubjectPatchPtrInput` via:
//
//	        ServiceAccountSubjectPatchArgs{...}
//
//	or:
//
//	        nil
type ServiceAccountSubjectPatchPtrInput interface {
	pulumi.Input

	ToServiceAccountSubjectPatchPtrOutput() ServiceAccountSubjectPatchPtrOutput
	ToServiceAccountSubjectPatchPtrOutputWithContext(context.Context) ServiceAccountSubjectPatchPtrOutput
}

type serviceAccountSubjectPatchPtrType ServiceAccountSubjectPatchArgs

func ServiceAccountSubjectPatchPtr(v *ServiceAccountSubjectPatchArgs) ServiceAccountSubjectPatchPtrInput {
	return (*serviceAccountSubjectPatchPtrType)(v)
}

func (*serviceAccountSubjectPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccountSubjectPatch)(nil)).Elem()
}

func (i *serviceAccountSubjectPatchPtrType) ToServiceAccountSubjectPatchPtrOutput() ServiceAccountSubjectPatchPtrOutput {
	return i.ToServiceAccountSubjectPatchPtrOutputWithContext(context.Background())
}

func (i *serviceAccountSubjectPatchPtrType) ToServiceAccountSubjectPatchPtrOutputWithContext(ctx context.Context) ServiceAccountSubjectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountSubjectPatchPtrOutput)
}

// ServiceAccountSubject holds detailed information for service-account-kind subject.
type ServiceAccountSubjectPatchOutput struct{ *pulumi.OutputState }

func (ServiceAccountSubjectPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccountSubjectPatch)(nil)).Elem()
}

func (o ServiceAccountSubjectPatchOutput) ToServiceAccountSubjectPatchOutput() ServiceAccountSubjectPatchOutput {
	return o
}

func (o ServiceAccountSubjectPatchOutput) ToServiceAccountSubjectPatchOutputWithContext(ctx context.Context) ServiceAccountSubjectPatchOutput {
	return o
}

func (o ServiceAccountSubjectPatchOutput) ToServiceAccountSubjectPatchPtrOutput() ServiceAccountSubjectPatchPtrOutput {
	return o.ToServiceAccountSubjectPatchPtrOutputWithContext(context.Background())
}

func (o ServiceAccountSubjectPatchOutput) ToServiceAccountSubjectPatchPtrOutputWithContext(ctx context.Context) ServiceAccountSubjectPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServiceAccountSubjectPatch) *ServiceAccountSubjectPatch {
		return &v
	}).(ServiceAccountSubjectPatchPtrOutput)
}

// `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required.
func (o ServiceAccountSubjectPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceAccountSubjectPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// `namespace` is the namespace of matching ServiceAccount objects. Required.
func (o ServiceAccountSubjectPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceAccountSubjectPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type ServiceAccountSubjectPatchPtrOutput struct{ *pulumi.OutputState }

func (ServiceAccountSubjectPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccountSubjectPatch)(nil)).Elem()
}

func (o ServiceAccountSubjectPatchPtrOutput) ToServiceAccountSubjectPatchPtrOutput() ServiceAccountSubjectPatchPtrOutput {
	return o
}

func (o ServiceAccountSubjectPatchPtrOutput) ToServiceAccountSubjectPatchPtrOutputWithContext(ctx context.Context) ServiceAccountSubjectPatchPtrOutput {
	return o
}

func (o ServiceAccountSubjectPatchPtrOutput) Elem() ServiceAccountSubjectPatchOutput {
	return o.ApplyT(func(v *ServiceAccountSubjectPatch) ServiceAccountSubjectPatch {
		if v != nil {
			return *v
		}
		var ret ServiceAccountSubjectPatch
		return ret
	}).(ServiceAccountSubjectPatchOutput)
}

// `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name. Required.
func (o ServiceAccountSubjectPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAccountSubjectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// `namespace` is the namespace of matching ServiceAccount objects. Required.
func (o ServiceAccountSubjectPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAccountSubjectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account.
type Subject struct {
	// `group` matches based on user group name.
	Group *GroupSubject `pulumi:"group"`
	// `kind` indicates which one of the other fields is non-empty. Required
	Kind string `pulumi:"kind"`
	// `serviceAccount` matches ServiceAccounts.
	ServiceAccount *ServiceAccountSubject `pulumi:"serviceAccount"`
	// `user` matches based on username.
	User *UserSubject `pulumi:"user"`
}

// SubjectInput is an input type that accepts SubjectArgs and SubjectOutput values.
// You can construct a concrete instance of `SubjectInput` via:
//
//	SubjectArgs{...}
type SubjectInput interface {
	pulumi.Input

	ToSubjectOutput() SubjectOutput
	ToSubjectOutputWithContext(context.Context) SubjectOutput
}

// Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account.
type SubjectArgs struct {
	// `group` matches based on user group name.
	Group GroupSubjectPtrInput `pulumi:"group"`
	// `kind` indicates which one of the other fields is non-empty. Required
	Kind pulumi.StringInput `pulumi:"kind"`
	// `serviceAccount` matches ServiceAccounts.
	ServiceAccount ServiceAccountSubjectPtrInput `pulumi:"serviceAccount"`
	// `user` matches based on username.
	User UserSubjectPtrInput `pulumi:"user"`
}

func (SubjectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Subject)(nil)).Elem()
}

func (i SubjectArgs) ToSubjectOutput() SubjectOutput {
	return i.ToSubjectOutputWithContext(context.Background())
}

func (i SubjectArgs) ToSubjectOutputWithContext(ctx context.Context) SubjectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubjectOutput)
}

// SubjectArrayInput is an input type that accepts SubjectArray and SubjectArrayOutput values.
// You can construct a concrete instance of `SubjectArrayInput` via:
//
//	SubjectArray{ SubjectArgs{...} }
type SubjectArrayInput interface {
	pulumi.Input

	ToSubjectArrayOutput() SubjectArrayOutput
	ToSubjectArrayOutputWithContext(context.Context) SubjectArrayOutput
}

type SubjectArray []SubjectInput

func (SubjectArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Subject)(nil)).Elem()
}

func (i SubjectArray) ToSubjectArrayOutput() SubjectArrayOutput {
	return i.ToSubjectArrayOutputWithContext(context.Background())
}

func (i SubjectArray) ToSubjectArrayOutputWithContext(ctx context.Context) SubjectArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubjectArrayOutput)
}

// Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account.
type SubjectOutput struct{ *pulumi.OutputState }

func (SubjectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Subject)(nil)).Elem()
}

func (o SubjectOutput) ToSubjectOutput() SubjectOutput {
	return o
}

func (o SubjectOutput) ToSubjectOutputWithContext(ctx context.Context) SubjectOutput {
	return o
}

// `group` matches based on user group name.
func (o SubjectOutput) Group() GroupSubjectPtrOutput {
	return o.ApplyT(func(v Subject) *GroupSubject { return v.Group }).(GroupSubjectPtrOutput)
}

// `kind` indicates which one of the other fields is non-empty. Required
func (o SubjectOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v Subject) string { return v.Kind }).(pulumi.StringOutput)
}

// `serviceAccount` matches ServiceAccounts.
func (o SubjectOutput) ServiceAccount() ServiceAccountSubjectPtrOutput {
	return o.ApplyT(func(v Subject) *ServiceAccountSubject { return v.ServiceAccount }).(ServiceAccountSubjectPtrOutput)
}

// `user` matches based on username.
func (o SubjectOutput) User() UserSubjectPtrOutput {
	return o.ApplyT(func(v Subject) *UserSubject { return v.User }).(UserSubjectPtrOutput)
}

type SubjectArrayOutput struct{ *pulumi.OutputState }

func (SubjectArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Subject)(nil)).Elem()
}

func (o SubjectArrayOutput) ToSubjectArrayOutput() SubjectArrayOutput {
	return o
}

func (o SubjectArrayOutput) ToSubjectArrayOutputWithContext(ctx context.Context) SubjectArrayOutput {
	return o
}

func (o SubjectArrayOutput) Index(i pulumi.IntInput) SubjectOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Subject {
		return vs[0].([]Subject)[vs[1].(int)]
	}).(SubjectOutput)
}

// Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account.
type SubjectPatch struct {
	// `group` matches based on user group name.
	Group *GroupSubjectPatch `pulumi:"group"`
	// `kind` indicates which one of the other fields is non-empty. Required
	Kind *string `pulumi:"kind"`
	// `serviceAccount` matches ServiceAccounts.
	ServiceAccount *ServiceAccountSubjectPatch `pulumi:"serviceAccount"`
	// `user` matches based on username.
	User *UserSubjectPatch `pulumi:"user"`
}

// SubjectPatchInput is an input type that accepts SubjectPatchArgs and SubjectPatchOutput values.
// You can construct a concrete instance of `SubjectPatchInput` via:
//
//	SubjectPatchArgs{...}
type SubjectPatchInput interface {
	pulumi.Input

	ToSubjectPatchOutput() SubjectPatchOutput
	ToSubjectPatchOutputWithContext(context.Context) SubjectPatchOutput
}

// Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account.
type SubjectPatchArgs struct {
	// `group` matches based on user group name.
	Group GroupSubjectPatchPtrInput `pulumi:"group"`
	// `kind` indicates which one of the other fields is non-empty. Required
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// `serviceAccount` matches ServiceAccounts.
	ServiceAccount ServiceAccountSubjectPatchPtrInput `pulumi:"serviceAccount"`
	// `user` matches based on username.
	User UserSubjectPatchPtrInput `pulumi:"user"`
}

func (SubjectPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubjectPatch)(nil)).Elem()
}

func (i SubjectPatchArgs) ToSubjectPatchOutput() SubjectPatchOutput {
	return i.ToSubjectPatchOutputWithContext(context.Background())
}

func (i SubjectPatchArgs) ToSubjectPatchOutputWithContext(ctx context.Context) SubjectPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubjectPatchOutput)
}

// SubjectPatchArrayInput is an input type that accepts SubjectPatchArray and SubjectPatchArrayOutput values.
// You can construct a concrete instance of `SubjectPatchArrayInput` via:
//
//	SubjectPatchArray{ SubjectPatchArgs{...} }
type SubjectPatchArrayInput interface {
	pulumi.Input

	ToSubjectPatchArrayOutput() SubjectPatchArrayOutput
	ToSubjectPatchArrayOutputWithContext(context.Context) SubjectPatchArrayOutput
}

type SubjectPatchArray []SubjectPatchInput

func (SubjectPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubjectPatch)(nil)).Elem()
}

func (i SubjectPatchArray) ToSubjectPatchArrayOutput() SubjectPatchArrayOutput {
	return i.ToSubjectPatchArrayOutputWithContext(context.Background())
}

func (i SubjectPatchArray) ToSubjectPatchArrayOutputWithContext(ctx context.Context) SubjectPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubjectPatchArrayOutput)
}

// Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account.
type SubjectPatchOutput struct{ *pulumi.OutputState }

func (SubjectPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubjectPatch)(nil)).Elem()
}

func (o SubjectPatchOutput) ToSubjectPatchOutput() SubjectPatchOutput {
	return o
}

func (o SubjectPatchOutput) ToSubjectPatchOutputWithContext(ctx context.Context) SubjectPatchOutput {
	return o
}

// `group` matches based on user group name.
func (o SubjectPatchOutput) Group() GroupSubjectPatchPtrOutput {
	return o.ApplyT(func(v SubjectPatch) *GroupSubjectPatch { return v.Group }).(GroupSubjectPatchPtrOutput)
}

// `kind` indicates which one of the other fields is non-empty. Required
func (o SubjectPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubjectPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// `serviceAccount` matches ServiceAccounts.
func (o SubjectPatchOutput) ServiceAccount() ServiceAccountSubjectPatchPtrOutput {
	return o.ApplyT(func(v SubjectPatch) *ServiceAccountSubjectPatch { return v.ServiceAccount }).(ServiceAccountSubjectPatchPtrOutput)
}

// `user` matches based on username.
func (o SubjectPatchOutput) User() UserSubjectPatchPtrOutput {
	return o.ApplyT(func(v SubjectPatch) *UserSubjectPatch { return v.User }).(UserSubjectPatchPtrOutput)
}

type SubjectPatchArrayOutput struct{ *pulumi.OutputState }

func (SubjectPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubjectPatch)(nil)).Elem()
}

func (o SubjectPatchArrayOutput) ToSubjectPatchArrayOutput() SubjectPatchArrayOutput {
	return o
}

func (o SubjectPatchArrayOutput) ToSubjectPatchArrayOutputWithContext(ctx context.Context) SubjectPatchArrayOutput {
	return o
}

func (o SubjectPatchArrayOutput) Index(i pulumi.IntInput) SubjectPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubjectPatch {
		return vs[0].([]SubjectPatch)[vs[1].(int)]
	}).(SubjectPatchOutput)
}

// UserSubject holds detailed information for user-kind subject.
type UserSubject struct {
	// `name` is the username that matches, or "*" to match all usernames. Required.
	Name string `pulumi:"name"`
}

// UserSubjectInput is an input type that accepts UserSubjectArgs and UserSubjectOutput values.
// You can construct a concrete instance of `UserSubjectInput` via:
//
//	UserSubjectArgs{...}
type UserSubjectInput interface {
	pulumi.Input

	ToUserSubjectOutput() UserSubjectOutput
	ToUserSubjectOutputWithContext(context.Context) UserSubjectOutput
}

// UserSubject holds detailed information for user-kind subject.
type UserSubjectArgs struct {
	// `name` is the username that matches, or "*" to match all usernames. Required.
	Name pulumi.StringInput `pulumi:"name"`
}

func (UserSubjectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserSubject)(nil)).Elem()
}

func (i UserSubjectArgs) ToUserSubjectOutput() UserSubjectOutput {
	return i.ToUserSubjectOutputWithContext(context.Background())
}

func (i UserSubjectArgs) ToUserSubjectOutputWithContext(ctx context.Context) UserSubjectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserSubjectOutput)
}

func (i UserSubjectArgs) ToUserSubjectPtrOutput() UserSubjectPtrOutput {
	return i.ToUserSubjectPtrOutputWithContext(context.Background())
}

func (i UserSubjectArgs) ToUserSubjectPtrOutputWithContext(ctx context.Context) UserSubjectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserSubjectOutput).ToUserSubjectPtrOutputWithContext(ctx)
}

// UserSubjectPtrInput is an input type that accepts UserSubjectArgs, UserSubjectPtr and UserSubjectPtrOutput values.
// You can construct a concrete instance of `UserSubjectPtrInput` via:
//
//	        UserSubjectArgs{...}
//
//	or:
//
//	        nil
type UserSubjectPtrInput interface {
	pulumi.Input

	ToUserSubjectPtrOutput() UserSubjectPtrOutput
	ToUserSubjectPtrOutputWithContext(context.Context) UserSubjectPtrOutput
}

type userSubjectPtrType UserSubjectArgs

func UserSubjectPtr(v *UserSubjectArgs) UserSubjectPtrInput {
	return (*userSubjectPtrType)(v)
}

func (*userSubjectPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UserSubject)(nil)).Elem()
}

func (i *userSubjectPtrType) ToUserSubjectPtrOutput() UserSubjectPtrOutput {
	return i.ToUserSubjectPtrOutputWithContext(context.Background())
}

func (i *userSubjectPtrType) ToUserSubjectPtrOutputWithContext(ctx context.Context) UserSubjectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserSubjectPtrOutput)
}

// UserSubject holds detailed information for user-kind subject.
type UserSubjectOutput struct{ *pulumi.OutputState }

func (UserSubjectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserSubject)(nil)).Elem()
}

func (o UserSubjectOutput) ToUserSubjectOutput() UserSubjectOutput {
	return o
}

func (o UserSubjectOutput) ToUserSubjectOutputWithContext(ctx context.Context) UserSubjectOutput {
	return o
}

func (o UserSubjectOutput) ToUserSubjectPtrOutput() UserSubjectPtrOutput {
	return o.ToUserSubjectPtrOutputWithContext(context.Background())
}

func (o UserSubjectOutput) ToUserSubjectPtrOutputWithContext(ctx context.Context) UserSubjectPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UserSubject) *UserSubject {
		return &v
	}).(UserSubjectPtrOutput)
}

// `name` is the username that matches, or "*" to match all usernames. Required.
func (o UserSubjectOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v UserSubject) string { return v.Name }).(pulumi.StringOutput)
}

type UserSubjectPtrOutput struct{ *pulumi.OutputState }

func (UserSubjectPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserSubject)(nil)).Elem()
}

func (o UserSubjectPtrOutput) ToUserSubjectPtrOutput() UserSubjectPtrOutput {
	return o
}

func (o UserSubjectPtrOutput) ToUserSubjectPtrOutputWithContext(ctx context.Context) UserSubjectPtrOutput {
	return o
}

func (o UserSubjectPtrOutput) Elem() UserSubjectOutput {
	return o.ApplyT(func(v *UserSubject) UserSubject {
		if v != nil {
			return *v
		}
		var ret UserSubject
		return ret
	}).(UserSubjectOutput)
}

// `name` is the username that matches, or "*" to match all usernames. Required.
func (o UserSubjectPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UserSubject) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// UserSubject holds detailed information for user-kind subject.
type UserSubjectPatch struct {
	// `name` is the username that matches, or "*" to match all usernames. Required.
	Name *string `pulumi:"name"`
}

// UserSubjectPatchInput is an input type that accepts UserSubjectPatchArgs and UserSubjectPatchOutput values.
// You can construct a concrete instance of `UserSubjectPatchInput` via:
//
//	UserSubjectPatchArgs{...}
type UserSubjectPatchInput interface {
	pulumi.Input

	ToUserSubjectPatchOutput() UserSubjectPatchOutput
	ToUserSubjectPatchOutputWithContext(context.Context) UserSubjectPatchOutput
}

// UserSubject holds detailed information for user-kind subject.
type UserSubjectPatchArgs struct {
	// `name` is the username that matches, or "*" to match all usernames. Required.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (UserSubjectPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserSubjectPatch)(nil)).Elem()
}

func (i UserSubjectPatchArgs) ToUserSubjectPatchOutput() UserSubjectPatchOutput {
	return i.ToUserSubjectPatchOutputWithContext(context.Background())
}

func (i UserSubjectPatchArgs) ToUserSubjectPatchOutputWithContext(ctx context.Context) UserSubjectPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserSubjectPatchOutput)
}

func (i UserSubjectPatchArgs) ToUserSubjectPatchPtrOutput() UserSubjectPatchPtrOutput {
	return i.ToUserSubjectPatchPtrOutputWithContext(context.Background())
}

func (i UserSubjectPatchArgs) ToUserSubjectPatchPtrOutputWithContext(ctx context.Context) UserSubjectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserSubjectPatchOutput).ToUserSubjectPatchPtrOutputWithContext(ctx)
}

// UserSubjectPatchPtrInput is an input type that accepts UserSubjectPatchArgs, UserSubjectPatchPtr and UserSubjectPatchPtrOutput values.
// You can construct a concrete instance of `UserSubjectPatchPtrInput` via:
//
//	        UserSubjectPatchArgs{...}
//
//	or:
//
//	        nil
type UserSubjectPatchPtrInput interface {
	pulumi.Input

	ToUserSubjectPatchPtrOutput() UserSubjectPatchPtrOutput
	ToUserSubjectPatchPtrOutputWithContext(context.Context) UserSubjectPatchPtrOutput
}

type userSubjectPatchPtrType UserSubjectPatchArgs

func UserSubjectPatchPtr(v *UserSubjectPatchArgs) UserSubjectPatchPtrInput {
	return (*userSubjectPatchPtrType)(v)
}

func (*userSubjectPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UserSubjectPatch)(nil)).Elem()
}

func (i *userSubjectPatchPtrType) ToUserSubjectPatchPtrOutput() UserSubjectPatchPtrOutput {
	return i.ToUserSubjectPatchPtrOutputWithContext(context.Background())
}

func (i *userSubjectPatchPtrType) ToUserSubjectPatchPtrOutputWithContext(ctx context.Context) UserSubjectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserSubjectPatchPtrOutput)
}

// UserSubject holds detailed information for user-kind subject.
type UserSubjectPatchOutput struct{ *pulumi.OutputState }

func (UserSubjectPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserSubjectPatch)(nil)).Elem()
}

func (o UserSubjectPatchOutput) ToUserSubjectPatchOutput() UserSubjectPatchOutput {
	return o
}

func (o UserSubjectPatchOutput) ToUserSubjectPatchOutputWithContext(ctx context.Context) UserSubjectPatchOutput {
	return o
}

func (o UserSubjectPatchOutput) ToUserSubjectPatchPtrOutput() UserSubjectPatchPtrOutput {
	return o.ToUserSubjectPatchPtrOutputWithContext(context.Background())
}

func (o UserSubjectPatchOutput) ToUserSubjectPatchPtrOutputWithContext(ctx context.Context) UserSubjectPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UserSubjectPatch) *UserSubjectPatch {
		return &v
	}).(UserSubjectPatchPtrOutput)
}

// `name` is the username that matches, or "*" to match all usernames. Required.
func (o UserSubjectPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserSubjectPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type UserSubjectPatchPtrOutput struct{ *pulumi.OutputState }

func (UserSubjectPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserSubjectPatch)(nil)).Elem()
}

func (o UserSubjectPatchPtrOutput) ToUserSubjectPatchPtrOutput() UserSubjectPatchPtrOutput {
	return o
}

func (o UserSubjectPatchPtrOutput) ToUserSubjectPatchPtrOutputWithContext(ctx context.Context) UserSubjectPatchPtrOutput {
	return o
}

func (o UserSubjectPatchPtrOutput) Elem() UserSubjectPatchOutput {
	return o.ApplyT(func(v *UserSubjectPatch) UserSubjectPatch {
		if v != nil {
			return *v
		}
		var ret UserSubjectPatch
		return ret
	}).(UserSubjectPatchOutput)
}

// `name` is the username that matches, or "*" to match all usernames. Required.
func (o UserSubjectPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UserSubjectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ExemptPriorityLevelConfigurationInput)(nil)).Elem(), ExemptPriorityLevelConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExemptPriorityLevelConfigurationPtrInput)(nil)).Elem(), ExemptPriorityLevelConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExemptPriorityLevelConfigurationPatchInput)(nil)).Elem(), ExemptPriorityLevelConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExemptPriorityLevelConfigurationPatchPtrInput)(nil)).Elem(), ExemptPriorityLevelConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowDistinguisherMethodInput)(nil)).Elem(), FlowDistinguisherMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowDistinguisherMethodPtrInput)(nil)).Elem(), FlowDistinguisherMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowDistinguisherMethodPatchInput)(nil)).Elem(), FlowDistinguisherMethodPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowDistinguisherMethodPatchPtrInput)(nil)).Elem(), FlowDistinguisherMethodPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaTypeInput)(nil)).Elem(), FlowSchemaTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaTypeArrayInput)(nil)).Elem(), FlowSchemaTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaConditionInput)(nil)).Elem(), FlowSchemaConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaConditionArrayInput)(nil)).Elem(), FlowSchemaConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaConditionPatchInput)(nil)).Elem(), FlowSchemaConditionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaConditionPatchArrayInput)(nil)).Elem(), FlowSchemaConditionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaListTypeInput)(nil)).Elem(), FlowSchemaListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaPatchTypeInput)(nil)).Elem(), FlowSchemaPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaSpecInput)(nil)).Elem(), FlowSchemaSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaSpecPtrInput)(nil)).Elem(), FlowSchemaSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaSpecPatchInput)(nil)).Elem(), FlowSchemaSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaSpecPatchPtrInput)(nil)).Elem(), FlowSchemaSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaStatusInput)(nil)).Elem(), FlowSchemaStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaStatusPtrInput)(nil)).Elem(), FlowSchemaStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaStatusPatchInput)(nil)).Elem(), FlowSchemaStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlowSchemaStatusPatchPtrInput)(nil)).Elem(), FlowSchemaStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupSubjectInput)(nil)).Elem(), GroupSubjectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupSubjectPtrInput)(nil)).Elem(), GroupSubjectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupSubjectPatchInput)(nil)).Elem(), GroupSubjectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupSubjectPatchPtrInput)(nil)).Elem(), GroupSubjectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LimitResponseInput)(nil)).Elem(), LimitResponseArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LimitResponsePtrInput)(nil)).Elem(), LimitResponseArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LimitResponsePatchInput)(nil)).Elem(), LimitResponsePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LimitResponsePatchPtrInput)(nil)).Elem(), LimitResponsePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LimitedPriorityLevelConfigurationInput)(nil)).Elem(), LimitedPriorityLevelConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LimitedPriorityLevelConfigurationPtrInput)(nil)).Elem(), LimitedPriorityLevelConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LimitedPriorityLevelConfigurationPatchInput)(nil)).Elem(), LimitedPriorityLevelConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LimitedPriorityLevelConfigurationPatchPtrInput)(nil)).Elem(), LimitedPriorityLevelConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NonResourcePolicyRuleInput)(nil)).Elem(), NonResourcePolicyRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NonResourcePolicyRuleArrayInput)(nil)).Elem(), NonResourcePolicyRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NonResourcePolicyRulePatchInput)(nil)).Elem(), NonResourcePolicyRulePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NonResourcePolicyRulePatchArrayInput)(nil)).Elem(), NonResourcePolicyRulePatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyRulesWithSubjectsInput)(nil)).Elem(), PolicyRulesWithSubjectsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyRulesWithSubjectsArrayInput)(nil)).Elem(), PolicyRulesWithSubjectsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyRulesWithSubjectsPatchInput)(nil)).Elem(), PolicyRulesWithSubjectsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyRulesWithSubjectsPatchArrayInput)(nil)).Elem(), PolicyRulesWithSubjectsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationTypeInput)(nil)).Elem(), PriorityLevelConfigurationTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationTypeArrayInput)(nil)).Elem(), PriorityLevelConfigurationTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationConditionInput)(nil)).Elem(), PriorityLevelConfigurationConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationConditionArrayInput)(nil)).Elem(), PriorityLevelConfigurationConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationConditionPatchInput)(nil)).Elem(), PriorityLevelConfigurationConditionPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationConditionPatchArrayInput)(nil)).Elem(), PriorityLevelConfigurationConditionPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationListTypeInput)(nil)).Elem(), PriorityLevelConfigurationListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationPatchTypeInput)(nil)).Elem(), PriorityLevelConfigurationPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationReferenceInput)(nil)).Elem(), PriorityLevelConfigurationReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationReferencePtrInput)(nil)).Elem(), PriorityLevelConfigurationReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationReferencePatchInput)(nil)).Elem(), PriorityLevelConfigurationReferencePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationReferencePatchPtrInput)(nil)).Elem(), PriorityLevelConfigurationReferencePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationSpecInput)(nil)).Elem(), PriorityLevelConfigurationSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationSpecPtrInput)(nil)).Elem(), PriorityLevelConfigurationSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationSpecPatchInput)(nil)).Elem(), PriorityLevelConfigurationSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationSpecPatchPtrInput)(nil)).Elem(), PriorityLevelConfigurationSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationStatusInput)(nil)).Elem(), PriorityLevelConfigurationStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationStatusPtrInput)(nil)).Elem(), PriorityLevelConfigurationStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationStatusPatchInput)(nil)).Elem(), PriorityLevelConfigurationStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PriorityLevelConfigurationStatusPatchPtrInput)(nil)).Elem(), PriorityLevelConfigurationStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*QueuingConfigurationInput)(nil)).Elem(), QueuingConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*QueuingConfigurationPtrInput)(nil)).Elem(), QueuingConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*QueuingConfigurationPatchInput)(nil)).Elem(), QueuingConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*QueuingConfigurationPatchPtrInput)(nil)).Elem(), QueuingConfigurationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePolicyRuleInput)(nil)).Elem(), ResourcePolicyRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePolicyRuleArrayInput)(nil)).Elem(), ResourcePolicyRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePolicyRulePatchInput)(nil)).Elem(), ResourcePolicyRulePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourcePolicyRulePatchArrayInput)(nil)).Elem(), ResourcePolicyRulePatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAccountSubjectInput)(nil)).Elem(), ServiceAccountSubjectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAccountSubjectPtrInput)(nil)).Elem(), ServiceAccountSubjectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAccountSubjectPatchInput)(nil)).Elem(), ServiceAccountSubjectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAccountSubjectPatchPtrInput)(nil)).Elem(), ServiceAccountSubjectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubjectInput)(nil)).Elem(), SubjectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubjectArrayInput)(nil)).Elem(), SubjectArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubjectPatchInput)(nil)).Elem(), SubjectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubjectPatchArrayInput)(nil)).Elem(), SubjectPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserSubjectInput)(nil)).Elem(), UserSubjectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserSubjectPtrInput)(nil)).Elem(), UserSubjectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserSubjectPatchInput)(nil)).Elem(), UserSubjectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserSubjectPatchPtrInput)(nil)).Elem(), UserSubjectPatchArgs{})
	pulumi.RegisterOutputType(ExemptPriorityLevelConfigurationOutput{})
	pulumi.RegisterOutputType(ExemptPriorityLevelConfigurationPtrOutput{})
	pulumi.RegisterOutputType(ExemptPriorityLevelConfigurationPatchOutput{})
	pulumi.RegisterOutputType(ExemptPriorityLevelConfigurationPatchPtrOutput{})
	pulumi.RegisterOutputType(FlowDistinguisherMethodOutput{})
	pulumi.RegisterOutputType(FlowDistinguisherMethodPtrOutput{})
	pulumi.RegisterOutputType(FlowDistinguisherMethodPatchOutput{})
	pulumi.RegisterOutputType(FlowDistinguisherMethodPatchPtrOutput{})
	pulumi.RegisterOutputType(FlowSchemaTypeOutput{})
	pulumi.RegisterOutputType(FlowSchemaTypeArrayOutput{})
	pulumi.RegisterOutputType(FlowSchemaConditionOutput{})
	pulumi.RegisterOutputType(FlowSchemaConditionArrayOutput{})
	pulumi.RegisterOutputType(FlowSchemaConditionPatchOutput{})
	pulumi.RegisterOutputType(FlowSchemaConditionPatchArrayOutput{})
	pulumi.RegisterOutputType(FlowSchemaListTypeOutput{})
	pulumi.RegisterOutputType(FlowSchemaPatchTypeOutput{})
	pulumi.RegisterOutputType(FlowSchemaSpecOutput{})
	pulumi.RegisterOutputType(FlowSchemaSpecPtrOutput{})
	pulumi.RegisterOutputType(FlowSchemaSpecPatchOutput{})
	pulumi.RegisterOutputType(FlowSchemaSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(FlowSchemaStatusOutput{})
	pulumi.RegisterOutputType(FlowSchemaStatusPtrOutput{})
	pulumi.RegisterOutputType(FlowSchemaStatusPatchOutput{})
	pulumi.RegisterOutputType(FlowSchemaStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(GroupSubjectOutput{})
	pulumi.RegisterOutputType(GroupSubjectPtrOutput{})
	pulumi.RegisterOutputType(GroupSubjectPatchOutput{})
	pulumi.RegisterOutputType(GroupSubjectPatchPtrOutput{})
	pulumi.RegisterOutputType(LimitResponseOutput{})
	pulumi.RegisterOutputType(LimitResponsePtrOutput{})
	pulumi.RegisterOutputType(LimitResponsePatchOutput{})
	pulumi.RegisterOutputType(LimitResponsePatchPtrOutput{})
	pulumi.RegisterOutputType(LimitedPriorityLevelConfigurationOutput{})
	pulumi.RegisterOutputType(LimitedPriorityLevelConfigurationPtrOutput{})
	pulumi.RegisterOutputType(LimitedPriorityLevelConfigurationPatchOutput{})
	pulumi.RegisterOutputType(LimitedPriorityLevelConfigurationPatchPtrOutput{})
	pulumi.RegisterOutputType(NonResourcePolicyRuleOutput{})
	pulumi.RegisterOutputType(NonResourcePolicyRuleArrayOutput{})
	pulumi.RegisterOutputType(NonResourcePolicyRulePatchOutput{})
	pulumi.RegisterOutputType(NonResourcePolicyRulePatchArrayOutput{})
	pulumi.RegisterOutputType(PolicyRulesWithSubjectsOutput{})
	pulumi.RegisterOutputType(PolicyRulesWithSubjectsArrayOutput{})
	pulumi.RegisterOutputType(PolicyRulesWithSubjectsPatchOutput{})
	pulumi.RegisterOutputType(PolicyRulesWithSubjectsPatchArrayOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationTypeOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationTypeArrayOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationConditionOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationConditionArrayOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationConditionPatchOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationConditionPatchArrayOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationListTypeOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationPatchTypeOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationReferenceOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationReferencePtrOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationReferencePatchOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationReferencePatchPtrOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationSpecOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationSpecPtrOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationSpecPatchOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationStatusOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationStatusPtrOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationStatusPatchOutput{})
	pulumi.RegisterOutputType(PriorityLevelConfigurationStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(QueuingConfigurationOutput{})
	pulumi.RegisterOutputType(QueuingConfigurationPtrOutput{})
	pulumi.RegisterOutputType(QueuingConfigurationPatchOutput{})
	pulumi.RegisterOutputType(QueuingConfigurationPatchPtrOutput{})
	pulumi.RegisterOutputType(ResourcePolicyRuleOutput{})
	pulumi.RegisterOutputType(ResourcePolicyRuleArrayOutput{})
	pulumi.RegisterOutputType(ResourcePolicyRulePatchOutput{})
	pulumi.RegisterOutputType(ResourcePolicyRulePatchArrayOutput{})
	pulumi.RegisterOutputType(ServiceAccountSubjectOutput{})
	pulumi.RegisterOutputType(ServiceAccountSubjectPtrOutput{})
	pulumi.RegisterOutputType(ServiceAccountSubjectPatchOutput{})
	pulumi.RegisterOutputType(ServiceAccountSubjectPatchPtrOutput{})
	pulumi.RegisterOutputType(SubjectOutput{})
	pulumi.RegisterOutputType(SubjectArrayOutput{})
	pulumi.RegisterOutputType(SubjectPatchOutput{})
	pulumi.RegisterOutputType(SubjectPatchArrayOutput{})
	pulumi.RegisterOutputType(UserSubjectOutput{})
	pulumi.RegisterOutputType(UserSubjectPtrOutput{})
	pulumi.RegisterOutputType(UserSubjectPatchOutput{})
	pulumi.RegisterOutputType(UserSubjectPatchPtrOutput{})
}
