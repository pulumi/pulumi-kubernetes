// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Types.Outputs.Certificates.V1Beta1
{

    /// <summary>
    /// PodCertificateRequestSpec describes the certificate request.  All fields are immutable after creation.
    /// </summary>
    [OutputType]
    public sealed class PodCertificateRequestSpec
    {
        /// <summary>
        /// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
        /// 
        /// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
        /// 
        /// The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
        /// </summary>
        public readonly int MaxExpirationSeconds;
        /// <summary>
        /// nodeName is the name of the node the pod is assigned to.
        /// </summary>
        public readonly string NodeName;
        /// <summary>
        /// nodeUID is the UID of the node the pod is assigned to.
        /// </summary>
        public readonly string NodeUID;
        /// <summary>
        /// pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
        /// 
        /// The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
        /// 
        /// Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of "Denied" and a reason of "UnsupportedKeyType". It may also suggest a key type that it does support in the message field.
        /// </summary>
        public readonly string PkixPublicKey;
        /// <summary>
        /// podName is the name of the pod into which the certificate will be mounted.
        /// </summary>
        public readonly string PodName;
        /// <summary>
        /// podUID is the UID of the pod into which the certificate will be mounted.
        /// </summary>
        public readonly string PodUID;
        /// <summary>
        /// proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
        /// 
        /// It is contructed by signing the ASCII bytes of the pod's UID using `pkixPublicKey`.
        /// 
        /// kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
        /// 
        /// If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
        /// 
        /// If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
        /// 
        /// If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
        /// </summary>
        public readonly string ProofOfPossession;
        /// <summary>
        /// serviceAccountName is the name of the service account the pod is running as.
        /// </summary>
        public readonly string ServiceAccountName;
        /// <summary>
        /// serviceAccountUID is the UID of the service account the pod is running as.
        /// </summary>
        public readonly string ServiceAccountUID;
        /// <summary>
        /// signerName indicates the requested signer.
        /// 
        /// All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
        /// </summary>
        public readonly string SignerName;
        /// <summary>
        /// unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
        /// 
        /// Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
        /// 
        /// Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
        /// </summary>
        public readonly ImmutableDictionary<string, string> UnverifiedUserAnnotations;

        [OutputConstructor]
        private PodCertificateRequestSpec(
            int maxExpirationSeconds,

            string nodeName,

            string nodeUID,

            string pkixPublicKey,

            string podName,

            string podUID,

            string proofOfPossession,

            string serviceAccountName,

            string serviceAccountUID,

            string signerName,

            ImmutableDictionary<string, string> unverifiedUserAnnotations)
        {
            MaxExpirationSeconds = maxExpirationSeconds;
            NodeName = nodeName;
            NodeUID = nodeUID;
            PkixPublicKey = pkixPublicKey;
            PodName = podName;
            PodUID = podUID;
            ProofOfPossession = proofOfPossession;
            ServiceAccountName = serviceAccountName;
            ServiceAccountUID = serviceAccountUID;
            SignerName = signerName;
            UnverifiedUserAnnotations = unverifiedUserAnnotations;
        }
    }
}
