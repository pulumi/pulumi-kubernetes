// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Types.Inputs.Certificates.V1Beta1
{

    /// <summary>
    /// PodCertificateRequestSpec describes the certificate request.  All fields are immutable after creation.
    /// </summary>
    public class PodCertificateRequestSpecPatchArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
        /// 
        /// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).
        /// 
        /// The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.
        /// </summary>
        [Input("maxExpirationSeconds")]
        public Input<int>? MaxExpirationSeconds { get; set; }

        /// <summary>
        /// nodeName is the name of the node the pod is assigned to.
        /// </summary>
        [Input("nodeName")]
        public Input<string>? NodeName { get; set; }

        /// <summary>
        /// nodeUID is the UID of the node the pod is assigned to.
        /// </summary>
        [Input("nodeUID")]
        public Input<string>? NodeUID { get; set; }

        /// <summary>
        /// pkixPublicKey is the PKIX-serialized public key the signer will issue the certificate to.
        /// 
        /// The key must be one of RSA3072, RSA4096, ECDSAP256, ECDSAP384, ECDSAP521, or ED25519. Note that this list may be expanded in the future.
        /// 
        /// Signer implementations do not need to support all key types supported by kube-apiserver and kubelet.  If a signer does not support the key type used for a given PodCertificateRequest, it must deny the request by setting a status.conditions entry with a type of "Denied" and a reason of "UnsupportedKeyType". It may also suggest a key type that it does support in the message field.
        /// </summary>
        [Input("pkixPublicKey")]
        public Input<string>? PkixPublicKey { get; set; }

        /// <summary>
        /// podName is the name of the pod into which the certificate will be mounted.
        /// </summary>
        [Input("podName")]
        public Input<string>? PodName { get; set; }

        /// <summary>
        /// podUID is the UID of the pod into which the certificate will be mounted.
        /// </summary>
        [Input("podUID")]
        public Input<string>? PodUID { get; set; }

        /// <summary>
        /// proofOfPossession proves that the requesting kubelet holds the private key corresponding to pkixPublicKey.
        /// 
        /// It is contructed by signing the ASCII bytes of the pod's UID using `pkixPublicKey`.
        /// 
        /// kube-apiserver validates the proof of possession during creation of the PodCertificateRequest.
        /// 
        /// If the key is an RSA key, then the signature is over the ASCII bytes of the pod UID, using RSASSA-PSS from RFC 8017 (as implemented by the golang function crypto/rsa.SignPSS with nil options).
        /// 
        /// If the key is an ECDSA key, then the signature is as described by [SEC 1, Version 2.0](https://www.secg.org/sec1-v2.pdf) (as implemented by the golang library function crypto/ecdsa.SignASN1)
        /// 
        /// If the key is an ED25519 key, the the signature is as described by the [ED25519 Specification](https://ed25519.cr.yp.to/) (as implemented by the golang library crypto/ed25519.Sign).
        /// </summary>
        [Input("proofOfPossession")]
        public Input<string>? ProofOfPossession { get; set; }

        /// <summary>
        /// serviceAccountName is the name of the service account the pod is running as.
        /// </summary>
        [Input("serviceAccountName")]
        public Input<string>? ServiceAccountName { get; set; }

        /// <summary>
        /// serviceAccountUID is the UID of the service account the pod is running as.
        /// </summary>
        [Input("serviceAccountUID")]
        public Input<string>? ServiceAccountUID { get; set; }

        /// <summary>
        /// signerName indicates the requested signer.
        /// 
        /// All signer names beginning with `kubernetes.io` are reserved for use by the Kubernetes project.  There is currently one well-known signer documented by the Kubernetes project, `kubernetes.io/kube-apiserver-client-pod`, which will issue client certificates understood by kube-apiserver.  It is currently unimplemented.
        /// </summary>
        [Input("signerName")]
        public Input<string>? SignerName { get; set; }

        [Input("unverifiedUserAnnotations")]
        private InputMap<string>? _unverifiedUserAnnotations;

        /// <summary>
        /// unverifiedUserAnnotations allow pod authors to pass additional information to the signer implementation.  Kubernetes does not restrict or validate this metadata in any way.
        /// 
        /// Entries are subject to the same validation as object metadata annotations, with the addition that all keys must be domain-prefixed. No restrictions are placed on values, except an overall size limitation on the entire field.
        /// 
        /// Signers should document the keys and values they support.  Signers should deny requests that contain keys they do not recognize.
        /// </summary>
        public InputMap<string> UnverifiedUserAnnotations
        {
            get => _unverifiedUserAnnotations ?? (_unverifiedUserAnnotations = new InputMap<string>());
            set => _unverifiedUserAnnotations = value;
        }

        public PodCertificateRequestSpecPatchArgs()
        {
        }
        public static new PodCertificateRequestSpecPatchArgs Empty => new PodCertificateRequestSpecPatchArgs();
    }
}
