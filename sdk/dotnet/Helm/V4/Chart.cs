// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Helm.V4
{
    /// <summary>
    /// Chart is a component representing a collection of resources described by an arbitrary Helm Chart.
    /// 
    /// The Helm Chart can be fetched from any source that is accessible to the `helm` command line. Values in the `values.yml` file can be overridden using `ChartOpts.values` (equivalent to `--set` or having multiple `values.yml` files). Objects can be transformed arbitrarily by supplying callbacks to `ChartOpts.transformations`.
    /// 
    /// The `Chart` resource renders the templates from your chart and then manage them directly with the Pulumi Kubernetes provider.
    /// 
    /// `Chart` does not use Tiller. The Chart specified is copied and expanded locally; the semantics are equivalent to running `helm template` and then using Pulumi to manage the resulting YAML manifests. Any values that would be retrieved in-cluster are assigned fake values, and none of Tiller's server-side validity testing is executed.
    /// 
    /// You may also want to consider the `Release` resource as an alternative method for managing helm charts. For more information about the trade-offs between these options see: [Choosing the right Helm resource for your use case](https://www.pulumi.com/registry/packages/kubernetes/how-to-guides/choosing-the-right-helm-resource-for-your-use-case)
    /// 
    /// ## Example Usage
    /// ### Local Chart Directory
    /// ```csharp
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V3;
    /// 
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var nginx = new Chart("nginx-ingress", new LocalChartArgs
    ///         {
    ///             Path = "./nginx-ingress",
    ///         });
    /// 
    ///     }
    /// }
    /// ```
    /// ### Remote Chart
    /// ```csharp
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V3;
    /// 
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var nginx = new Chart("nginx-ingress", new ChartArgs
    ///         {
    ///             Chart = "nginx-ingress",
    ///             Version = "1.24.4",
    ///             FetchOptions = new ChartFetchArgs
    ///             {
    ///                 Repo = "https://charts.helm.sh/stable"
    ///             }
    ///         });
    /// 
    ///     }
    /// }
    /// ```
    /// ### Set Chart Values
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V3;
    /// 
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var values = new Dictionary&lt;string, object&gt;
    ///         {
    ///             ["controller"] = new Dictionary&lt;string, object&gt;
    ///             {
    ///                 ["metrics"] = new Dictionary&lt;string, object&gt;
    ///                 {
    ///                     ["enabled"] = true
    ///                 }
    ///             },
    ///         };
    /// 
    ///         var nginx = new Chart("nginx-ingress", new ChartArgs
    ///         {
    ///             Chart = "nginx-ingress",
    ///             Version = "1.24.4",
    ///             FetchOptions = new ChartFetchArgs
    ///             {
    ///                 Repo = "https://charts.helm.sh/stable"
    ///             },
    ///             Values = values,
    ///         });
    /// 
    ///     }
    /// }
    /// ```
    /// ### Deploy Chart into Namespace
    /// ```csharp
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V3;
    /// 
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var nginx = new Chart("nginx-ingress", new ChartArgs
    ///         {
    ///             Chart = "nginx-ingress",
    ///             Version = "1.24.4",
    ///             Namespace = "test-namespace",
    ///             FetchOptions = new ChartFetchArgs
    ///             {
    ///                 Repo = "https://charts.helm.sh/stable"
    ///             },
    ///         });
    /// 
    ///     }
    /// }
    /// ```
    /// ### Depend on a Chart resource
    /// ```csharp
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Core.V1;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V3;
    /// 
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var nginx = new Chart("nginx-ingress", new ChartArgs
    ///         {
    ///             Chart = "nginx-ingress",
    ///             Version = "1.24.4",
    ///             Namespace = "test-namespace",
    ///             FetchOptions = new ChartFetchArgs
    ///             {
    ///                 Repo = "https://charts.helm.sh/stable"
    ///             },
    ///         });
    /// 
    ///         // Create a ConfigMap depending on the Chart. The ConfigMap will not be created until after all of the Chart
    ///         // resources are ready. Note the use of the `Ready()` method; depending on the Chart resource directly will
    ///         // not work.
    ///         new ConfigMap("foo", new Pulumi.Kubernetes.Types.Inputs.Core.V1.ConfigMapArgs
    ///         {
    ///             Data = new InputMap&lt;string&gt;
    ///             {
    ///                 {"foo", "bar"}
    ///             },
    ///         }, new CustomResourceOptions
    ///         {
    ///             DependsOn = nginx.Ready(),
    ///         });
    /// 
    ///     }
    /// }
    /// ```
    /// ### Chart with Transformations
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Collections.Immutable;
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V3;
    /// 
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var nginx = new Chart("nginx-ingress", new ChartArgs
    ///         {
    ///             Chart = "nginx-ingress",
    ///             Version = "1.24.4",
    ///             FetchOptions = new ChartFetchArgs
    ///             {
    ///                 Repo = "https://charts.helm.sh/stable"
    ///             },
    ///             Transformations =
    ///             {
    ///                 LoadBalancerToClusterIP,
    ///                 ResourceAlias,
    ///                 OmitTestPod,
    ///             }
    /// 
    ///         });
    /// 
    ///         // Make every service private to the cluster, i.e., turn all services into ClusterIP instead of LoadBalancer.
    ///         ImmutableDictionary&lt;string, object&gt; LoadBalancerToClusterIP(ImmutableDictionary&lt;string, object&gt; obj, CustomResourceOptions opts)
    ///         {
    ///             if ((string)obj["kind"] == "Service" &amp;&amp; (string)obj["apiVersion"] == "v1")
    ///             {
    ///                 var spec = (ImmutableDictionary&lt;string, object&gt;)obj["spec"];
    ///                 if (spec != null &amp;&amp; (string)spec["type"] == "LoadBalancer")
    ///                 {
    ///                     return obj.SetItem("spec", spec.SetItem("type", "ClusterIP"));
    ///                 }
    ///             }
    /// 
    ///             return obj;
    ///         }
    /// 
    ///         // Set a resource alias for a previous name.
    ///         ImmutableDictionary&lt;string, object&gt; ResourceAlias(ImmutableDictionary&lt;string, object&gt; obj, CustomResourceOptions opts)
    ///         {
    ///             if ((string)obj["kind"] == "Deployment")
    ///             {
    ///                 opts.Aliases.Add(new Alias { Name = "oldName" });
    ///             }
    /// 
    ///             return obj;
    ///         }
    /// 
    ///         // Omit a resource from the Chart by transforming the specified resource definition to an empty List.
    ///         ImmutableDictionary&lt;string, object&gt; OmitTestPod(ImmutableDictionary&lt;string, object&gt; obj, CustomResourceOptions opts)
    ///         {
    ///             var metadata = (ImmutableDictionary&lt;string, object&gt;)obj["metadata"];
    ///             if ((string)obj["kind"] == "Pod" &amp;&amp; (string)metadata["name"] == "test")
    ///             {
    ///                 return new Dictionary&lt;string, object&gt;
    ///                 {
    ///                     ["apiVersion"] = "v1",
    ///                     ["kind"] = "List",
    ///                     ["items"] = new Dictionary&lt;string, object&gt;(),
    ///                 }.ToImmutableDictionary();
    ///             }
    /// 
    ///             return obj;
    ///         }
    ///     }
    /// }
    /// ```
    /// </summary>
    [KubernetesResourceType("kubernetes:helm.sh/v4:Chart")]
    public partial class Chart : global::Pulumi.ComponentResource
    {
        /// <summary>
        /// Resources created by the Chart.
        /// </summary>
        [Output("resources")]
        public Output<ImmutableArray<object>> Resources { get; private set; } = null!;


        /// <summary>
        /// Create a Chart resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Chart(string name, Pulumi.Kubernetes.Types.Inputs.Helm.V4.ChartArgs? args = null, ComponentResourceOptions? options = null)
            : base("kubernetes:helm.sh/v4:Chart", name, args ?? new Pulumi.Kubernetes.Types.Inputs.Helm.V4.ChartArgs(), MakeResourceOptions(options, ""), remote: true)
        {
        }

        private static ComponentResourceOptions MakeResourceOptions(ComponentResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new ComponentResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = ComponentResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
    }
}
namespace Pulumi.Kubernetes.Types.Inputs.Helm.V4
{

    public class ChartArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Chart name to be installed. A path may be used.
        /// </summary>
        [Input("chart", required: true)]
        public Input<string> Chart { get; set; } = null!;

        /// <summary>
        /// Run helm dependency update before installing the chart.
        /// </summary>
        [Input("dependencyUpdate")]
        public Input<bool>? DependencyUpdate { get; set; }

        /// <summary>
        /// Use chart development versions, too. Equivalent to version '&gt;0.0.0-0'. If `version` is set, this is ignored.
        /// </summary>
        [Input("devel")]
        public Input<bool>? Devel { get; set; }

        /// <summary>
        /// Location of public keys used for verification. Used only if `verify` is true
        /// </summary>
        [Input("keyring")]
        public Input<AssetOrArchive>? Keyring { get; set; }

        /// <summary>
        /// Release name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace for the release.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Specification defining the post-renderer to use.
        /// </summary>
        [Input("postRenderer")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Helm.V4.PostRendererArgs>? PostRenderer { get; set; }

        /// <summary>
        /// Specification defining the Helm chart repository to use.
        /// </summary>
        [Input("repositoryOpts")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Helm.V3.RepositoryOptsArgs>? RepositoryOpts { get; set; }

        /// <summary>
        /// An optional prefix for the auto-generated resource names. Example: A resource created with resourcePrefix="foo" would produce a resource named "foo:resourceName".
        /// </summary>
        [Input("resourcePrefix")]
        public Input<string>? ResourcePrefix { get; set; }

        /// <summary>
        /// By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
        /// </summary>
        [Input("skipAwait")]
        public Input<bool>? SkipAwait { get; set; }

        /// <summary>
        /// If set, no CRDs will be installed. By default, CRDs are installed if not already present.
        /// </summary>
        [Input("skipCrds")]
        public Input<bool>? SkipCrds { get; set; }

        [Input("valueYamlFiles")]
        private InputList<AssetOrArchive>? _valueYamlFiles;

        /// <summary>
        /// List of assets (raw yaml files). Content is read and merged with values.
        /// </summary>
        public InputList<AssetOrArchive> ValueYamlFiles
        {
            get => _valueYamlFiles ?? (_valueYamlFiles = new InputList<AssetOrArchive>());
            set => _valueYamlFiles = value;
        }

        [Input("values")]
        private InputMap<object>? _values;

        /// <summary>
        /// Custom values set for the release.
        /// </summary>
        public InputMap<object> Values
        {
            get => _values ?? (_values = new InputMap<object>());
            set => _values = value;
        }

        /// <summary>
        /// Verify the chart's integrity.
        /// </summary>
        [Input("verify")]
        public Input<bool>? Verify { get; set; }

        /// <summary>
        /// Specify the chart version to install. If this is not specified, the latest version is installed.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        public ChartArgs()
        {
        }
        public static new ChartArgs Empty => new ChartArgs();
    }
}
