// *** WARNING: this file was generated by the Pulumi Kubernetes client generation tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Types.Inputs.AdmissionRegistration {
  namespace V1 {
    /// <summary>
    /// MutatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    class MutatingWebhook {
        /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy.
        /// </summary>
        public Input<Input<string>[]> AdmissionReviewVersions { get; set; } = null!;

        /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
        public Input<AdmissionRegistration.V1.WebhookClientConfig> ClientConfig { get; set; } = null!;

        /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// SideEffects states whether this webhook has side effects. Acceptable values are: None,
        /// NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks
        /// with side effects MUST implement a reconciliation system, since a request may be
        /// rejected by a future step in the admission change and the side effects therefore need to
        /// be undone. Requests with the dryRun attribute will be auto-rejected if they match a
        /// webhook with sideEffects == Unknown or Some.
        /// </summary>
        public Input<string> SideEffects { get; set; } = null!;

        /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Fail.
        /// </summary>
        public Input<string>? FailurePolicy { get; set; }

        /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Equivalent"
        /// </summary>
        public Input<string>? MatchPolicy { get; set; }

        /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? NamespaceSelector { get; set; }

        /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? ObjectSelector { get; set; }

        /// <summary>
        /// reinvocationPolicy indicates whether this webhook should be called multiple times as
        /// part of a single admission evaluation. Allowed values are "Never" and "IfNeeded".
        /// 
        /// Never: the webhook will not be called more than once in a single admission evaluation.
        /// 
        /// IfNeeded: the webhook will be called at least one additional time as part of the
        /// admission evaluation if the object being admitted is modified by other admission plugins
        /// after the initial webhook call. Webhooks that specify this option *must* be idempotent,
        /// able to process objects they previously admitted. Note: * the number of additional
        /// invocations is not guaranteed to be exactly one. * if additional invocations result in
        /// further modifications to the object, webhooks are not guaranteed to be invoked again. *
        /// webhooks that use this option may be reordered to minimize the number of additional
        /// invocations. * to validate an object after all mutations are guaranteed complete, use a
        /// validating admission webhook instead.
        /// 
        /// Defaults to "Never".
        /// </summary>
        public Input<string>? ReinvocationPolicy { get; set; }

        /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1.RuleWithOperations>[]>? Rules { get; set; }

        /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 10 seconds.
        /// </summary>
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// MutatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and may change the object.
    /// </summary>
    class MutatingWebhookConfiguration {
        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1.MutatingWebhook>[]>? Webhooks { get; set; }

    }

    /// <summary>
    /// MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
    /// </summary>
    class MutatingWebhookConfigurationList {
        /// <summary>
        /// List of MutatingWebhookConfiguration.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1.MutatingWebhookConfiguration>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure
    /// that all the tuple expansions are valid.
    /// </summary>
    class RuleWithOperations {
        /// <summary>
        /// APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
        public Input<Input<string>[]>? ApiGroups { get; set; }

        /// <summary>
        /// APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
        public Input<Input<string>[]>? ApiVersions { get; set; }

        /// <summary>
        /// Operations is the operations the admission hook cares about - CREATE, UPDATE, or * for
        /// all operations. If '*' is present, the length of the slice must be one. Required.
        /// </summary>
        public Input<Input<string>[]>? Operations { get; set; }

        /// <summary>
        /// Resources is a list of resources this rule applies to.
        /// 
        /// For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means
        /// all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale'
        /// means all scale subresources. '*/*' means all resources and their subresources.
        /// 
        /// If wildcard is present, the validation rule will ensure resources do not overlap with
        /// each other.
        /// 
        /// Depending on the enclosing object, subresources might not be allowed. Required.
        /// </summary>
        public Input<Input<string>[]>? Resources { get; set; }

        /// <summary>
        /// scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and
        /// "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace
        /// API objects are cluster-scoped. "Namespaced" means that only namespaced resources will
        /// match this rule. "*" means that there are no scope restrictions. Subresources match the
        /// scope of their parent resource. Default is "*".
        /// </summary>
        public Input<string>? Scope { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    class ServiceReference {
        /// <summary>
        /// `name` is the name of the service. Required
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// `namespace` is the namespace of the service. Required
        /// </summary>
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// `path` is an optional URL path which will be sent in any request to this service.
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// ValidatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    class ValidatingWebhook {
        /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy.
        /// </summary>
        public Input<Input<string>[]> AdmissionReviewVersions { get; set; } = null!;

        /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
        public Input<AdmissionRegistration.V1.WebhookClientConfig> ClientConfig { get; set; } = null!;

        /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// SideEffects states whether this webhook has side effects. Acceptable values are: None,
        /// NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks
        /// with side effects MUST implement a reconciliation system, since a request may be
        /// rejected by a future step in the admission change and the side effects therefore need to
        /// be undone. Requests with the dryRun attribute will be auto-rejected if they match a
        /// webhook with sideEffects == Unknown or Some.
        /// </summary>
        public Input<string> SideEffects { get; set; } = null!;

        /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Fail.
        /// </summary>
        public Input<string>? FailurePolicy { get; set; }

        /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Equivalent"
        /// </summary>
        public Input<string>? MatchPolicy { get; set; }

        /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? NamespaceSelector { get; set; }

        /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? ObjectSelector { get; set; }

        /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1.RuleWithOperations>[]>? Rules { get; set; }

        /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 10 seconds.
        /// </summary>
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// ValidatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and object without changing it.
    /// </summary>
    class ValidatingWebhookConfiguration {
        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1.ValidatingWebhook>[]>? Webhooks { get; set; }

    }

    /// <summary>
    /// ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
    /// </summary>
    class ValidatingWebhookConfigurationList {
        /// <summary>
        /// List of ValidatingWebhookConfiguration.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1.ValidatingWebhookConfiguration>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook
    /// </summary>
    class WebhookClientConfig {
        /// <summary>
        /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's
        /// server certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// `service` is a reference to the service for this webhook. Either `service` or `url` must
        /// be specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        public Input<AdmissionRegistration.V1.ServiceReference>? Service { get; set; }

        /// <summary>
        /// `url` gives the location of the webhook, in standard URL form
        /// (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        public Input<string>? Url { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// MutatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    class MutatingWebhook {
        /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
        public Input<AdmissionRegistration.V1Beta1.WebhookClientConfig> ClientConfig { get; set; } = null!;

        /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy. Default to `['v1beta1']`.
        /// </summary>
        public Input<Input<string>[]>? AdmissionReviewVersions { get; set; }

        /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Ignore.
        /// </summary>
        public Input<string>? FailurePolicy { get; set; }

        /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Exact"
        /// </summary>
        public Input<string>? MatchPolicy { get; set; }

        /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? NamespaceSelector { get; set; }

        /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? ObjectSelector { get; set; }

        /// <summary>
        /// reinvocationPolicy indicates whether this webhook should be called multiple times as
        /// part of a single admission evaluation. Allowed values are "Never" and "IfNeeded".
        /// 
        /// Never: the webhook will not be called more than once in a single admission evaluation.
        /// 
        /// IfNeeded: the webhook will be called at least one additional time as part of the
        /// admission evaluation if the object being admitted is modified by other admission plugins
        /// after the initial webhook call. Webhooks that specify this option *must* be idempotent,
        /// able to process objects they previously admitted. Note: * the number of additional
        /// invocations is not guaranteed to be exactly one. * if additional invocations result in
        /// further modifications to the object, webhooks are not guaranteed to be invoked again. *
        /// webhooks that use this option may be reordered to minimize the number of additional
        /// invocations. * to validate an object after all mutations are guaranteed complete, use a
        /// validating admission webhook instead.
        /// 
        /// Defaults to "Never".
        /// </summary>
        public Input<string>? ReinvocationPolicy { get; set; }

        /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1Beta1.RuleWithOperations>[]>? Rules { get; set; }

        /// <summary>
        /// SideEffects states whether this webhookk has side effects. Acceptable values are:
        /// Unknown, None, Some, NoneOnDryRun Webhooks with side effects MUST implement a
        /// reconciliation system, since a request may be rejected by a future step in the admission
        /// change and the side effects therefore need to be undone. Requests with the dryRun
        /// attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or
        /// Some. Defaults to Unknown.
        /// </summary>
        public Input<string>? SideEffects { get; set; }

        /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 30 seconds.
        /// </summary>
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// MutatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and may change the object. Deprecated in v1.16, planned for removal in
    /// v1.19. Use admissionregistration.k8s.io/v1 MutatingWebhookConfiguration instead.
    /// </summary>
    class MutatingWebhookConfiguration {
        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1Beta1.MutatingWebhook>[]>? Webhooks { get; set; }

    }

    /// <summary>
    /// MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
    /// </summary>
    class MutatingWebhookConfigurationList {
        /// <summary>
        /// List of MutatingWebhookConfiguration.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1Beta1.MutatingWebhookConfiguration>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure
    /// that all the tuple expansions are valid.
    /// </summary>
    class RuleWithOperations {
        /// <summary>
        /// APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
        public Input<Input<string>[]>? ApiGroups { get; set; }

        /// <summary>
        /// APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
        public Input<Input<string>[]>? ApiVersions { get; set; }

        /// <summary>
        /// Operations is the operations the admission hook cares about - CREATE, UPDATE, or * for
        /// all operations. If '*' is present, the length of the slice must be one. Required.
        /// </summary>
        public Input<Input<string>[]>? Operations { get; set; }

        /// <summary>
        /// Resources is a list of resources this rule applies to.
        /// 
        /// For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means
        /// all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale'
        /// means all scale subresources. '*/*' means all resources and their subresources.
        /// 
        /// If wildcard is present, the validation rule will ensure resources do not overlap with
        /// each other.
        /// 
        /// Depending on the enclosing object, subresources might not be allowed. Required.
        /// </summary>
        public Input<Input<string>[]>? Resources { get; set; }

        /// <summary>
        /// scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and
        /// "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace
        /// API objects are cluster-scoped. "Namespaced" means that only namespaced resources will
        /// match this rule. "*" means that there are no scope restrictions. Subresources match the
        /// scope of their parent resource. Default is "*".
        /// </summary>
        public Input<string>? Scope { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    class ServiceReference {
        /// <summary>
        /// `name` is the name of the service. Required
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// `namespace` is the namespace of the service. Required
        /// </summary>
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// `path` is an optional URL path which will be sent in any request to this service.
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// ValidatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    class ValidatingWebhook {
        /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
        public Input<AdmissionRegistration.V1Beta1.WebhookClientConfig> ClientConfig { get; set; } = null!;

        /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy. Default to `['v1beta1']`.
        /// </summary>
        public Input<Input<string>[]>? AdmissionReviewVersions { get; set; }

        /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Ignore.
        /// </summary>
        public Input<string>? FailurePolicy { get; set; }

        /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Exact"
        /// </summary>
        public Input<string>? MatchPolicy { get; set; }

        /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? NamespaceSelector { get; set; }

        /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? ObjectSelector { get; set; }

        /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1Beta1.RuleWithOperations>[]>? Rules { get; set; }

        /// <summary>
        /// SideEffects states whether this webhookk has side effects. Acceptable values are:
        /// Unknown, None, Some, NoneOnDryRun Webhooks with side effects MUST implement a
        /// reconciliation system, since a request may be rejected by a future step in the admission
        /// change and the side effects therefore need to be undone. Requests with the dryRun
        /// attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or
        /// Some. Defaults to Unknown.
        /// </summary>
        public Input<string>? SideEffects { get; set; }

        /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 30 seconds.
        /// </summary>
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// ValidatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and object without changing it. Deprecated in v1.16, planned for removal in
    /// v1.19. Use admissionregistration.k8s.io/v1 ValidatingWebhookConfiguration instead.
    /// </summary>
    class ValidatingWebhookConfiguration {
        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1Beta1.ValidatingWebhook>[]>? Webhooks { get; set; }

    }

    /// <summary>
    /// ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
    /// </summary>
    class ValidatingWebhookConfigurationList {
        /// <summary>
        /// List of ValidatingWebhookConfiguration.
        /// </summary>
        public Input<Input<AdmissionRegistration.V1Beta1.ValidatingWebhookConfiguration>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook
    /// </summary>
    class WebhookClientConfig {
        /// <summary>
        /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's
        /// server certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// `service` is a reference to the service for this webhook. Either `service` or `url` must
        /// be specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        public Input<AdmissionRegistration.V1Beta1.ServiceReference>? Service { get; set; }

        /// <summary>
        /// `url` gives the location of the webhook, in standard URL form
        /// (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        public Input<string>? Url { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.ApiExtensions {
  namespace V1 {
    /// <summary>
    /// CustomResourceColumnDefinition specifies a column for server side printing.
    /// </summary>
    class CustomResourceColumnDefinition {
        /// <summary>
        /// jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against
        /// each custom resource to produce the value for this column.
        /// </summary>
        public Input<string> JsonPath { get; set; } = null!;

        /// <summary>
        /// name is a human readable name for the column.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// type is an OpenAPI type definition for this column. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// description is a human readable description of this column.
        /// </summary>
        public Input<string>? Description { get; set; }

        /// <summary>
        /// format is an optional OpenAPI type definition for this column. The 'name' format is
        /// applied to the primary identifier column to assist in clients identifying column is the
        /// resource name. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
        public Input<string>? Format { get; set; }

        /// <summary>
        /// priority is an integer defining the relative importance of this column compared to
        /// others. Lower numbers are considered higher priority. Columns that may be omitted in
        /// limited space scenarios should be given a priority greater than 0.
        /// </summary>
        public Input<int>? Priority { get; set; }

    }

    /// <summary>
    /// CustomResourceConversion describes how to convert different versions of a CR.
    /// </summary>
    class CustomResourceConversion {
        /// <summary>
        /// strategy specifies how custom resources are converted between versions. Allowed values
        /// are: - `None`: The converter only change the apiVersion and would not touch any other
        /// field in the custom resource. - `Webhook`: API Server will call to an external webhook
        /// to do the conversion. Additional information
        ///   is needed for this option. This requires spec.preserveUnknownFields to be false, and
        /// spec.conversion.webhook to be set.
        /// </summary>
        public Input<string> Strategy { get; set; } = null!;

        /// <summary>
        /// webhook describes how to call the conversion webhook. Required when `strategy` is set to
        /// `Webhook`.
        /// </summary>
        public Input<ApiExtensions.V1.WebhookConversion>? Webhook { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinition represents a resource that should be exposed on the API server.
    /// Its name MUST be in the format &lt;.spec.name&gt;.&lt;.spec.group&gt;.
    /// </summary>
    class CustomResourceDefinition {
        /// <summary>
        /// spec describes how the user wants the resources to appear
        /// </summary>
        public Input<ApiExtensions.V1.CustomResourceDefinitionSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionCondition contains details for the current condition of this pod.
    /// </summary>
    class CustomResourceDefinitionCondition {
        /// <summary>
        /// status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// type is the type of the condition. Types include Established, NamesAccepted and
        /// Terminating.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// lastTransitionTime last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// message is a human-readable message indicating details about last transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// reason is a unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
    /// </summary>
    class CustomResourceDefinitionList {
        /// <summary>
        /// items list individual CustomResourceDefinition objects
        /// </summary>
        public Input<Input<ApiExtensions.V1.CustomResourceDefinition>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition
    /// </summary>
    class CustomResourceDefinitionNames {
        /// <summary>
        /// plural is the plural name of the resource to serve. The custom resources are served
        /// under `/apis/&lt;group&gt;/&lt;version&gt;/.../&lt;plural&gt;`. Must match the name of
        /// the CustomResourceDefinition (in the form `&lt;names.plural&gt;.&lt;group&gt;`). Must be
        /// all lowercase.
        /// </summary>
        public Input<string> Plural { get; set; } = null!;

        /// <summary>
        /// categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
        /// This is published in API discovery documents, and used by clients to support invocations
        /// like `kubectl get all`.
        /// </summary>
        public Input<Input<string>[]>? Categories { get; set; }

        /// <summary>
        /// listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
        /// </summary>
        public Input<string>? ListKind { get; set; }

        /// <summary>
        /// shortNames are short names for the resource, exposed in API discovery documents, and
        /// used by clients to support invocations like `kubectl get &lt;shortname&gt;`. It must be
        /// all lowercase.
        /// </summary>
        public Input<Input<string>[]>? ShortNames { get; set; }

        /// <summary>
        /// singular is the singular name of the resource. It must be all lowercase. Defaults to
        /// lowercased `kind`.
        /// </summary>
        public Input<string>? Singular { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionSpec describes how a user wants their resource to appear
    /// </summary>
    class CustomResourceDefinitionSpec {
        /// <summary>
        /// group is the API group of the defined custom resource. The custom resources are served
        /// under `/apis/&lt;group&gt;/...`. Must match the name of the CustomResourceDefinition (in
        /// the form `&lt;names.plural&gt;.&lt;group&gt;`).
        /// </summary>
        public Input<string> Group { get; set; } = null!;

        /// <summary>
        /// names specify the resource and kind names for the custom resource.
        /// </summary>
        public Input<ApiExtensions.V1.CustomResourceDefinitionNames> Names { get; set; } = null!;

        /// <summary>
        /// scope indicates whether the defined custom resource is cluster- or namespace-scoped.
        /// Allowed values are `Cluster` and `Namespaced`. Default is `Namespaced`.
        /// </summary>
        public Input<string> Scope { get; set; } = null!;

        /// <summary>
        /// versions is the list of all API versions of the defined custom resource. Version names
        /// are used to compute the order in which served versions are listed in API discovery. If
        /// the version string is "kube-like", it will sort above non "kube-like" version strings,
        /// which are ordered lexicographically. "Kube-like" versions start with a "v", then are
        /// followed by a number (the major version), then optionally the string "alpha" or "beta"
        /// and another number (the minor version). These are sorted first by GA &gt; beta &gt;
        /// alpha (where GA is a version with no suffix such as beta or alpha), and then by
        /// comparing major version, then minor version. An example sorted list of versions: v10,
        /// v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
        /// </summary>
        public Input<Input<ApiExtensions.V1.CustomResourceDefinitionVersion>[]> Versions { get; set; } = null!;

        /// <summary>
        /// conversion defines conversion settings for the CRD.
        /// </summary>
        public Input<ApiExtensions.V1.CustomResourceConversion>? Conversion { get; set; }

        /// <summary>
        /// preserveUnknownFields indicates that object fields which are not specified in the
        /// OpenAPI schema should be preserved when persisting to storage. apiVersion, kind,
        /// metadata and known fields inside metadata are always preserved. This field is deprecated
        /// in favor of setting `x-preserve-unknown-fields` to true in
        /// `spec.versions[*].schema.openAPIV3Schema`. See
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields
        /// for details.
        /// </summary>
        public Input<bool>? PreserveUnknownFields { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition
    /// </summary>
    class CustomResourceDefinitionStatus {
        /// <summary>
        /// acceptedNames are the names that are actually being used to serve discovery. They may be
        /// different than the names in spec.
        /// </summary>
        public Input<ApiExtensions.V1.CustomResourceDefinitionNames> AcceptedNames { get; set; } = null!;

        /// <summary>
        /// storedVersions lists all versions of CustomResources that were ever persisted. Tracking
        /// these versions allows a migration path for stored versions in etcd. The field is mutable
        /// so a migration controller can finish a migration to another version (ensuring no old
        /// objects are left in storage), and then remove the rest of the versions from this list.
        /// Versions may not be removed from `spec.versions` while they exist in this list.
        /// </summary>
        public Input<Input<string>[]> StoredVersions { get; set; } = null!;

        /// <summary>
        /// conditions indicate state for particular aspects of a CustomResourceDefinition
        /// </summary>
        public Input<Input<ApiExtensions.V1.CustomResourceDefinitionCondition>[]>? Conditions { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionVersion describes a version for CRD.
    /// </summary>
    class CustomResourceDefinitionVersion {
        /// <summary>
        /// name is the version name, e.g. “v1”, “v2beta1”, etc. The custom resources are
        /// served under this version at `/apis/&lt;group&gt;/&lt;version&gt;/...` if `served` is
        /// true.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// served is a flag enabling/disabling this version from being served via REST APIs
        /// </summary>
        public Input<bool> Served { get; set; } = null!;

        /// <summary>
        /// storage indicates this version should be used when persisting custom resources to
        /// storage. There must be exactly one version with storage=true.
        /// </summary>
        public Input<bool> Storage { get; set; } = null!;

        /// <summary>
        /// additionalPrinterColumns specifies additional columns returned in Table output. See
        /// https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
        /// for details. If no columns are specified, a single column displaying the age of the
        /// custom resource is used.
        /// </summary>
        public Input<Input<ApiExtensions.V1.CustomResourceColumnDefinition>[]>? AdditionalPrinterColumns { get; set; }

        /// <summary>
        /// schema describes the schema used for validation, pruning, and defaulting of this version
        /// of the custom resource.
        /// </summary>
        public Input<ApiExtensions.V1.CustomResourceValidation>? Schema { get; set; }

        /// <summary>
        /// subresources specify what subresources this version of the defined custom resource have.
        /// </summary>
        public Input<ApiExtensions.V1.CustomResourceSubresources>? Subresources { get; set; }

    }

    /// <summary>
    /// CustomResourceSubresourceScale defines how to serve the scale subresource for
    /// CustomResources.
    /// </summary>
    class CustomResourceSubresourceScale {
        /// <summary>
        /// specReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a
        /// JSON Path under `.spec`. If there is no value under the given path in the custom
        /// resource, the `/scale` subresource will return an error on GET.
        /// </summary>
        public Input<string> SpecReplicasPath { get; set; } = null!;

        /// <summary>
        /// statusReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status`. If there is no value under the given path in the custom
        /// resource, the `status.replicas` value in the `/scale` subresource will default to 0.
        /// </summary>
        public Input<string> StatusReplicasPath { get; set; } = null!;

        /// <summary>
        /// labelSelectorPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status` or `.spec`. Must be set to work with
        /// HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not
        /// a complex selector struct) which contains a serialized label selector in string form.
        /// More info:
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource
        /// If there is no value under the given path in the custom resource, the `status.selector`
        /// value in the `/scale` subresource will default to the empty string.
        /// </summary>
        public Input<string>? LabelSelectorPath { get; set; }

    }

    /// <summary>
    /// CustomResourceSubresources defines the status and scale subresources for CustomResources.
    /// </summary>
    class CustomResourceSubresources {
        /// <summary>
        /// scale indicates the custom resource should serve a `/scale` subresource that returns an
        /// `autoscaling/v1` Scale object.
        /// </summary>
        public Input<ApiExtensions.V1.CustomResourceSubresourceScale>? Scale { get; set; }

    }

    /// <summary>
    /// CustomResourceValidation is a list of validation methods for CustomResources.
    /// </summary>
    class CustomResourceValidation {
        /// <summary>
        /// openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.
        /// </summary>
        public Input<ApiExtensions.V1.JSONSchemaProps>? OpenAPIV3Schema { get; set; }

    }

    /// <summary>
    /// ExternalDocumentation allows referencing an external resource for extended documentation.
    /// </summary>
    class ExternalDocumentation {
        
        public Input<string>? Description { get; set; }

        
        public Input<string>? Url { get; set; }

    }

    /// <summary>
    /// JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
    /// </summary>
    class JSONSchemaProps {
        
        public Input<string>? Ref { get; set; }

        
        public Input<string>? Schema { get; set; }

        
        public Input<ApiExtensions.V1.JSONSchemaProps /* TODO: or bool */>? AdditionalItems { get; set; }

        
        public Input<ApiExtensions.V1.JSONSchemaProps /* TODO: or bool */>? AdditionalProperties { get; set; }

        
        public Input<Input<ApiExtensions.V1.JSONSchemaProps>[]>? AllOf { get; set; }

        
        public Input<Input<ApiExtensions.V1.JSONSchemaProps>[]>? AnyOf { get; set; }

        /// <summary>
        /// default is a default value for undefined object fields. Defaulting is a beta feature
        /// under the CustomResourceDefaulting feature gate. Defaulting requires
        /// spec.preserveUnknownFields to be false.
        /// </summary>
        public Input<object>? Default { get; set; }

        
        public Input<object>? Definitions { get; set; }

        
        public Input<object>? Dependencies { get; set; }

        
        public Input<string>? Description { get; set; }

        
        public Input<Input<object>[]>? Enum { get; set; }

        
        public Input<object>? Example { get; set; }

        
        public Input<bool>? ExclusiveMaximum { get; set; }

        
        public Input<bool>? ExclusiveMinimum { get; set; }

        
        public Input<ApiExtensions.V1.ExternalDocumentation>? ExternalDocs { get; set; }

        
        public Input<string>? Format { get; set; }

        
        public Input<string>? Id { get; set; }

        
        public Input<ApiExtensions.V1.JSONSchemaProps /* TODO: or array */>? Items { get; set; }

        
        public Input<int>? MaxItems { get; set; }

        
        public Input<int>? MaxLength { get; set; }

        
        public Input<int>? MaxProperties { get; set; }

        
        public Input<int>? Maximum { get; set; }

        
        public Input<int>? MinItems { get; set; }

        
        public Input<int>? MinLength { get; set; }

        
        public Input<int>? MinProperties { get; set; }

        
        public Input<int>? Minimum { get; set; }

        
        public Input<int>? MultipleOf { get; set; }

        
        public Input<ApiExtensions.V1.JSONSchemaProps>? Not { get; set; }

        
        public Input<bool>? Nullable { get; set; }

        
        public Input<Input<ApiExtensions.V1.JSONSchemaProps>[]>? OneOf { get; set; }

        
        public Input<string>? Pattern { get; set; }

        
        public Input<object>? PatternProperties { get; set; }

        
        public Input<object>? Properties { get; set; }

        
        public Input<Input<string>[]>? Required { get; set; }

        
        public Input<string>? Title { get; set; }

        
        public Input<string>? Type { get; set; }

        
        public Input<bool>? UniqueItems { get; set; }

        /// <summary>
        /// x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes
        /// runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to
        /// further restrict the embedded object. kind, apiVersion and metadata are validated
        /// automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not
        /// have to be if the object is fully specified (up to kind, apiVersion, metadata).
        /// </summary>
        public Input<bool>? X_kubernetes_embedded_resource { get; set; }

        /// <summary>
        /// x-kubernetes-int-or-string specifies that this value is either an integer or a string.
        /// If this is true, an empty type is allowed and type as child of anyOf is permitted if
        /// following one of the following patterns:
        /// 
        /// 1) anyOf:
        ///    - type: integer
        ///    - type: string
        /// 2) allOf:
        ///    - anyOf:
        ///      - type: integer
        ///      - type: string
        ///    - ... zero or more
        /// </summary>
        public Input<bool>? X_kubernetes_int_or_string { get; set; }

        /// <summary>
        /// x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by
        /// specifying the keys used as the index of the map.
        /// 
        /// This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set
        /// to "map". Also, the values specified for this attribute must be a scalar typed field of
        /// the child structure (no nesting is supported).
        /// </summary>
        public Input<Input<string>[]>? X_kubernetes_list_map_keys { get; set; }

        /// <summary>
        /// x-kubernetes-list-type annotates an array to further describe its topology. This
        /// extension must only be used on lists and may have 3 possible values:
        /// 
        /// 1) `atomic`: the list is treated as a single entity, like a scalar.
        ///      Atomic lists will be entirely replaced when updated. This extension
        ///      may be used on any type of list (struct, scalar, ...).
        /// 2) `set`:
        ///      Sets are lists that must not have multiple items with the same value. Each
        ///      value must be a scalar (or another atomic type).
        /// 3) `map`:
        ///      These lists are like maps in that their elements have a non-index key
        ///      used to identify them. Order is preserved upon merge. The map tag
        ///      must only be used on a list with elements of type object.
        /// Defaults to atomic for arrays.
        /// </summary>
        public Input<string>? X_kubernetes_list_type { get; set; }

        /// <summary>
        /// x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning
        /// fields which are not specified in the validation schema. This affects fields
        /// recursively, but switches back to normal pruning behaviour if nested properties or
        /// additionalProperties are specified in the schema. This can either be true or undefined.
        /// False is forbidden.
        /// </summary>
        public Input<bool>? X_kubernetes_preserve_unknown_fields { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    class ServiceReference {
        /// <summary>
        /// name is the name of the service. Required
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// namespace is the namespace of the service. Required
        /// </summary>
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// path is an optional URL path at which the webhook will be contacted.
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// port is an optional service port at which the webhook will be contacted. `port` should
        /// be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.
        /// </summary>
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook.
    /// </summary>
    class WebhookClientConfig {
        /// <summary>
        /// caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server
        /// certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// service is a reference to the service for this webhook. Either service or url must be
        /// specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        public Input<ApiExtensions.V1.ServiceReference>? Service { get; set; }

        /// <summary>
        /// url gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
        /// Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        public Input<string>? Url { get; set; }

    }

    /// <summary>
    /// WebhookConversion describes how to call a conversion webhook
    /// </summary>
    class WebhookConversion {
        /// <summary>
        /// conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the
        /// Webhook expects. The API server will use the first version in the list which it
        /// supports. If none of the versions specified in this list are supported by API server,
        /// conversion will fail for the custom resource. If a persisted Webhook configuration
        /// specifies allowed versions and does not include any versions known to the API Server,
        /// calls to the webhook will fail.
        /// </summary>
        public Input<Input<string>[]> ConversionReviewVersions { get; set; } = null!;

        /// <summary>
        /// clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
        /// </summary>
        public Input<ApiExtensions.V1.WebhookClientConfig>? ClientConfig { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// CustomResourceColumnDefinition specifies a column for server side printing.
    /// </summary>
    class CustomResourceColumnDefinition {
        /// <summary>
        /// JSONPath is a simple JSON path (i.e. with array notation) which is evaluated against
        /// each custom resource to produce the value for this column.
        /// </summary>
        public Input<string> JSONPath { get; set; } = null!;

        /// <summary>
        /// name is a human readable name for the column.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// type is an OpenAPI type definition for this column. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// description is a human readable description of this column.
        /// </summary>
        public Input<string>? Description { get; set; }

        /// <summary>
        /// format is an optional OpenAPI type definition for this column. The 'name' format is
        /// applied to the primary identifier column to assist in clients identifying column is the
        /// resource name. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
        public Input<string>? Format { get; set; }

        /// <summary>
        /// priority is an integer defining the relative importance of this column compared to
        /// others. Lower numbers are considered higher priority. Columns that may be omitted in
        /// limited space scenarios should be given a priority greater than 0.
        /// </summary>
        public Input<int>? Priority { get; set; }

    }

    /// <summary>
    /// CustomResourceConversion describes how to convert different versions of a CR.
    /// </summary>
    class CustomResourceConversion {
        /// <summary>
        /// strategy specifies how custom resources are converted between versions. Allowed values
        /// are: - `None`: The converter only change the apiVersion and would not touch any other
        /// field in the custom resource. - `Webhook`: API Server will call to an external webhook
        /// to do the conversion. Additional information
        ///   is needed for this option. This requires spec.preserveUnknownFields to be false, and
        /// spec.conversion.webhookClientConfig to be set.
        /// </summary>
        public Input<string> Strategy { get; set; } = null!;

        /// <summary>
        /// conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the
        /// Webhook expects. The API server will use the first version in the list which it
        /// supports. If none of the versions specified in this list are supported by API server,
        /// conversion will fail for the custom resource. If a persisted Webhook configuration
        /// specifies allowed versions and does not include any versions known to the API Server,
        /// calls to the webhook will fail. Defaults to `["v1beta1"]`.
        /// </summary>
        public Input<Input<string>[]>? ConversionReviewVersions { get; set; }

        /// <summary>
        /// webhookClientConfig is the instructions for how to call the webhook if strategy is
        /// `Webhook`. Required when `strategy` is set to `Webhook`.
        /// </summary>
        public Input<ApiExtensions.V1Beta1.WebhookClientConfig>? WebhookClientConfig { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinition represents a resource that should be exposed on the API server.
    /// Its name MUST be in the format &lt;.spec.name&gt;.&lt;.spec.group&gt;. Deprecated in v1.16,
    /// planned for removal in v1.19. Use apiextensions.k8s.io/v1 CustomResourceDefinition instead.
    /// </summary>
    class CustomResourceDefinition {
        /// <summary>
        /// spec describes how the user wants the resources to appear
        /// </summary>
        public Input<ApiExtensions.V1Beta1.CustomResourceDefinitionSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionCondition contains details for the current condition of this pod.
    /// </summary>
    class CustomResourceDefinitionCondition {
        /// <summary>
        /// status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// type is the type of the condition. Types include Established, NamesAccepted and
        /// Terminating.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// lastTransitionTime last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// message is a human-readable message indicating details about last transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// reason is a unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
    /// </summary>
    class CustomResourceDefinitionList {
        /// <summary>
        /// items list individual CustomResourceDefinition objects
        /// </summary>
        public Input<Input<ApiExtensions.V1Beta1.CustomResourceDefinition>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition
    /// </summary>
    class CustomResourceDefinitionNames {
        /// <summary>
        /// plural is the plural name of the resource to serve. The custom resources are served
        /// under `/apis/&lt;group&gt;/&lt;version&gt;/.../&lt;plural&gt;`. Must match the name of
        /// the CustomResourceDefinition (in the form `&lt;names.plural&gt;.&lt;group&gt;`). Must be
        /// all lowercase.
        /// </summary>
        public Input<string> Plural { get; set; } = null!;

        /// <summary>
        /// categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
        /// This is published in API discovery documents, and used by clients to support invocations
        /// like `kubectl get all`.
        /// </summary>
        public Input<Input<string>[]>? Categories { get; set; }

        /// <summary>
        /// listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
        /// </summary>
        public Input<string>? ListKind { get; set; }

        /// <summary>
        /// shortNames are short names for the resource, exposed in API discovery documents, and
        /// used by clients to support invocations like `kubectl get &lt;shortname&gt;`. It must be
        /// all lowercase.
        /// </summary>
        public Input<Input<string>[]>? ShortNames { get; set; }

        /// <summary>
        /// singular is the singular name of the resource. It must be all lowercase. Defaults to
        /// lowercased `kind`.
        /// </summary>
        public Input<string>? Singular { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionSpec describes how a user wants their resource to appear
    /// </summary>
    class CustomResourceDefinitionSpec {
        /// <summary>
        /// group is the API group of the defined custom resource. The custom resources are served
        /// under `/apis/&lt;group&gt;/...`. Must match the name of the CustomResourceDefinition (in
        /// the form `&lt;names.plural&gt;.&lt;group&gt;`).
        /// </summary>
        public Input<string> Group { get; set; } = null!;

        /// <summary>
        /// names specify the resource and kind names for the custom resource.
        /// </summary>
        public Input<ApiExtensions.V1Beta1.CustomResourceDefinitionNames> Names { get; set; } = null!;

        /// <summary>
        /// scope indicates whether the defined custom resource is cluster- or namespace-scoped.
        /// Allowed values are `Cluster` and `Namespaced`. Default is `Namespaced`.
        /// </summary>
        public Input<string> Scope { get; set; } = null!;

        /// <summary>
        /// additionalPrinterColumns specifies additional columns returned in Table output. See
        /// https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
        /// for details. If present, this field configures columns for all versions. Top-level and
        /// per-version columns are mutually exclusive. If no top-level or per-version columns are
        /// specified, a single column displaying the age of the custom resource is used.
        /// </summary>
        public Input<Input<ApiExtensions.V1Beta1.CustomResourceColumnDefinition>[]>? AdditionalPrinterColumns { get; set; }

        /// <summary>
        /// conversion defines conversion settings for the CRD.
        /// </summary>
        public Input<ApiExtensions.V1Beta1.CustomResourceConversion>? Conversion { get; set; }

        /// <summary>
        /// preserveUnknownFields indicates that object fields which are not specified in the
        /// OpenAPI schema should be preserved when persisting to storage. apiVersion, kind,
        /// metadata and known fields inside metadata are always preserved. If false, schemas must
        /// be defined for all versions. Defaults to true in v1beta for backwards compatibility.
        /// Deprecated: will be required to be false in v1. Preservation of unknown fields can be
        /// specified in the validation schema using the `x-kubernetes-preserve-unknown-fields:
        /// true` extension. See
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields
        /// for details.
        /// </summary>
        public Input<bool>? PreserveUnknownFields { get; set; }

        /// <summary>
        /// subresources specify what subresources the defined custom resource has. If present, this
        /// field configures subresources for all versions. Top-level and per-version subresources
        /// are mutually exclusive.
        /// </summary>
        public Input<ApiExtensions.V1Beta1.CustomResourceSubresources>? Subresources { get; set; }

        /// <summary>
        /// validation describes the schema used for validation and pruning of the custom resource.
        /// If present, this validation schema is used to validate all versions. Top-level and
        /// per-version schemas are mutually exclusive.
        /// </summary>
        public Input<ApiExtensions.V1Beta1.CustomResourceValidation>? Validation { get; set; }

        /// <summary>
        /// version is the API version of the defined custom resource. The custom resources are
        /// served under `/apis/&lt;group&gt;/&lt;version&gt;/...`. Must match the name of the first
        /// item in the `versions` list if `version` and `versions` are both specified. Optional if
        /// `versions` is specified. Deprecated: use `versions` instead.
        /// </summary>
        public Input<string>? Version { get; set; }

        /// <summary>
        /// versions is the list of all API versions of the defined custom resource. Optional if
        /// `version` is specified. The name of the first item in the `versions` list must match the
        /// `version` field if `version` and `versions` are both specified. Version names are used
        /// to compute the order in which served versions are listed in API discovery. If the
        /// version string is "kube-like", it will sort above non "kube-like" version strings, which
        /// are ordered lexicographically. "Kube-like" versions start with a "v", then are followed
        /// by a number (the major version), then optionally the string "alpha" or "beta" and
        /// another number (the minor version). These are sorted first by GA &gt; beta &gt; alpha
        /// (where GA is a version with no suffix such as beta or alpha), and then by comparing
        /// major version, then minor version. An example sorted list of versions: v10, v2, v1,
        /// v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
        /// </summary>
        public Input<Input<ApiExtensions.V1Beta1.CustomResourceDefinitionVersion>[]>? Versions { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition
    /// </summary>
    class CustomResourceDefinitionStatus {
        /// <summary>
        /// acceptedNames are the names that are actually being used to serve discovery. They may be
        /// different than the names in spec.
        /// </summary>
        public Input<ApiExtensions.V1Beta1.CustomResourceDefinitionNames> AcceptedNames { get; set; } = null!;

        /// <summary>
        /// storedVersions lists all versions of CustomResources that were ever persisted. Tracking
        /// these versions allows a migration path for stored versions in etcd. The field is mutable
        /// so a migration controller can finish a migration to another version (ensuring no old
        /// objects are left in storage), and then remove the rest of the versions from this list.
        /// Versions may not be removed from `spec.versions` while they exist in this list.
        /// </summary>
        public Input<Input<string>[]> StoredVersions { get; set; } = null!;

        /// <summary>
        /// conditions indicate state for particular aspects of a CustomResourceDefinition
        /// </summary>
        public Input<Input<ApiExtensions.V1Beta1.CustomResourceDefinitionCondition>[]>? Conditions { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionVersion describes a version for CRD.
    /// </summary>
    class CustomResourceDefinitionVersion {
        /// <summary>
        /// name is the version name, e.g. “v1”, “v2beta1”, etc. The custom resources are
        /// served under this version at `/apis/&lt;group&gt;/&lt;version&gt;/...` if `served` is
        /// true.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// served is a flag enabling/disabling this version from being served via REST APIs
        /// </summary>
        public Input<bool> Served { get; set; } = null!;

        /// <summary>
        /// storage indicates this version should be used when persisting custom resources to
        /// storage. There must be exactly one version with storage=true.
        /// </summary>
        public Input<bool> Storage { get; set; } = null!;

        /// <summary>
        /// additionalPrinterColumns specifies additional columns returned in Table output. See
        /// https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
        /// for details. Top-level and per-version columns are mutually exclusive. Per-version
        /// columns must not all be set to identical values (top-level columns should be used
        /// instead). If no top-level or per-version columns are specified, a single column
        /// displaying the age of the custom resource is used.
        /// </summary>
        public Input<Input<ApiExtensions.V1Beta1.CustomResourceColumnDefinition>[]>? AdditionalPrinterColumns { get; set; }

        /// <summary>
        /// schema describes the schema used for validation and pruning of this version of the
        /// custom resource. Top-level and per-version schemas are mutually exclusive. Per-version
        /// schemas must not all be set to identical values (top-level validation schema should be
        /// used instead).
        /// </summary>
        public Input<ApiExtensions.V1Beta1.CustomResourceValidation>? Schema { get; set; }

        /// <summary>
        /// subresources specify what subresources this version of the defined custom resource have.
        /// Top-level and per-version subresources are mutually exclusive. Per-version subresources
        /// must not all be set to identical values (top-level subresources should be used instead).
        /// </summary>
        public Input<ApiExtensions.V1Beta1.CustomResourceSubresources>? Subresources { get; set; }

    }

    /// <summary>
    /// CustomResourceSubresourceScale defines how to serve the scale subresource for
    /// CustomResources.
    /// </summary>
    class CustomResourceSubresourceScale {
        /// <summary>
        /// specReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a
        /// JSON Path under `.spec`. If there is no value under the given path in the custom
        /// resource, the `/scale` subresource will return an error on GET.
        /// </summary>
        public Input<string> SpecReplicasPath { get; set; } = null!;

        /// <summary>
        /// statusReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status`. If there is no value under the given path in the custom
        /// resource, the `status.replicas` value in the `/scale` subresource will default to 0.
        /// </summary>
        public Input<string> StatusReplicasPath { get; set; } = null!;

        /// <summary>
        /// labelSelectorPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status` or `.spec`. Must be set to work with
        /// HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not
        /// a complex selector struct) which contains a serialized label selector in string form.
        /// More info:
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource
        /// If there is no value under the given path in the custom resource, the `status.selector`
        /// value in the `/scale` subresource will default to the empty string.
        /// </summary>
        public Input<string>? LabelSelectorPath { get; set; }

    }

    /// <summary>
    /// CustomResourceSubresources defines the status and scale subresources for CustomResources.
    /// </summary>
    class CustomResourceSubresources {
        /// <summary>
        /// scale indicates the custom resource should serve a `/scale` subresource that returns an
        /// `autoscaling/v1` Scale object.
        /// </summary>
        public Input<ApiExtensions.V1Beta1.CustomResourceSubresourceScale>? Scale { get; set; }

    }

    /// <summary>
    /// CustomResourceValidation is a list of validation methods for CustomResources.
    /// </summary>
    class CustomResourceValidation {
        /// <summary>
        /// openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.
        /// </summary>
        public Input<ApiExtensions.V1Beta1.JSONSchemaProps>? OpenAPIV3Schema { get; set; }

    }

    /// <summary>
    /// ExternalDocumentation allows referencing an external resource for extended documentation.
    /// </summary>
    class ExternalDocumentation {
        
        public Input<string>? Description { get; set; }

        
        public Input<string>? Url { get; set; }

    }

    /// <summary>
    /// JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
    /// </summary>
    class JSONSchemaProps {
        
        public Input<string>? Ref { get; set; }

        
        public Input<string>? Schema { get; set; }

        
        public Input<ApiExtensions.V1Beta1.JSONSchemaProps /* TODO: or bool */>? AdditionalItems { get; set; }

        
        public Input<ApiExtensions.V1Beta1.JSONSchemaProps /* TODO: or bool */>? AdditionalProperties { get; set; }

        
        public Input<Input<ApiExtensions.V1Beta1.JSONSchemaProps>[]>? AllOf { get; set; }

        
        public Input<Input<ApiExtensions.V1Beta1.JSONSchemaProps>[]>? AnyOf { get; set; }

        /// <summary>
        /// default is a default value for undefined object fields. Defaulting is a beta feature
        /// under the CustomResourceDefaulting feature gate. CustomResourceDefinitions with defaults
        /// must be created using the v1 (or newer) CustomResourceDefinition API.
        /// </summary>
        public Input<object>? Default { get; set; }

        
        public Input<object>? Definitions { get; set; }

        
        public Input<object>? Dependencies { get; set; }

        
        public Input<string>? Description { get; set; }

        
        public Input<Input<object>[]>? Enum { get; set; }

        
        public Input<object>? Example { get; set; }

        
        public Input<bool>? ExclusiveMaximum { get; set; }

        
        public Input<bool>? ExclusiveMinimum { get; set; }

        
        public Input<ApiExtensions.V1Beta1.ExternalDocumentation>? ExternalDocs { get; set; }

        
        public Input<string>? Format { get; set; }

        
        public Input<string>? Id { get; set; }

        
        public Input<ApiExtensions.V1Beta1.JSONSchemaProps /* TODO: or array */>? Items { get; set; }

        
        public Input<int>? MaxItems { get; set; }

        
        public Input<int>? MaxLength { get; set; }

        
        public Input<int>? MaxProperties { get; set; }

        
        public Input<int>? Maximum { get; set; }

        
        public Input<int>? MinItems { get; set; }

        
        public Input<int>? MinLength { get; set; }

        
        public Input<int>? MinProperties { get; set; }

        
        public Input<int>? Minimum { get; set; }

        
        public Input<int>? MultipleOf { get; set; }

        
        public Input<ApiExtensions.V1Beta1.JSONSchemaProps>? Not { get; set; }

        
        public Input<bool>? Nullable { get; set; }

        
        public Input<Input<ApiExtensions.V1Beta1.JSONSchemaProps>[]>? OneOf { get; set; }

        
        public Input<string>? Pattern { get; set; }

        
        public Input<object>? PatternProperties { get; set; }

        
        public Input<object>? Properties { get; set; }

        
        public Input<Input<string>[]>? Required { get; set; }

        
        public Input<string>? Title { get; set; }

        
        public Input<string>? Type { get; set; }

        
        public Input<bool>? UniqueItems { get; set; }

        /// <summary>
        /// x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes
        /// runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to
        /// further restrict the embedded object. kind, apiVersion and metadata are validated
        /// automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not
        /// have to be if the object is fully specified (up to kind, apiVersion, metadata).
        /// </summary>
        public Input<bool>? X_kubernetes_embedded_resource { get; set; }

        /// <summary>
        /// x-kubernetes-int-or-string specifies that this value is either an integer or a string.
        /// If this is true, an empty type is allowed and type as child of anyOf is permitted if
        /// following one of the following patterns:
        /// 
        /// 1) anyOf:
        ///    - type: integer
        ///    - type: string
        /// 2) allOf:
        ///    - anyOf:
        ///      - type: integer
        ///      - type: string
        ///    - ... zero or more
        /// </summary>
        public Input<bool>? X_kubernetes_int_or_string { get; set; }

        /// <summary>
        /// x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by
        /// specifying the keys used as the index of the map.
        /// 
        /// This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set
        /// to "map". Also, the values specified for this attribute must be a scalar typed field of
        /// the child structure (no nesting is supported).
        /// </summary>
        public Input<Input<string>[]>? X_kubernetes_list_map_keys { get; set; }

        /// <summary>
        /// x-kubernetes-list-type annotates an array to further describe its topology. This
        /// extension must only be used on lists and may have 3 possible values:
        /// 
        /// 1) `atomic`: the list is treated as a single entity, like a scalar.
        ///      Atomic lists will be entirely replaced when updated. This extension
        ///      may be used on any type of list (struct, scalar, ...).
        /// 2) `set`:
        ///      Sets are lists that must not have multiple items with the same value. Each
        ///      value must be a scalar (or another atomic type).
        /// 3) `map`:
        ///      These lists are like maps in that their elements have a non-index key
        ///      used to identify them. Order is preserved upon merge. The map tag
        ///      must only be used on a list with elements of type object.
        /// Defaults to atomic for arrays.
        /// </summary>
        public Input<string>? X_kubernetes_list_type { get; set; }

        /// <summary>
        /// x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning
        /// fields which are not specified in the validation schema. This affects fields
        /// recursively, but switches back to normal pruning behaviour if nested properties or
        /// additionalProperties are specified in the schema. This can either be true or undefined.
        /// False is forbidden.
        /// </summary>
        public Input<bool>? X_kubernetes_preserve_unknown_fields { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    class ServiceReference {
        /// <summary>
        /// name is the name of the service. Required
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// namespace is the namespace of the service. Required
        /// </summary>
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// path is an optional URL path at which the webhook will be contacted.
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// port is an optional service port at which the webhook will be contacted. `port` should
        /// be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.
        /// </summary>
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook.
    /// </summary>
    class WebhookClientConfig {
        /// <summary>
        /// caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server
        /// certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// service is a reference to the service for this webhook. Either service or url must be
        /// specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        public Input<ApiExtensions.V1Beta1.ServiceReference>? Service { get; set; }

        /// <summary>
        /// url gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
        /// Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        public Input<string>? Url { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.ApiRegistration {
  namespace V1 {
    /// <summary>
    /// APIService represents a server for a particular GroupVersion. Name must be "version.group".
    /// </summary>
    class APIService {
        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec contains information for locating and communicating with a server
        /// </summary>
        public Input<ApiRegistration.V1.APIServiceSpec>? Spec { get; set; }

    }

    /// <summary>
    /// APIServiceCondition describes the state of an APIService at a particular point
    /// </summary>
    class APIServiceCondition {
        /// <summary>
        /// Status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type is the type of the condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// APIServiceList is a list of APIService objects.
    /// </summary>
    class APIServiceList {
        
        public Input<Input<ApiRegistration.V1.APIService>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// APIServiceSpec contains information for locating and communicating with a server. Only https
    /// is supported, though you are able to disable certificate verification.
    /// </summary>
    class APIServiceSpec {
        /// <summary>
        /// GroupPriorityMininum is the priority this group should have at least. Higher priority
        /// means that the group is preferred by clients over lower priority ones. Note that other
        /// versions of this group might specify even higher GroupPriorityMininum values such that
        /// the whole group gets a higher priority. The primary sort is based on
        /// GroupPriorityMinimum, ordered highest number to lowest (20 before 10). The secondary
        /// sort is based on the alphabetical comparison of the name of the object.  (v1.bar before
        /// v1.foo) We'd recommend something like: *.k8s.io (except extensions) at 18000 and PaaSes
        /// (OpenShift, Deis) are recommended to be in the 2000s
        /// </summary>
        public Input<int> GroupPriorityMinimum { get; set; } = null!;

        /// <summary>
        /// Service is a reference to the service for this API server.  It must communicate on port
        /// 443 If the Service is nil, that means the handling for the API groupversion is handled
        /// locally on this server. The call will simply delegate to the normal handler chain to be
        /// fulfilled.
        /// </summary>
        public Input<ApiRegistration.V1.ServiceReference> Service { get; set; } = null!;

        /// <summary>
        /// VersionPriority controls the ordering of this API version inside of its group.  Must be
        /// greater than zero. The primary sort is based on VersionPriority, ordered highest to
        /// lowest (20 before 10). Since it's inside of a group, the number can be small, probably
        /// in the 10s. In case of equal version priorities, the version string will be used to
        /// compute the order inside a group. If the version string is "kube-like", it will sort
        /// above non "kube-like" version strings, which are ordered lexicographically. "Kube-like"
        /// versions start with a "v", then are followed by a number (the major version), then
        /// optionally the string "alpha" or "beta" and another number (the minor version). These
        /// are sorted first by GA &gt; beta &gt; alpha (where GA is a version with no suffix such
        /// as beta or alpha), and then by comparing major version, then minor version. An example
        /// sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2,
        /// foo1, foo10.
        /// </summary>
        public Input<int> VersionPriority { get; set; } = null!;

        /// <summary>
        /// CABundle is a PEM encoded CA bundle which will be used to validate an API server's
        /// serving certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// Group is the API group name this server hosts
        /// </summary>
        public Input<string>? Group { get; set; }

        /// <summary>
        /// InsecureSkipTLSVerify disables TLS certificate verification when communicating with this
        /// server. This is strongly discouraged.  You should use the CABundle instead.
        /// </summary>
        public Input<bool>? InsecureSkipTLSVerify { get; set; }

        /// <summary>
        /// Version is the API version this server hosts.  For example, "v1"
        /// </summary>
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// APIServiceStatus contains derived information about an API server
    /// </summary>
    class APIServiceStatus {
        /// <summary>
        /// Current service state of apiService.
        /// </summary>
        public Input<Input<ApiRegistration.V1.APIServiceCondition>[]>? Conditions { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    class ServiceReference {
        /// <summary>
        /// Name is the name of the service
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace is the namespace of the service
        /// </summary>
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        public Input<int>? Port { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// APIService represents a server for a particular GroupVersion. Name must be "version.group".
    /// </summary>
    class APIService {
        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec contains information for locating and communicating with a server
        /// </summary>
        public Input<ApiRegistration.V1Beta1.APIServiceSpec>? Spec { get; set; }

    }

    /// <summary>
    /// APIServiceCondition describes the state of an APIService at a particular point
    /// </summary>
    class APIServiceCondition {
        /// <summary>
        /// Status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type is the type of the condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// APIServiceList is a list of APIService objects.
    /// </summary>
    class APIServiceList {
        
        public Input<Input<ApiRegistration.V1Beta1.APIService>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// APIServiceSpec contains information for locating and communicating with a server. Only https
    /// is supported, though you are able to disable certificate verification.
    /// </summary>
    class APIServiceSpec {
        /// <summary>
        /// GroupPriorityMininum is the priority this group should have at least. Higher priority
        /// means that the group is preferred by clients over lower priority ones. Note that other
        /// versions of this group might specify even higher GroupPriorityMininum values such that
        /// the whole group gets a higher priority. The primary sort is based on
        /// GroupPriorityMinimum, ordered highest number to lowest (20 before 10). The secondary
        /// sort is based on the alphabetical comparison of the name of the object.  (v1.bar before
        /// v1.foo) We'd recommend something like: *.k8s.io (except extensions) at 18000 and PaaSes
        /// (OpenShift, Deis) are recommended to be in the 2000s
        /// </summary>
        public Input<int> GroupPriorityMinimum { get; set; } = null!;

        /// <summary>
        /// Service is a reference to the service for this API server.  It must communicate on port
        /// 443 If the Service is nil, that means the handling for the API groupversion is handled
        /// locally on this server. The call will simply delegate to the normal handler chain to be
        /// fulfilled.
        /// </summary>
        public Input<ApiRegistration.V1Beta1.ServiceReference> Service { get; set; } = null!;

        /// <summary>
        /// VersionPriority controls the ordering of this API version inside of its group.  Must be
        /// greater than zero. The primary sort is based on VersionPriority, ordered highest to
        /// lowest (20 before 10). Since it's inside of a group, the number can be small, probably
        /// in the 10s. In case of equal version priorities, the version string will be used to
        /// compute the order inside a group. If the version string is "kube-like", it will sort
        /// above non "kube-like" version strings, which are ordered lexicographically. "Kube-like"
        /// versions start with a "v", then are followed by a number (the major version), then
        /// optionally the string "alpha" or "beta" and another number (the minor version). These
        /// are sorted first by GA &gt; beta &gt; alpha (where GA is a version with no suffix such
        /// as beta or alpha), and then by comparing major version, then minor version. An example
        /// sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2,
        /// foo1, foo10.
        /// </summary>
        public Input<int> VersionPriority { get; set; } = null!;

        /// <summary>
        /// CABundle is a PEM encoded CA bundle which will be used to validate an API server's
        /// serving certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// Group is the API group name this server hosts
        /// </summary>
        public Input<string>? Group { get; set; }

        /// <summary>
        /// InsecureSkipTLSVerify disables TLS certificate verification when communicating with this
        /// server. This is strongly discouraged.  You should use the CABundle instead.
        /// </summary>
        public Input<bool>? InsecureSkipTLSVerify { get; set; }

        /// <summary>
        /// Version is the API version this server hosts.  For example, "v1"
        /// </summary>
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// APIServiceStatus contains derived information about an API server
    /// </summary>
    class APIServiceStatus {
        /// <summary>
        /// Current service state of apiService.
        /// </summary>
        public Input<Input<ApiRegistration.V1Beta1.APIServiceCondition>[]>? Conditions { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    class ServiceReference {
        /// <summary>
        /// Name is the name of the service
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace is the namespace of the service
        /// </summary>
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        public Input<int>? Port { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Apps {
  namespace V1 {
    /// <summary>
    /// ControllerRevision implements an immutable snapshot of state data. Clients are responsible
    /// for serializing and deserializing the objects that contain their internal state. Once a
    /// ControllerRevision has been successfully created, it can not be updated. The API Server will
    /// fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
    /// may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
    /// controllers for update and rollback, this object is beta. However, it may be subject to name
    /// and representation changes in future releases, and clients should not depend on its
    /// stability. It is primarily for internal use by controllers.
    /// </summary>
    class ControllerRevision {
        /// <summary>
        /// Revision indicates the revision of the state represented by Data.
        /// </summary>
        public Input<int> Revision { get; set; } = null!;

        /// <summary>
        /// Data is the serialized representation of the state.
        /// </summary>
        public Input<object>? Data { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
    /// </summary>
    class ControllerRevisionList {
        /// <summary>
        /// Items is the list of ControllerRevisions
        /// </summary>
        public Input<Input<Apps.V1.ControllerRevision>[]> Items { get; set; } = null!;

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DaemonSet represents the configuration of a daemon set.
    /// </summary>
    class DaemonSet {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// The desired behavior of this daemon set. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Apps.V1.DaemonSetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// DaemonSetCondition describes the state of a DaemonSet at a certain point.
    /// </summary>
    class DaemonSetCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of DaemonSet condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DaemonSetList is a collection of daemon sets.
    /// </summary>
    class DaemonSetList {
        /// <summary>
        /// A list of daemon sets.
        /// </summary>
        public Input<Input<Apps.V1.DaemonSet>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DaemonSetSpec is the specification of a daemon set.
    /// </summary>
    class DaemonSetSpec {
        /// <summary>
        /// A label query over pods that are managed by the daemon set. Must match in order to be
        /// controlled. It must match the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector> Selector { get; set; } = null!;

        /// <summary>
        /// An object that describes the pod that will be created. The DaemonSet will create exactly
        /// one copy of this pod on every node that matches the template's node selector (or on
        /// every node if no node selector is specified). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// The minimum number of seconds for which a newly created DaemonSet pod should be ready
        /// without any of its container crashing, for it to be considered available. Defaults to 0
        /// (pod will be considered available as soon as it is ready).
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// The number of old history to retain to allow rollback. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 10.
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// An update strategy to replace existing DaemonSet pods with new pods.
        /// </summary>
        public Input<Apps.V1.DaemonSetUpdateStrategy>? UpdateStrategy { get; set; }

    }

    /// <summary>
    /// DaemonSetStatus represents the current status of a daemon set.
    /// </summary>
    class DaemonSetStatus {
        /// <summary>
        /// The number of nodes that are running at least 1 daemon pod and are supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        public Input<int> CurrentNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The total number of nodes that should be running the daemon pod (including nodes
        /// correctly running the daemon pod). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        public Input<int> DesiredNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that are running the daemon pod, but are not supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        public Input<int> NumberMisscheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and ready.
        /// </summary>
        public Input<int> NumberReady { get; set; } = null!;

        /// <summary>
        /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as
        /// a collision avoidance mechanism when it needs to create the name for the newest
        /// ControllerRevision.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a DaemonSet's current state.
        /// </summary>
        public Input<Input<Apps.V1.DaemonSetCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        public Input<int>? NumberAvailable { get; set; }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have none of the daemon
        /// pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        public Input<int>? NumberUnavailable { get; set; }

        /// <summary>
        /// The most recent generation observed by the daemon set controller.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The total number of nodes that are running updated daemon pod
        /// </summary>
        public Input<int>? UpdatedNumberScheduled { get; set; }

    }

    /// <summary>
    /// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
    /// </summary>
    class DaemonSetUpdateStrategy {
        /// <summary>
        /// Rolling update config params. Present only if type = "RollingUpdate".
        /// </summary>
        public Input<Apps.V1.RollingUpdateDaemonSet>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is
        /// RollingUpdate.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    class Deployment {
        /// <summary>
        /// Standard object metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
        public Input<Apps.V1.DeploymentSpec>? Spec { get; set; }

    }

    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    class DeploymentCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of deployment condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// The last time this condition was updated.
        /// </summary>
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    class DeploymentList {
        /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
        public Input<Input<Apps.V1.Deployment>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    class DeploymentSpec {
        /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment. It must match the pod template's labels.
        /// </summary>
        public Input<Meta.V1.LabelSelector> Selector { get; set; } = null!;

        /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Indicates that the deployment is paused.
        /// </summary>
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// Defaults to 600s.
        /// </summary>
        public Input<int>? ProgressDeadlineSeconds { get; set; }

        /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. Defaults to 10.
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
        public Input<Apps.V1.DeploymentStrategy>? Strategy { get; set; }

    }

    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    class DeploymentStatus {
        /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
        public Input<Input<Apps.V1.DeploymentCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
        public Input<int>? UnavailableReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    class DeploymentStrategy {
        /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
        public Input<Apps.V1.RollingUpdateDeployment>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
    /// </summary>
    class ReplicaSet {
        /// <summary>
        /// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
        /// that the ReplicaSet manages. Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the specification of the desired behavior of the ReplicaSet. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Apps.V1.ReplicaSetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// ReplicaSetCondition describes the state of a replica set at a certain point.
    /// </summary>
    class ReplicaSetCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of replica set condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ReplicaSetList is a collection of ReplicaSets.
    /// </summary>
    class ReplicaSetList {
        /// <summary>
        /// List of ReplicaSets. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
        public Input<Input<Apps.V1.ReplicaSet>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ReplicaSetSpec is the specification of a ReplicaSet.
    /// </summary>
    class ReplicaSetSpec {
        /// <summary>
        /// Selector is a label query over pods that should match the replica count. Label keys and
        /// values that must match in order to be controlled by this replica set. It must match the
        /// pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector> Selector { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        public Input<Core.V1.PodTemplateSpec>? Template { get; set; }

    }

    /// <summary>
    /// ReplicaSetStatus represents the current status of a ReplicaSet.
    /// </summary>
    class ReplicaSetStatus {
        /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this replica
        /// set.
        /// </summary>
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Represents the latest available observations of a replica set's current state.
        /// </summary>
        public Input<Input<Apps.V1.ReplicaSetCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replicaset.
        /// </summary>
        public Input<int>? FullyLabeledReplicas { get; set; }

        /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The number of ready replicas for this replica set.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of daemon set rolling update.
    /// </summary>
    class RollingUpdateDaemonSet {
        /// <summary>
        /// The maximum number of DaemonSet pods that can be unavailable during the update. Value
        /// can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at
        /// the start of the update (ex: 10%). Absolute number is calculated from percentage by
        /// rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at
        /// most 30% of the total number of nodes that should be running the daemon pod (i.e.
        /// status.desiredNumberScheduled) can have their pods stopped for an update at any given
        /// time. The update starts by stopping at most 30% of those DaemonSet pods and then brings
        /// up new DaemonSet pods in their place. Once the new pods are available, it then proceeds
        /// onto other DaemonSet pods, thus ensuring that at least 70% of original number of
        /// DaemonSet pods are available at all times during the update.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    class RollingUpdateDeployment {
        /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can
        /// be scaled up immediately when the rolling update starts, such that the total number of
        /// old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new
        /// ReplicaSet can be scaled up further, ensuring that total number of pods running at any
        /// time during the update is at most 130% of desired pods.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxSurge { get; set; }

        /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0.
        /// Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down
        /// to 70% of desired pods immediately when the rolling update starts. Once new pods are
        /// ready, old ReplicaSet can be scaled down further, followed by scaling up the new
        /// ReplicaSet, ensuring that the total number of pods available at all times during the
        /// update is at least 70% of desired pods.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// RollingUpdateStatefulSetStrategy is used to communicate parameter for
    /// RollingUpdateStatefulSetStrategyType.
    /// </summary>
    class RollingUpdateStatefulSetStrategy {
        /// <summary>
        /// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default
        /// value is 0.
        /// </summary>
        public Input<int>? Partition { get; set; }

    }

    /// <summary>
    /// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
    ///  - Network: A single stable DNS and hostname.
    ///  - Storage: As many VolumeClaims as requested.
    /// The StatefulSet guarantees that a given network identity will always map to the same storage
    /// identity.
    /// </summary>
    class StatefulSet {
        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired identities of pods in this set.
        /// </summary>
        public Input<Apps.V1.StatefulSetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// StatefulSetCondition describes the state of a statefulset at a certain point.
    /// </summary>
    class StatefulSetCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of statefulset condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatefulSetList is a collection of StatefulSets.
    /// </summary>
    class StatefulSetList {
        
        public Input<Input<Apps.V1.StatefulSet>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// A StatefulSetSpec is the specification of a StatefulSet.
    /// </summary>
    class StatefulSetSpec {
        /// <summary>
        /// selector is a label query over pods that should match the replica count. It must match
        /// the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector> Selector { get; set; } = null!;

        /// <summary>
        /// serviceName is the name of the service that governs this StatefulSet. This service must
        /// exist before the StatefulSet, and is responsible for the network identity of the set.
        /// Pods get DNS/hostnames that follow the pattern:
        /// pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
        /// managed by the StatefulSet controller.
        /// </summary>
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. Each pod stamped out by the StatefulSet will fulfill this
        /// Template, but have a unique identity from the rest of the StatefulSet.
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// podManagementPolicy controls how pods are created during initial scale up, when
        /// replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`,
        /// where pods are created in increasing order (pod-0, then pod-1, etc) and the controller
        /// will wait until each pod is ready before continuing. When scaling down, the pods are
        /// removed in the opposite order. The alternative policy is `Parallel` which will create
        /// pods in parallel to match the desired scale without waiting, and on scale down will
        /// delete all pods at once.
        /// </summary>
        public Input<string>? PodManagementPolicy { get; set; }

        /// <summary>
        /// replicas is the desired number of replicas of the given Template. These are replicas in
        /// the sense that they are instantiations of the same Template, but individual replicas
        /// also have a consistent identity. If unspecified, defaults to 1.
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the
        /// StatefulSet's revision history. The revision history consists of all revisions not
        /// represented by a currently applied StatefulSetSpec version. The default value is 10.
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update
        /// Pods in the StatefulSet when a revision is made to Template.
        /// </summary>
        public Input<Apps.V1.StatefulSetUpdateStrategy>? UpdateStrategy { get; set; }

        /// <summary>
        /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The
        /// StatefulSet controller is responsible for mapping network identities to claims in a way
        /// that maintains the identity of a pod. Every claim in this list must have at least one
        /// matching (by name) volumeMount in one container in the template. A claim in this list
        /// takes precedence over any volumes in the template, with the same name.
        /// </summary>
        public Input<Input<Core.V1.PersistentVolumeClaim>[]>? VolumeClaimTemplates { get; set; }

    }

    /// <summary>
    /// StatefulSetStatus represents the current state of a StatefulSet.
    /// </summary>
    class StatefulSetStatus {
        /// <summary>
        /// replicas is the number of Pods created by the StatefulSet controller.
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet
        /// controller uses this field as a collision avoidance mechanism when it needs to create
        /// the name for the newest ControllerRevision.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a statefulset's current state.
        /// </summary>
        public Input<Input<Apps.V1.StatefulSetCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// currentReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by currentRevision.
        /// </summary>
        public Input<int>? CurrentReplicas { get; set; }

        /// <summary>
        /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [0,currentReplicas).
        /// </summary>
        public Input<string>? CurrentRevision { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed for this StatefulSet. It
        /// corresponds to the StatefulSet's generation, which is updated on mutation by the API
        /// Server.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// readyReplicas is the number of Pods created by the StatefulSet controller that have a
        /// Ready Condition.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [replicas-updatedReplicas,replicas)
        /// </summary>
        public Input<string>? UpdateRevision { get; set; }

        /// <summary>
        /// updatedReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by updateRevision.
        /// </summary>
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
    /// perform updates. It includes any additional parameters necessary to perform the update for
    /// the indicated strategy.
    /// </summary>
    class StatefulSetUpdateStrategy {
        /// <summary>
        /// RollingUpdate is used to communicate parameters when Type is
        /// RollingUpdateStatefulSetStrategyType.
        /// </summary>
        public Input<Apps.V1.RollingUpdateStatefulSetStrategy>? RollingUpdate { get; set; }

        /// <summary>
        /// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// DEPRECATED - apps/v1beta1/ControllerRevision is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/ControllerRevision instead.
    /// 
    /// ControllerRevision implements an immutable snapshot of state data. Clients are responsible
    /// for serializing and deserializing the objects that contain their internal state. Once a
    /// ControllerRevision has been successfully created, it can not be updated. The API Server will
    /// fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
    /// may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
    /// controllers for update and rollback, this object is beta. However, it may be subject to name
    /// and representation changes in future releases, and clients should not depend on its
    /// stability. It is primarily for internal use by controllers.
    /// </summary>
    class ControllerRevision {
        /// <summary>
        /// Revision indicates the revision of the state represented by Data.
        /// </summary>
        public Input<int> Revision { get; set; } = null!;

        /// <summary>
        /// Data is the serialized representation of the state.
        /// </summary>
        public Input<object>? Data { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
    /// </summary>
    class ControllerRevisionList {
        /// <summary>
        /// Items is the list of ControllerRevisions
        /// </summary>
        public Input<Input<Apps.V1Beta1.ControllerRevision>[]> Items { get; set; } = null!;

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta1/Deployment is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/Deployment instead.
    /// 
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    class Deployment {
        /// <summary>
        /// Standard object metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
        public Input<Apps.V1Beta1.DeploymentSpec>? Spec { get; set; }

    }

    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    class DeploymentCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of deployment condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// The last time this condition was updated.
        /// </summary>
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    class DeploymentList {
        /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
        public Input<Input<Apps.V1Beta1.Deployment>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
    /// </summary>
    class DeploymentRollback {
        /// <summary>
        /// Required: This must match the Name of a deployment.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// The config of this deployment rollback.
        /// </summary>
        public Input<Apps.V1Beta1.RollbackConfig> RollbackTo { get; set; } = null!;

        /// <summary>
        /// The annotations to be updated to a deployment
        /// </summary>
        public InputMap<string>? UpdatedAnnotations { get; set; }

    }

    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    class DeploymentSpec {
        /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Indicates that the deployment is paused.
        /// </summary>
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// Defaults to 600s.
        /// </summary>
        public Input<int>? ProgressDeadlineSeconds { get; set; }

        /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. Defaults to 2.
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// DEPRECATED. The config this deployment is rolling back to. Will be cleared after
        /// rollback is done.
        /// </summary>
        public Input<Apps.V1Beta1.RollbackConfig>? RollbackTo { get; set; }

        /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

        /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
        public Input<Apps.V1Beta1.DeploymentStrategy>? Strategy { get; set; }

    }

    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    class DeploymentStatus {
        /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
        public Input<Input<Apps.V1Beta1.DeploymentCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
        public Input<int>? UnavailableReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    class DeploymentStrategy {
        /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
        public Input<Apps.V1Beta1.RollingUpdateDeployment>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// DEPRECATED.
    /// </summary>
    class RollbackConfig {
        /// <summary>
        /// The revision to rollback to. If set to 0, rollback to the last revision.
        /// </summary>
        public Input<int>? Revision { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    class RollingUpdateDeployment {
        /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can
        /// be scaled up immediately when the rolling update starts, such that the total number of
        /// old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new
        /// ReplicaSet can be scaled up further, ensuring that total number of pods running at any
        /// time during the update is at most 130% of desired pods.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxSurge { get; set; }

        /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0.
        /// Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down
        /// to 70% of desired pods immediately when the rolling update starts. Once new pods are
        /// ready, old ReplicaSet can be scaled down further, followed by scaling up the new
        /// ReplicaSet, ensuring that the total number of pods available at all times during the
        /// update is at least 70% of desired pods.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// RollingUpdateStatefulSetStrategy is used to communicate parameter for
    /// RollingUpdateStatefulSetStrategyType.
    /// </summary>
    class RollingUpdateStatefulSetStrategy {
        /// <summary>
        /// Partition indicates the ordinal at which the StatefulSet should be partitioned.
        /// </summary>
        public Input<int>? Partition { get; set; }

    }

    /// <summary>
    /// Scale represents a scaling request for a resource.
    /// </summary>
    class Scale {
        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        public Input<Apps.V1Beta1.ScaleSpec>? Spec { get; set; }

    }

    /// <summary>
    /// ScaleSpec describes the attributes of a scale subresource
    /// </summary>
    class ScaleSpec {
        /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
        public Input<int>? Replicas { get; set; }

    }

    /// <summary>
    /// ScaleStatus represents the current status of a scale subresource.
    /// </summary>
    class ScaleStatus {
        /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// label query over pods that should match the replicas count. More info:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
        public InputMap<string>? Selector { get; set; }

        /// <summary>
        /// label selector for pods that should match the replicas count. This is a serializated
        /// version of both map-based and more expressive set-based selectors. This is done to avoid
        /// introspection in the clients. The string will be in the same format as the query-param
        /// syntax. If the target type only supports map-based selectors, both this field and
        /// map-based selector field are populated. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<string>? TargetSelector { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta1/StatefulSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/StatefulSet instead.
    /// 
    /// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
    ///  - Network: A single stable DNS and hostname.
    ///  - Storage: As many VolumeClaims as requested.
    /// The StatefulSet guarantees that a given network identity will always map to the same storage
    /// identity.
    /// </summary>
    class StatefulSet {
        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired identities of pods in this set.
        /// </summary>
        public Input<Apps.V1Beta1.StatefulSetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// StatefulSetCondition describes the state of a statefulset at a certain point.
    /// </summary>
    class StatefulSetCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of statefulset condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatefulSetList is a collection of StatefulSets.
    /// </summary>
    class StatefulSetList {
        
        public Input<Input<Apps.V1Beta1.StatefulSet>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// A StatefulSetSpec is the specification of a StatefulSet.
    /// </summary>
    class StatefulSetSpec {
        /// <summary>
        /// serviceName is the name of the service that governs this StatefulSet. This service must
        /// exist before the StatefulSet, and is responsible for the network identity of the set.
        /// Pods get DNS/hostnames that follow the pattern:
        /// pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
        /// managed by the StatefulSet controller.
        /// </summary>
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. Each pod stamped out by the StatefulSet will fulfill this
        /// Template, but have a unique identity from the rest of the StatefulSet.
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// podManagementPolicy controls how pods are created during initial scale up, when
        /// replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`,
        /// where pods are created in increasing order (pod-0, then pod-1, etc) and the controller
        /// will wait until each pod is ready before continuing. When scaling down, the pods are
        /// removed in the opposite order. The alternative policy is `Parallel` which will create
        /// pods in parallel to match the desired scale without waiting, and on scale down will
        /// delete all pods at once.
        /// </summary>
        public Input<string>? PodManagementPolicy { get; set; }

        /// <summary>
        /// replicas is the desired number of replicas of the given Template. These are replicas in
        /// the sense that they are instantiations of the same Template, but individual replicas
        /// also have a consistent identity. If unspecified, defaults to 1.
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the
        /// StatefulSet's revision history. The revision history consists of all revisions not
        /// represented by a currently applied StatefulSetSpec version. The default value is 10.
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// selector is a label query over pods that should match the replica count. If empty,
        /// defaulted to labels on the pod template. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

        /// <summary>
        /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update
        /// Pods in the StatefulSet when a revision is made to Template.
        /// </summary>
        public Input<Apps.V1Beta1.StatefulSetUpdateStrategy>? UpdateStrategy { get; set; }

        /// <summary>
        /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The
        /// StatefulSet controller is responsible for mapping network identities to claims in a way
        /// that maintains the identity of a pod. Every claim in this list must have at least one
        /// matching (by name) volumeMount in one container in the template. A claim in this list
        /// takes precedence over any volumes in the template, with the same name.
        /// </summary>
        public Input<Input<Core.V1.PersistentVolumeClaim>[]>? VolumeClaimTemplates { get; set; }

    }

    /// <summary>
    /// StatefulSetStatus represents the current state of a StatefulSet.
    /// </summary>
    class StatefulSetStatus {
        /// <summary>
        /// replicas is the number of Pods created by the StatefulSet controller.
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet
        /// controller uses this field as a collision avoidance mechanism when it needs to create
        /// the name for the newest ControllerRevision.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a statefulset's current state.
        /// </summary>
        public Input<Input<Apps.V1Beta1.StatefulSetCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// currentReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by currentRevision.
        /// </summary>
        public Input<int>? CurrentReplicas { get; set; }

        /// <summary>
        /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [0,currentReplicas).
        /// </summary>
        public Input<string>? CurrentRevision { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed for this StatefulSet. It
        /// corresponds to the StatefulSet's generation, which is updated on mutation by the API
        /// Server.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// readyReplicas is the number of Pods created by the StatefulSet controller that have a
        /// Ready Condition.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [replicas-updatedReplicas,replicas)
        /// </summary>
        public Input<string>? UpdateRevision { get; set; }

        /// <summary>
        /// updatedReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by updateRevision.
        /// </summary>
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
    /// perform updates. It includes any additional parameters necessary to perform the update for
    /// the indicated strategy.
    /// </summary>
    class StatefulSetUpdateStrategy {
        /// <summary>
        /// RollingUpdate is used to communicate parameters when Type is
        /// RollingUpdateStatefulSetStrategyType.
        /// </summary>
        public Input<Apps.V1Beta1.RollingUpdateStatefulSetStrategy>? RollingUpdate { get; set; }

        /// <summary>
        /// Type indicates the type of the StatefulSetUpdateStrategy.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

  }

  namespace V1Beta2 {
    /// <summary>
    /// DEPRECATED - apps/v1beta2/ControllerRevision is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/ControllerRevision instead.
    /// 
    /// ControllerRevision implements an immutable snapshot of state data. Clients are responsible
    /// for serializing and deserializing the objects that contain their internal state. Once a
    /// ControllerRevision has been successfully created, it can not be updated. The API Server will
    /// fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
    /// may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
    /// controllers for update and rollback, this object is beta. However, it may be subject to name
    /// and representation changes in future releases, and clients should not depend on its
    /// stability. It is primarily for internal use by controllers.
    /// </summary>
    class ControllerRevision {
        /// <summary>
        /// Revision indicates the revision of the state represented by Data.
        /// </summary>
        public Input<int> Revision { get; set; } = null!;

        /// <summary>
        /// Data is the serialized representation of the state.
        /// </summary>
        public Input<object>? Data { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
    /// </summary>
    class ControllerRevisionList {
        /// <summary>
        /// Items is the list of ControllerRevisions
        /// </summary>
        public Input<Input<Apps.V1Beta2.ControllerRevision>[]> Items { get; set; } = null!;

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta2/DaemonSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/DaemonSet instead.
    /// 
    /// DaemonSet represents the configuration of a daemon set.
    /// </summary>
    class DaemonSet {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// The desired behavior of this daemon set. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Apps.V1Beta2.DaemonSetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// DaemonSetCondition describes the state of a DaemonSet at a certain point.
    /// </summary>
    class DaemonSetCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of DaemonSet condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DaemonSetList is a collection of daemon sets.
    /// </summary>
    class DaemonSetList {
        /// <summary>
        /// A list of daemon sets.
        /// </summary>
        public Input<Input<Apps.V1Beta2.DaemonSet>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DaemonSetSpec is the specification of a daemon set.
    /// </summary>
    class DaemonSetSpec {
        /// <summary>
        /// A label query over pods that are managed by the daemon set. Must match in order to be
        /// controlled. It must match the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector> Selector { get; set; } = null!;

        /// <summary>
        /// An object that describes the pod that will be created. The DaemonSet will create exactly
        /// one copy of this pod on every node that matches the template's node selector (or on
        /// every node if no node selector is specified). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// The minimum number of seconds for which a newly created DaemonSet pod should be ready
        /// without any of its container crashing, for it to be considered available. Defaults to 0
        /// (pod will be considered available as soon as it is ready).
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// The number of old history to retain to allow rollback. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 10.
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// An update strategy to replace existing DaemonSet pods with new pods.
        /// </summary>
        public Input<Apps.V1Beta2.DaemonSetUpdateStrategy>? UpdateStrategy { get; set; }

    }

    /// <summary>
    /// DaemonSetStatus represents the current status of a daemon set.
    /// </summary>
    class DaemonSetStatus {
        /// <summary>
        /// The number of nodes that are running at least 1 daemon pod and are supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        public Input<int> CurrentNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The total number of nodes that should be running the daemon pod (including nodes
        /// correctly running the daemon pod). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        public Input<int> DesiredNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that are running the daemon pod, but are not supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        public Input<int> NumberMisscheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and ready.
        /// </summary>
        public Input<int> NumberReady { get; set; } = null!;

        /// <summary>
        /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as
        /// a collision avoidance mechanism when it needs to create the name for the newest
        /// ControllerRevision.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a DaemonSet's current state.
        /// </summary>
        public Input<Input<Apps.V1Beta2.DaemonSetCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        public Input<int>? NumberAvailable { get; set; }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have none of the daemon
        /// pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        public Input<int>? NumberUnavailable { get; set; }

        /// <summary>
        /// The most recent generation observed by the daemon set controller.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The total number of nodes that are running updated daemon pod
        /// </summary>
        public Input<int>? UpdatedNumberScheduled { get; set; }

    }

    /// <summary>
    /// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
    /// </summary>
    class DaemonSetUpdateStrategy {
        /// <summary>
        /// Rolling update config params. Present only if type = "RollingUpdate".
        /// </summary>
        public Input<Apps.V1Beta2.RollingUpdateDaemonSet>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is
        /// RollingUpdate.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta2/Deployment is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/Deployment instead.
    /// 
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    class Deployment {
        /// <summary>
        /// Standard object metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
        public Input<Apps.V1Beta2.DeploymentSpec>? Spec { get; set; }

    }

    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    class DeploymentCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of deployment condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// The last time this condition was updated.
        /// </summary>
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    class DeploymentList {
        /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
        public Input<Input<Apps.V1Beta2.Deployment>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    class DeploymentSpec {
        /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment. It must match the pod template's labels.
        /// </summary>
        public Input<Meta.V1.LabelSelector> Selector { get; set; } = null!;

        /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Indicates that the deployment is paused.
        /// </summary>
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// Defaults to 600s.
        /// </summary>
        public Input<int>? ProgressDeadlineSeconds { get; set; }

        /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. Defaults to 10.
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
        public Input<Apps.V1Beta2.DeploymentStrategy>? Strategy { get; set; }

    }

    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    class DeploymentStatus {
        /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
        public Input<Input<Apps.V1Beta2.DeploymentCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
        public Input<int>? UnavailableReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    class DeploymentStrategy {
        /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
        public Input<Apps.V1Beta2.RollingUpdateDeployment>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta2/ReplicaSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/ReplicaSet instead.
    /// 
    /// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
    /// </summary>
    class ReplicaSet {
        /// <summary>
        /// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
        /// that the ReplicaSet manages. Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the specification of the desired behavior of the ReplicaSet. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Apps.V1Beta2.ReplicaSetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// ReplicaSetCondition describes the state of a replica set at a certain point.
    /// </summary>
    class ReplicaSetCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of replica set condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ReplicaSetList is a collection of ReplicaSets.
    /// </summary>
    class ReplicaSetList {
        /// <summary>
        /// List of ReplicaSets. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
        public Input<Input<Apps.V1Beta2.ReplicaSet>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ReplicaSetSpec is the specification of a ReplicaSet.
    /// </summary>
    class ReplicaSetSpec {
        /// <summary>
        /// Selector is a label query over pods that should match the replica count. Label keys and
        /// values that must match in order to be controlled by this replica set. It must match the
        /// pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector> Selector { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        public Input<Core.V1.PodTemplateSpec>? Template { get; set; }

    }

    /// <summary>
    /// ReplicaSetStatus represents the current status of a ReplicaSet.
    /// </summary>
    class ReplicaSetStatus {
        /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this replica
        /// set.
        /// </summary>
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Represents the latest available observations of a replica set's current state.
        /// </summary>
        public Input<Input<Apps.V1Beta2.ReplicaSetCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replicaset.
        /// </summary>
        public Input<int>? FullyLabeledReplicas { get; set; }

        /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The number of ready replicas for this replica set.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of daemon set rolling update.
    /// </summary>
    class RollingUpdateDaemonSet {
        /// <summary>
        /// The maximum number of DaemonSet pods that can be unavailable during the update. Value
        /// can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at
        /// the start of the update (ex: 10%). Absolute number is calculated from percentage by
        /// rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at
        /// most 30% of the total number of nodes that should be running the daemon pod (i.e.
        /// status.desiredNumberScheduled) can have their pods stopped for an update at any given
        /// time. The update starts by stopping at most 30% of those DaemonSet pods and then brings
        /// up new DaemonSet pods in their place. Once the new pods are available, it then proceeds
        /// onto other DaemonSet pods, thus ensuring that at least 70% of original number of
        /// DaemonSet pods are available at all times during the update.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    class RollingUpdateDeployment {
        /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can
        /// be scaled up immediately when the rolling update starts, such that the total number of
        /// old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new
        /// ReplicaSet can be scaled up further, ensuring that total number of pods running at any
        /// time during the update is at most 130% of desired pods.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxSurge { get; set; }

        /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0.
        /// Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down
        /// to 70% of desired pods immediately when the rolling update starts. Once new pods are
        /// ready, old ReplicaSet can be scaled down further, followed by scaling up the new
        /// ReplicaSet, ensuring that the total number of pods available at all times during the
        /// update is at least 70% of desired pods.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// RollingUpdateStatefulSetStrategy is used to communicate parameter for
    /// RollingUpdateStatefulSetStrategyType.
    /// </summary>
    class RollingUpdateStatefulSetStrategy {
        /// <summary>
        /// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default
        /// value is 0.
        /// </summary>
        public Input<int>? Partition { get; set; }

    }

    /// <summary>
    /// Scale represents a scaling request for a resource.
    /// </summary>
    class Scale {
        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        public Input<Apps.V1Beta2.ScaleSpec>? Spec { get; set; }

    }

    /// <summary>
    /// ScaleSpec describes the attributes of a scale subresource
    /// </summary>
    class ScaleSpec {
        /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
        public Input<int>? Replicas { get; set; }

    }

    /// <summary>
    /// ScaleStatus represents the current status of a scale subresource.
    /// </summary>
    class ScaleStatus {
        /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// label query over pods that should match the replicas count. More info:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
        public InputMap<string>? Selector { get; set; }

        /// <summary>
        /// label selector for pods that should match the replicas count. This is a serializated
        /// version of both map-based and more expressive set-based selectors. This is done to avoid
        /// introspection in the clients. The string will be in the same format as the query-param
        /// syntax. If the target type only supports map-based selectors, both this field and
        /// map-based selector field are populated. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<string>? TargetSelector { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta2/StatefulSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/StatefulSet instead.
    /// 
    /// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
    ///  - Network: A single stable DNS and hostname.
    ///  - Storage: As many VolumeClaims as requested.
    /// The StatefulSet guarantees that a given network identity will always map to the same storage
    /// identity.
    /// </summary>
    class StatefulSet {
        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired identities of pods in this set.
        /// </summary>
        public Input<Apps.V1Beta2.StatefulSetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// StatefulSetCondition describes the state of a statefulset at a certain point.
    /// </summary>
    class StatefulSetCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of statefulset condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatefulSetList is a collection of StatefulSets.
    /// </summary>
    class StatefulSetList {
        
        public Input<Input<Apps.V1Beta2.StatefulSet>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// A StatefulSetSpec is the specification of a StatefulSet.
    /// </summary>
    class StatefulSetSpec {
        /// <summary>
        /// selector is a label query over pods that should match the replica count. It must match
        /// the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector> Selector { get; set; } = null!;

        /// <summary>
        /// serviceName is the name of the service that governs this StatefulSet. This service must
        /// exist before the StatefulSet, and is responsible for the network identity of the set.
        /// Pods get DNS/hostnames that follow the pattern:
        /// pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
        /// managed by the StatefulSet controller.
        /// </summary>
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. Each pod stamped out by the StatefulSet will fulfill this
        /// Template, but have a unique identity from the rest of the StatefulSet.
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// podManagementPolicy controls how pods are created during initial scale up, when
        /// replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`,
        /// where pods are created in increasing order (pod-0, then pod-1, etc) and the controller
        /// will wait until each pod is ready before continuing. When scaling down, the pods are
        /// removed in the opposite order. The alternative policy is `Parallel` which will create
        /// pods in parallel to match the desired scale without waiting, and on scale down will
        /// delete all pods at once.
        /// </summary>
        public Input<string>? PodManagementPolicy { get; set; }

        /// <summary>
        /// replicas is the desired number of replicas of the given Template. These are replicas in
        /// the sense that they are instantiations of the same Template, but individual replicas
        /// also have a consistent identity. If unspecified, defaults to 1.
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the
        /// StatefulSet's revision history. The revision history consists of all revisions not
        /// represented by a currently applied StatefulSetSpec version. The default value is 10.
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update
        /// Pods in the StatefulSet when a revision is made to Template.
        /// </summary>
        public Input<Apps.V1Beta2.StatefulSetUpdateStrategy>? UpdateStrategy { get; set; }

        /// <summary>
        /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The
        /// StatefulSet controller is responsible for mapping network identities to claims in a way
        /// that maintains the identity of a pod. Every claim in this list must have at least one
        /// matching (by name) volumeMount in one container in the template. A claim in this list
        /// takes precedence over any volumes in the template, with the same name.
        /// </summary>
        public Input<Input<Core.V1.PersistentVolumeClaim>[]>? VolumeClaimTemplates { get; set; }

    }

    /// <summary>
    /// StatefulSetStatus represents the current state of a StatefulSet.
    /// </summary>
    class StatefulSetStatus {
        /// <summary>
        /// replicas is the number of Pods created by the StatefulSet controller.
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet
        /// controller uses this field as a collision avoidance mechanism when it needs to create
        /// the name for the newest ControllerRevision.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a statefulset's current state.
        /// </summary>
        public Input<Input<Apps.V1Beta2.StatefulSetCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// currentReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by currentRevision.
        /// </summary>
        public Input<int>? CurrentReplicas { get; set; }

        /// <summary>
        /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [0,currentReplicas).
        /// </summary>
        public Input<string>? CurrentRevision { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed for this StatefulSet. It
        /// corresponds to the StatefulSet's generation, which is updated on mutation by the API
        /// Server.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// readyReplicas is the number of Pods created by the StatefulSet controller that have a
        /// Ready Condition.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [replicas-updatedReplicas,replicas)
        /// </summary>
        public Input<string>? UpdateRevision { get; set; }

        /// <summary>
        /// updatedReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by updateRevision.
        /// </summary>
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
    /// perform updates. It includes any additional parameters necessary to perform the update for
    /// the indicated strategy.
    /// </summary>
    class StatefulSetUpdateStrategy {
        /// <summary>
        /// RollingUpdate is used to communicate parameters when Type is
        /// RollingUpdateStatefulSetStrategyType.
        /// </summary>
        public Input<Apps.V1Beta2.RollingUpdateStatefulSetStrategy>? RollingUpdate { get; set; }

        /// <summary>
        /// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.AuditRegistraion {
  namespace V1Alpha1 {
    /// <summary>
    /// AuditSink represents a cluster level audit sink
    /// </summary>
    class AuditSink {
        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the audit configuration spec
        /// </summary>
        public Input<AuditRegistraion.V1Alpha1.AuditSinkSpec>? Spec { get; set; }

    }

    /// <summary>
    /// AuditSinkList is a list of AuditSink items.
    /// </summary>
    class AuditSinkList {
        /// <summary>
        /// List of audit configurations.
        /// </summary>
        public Input<Input<AuditRegistraion.V1Alpha1.AuditSink>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// AuditSinkSpec holds the spec for the audit sink
    /// </summary>
    class AuditSinkSpec {
        /// <summary>
        /// Policy defines the policy for selecting which events should be sent to the webhook
        /// required
        /// </summary>
        public Input<AuditRegistraion.V1Alpha1.Policy> Policy { get; set; } = null!;

        /// <summary>
        /// Webhook to send events required
        /// </summary>
        public Input<AuditRegistraion.V1Alpha1.Webhook> Webhook { get; set; } = null!;

    }

    /// <summary>
    /// Policy defines the configuration of how audit events are logged
    /// </summary>
    class Policy {
        /// <summary>
        /// The Level that all requests are recorded at. available options: None, Metadata, Request,
        /// RequestResponse required
        /// </summary>
        public Input<string> Level { get; set; } = null!;

        /// <summary>
        /// Stages is a list of stages for which events are created.
        /// </summary>
        public Input<Input<string>[]>? Stages { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    class ServiceReference {
        /// <summary>
        /// `name` is the name of the service. Required
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// `namespace` is the namespace of the service. Required
        /// </summary>
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// `path` is an optional URL path which will be sent in any request to this service.
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// Webhook holds the configuration of the webhook
    /// </summary>
    class Webhook {
        /// <summary>
        /// ClientConfig holds the connection parameters for the webhook required
        /// </summary>
        public Input<AuditRegistraion.V1Alpha1.WebhookClientConfig> ClientConfig { get; set; } = null!;

        /// <summary>
        /// Throttle holds the options for throttling the webhook
        /// </summary>
        public Input<AuditRegistraion.V1Alpha1.WebhookThrottleConfig>? Throttle { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a connection with the webhook
    /// </summary>
    class WebhookClientConfig {
        /// <summary>
        /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's
        /// server certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// `service` is a reference to the service for this webhook. Either `service` or `url` must
        /// be specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        public Input<AuditRegistraion.V1Alpha1.ServiceReference>? Service { get; set; }

        /// <summary>
        /// `url` gives the location of the webhook, in standard URL form
        /// (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        public Input<string>? Url { get; set; }

    }

    /// <summary>
    /// WebhookThrottleConfig holds the configuration for throttling events
    /// </summary>
    class WebhookThrottleConfig {
        /// <summary>
        /// ThrottleBurst is the maximum number of events sent at the same moment default 15 QPS
        /// </summary>
        public Input<int>? Burst { get; set; }

        /// <summary>
        /// ThrottleQPS maximum number of batches per second default 10 QPS
        /// </summary>
        public Input<int>? Qps { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Authentication {
  namespace V1 {
    /// <summary>
    /// BoundObjectReference is a reference to an object that a token is bound to.
    /// </summary>
    class BoundObjectReference {
        /// <summary>
        /// Name of the referent.
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// UID of the referent.
        /// </summary>
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// TokenRequest requests a token for a given service account.
    /// </summary>
    class TokenRequest {
        
        public Input<Authentication.V1.TokenRequestSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// TokenRequestSpec contains client provided parameters of a token request.
    /// </summary>
    class TokenRequestSpec {
        /// <summary>
        /// Audiences are the intendend audiences of the token. A recipient of a token must
        /// identitfy themself with an identifier in the list of audiences of the token, and
        /// otherwise should reject the token. A token issued for multiple audiences may be used to
        /// authenticate against any of the audiences listed but implies a high degree of trust
        /// between the target audiences.
        /// </summary>
        public Input<Input<string>[]> Audiences { get; set; } = null!;

        /// <summary>
        /// BoundObjectRef is a reference to an object that the token will be bound to. The token
        /// will only be valid for as long as the bound object exists. NOTE: The API server's
        /// TokenReview endpoint will validate the BoundObjectRef, but other audiences may not. Keep
        /// ExpirationSeconds small if you want prompt revocation.
        /// </summary>
        public Input<Authentication.V1.BoundObjectReference>? BoundObjectRef { get; set; }

        /// <summary>
        /// ExpirationSeconds is the requested duration of validity of the request. The token issuer
        /// may return a token with a different validity duration so a client needs to check the
        /// 'expiration' field in a response.
        /// </summary>
        public Input<int>? ExpirationSeconds { get; set; }

    }

    /// <summary>
    /// TokenRequestStatus is the result of a token request.
    /// </summary>
    class TokenRequestStatus {
        /// <summary>
        /// ExpirationTimestamp is the time of expiration of the returned token.
        /// </summary>
        public Input<string> ExpirationTimestamp { get; set; } = null!;

        /// <summary>
        /// Token is the opaque bearer token.
        /// </summary>
        public Input<string> Token { get; set; } = null!;

    }

    /// <summary>
    /// TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may
    /// be cached by the webhook token authenticator plugin in the kube-apiserver.
    /// </summary>
    class TokenReview {
        /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
        public Input<Authentication.V1.TokenReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// TokenReviewSpec is a description of the token authentication request.
    /// </summary>
    class TokenReviewSpec {
        /// <summary>
        /// Audiences is a list of the identifiers that the resource server presented with the token
        /// identifies as. Audience-aware token authenticators will verify that the token was
        /// intended for at least one of the audiences in this list. If no audiences are provided,
        /// the audience will default to the audience of the Kubernetes apiserver.
        /// </summary>
        public Input<Input<string>[]>? Audiences { get; set; }

        /// <summary>
        /// Token is the opaque bearer token.
        /// </summary>
        public Input<string>? Token { get; set; }

    }

    /// <summary>
    /// TokenReviewStatus is the result of the token authentication request.
    /// </summary>
    class TokenReviewStatus {
        /// <summary>
        /// Audiences are audience identifiers chosen by the authenticator that are compatible with
        /// both the TokenReview and token. An identifier is any identifier in the intersection of
        /// the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API
        /// that sets the spec.audiences field should validate that a compatible audience identifier
        /// is returned in the status.audiences field to ensure that the TokenReview server is
        /// audience aware. If a TokenReview returns an empty status.audience field where
        /// status.authenticated is "true", the token is valid against the audience of the
        /// Kubernetes API server.
        /// </summary>
        public Input<Input<string>[]>? Audiences { get; set; }

        /// <summary>
        /// Authenticated indicates that the token was associated with a known user.
        /// </summary>
        public Input<bool>? Authenticated { get; set; }

        /// <summary>
        /// Error indicates that the token couldn't be checked
        /// </summary>
        public Input<string>? Error { get; set; }

        /// <summary>
        /// User is the UserInfo associated with the provided token.
        /// </summary>
        public Input<Authentication.V1.UserInfo>? User { get; set; }

    }

    /// <summary>
    /// UserInfo holds the information about the user needed to implement the user.Info interface.
    /// </summary>
    class UserInfo {
        /// <summary>
        /// Any additional information provided by the authenticator.
        /// </summary>
        public Input<object>? Extra { get; set; }

        /// <summary>
        /// The names of groups this user is a part of.
        /// </summary>
        public Input<Input<string>[]>? Groups { get; set; }

        /// <summary>
        /// A unique value that identifies this user across time. If this user is deleted and
        /// another user by the same name is added, they will have different UIDs.
        /// </summary>
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// The name that uniquely identifies this user among all active users.
        /// </summary>
        public Input<string>? Username { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may
    /// be cached by the webhook token authenticator plugin in the kube-apiserver.
    /// </summary>
    class TokenReview {
        /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
        public Input<Authentication.V1Beta1.TokenReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// TokenReviewSpec is a description of the token authentication request.
    /// </summary>
    class TokenReviewSpec {
        /// <summary>
        /// Audiences is a list of the identifiers that the resource server presented with the token
        /// identifies as. Audience-aware token authenticators will verify that the token was
        /// intended for at least one of the audiences in this list. If no audiences are provided,
        /// the audience will default to the audience of the Kubernetes apiserver.
        /// </summary>
        public Input<Input<string>[]>? Audiences { get; set; }

        /// <summary>
        /// Token is the opaque bearer token.
        /// </summary>
        public Input<string>? Token { get; set; }

    }

    /// <summary>
    /// TokenReviewStatus is the result of the token authentication request.
    /// </summary>
    class TokenReviewStatus {
        /// <summary>
        /// Audiences are audience identifiers chosen by the authenticator that are compatible with
        /// both the TokenReview and token. An identifier is any identifier in the intersection of
        /// the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API
        /// that sets the spec.audiences field should validate that a compatible audience identifier
        /// is returned in the status.audiences field to ensure that the TokenReview server is
        /// audience aware. If a TokenReview returns an empty status.audience field where
        /// status.authenticated is "true", the token is valid against the audience of the
        /// Kubernetes API server.
        /// </summary>
        public Input<Input<string>[]>? Audiences { get; set; }

        /// <summary>
        /// Authenticated indicates that the token was associated with a known user.
        /// </summary>
        public Input<bool>? Authenticated { get; set; }

        /// <summary>
        /// Error indicates that the token couldn't be checked
        /// </summary>
        public Input<string>? Error { get; set; }

        /// <summary>
        /// User is the UserInfo associated with the provided token.
        /// </summary>
        public Input<Authentication.V1Beta1.UserInfo>? User { get; set; }

    }

    /// <summary>
    /// UserInfo holds the information about the user needed to implement the user.Info interface.
    /// </summary>
    class UserInfo {
        /// <summary>
        /// Any additional information provided by the authenticator.
        /// </summary>
        public Input<object>? Extra { get; set; }

        /// <summary>
        /// The names of groups this user is a part of.
        /// </summary>
        public Input<Input<string>[]>? Groups { get; set; }

        /// <summary>
        /// A unique value that identifies this user across time. If this user is deleted and
        /// another user by the same name is added, they will have different UIDs.
        /// </summary>
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// The name that uniquely identifies this user among all active users.
        /// </summary>
        public Input<string>? Username { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Authorization {
  namespace V1 {
    /// <summary>
    /// LocalSubjectAccessReview checks whether or not a user or group can perform an action in a
    /// given namespace. Having a namespace scoped resource makes it much easier to grant namespace
    /// scoped policy that includes permissions checking.
    /// </summary>
    class LocalSubjectAccessReview {
        /// <summary>
        /// Spec holds information about the request being evaluated.  spec.namespace must be equal
        /// to the namespace you made the request against.  If empty, it is defaulted.
        /// </summary>
        public Input<Authorization.V1.SubjectAccessReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// NonResourceAttributes includes the authorization attributes available for non-resource
    /// requests to the Authorizer interface
    /// </summary>
    class NonResourceAttributes {
        /// <summary>
        /// Path is the URL path of the request
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Verb is the standard HTTP verb
        /// </summary>
        public Input<string>? Verb { get; set; }

    }

    /// <summary>
    /// NonResourceRule holds information that describes a rule for the non-resource
    /// </summary>
    class NonResourceRule {
        /// <summary>
        /// Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete,
        /// patch, head, options.  "*" means all.
        /// </summary>
        public Input<Input<string>[]> Verbs { get; set; } = null!;

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path.  "*" means all.
        /// </summary>
        public Input<Input<string>[]>? NonResourceURLs { get; set; }

    }

    /// <summary>
    /// ResourceAttributes includes the authorization attributes available for resource requests to
    /// the Authorizer interface
    /// </summary>
    class ResourceAttributes {
        /// <summary>
        /// Group is the API Group of the Resource.  "*" means all.
        /// </summary>
        public Input<string>? Group { get; set; }

        /// <summary>
        /// Name is the name of the resource being requested for a "get" or deleted for a "delete".
        /// "" (empty) means all.
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace is the namespace of the action being requested.  Currently, there is no
        /// distinction between no namespace and all namespaces "" (empty) is defaulted for
        /// LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty)
        /// means "all" for namespace scoped resources from a SubjectAccessReview or
        /// SelfSubjectAccessReview
        /// </summary>
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Resource is one of the existing resource types.  "*" means all.
        /// </summary>
        public Input<string>? Resource { get; set; }

        /// <summary>
        /// Subresource is one of the existing resource types.  "" means none.
        /// </summary>
        public Input<string>? Subresource { get; set; }

        /// <summary>
        /// Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete,
        /// proxy.  "*" means all.
        /// </summary>
        public Input<string>? Verb { get; set; }

        /// <summary>
        /// Version is the API Version of the Resource.  "*" means all.
        /// </summary>
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// ResourceRule is the list of actions the subject is allowed to perform on resources. The list
    /// ordering isn't significant, may contain duplicates, and possibly be incomplete.
    /// </summary>
    class ResourceRule {
        /// <summary>
        /// Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update,
        /// delete, proxy.  "*" means all.
        /// </summary>
        public Input<Input<string>[]> Verbs { get; set; } = null!;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.  "*" means all.
        /// </summary>
        public Input<Input<string>[]>? ApiGroups { get; set; }

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.  "*" means all.
        /// </summary>
        public Input<Input<string>[]>? ResourceNames { get; set; }

        /// <summary>
        /// Resources is a list of resources this rule applies to.  "*" means all in the specified
        /// apiGroups.
        ///  "*/foo" represents the subresource 'foo' for all resources in the specified apiGroups.
        /// </summary>
        public Input<Input<string>[]>? Resources { get; set; }

    }

    /// <summary>
    /// SelfSubjectAccessReview checks whether or the current user can perform an action.  Not
    /// filling in a spec.namespace means "in all namespaces".  Self is a special case, because
    /// users should always be able to check whether they can perform an action
    /// </summary>
    class SelfSubjectAccessReview {
        /// <summary>
        /// Spec holds information about the request being evaluated.  user and groups must be empty
        /// </summary>
        public Input<Authorization.V1.SelfSubjectAccessReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    class SelfSubjectAccessReviewSpec {
        /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
        public Input<Authorization.V1.NonResourceAttributes>? NonResourceAttributes { get; set; }

        /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
        public Input<Authorization.V1.ResourceAttributes>? ResourceAttributes { get; set; }

    }

    /// <summary>
    /// SelfSubjectRulesReview enumerates the set of actions the current user can perform within a
    /// namespace. The returned list of actions may be incomplete depending on the server's
    /// authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview
    /// should be used by UIs to show/hide actions, or to quickly let an end user reason about their
    /// permissions. It should NOT Be used by external systems to drive authorization decisions as
    /// this raises confused deputy, cache lifetime/revocation, and correctness concerns.
    /// SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization
    /// decisions to the API server.
    /// </summary>
    class SelfSubjectRulesReview {
        /// <summary>
        /// Spec holds information about the request being evaluated.
        /// </summary>
        public Input<Authorization.V1.SelfSubjectRulesReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    class SelfSubjectRulesReviewSpec {
        /// <summary>
        /// Namespace to evaluate rules for. Required.
        /// </summary>
        public Input<string>? Namespace { get; set; }

    }

    /// <summary>
    /// SubjectAccessReview checks whether or not a user or group can perform an action.
    /// </summary>
    class SubjectAccessReview {
        /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
        public Input<Authorization.V1.SubjectAccessReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// SubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    class SubjectAccessReviewSpec {
        /// <summary>
        /// Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that
        /// is input to the authorizer it needs a reflection here.
        /// </summary>
        public Input<object>? Extra { get; set; }

        /// <summary>
        /// Groups is the groups you're testing for.
        /// </summary>
        public Input<Input<string>[]>? Groups { get; set; }

        /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
        public Input<Authorization.V1.NonResourceAttributes>? NonResourceAttributes { get; set; }

        /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
        public Input<Authorization.V1.ResourceAttributes>? ResourceAttributes { get; set; }

        /// <summary>
        /// UID information about the requesting user.
        /// </summary>
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// User is the user you're testing for. If you specify "User" but not "Groups", then is it
        /// interpreted as "What if User were not a member of any groups
        /// </summary>
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// SubjectAccessReviewStatus
    /// </summary>
    class SubjectAccessReviewStatus {
        /// <summary>
        /// Allowed is required. True if the action would be allowed, false otherwise.
        /// </summary>
        public Input<bool> Allowed { get; set; } = null!;

        /// <summary>
        /// Denied is optional. True if the action would be denied, otherwise false. If both allowed
        /// is false and denied is false, then the authorizer has no opinion on whether to authorize
        /// the action. Denied may not be true if Allowed is true.
        /// </summary>
        public Input<bool>? Denied { get; set; }

        /// <summary>
        /// EvaluationError is an indication that some error occurred during the authorization
        /// check. It is entirely possible to get an error and be able to continue determine
        /// authorization status in spite of it. For instance, RBAC can be missing a role, but
        /// enough roles are still present and bound to reason about the request.
        /// </summary>
        public Input<string>? EvaluationError { get; set; }

        /// <summary>
        /// Reason is optional.  It indicates why a request was allowed or denied.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete
    /// depending on the set of authorizers the server is configured with and any errors experienced
    /// during evaluation. Because authorization rules are additive, if a rule appears in a list
    /// it's safe to assume the subject has that permission, even if that list is incomplete.
    /// </summary>
    class SubjectRulesReviewStatus {
        /// <summary>
        /// Incomplete is true when the rules returned by this call are incomplete. This is most
        /// commonly encountered when an authorizer, such as an external authorizer, doesn't support
        /// rules evaluation.
        /// </summary>
        public Input<bool> Incomplete { get; set; } = null!;

        /// <summary>
        /// NonResourceRules is the list of actions the subject is allowed to perform on
        /// non-resources. The list ordering isn't significant, may contain duplicates, and possibly
        /// be incomplete.
        /// </summary>
        public Input<Input<Authorization.V1.NonResourceRule>[]> NonResourceRules { get; set; } = null!;

        /// <summary>
        /// ResourceRules is the list of actions the subject is allowed to perform on resources. The
        /// list ordering isn't significant, may contain duplicates, and possibly be incomplete.
        /// </summary>
        public Input<Input<Authorization.V1.ResourceRule>[]> ResourceRules { get; set; } = null!;

        /// <summary>
        /// EvaluationError can appear in combination with Rules. It indicates an error occurred
        /// during rule evaluation, such as an authorizer that doesn't support rule evaluation, and
        /// that ResourceRules and/or NonResourceRules may be incomplete.
        /// </summary>
        public Input<string>? EvaluationError { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// LocalSubjectAccessReview checks whether or not a user or group can perform an action in a
    /// given namespace. Having a namespace scoped resource makes it much easier to grant namespace
    /// scoped policy that includes permissions checking.
    /// </summary>
    class LocalSubjectAccessReview {
        /// <summary>
        /// Spec holds information about the request being evaluated.  spec.namespace must be equal
        /// to the namespace you made the request against.  If empty, it is defaulted.
        /// </summary>
        public Input<Authorization.V1Beta1.SubjectAccessReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// NonResourceAttributes includes the authorization attributes available for non-resource
    /// requests to the Authorizer interface
    /// </summary>
    class NonResourceAttributes {
        /// <summary>
        /// Path is the URL path of the request
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Verb is the standard HTTP verb
        /// </summary>
        public Input<string>? Verb { get; set; }

    }

    /// <summary>
    /// NonResourceRule holds information that describes a rule for the non-resource
    /// </summary>
    class NonResourceRule {
        /// <summary>
        /// Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete,
        /// patch, head, options.  "*" means all.
        /// </summary>
        public Input<Input<string>[]> Verbs { get; set; } = null!;

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path.  "*" means all.
        /// </summary>
        public Input<Input<string>[]>? NonResourceURLs { get; set; }

    }

    /// <summary>
    /// ResourceAttributes includes the authorization attributes available for resource requests to
    /// the Authorizer interface
    /// </summary>
    class ResourceAttributes {
        /// <summary>
        /// Group is the API Group of the Resource.  "*" means all.
        /// </summary>
        public Input<string>? Group { get; set; }

        /// <summary>
        /// Name is the name of the resource being requested for a "get" or deleted for a "delete".
        /// "" (empty) means all.
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace is the namespace of the action being requested.  Currently, there is no
        /// distinction between no namespace and all namespaces "" (empty) is defaulted for
        /// LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty)
        /// means "all" for namespace scoped resources from a SubjectAccessReview or
        /// SelfSubjectAccessReview
        /// </summary>
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Resource is one of the existing resource types.  "*" means all.
        /// </summary>
        public Input<string>? Resource { get; set; }

        /// <summary>
        /// Subresource is one of the existing resource types.  "" means none.
        /// </summary>
        public Input<string>? Subresource { get; set; }

        /// <summary>
        /// Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete,
        /// proxy.  "*" means all.
        /// </summary>
        public Input<string>? Verb { get; set; }

        /// <summary>
        /// Version is the API Version of the Resource.  "*" means all.
        /// </summary>
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// ResourceRule is the list of actions the subject is allowed to perform on resources. The list
    /// ordering isn't significant, may contain duplicates, and possibly be incomplete.
    /// </summary>
    class ResourceRule {
        /// <summary>
        /// Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update,
        /// delete, proxy.  "*" means all.
        /// </summary>
        public Input<Input<string>[]> Verbs { get; set; } = null!;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.  "*" means all.
        /// </summary>
        public Input<Input<string>[]>? ApiGroups { get; set; }

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.  "*" means all.
        /// </summary>
        public Input<Input<string>[]>? ResourceNames { get; set; }

        /// <summary>
        /// Resources is a list of resources this rule applies to.  "*" means all in the specified
        /// apiGroups.
        ///  "*/foo" represents the subresource 'foo' for all resources in the specified apiGroups.
        /// </summary>
        public Input<Input<string>[]>? Resources { get; set; }

    }

    /// <summary>
    /// SelfSubjectAccessReview checks whether or the current user can perform an action.  Not
    /// filling in a spec.namespace means "in all namespaces".  Self is a special case, because
    /// users should always be able to check whether they can perform an action
    /// </summary>
    class SelfSubjectAccessReview {
        /// <summary>
        /// Spec holds information about the request being evaluated.  user and groups must be empty
        /// </summary>
        public Input<Authorization.V1Beta1.SelfSubjectAccessReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    class SelfSubjectAccessReviewSpec {
        /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
        public Input<Authorization.V1Beta1.NonResourceAttributes>? NonResourceAttributes { get; set; }

        /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
        public Input<Authorization.V1Beta1.ResourceAttributes>? ResourceAttributes { get; set; }

    }

    /// <summary>
    /// SelfSubjectRulesReview enumerates the set of actions the current user can perform within a
    /// namespace. The returned list of actions may be incomplete depending on the server's
    /// authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview
    /// should be used by UIs to show/hide actions, or to quickly let an end user reason about their
    /// permissions. It should NOT Be used by external systems to drive authorization decisions as
    /// this raises confused deputy, cache lifetime/revocation, and correctness concerns.
    /// SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization
    /// decisions to the API server.
    /// </summary>
    class SelfSubjectRulesReview {
        /// <summary>
        /// Spec holds information about the request being evaluated.
        /// </summary>
        public Input<Authorization.V1Beta1.SelfSubjectRulesReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    class SelfSubjectRulesReviewSpec {
        /// <summary>
        /// Namespace to evaluate rules for. Required.
        /// </summary>
        public Input<string>? Namespace { get; set; }

    }

    /// <summary>
    /// SubjectAccessReview checks whether or not a user or group can perform an action.
    /// </summary>
    class SubjectAccessReview {
        /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
        public Input<Authorization.V1Beta1.SubjectAccessReviewSpec> Spec { get; set; } = null!;

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// SubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    class SubjectAccessReviewSpec {
        /// <summary>
        /// Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that
        /// is input to the authorizer it needs a reflection here.
        /// </summary>
        public Input<object>? Extra { get; set; }

        /// <summary>
        /// Groups is the groups you're testing for.
        /// </summary>
        public Input<Input<string>[]>? Group { get; set; }

        /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
        public Input<Authorization.V1Beta1.NonResourceAttributes>? NonResourceAttributes { get; set; }

        /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
        public Input<Authorization.V1Beta1.ResourceAttributes>? ResourceAttributes { get; set; }

        /// <summary>
        /// UID information about the requesting user.
        /// </summary>
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// User is the user you're testing for. If you specify "User" but not "Group", then is it
        /// interpreted as "What if User were not a member of any groups
        /// </summary>
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// SubjectAccessReviewStatus
    /// </summary>
    class SubjectAccessReviewStatus {
        /// <summary>
        /// Allowed is required. True if the action would be allowed, false otherwise.
        /// </summary>
        public Input<bool> Allowed { get; set; } = null!;

        /// <summary>
        /// Denied is optional. True if the action would be denied, otherwise false. If both allowed
        /// is false and denied is false, then the authorizer has no opinion on whether to authorize
        /// the action. Denied may not be true if Allowed is true.
        /// </summary>
        public Input<bool>? Denied { get; set; }

        /// <summary>
        /// EvaluationError is an indication that some error occurred during the authorization
        /// check. It is entirely possible to get an error and be able to continue determine
        /// authorization status in spite of it. For instance, RBAC can be missing a role, but
        /// enough roles are still present and bound to reason about the request.
        /// </summary>
        public Input<string>? EvaluationError { get; set; }

        /// <summary>
        /// Reason is optional.  It indicates why a request was allowed or denied.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete
    /// depending on the set of authorizers the server is configured with and any errors experienced
    /// during evaluation. Because authorization rules are additive, if a rule appears in a list
    /// it's safe to assume the subject has that permission, even if that list is incomplete.
    /// </summary>
    class SubjectRulesReviewStatus {
        /// <summary>
        /// Incomplete is true when the rules returned by this call are incomplete. This is most
        /// commonly encountered when an authorizer, such as an external authorizer, doesn't support
        /// rules evaluation.
        /// </summary>
        public Input<bool> Incomplete { get; set; } = null!;

        /// <summary>
        /// NonResourceRules is the list of actions the subject is allowed to perform on
        /// non-resources. The list ordering isn't significant, may contain duplicates, and possibly
        /// be incomplete.
        /// </summary>
        public Input<Input<Authorization.V1Beta1.NonResourceRule>[]> NonResourceRules { get; set; } = null!;

        /// <summary>
        /// ResourceRules is the list of actions the subject is allowed to perform on resources. The
        /// list ordering isn't significant, may contain duplicates, and possibly be incomplete.
        /// </summary>
        public Input<Input<Authorization.V1Beta1.ResourceRule>[]> ResourceRules { get; set; } = null!;

        /// <summary>
        /// EvaluationError can appear in combination with Rules. It indicates an error occurred
        /// during rule evaluation, such as an authorizer that doesn't support rule evaluation, and
        /// that ResourceRules and/or NonResourceRules may be incomplete.
        /// </summary>
        public Input<string>? EvaluationError { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Autoscaling {
  namespace V1 {
    /// <summary>
    /// CrossVersionObjectReference contains enough information to let you identify the referred
    /// resource.
    /// </summary>
    class CrossVersionObjectReference {
        /// <summary>
        /// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// configuration of a horizontal pod autoscaler.
    /// </summary>
    class HorizontalPodAutoscaler {
        /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// behaviour of autoscaler. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        public Input<Autoscaling.V1.HorizontalPodAutoscalerSpec>? Spec { get; set; }

    }

    /// <summary>
    /// list of horizontal pod autoscaler objects.
    /// </summary>
    class HorizontalPodAutoscalerList {
        /// <summary>
        /// list of horizontal pod autoscaler objects.
        /// </summary>
        public Input<Input<Autoscaling.V1.HorizontalPodAutoscaler>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// specification of a horizontal pod autoscaler.
    /// </summary>
    class HorizontalPodAutoscalerSpec {
        /// <summary>
        /// upper limit for the number of pods that can be set by the autoscaler; cannot be smaller
        /// than MinReplicas.
        /// </summary>
        public Input<int> MaxReplicas { get; set; } = null!;

        /// <summary>
        /// reference to scaled resource; horizontal pod autoscaler will learn the current resource
        /// consumption and will set the desired number of pods by using its Scale subresource.
        /// </summary>
        public Input<Autoscaling.V1.CrossVersionObjectReference> ScaleTargetRef { get; set; } = null!;

        /// <summary>
        /// minReplicas is the lower limit for the number of replicas to which the autoscaler can
        /// scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature
        /// gate HPAScaleToZero is enabled and at least one Object or External metric is configured.
        /// Scaling is active as long as at least one metric value is available.
        /// </summary>
        public Input<int>? MinReplicas { get; set; }

        /// <summary>
        /// target average CPU utilization (represented as a percentage of requested CPU) over all
        /// the pods; if not specified the default autoscaling policy will be used.
        /// </summary>
        public Input<int>? TargetCPUUtilizationPercentage { get; set; }

    }

    /// <summary>
    /// current status of a horizontal pod autoscaler
    /// </summary>
    class HorizontalPodAutoscalerStatus {
        /// <summary>
        /// current number of replicas of pods managed by this autoscaler.
        /// </summary>
        public Input<int> CurrentReplicas { get; set; } = null!;

        /// <summary>
        /// desired number of replicas of pods managed by this autoscaler.
        /// </summary>
        public Input<int> DesiredReplicas { get; set; } = null!;

        /// <summary>
        /// current average CPU utilization over all pods, represented as a percentage of requested
        /// CPU, e.g. 70 means that an average pod is using now 70% of its requested CPU.
        /// </summary>
        public Input<int>? CurrentCPUUtilizationPercentage { get; set; }

        /// <summary>
        /// last time the HorizontalPodAutoscaler scaled the number of pods; used by the autoscaler
        /// to control how often the number of pods is changed.
        /// </summary>
        public Input<string>? LastScaleTime { get; set; }

        /// <summary>
        /// most recent generation observed by this autoscaler.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

    }

    /// <summary>
    /// Scale represents a scaling request for a resource.
    /// </summary>
    class Scale {
        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        public Input<Autoscaling.V1.ScaleSpec>? Spec { get; set; }

    }

    /// <summary>
    /// ScaleSpec describes the attributes of a scale subresource.
    /// </summary>
    class ScaleSpec {
        /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
        public Input<int>? Replicas { get; set; }

    }

    /// <summary>
    /// ScaleStatus represents the current status of a scale subresource.
    /// </summary>
    class ScaleStatus {
        /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// label query over pods that should match the replicas count. This is same as the label
        /// selector but in the string format to avoid introspection by clients. The string will be
        /// in the same format as the query-param syntax. More info about label selectors:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
        public Input<string>? Selector { get; set; }

    }

  }

  namespace V2Beta1 {
    /// <summary>
    /// CrossVersionObjectReference contains enough information to let you identify the referred
    /// resource.
    /// </summary>
    class CrossVersionObjectReference {
        /// <summary>
        /// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes
    /// object (for example length of queue in cloud messaging service, or QPS from loadbalancer
    /// running outside of cluster). Exactly one "target" type should be set.
    /// </summary>
    class ExternalMetricSource {
        /// <summary>
        /// metricName is the name of the metric in question.
        /// </summary>
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// metricSelector is used to identify a specific time series within a given metric.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? MetricSelector { get; set; }

        /// <summary>
        /// targetAverageValue is the target per-pod value of global metric (as a quantity).
        /// Mutually exclusive with TargetValue.
        /// </summary>
        public Input<string>? TargetAverageValue { get; set; }

        /// <summary>
        /// targetValue is the target value of the metric (as a quantity). Mutually exclusive with
        /// TargetAverageValue.
        /// </summary>
        public Input<string>? TargetValue { get; set; }

    }

    /// <summary>
    /// ExternalMetricStatus indicates the current value of a global metric not associated with any
    /// Kubernetes object.
    /// </summary>
    class ExternalMetricStatus {
        /// <summary>
        /// currentValue is the current value of the metric (as a quantity)
        /// </summary>
        public Input<string> CurrentValue { get; set; } = null!;

        /// <summary>
        /// metricName is the name of a metric used for autoscaling in metric system.
        /// </summary>
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// currentAverageValue is the current value of metric averaged over autoscaled pods.
        /// </summary>
        public Input<string>? CurrentAverageValue { get; set; }

        /// <summary>
        /// metricSelector is used to identify a specific time series within a given metric.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? MetricSelector { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which
    /// automatically manages the replica count of any resource implementing the scale subresource
    /// based on the metrics specified.
    /// </summary>
    class HorizontalPodAutoscaler {
        /// <summary>
        /// metadata is the standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// spec is the specification for the behaviour of the autoscaler. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        public Input<Autoscaling.V2Beta1.HorizontalPodAutoscalerSpec>? Spec { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a
    /// certain point.
    /// </summary>
    class HorizontalPodAutoscalerCondition {
        /// <summary>
        /// status is the status of the condition (True, False, Unknown)
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// type describes the current condition
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// lastTransitionTime is the last time the condition transitioned from one status to
        /// another
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// message is a human-readable explanation containing details about the transition
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// reason is the reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects.
    /// </summary>
    class HorizontalPodAutoscalerList {
        /// <summary>
        /// items is the list of horizontal pod autoscaler objects.
        /// </summary>
        public Input<Input<Autoscaling.V2Beta1.HorizontalPodAutoscaler>[]> Items { get; set; } = null!;

        /// <summary>
        /// metadata is the standard list metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerSpec describes the desired functionality of the
    /// HorizontalPodAutoscaler.
    /// </summary>
    class HorizontalPodAutoscalerSpec {
        /// <summary>
        /// maxReplicas is the upper limit for the number of replicas to which the autoscaler can
        /// scale up. It cannot be less that minReplicas.
        /// </summary>
        public Input<int> MaxReplicas { get; set; } = null!;

        /// <summary>
        /// scaleTargetRef points to the target resource to scale, and is used to the pods for which
        /// metrics should be collected, as well as to actually change the replica count.
        /// </summary>
        public Input<Autoscaling.V2Beta1.CrossVersionObjectReference> ScaleTargetRef { get; set; } = null!;

        /// <summary>
        /// metrics contains the specifications for which to use to calculate the desired replica
        /// count (the maximum replica count across all metrics will be used).  The desired replica
        /// count is calculated multiplying the ratio between the target value and the current value
        /// by the current number of pods.  Ergo, metrics used must decrease as the pod count is
        /// increased, and vice-versa.  See the individual metric source types for more information
        /// about how each type of metric must respond.
        /// </summary>
        public Input<Input<Autoscaling.V2Beta1.MetricSpec>[]>? Metrics { get; set; }

        /// <summary>
        /// minReplicas is the lower limit for the number of replicas to which the autoscaler can
        /// scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature
        /// gate HPAScaleToZero is enabled and at least one Object or External metric is configured.
        /// Scaling is active as long as at least one metric value is available.
        /// </summary>
        public Input<int>? MinReplicas { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.
    /// </summary>
    class HorizontalPodAutoscalerStatus {
        /// <summary>
        /// conditions is the set of conditions required for this autoscaler to scale its target,
        /// and indicates whether or not those conditions are met.
        /// </summary>
        public Input<Input<Autoscaling.V2Beta1.HorizontalPodAutoscalerCondition>[]> Conditions { get; set; } = null!;

        /// <summary>
        /// currentReplicas is current number of replicas of pods managed by this autoscaler, as
        /// last seen by the autoscaler.
        /// </summary>
        public Input<int> CurrentReplicas { get; set; } = null!;

        /// <summary>
        /// desiredReplicas is the desired number of replicas of pods managed by this autoscaler, as
        /// last calculated by the autoscaler.
        /// </summary>
        public Input<int> DesiredReplicas { get; set; } = null!;

        /// <summary>
        /// currentMetrics is the last read state of the metrics used by this autoscaler.
        /// </summary>
        public Input<Input<Autoscaling.V2Beta1.MetricStatus>[]>? CurrentMetrics { get; set; }

        /// <summary>
        /// lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods,
        /// used by the autoscaler to control how often the number of pods is changed.
        /// </summary>
        public Input<string>? LastScaleTime { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed by this autoscaler.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

    }

    /// <summary>
    /// MetricSpec specifies how to scale based on a single metric (only `type` and one other
    /// matching field should be set at once).
    /// </summary>
    class MetricSpec {
        /// <summary>
        /// type is the type of metric source.  It should be one of "Object", "Pods" or "Resource",
        /// each mapping to a matching field in the object.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
        public Input<Autoscaling.V2Beta1.ExternalMetricSource>? External { get; set; }

        /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
        public Input<Autoscaling.V2Beta1.ObjectMetricSource>? Object { get; set; }

        /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
        public Input<Autoscaling.V2Beta1.PodsMetricSource>? Pods { get; set; }

        /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
        public Input<Autoscaling.V2Beta1.ResourceMetricSource>? Resource { get; set; }

    }

    /// <summary>
    /// MetricStatus describes the last-read state of a single metric.
    /// </summary>
    class MetricStatus {
        /// <summary>
        /// type is the type of metric source.  It will be one of "Object", "Pods" or "Resource",
        /// each corresponds to a matching field in the object.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
        public Input<Autoscaling.V2Beta1.ExternalMetricStatus>? External { get; set; }

        /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
        public Input<Autoscaling.V2Beta1.ObjectMetricStatus>? Object { get; set; }

        /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
        public Input<Autoscaling.V2Beta1.PodsMetricStatus>? Pods { get; set; }

        /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
        public Input<Autoscaling.V2Beta1.ResourceMetricStatus>? Resource { get; set; }

    }

    /// <summary>
    /// ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for
    /// example, hits-per-second on an Ingress object).
    /// </summary>
    class ObjectMetricSource {
        /// <summary>
        /// metricName is the name of the metric in question.
        /// </summary>
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// target is the described Kubernetes object.
        /// </summary>
        public Input<Autoscaling.V2Beta1.CrossVersionObjectReference> Target { get; set; } = null!;

        /// <summary>
        /// targetValue is the target value of the metric (as a quantity).
        /// </summary>
        public Input<string> TargetValue { get; set; } = null!;

        /// <summary>
        /// averageValue is the target value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
        public Input<string>? AverageValue { get; set; }

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set, it is passed as an additional parameter to the metrics server for
        /// more specific metrics scoping When unset, just the metricName will be used to gather
        /// metrics.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

    }

    /// <summary>
    /// ObjectMetricStatus indicates the current value of a metric describing a kubernetes object
    /// (for example, hits-per-second on an Ingress object).
    /// </summary>
    class ObjectMetricStatus {
        /// <summary>
        /// currentValue is the current value of the metric (as a quantity).
        /// </summary>
        public Input<string> CurrentValue { get; set; } = null!;

        /// <summary>
        /// metricName is the name of the metric in question.
        /// </summary>
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// target is the described Kubernetes object.
        /// </summary>
        public Input<Autoscaling.V2Beta1.CrossVersionObjectReference> Target { get; set; } = null!;

        /// <summary>
        /// averageValue is the current value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
        public Input<string>? AverageValue { get; set; }

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set in the ObjectMetricSource, it is passed as an additional parameter
        /// to the metrics server for more specific metrics scoping. When unset, just the metricName
        /// will be used to gather metrics.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

    }

    /// <summary>
    /// PodsMetricSource indicates how to scale on a metric describing each pod in the current scale
    /// target (for example, transactions-processed-per-second). The values will be averaged
    /// together before being compared to the target value.
    /// </summary>
    class PodsMetricSource {
        /// <summary>
        /// metricName is the name of the metric in question
        /// </summary>
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// targetAverageValue is the target value of the average of the metric across all relevant
        /// pods (as a quantity)
        /// </summary>
        public Input<string> TargetAverageValue { get; set; } = null!;

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set, it is passed as an additional parameter to the metrics server for
        /// more specific metrics scoping When unset, just the metricName will be used to gather
        /// metrics.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

    }

    /// <summary>
    /// PodsMetricStatus indicates the current value of a metric describing each pod in the current
    /// scale target (for example, transactions-processed-per-second).
    /// </summary>
    class PodsMetricStatus {
        /// <summary>
        /// currentAverageValue is the current value of the average of the metric across all
        /// relevant pods (as a quantity)
        /// </summary>
        public Input<string> CurrentAverageValue { get; set; } = null!;

        /// <summary>
        /// metricName is the name of the metric in question
        /// </summary>
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set in the PodsMetricSource, it is passed as an additional parameter
        /// to the metrics server for more specific metrics scoping. When unset, just the metricName
        /// will be used to gather metrics.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

    }

    /// <summary>
    /// ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as
    /// specified in requests and limits, describing each pod in the current scale target (e.g. CPU
    /// or memory).  The values will be averaged together before being compared to the target.  Such
    /// metrics are built in to Kubernetes, and have special scaling options on top of those
    /// available to normal per-pod metrics using the "pods" source.  Only one "target" type should
    /// be set.
    /// </summary>
    class ResourceMetricSource {
        /// <summary>
        /// name is the name of the resource in question.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// targetAverageUtilization is the target value of the average of the resource metric
        /// across all relevant pods, represented as a percentage of the requested value of the
        /// resource for the pods.
        /// </summary>
        public Input<int>? TargetAverageUtilization { get; set; }

        /// <summary>
        /// targetAverageValue is the target value of the average of the resource metric across all
        /// relevant pods, as a raw value (instead of as a percentage of the request), similar to
        /// the "pods" metric source type.
        /// </summary>
        public Input<string>? TargetAverageValue { get; set; }

    }

    /// <summary>
    /// ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes,
    /// as specified in requests and limits, describing each pod in the current scale target (e.g.
    /// CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options
    /// on top of those available to normal per-pod metrics using the "pods" source.
    /// </summary>
    class ResourceMetricStatus {
        /// <summary>
        /// currentAverageValue is the current value of the average of the resource metric across
        /// all relevant pods, as a raw value (instead of as a percentage of the request), similar
        /// to the "pods" metric source type. It will always be set, regardless of the corresponding
        /// metric specification.
        /// </summary>
        public Input<string> CurrentAverageValue { get; set; } = null!;

        /// <summary>
        /// name is the name of the resource in question.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// currentAverageUtilization is the current value of the average of the resource metric
        /// across all relevant pods, represented as a percentage of the requested value of the
        /// resource for the pods.  It will only be present if `targetAverageValue` was set in the
        /// corresponding metric specification.
        /// </summary>
        public Input<int>? CurrentAverageUtilization { get; set; }

    }

  }

  namespace V2Beta2 {
    /// <summary>
    /// CrossVersionObjectReference contains enough information to let you identify the referred
    /// resource.
    /// </summary>
    class CrossVersionObjectReference {
        /// <summary>
        /// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes
    /// object (for example length of queue in cloud messaging service, or QPS from loadbalancer
    /// running outside of cluster).
    /// </summary>
    class ExternalMetricSource {
        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricIdentifier> Metric { get; set; } = null!;

        /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricTarget> Target { get; set; } = null!;

    }

    /// <summary>
    /// ExternalMetricStatus indicates the current value of a global metric not associated with any
    /// Kubernetes object.
    /// </summary>
    class ExternalMetricStatus {
        /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricValueStatus> Current { get; set; } = null!;

        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricIdentifier> Metric { get; set; } = null!;

    }

    /// <summary>
    /// HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which
    /// automatically manages the replica count of any resource implementing the scale subresource
    /// based on the metrics specified.
    /// </summary>
    class HorizontalPodAutoscaler {
        /// <summary>
        /// metadata is the standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// spec is the specification for the behaviour of the autoscaler. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        public Input<Autoscaling.V2Beta2.HorizontalPodAutoscalerSpec>? Spec { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a
    /// certain point.
    /// </summary>
    class HorizontalPodAutoscalerCondition {
        /// <summary>
        /// status is the status of the condition (True, False, Unknown)
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// type describes the current condition
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// lastTransitionTime is the last time the condition transitioned from one status to
        /// another
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// message is a human-readable explanation containing details about the transition
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// reason is the reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects.
    /// </summary>
    class HorizontalPodAutoscalerList {
        /// <summary>
        /// items is the list of horizontal pod autoscaler objects.
        /// </summary>
        public Input<Input<Autoscaling.V2Beta2.HorizontalPodAutoscaler>[]> Items { get; set; } = null!;

        /// <summary>
        /// metadata is the standard list metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerSpec describes the desired functionality of the
    /// HorizontalPodAutoscaler.
    /// </summary>
    class HorizontalPodAutoscalerSpec {
        /// <summary>
        /// maxReplicas is the upper limit for the number of replicas to which the autoscaler can
        /// scale up. It cannot be less that minReplicas.
        /// </summary>
        public Input<int> MaxReplicas { get; set; } = null!;

        /// <summary>
        /// scaleTargetRef points to the target resource to scale, and is used to the pods for which
        /// metrics should be collected, as well as to actually change the replica count.
        /// </summary>
        public Input<Autoscaling.V2Beta2.CrossVersionObjectReference> ScaleTargetRef { get; set; } = null!;

        /// <summary>
        /// metrics contains the specifications for which to use to calculate the desired replica
        /// count (the maximum replica count across all metrics will be used).  The desired replica
        /// count is calculated multiplying the ratio between the target value and the current value
        /// by the current number of pods.  Ergo, metrics used must decrease as the pod count is
        /// increased, and vice-versa.  See the individual metric source types for more information
        /// about how each type of metric must respond. If not set, the default metric will be set
        /// to 80% average CPU utilization.
        /// </summary>
        public Input<Input<Autoscaling.V2Beta2.MetricSpec>[]>? Metrics { get; set; }

        /// <summary>
        /// minReplicas is the lower limit for the number of replicas to which the autoscaler can
        /// scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature
        /// gate HPAScaleToZero is enabled and at least one Object or External metric is configured.
        /// Scaling is active as long as at least one metric value is available.
        /// </summary>
        public Input<int>? MinReplicas { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.
    /// </summary>
    class HorizontalPodAutoscalerStatus {
        /// <summary>
        /// conditions is the set of conditions required for this autoscaler to scale its target,
        /// and indicates whether or not those conditions are met.
        /// </summary>
        public Input<Input<Autoscaling.V2Beta2.HorizontalPodAutoscalerCondition>[]> Conditions { get; set; } = null!;

        /// <summary>
        /// currentReplicas is current number of replicas of pods managed by this autoscaler, as
        /// last seen by the autoscaler.
        /// </summary>
        public Input<int> CurrentReplicas { get; set; } = null!;

        /// <summary>
        /// desiredReplicas is the desired number of replicas of pods managed by this autoscaler, as
        /// last calculated by the autoscaler.
        /// </summary>
        public Input<int> DesiredReplicas { get; set; } = null!;

        /// <summary>
        /// currentMetrics is the last read state of the metrics used by this autoscaler.
        /// </summary>
        public Input<Input<Autoscaling.V2Beta2.MetricStatus>[]>? CurrentMetrics { get; set; }

        /// <summary>
        /// lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods,
        /// used by the autoscaler to control how often the number of pods is changed.
        /// </summary>
        public Input<string>? LastScaleTime { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed by this autoscaler.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

    }

    /// <summary>
    /// MetricIdentifier defines the name and optionally selector for a metric
    /// </summary>
    class MetricIdentifier {
        /// <summary>
        /// name is the name of the given metric
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set, it is passed as an additional parameter to the metrics server for
        /// more specific metrics scoping. When unset, just the metricName will be used to gather
        /// metrics.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

    }

    /// <summary>
    /// MetricSpec specifies how to scale based on a single metric (only `type` and one other
    /// matching field should be set at once).
    /// </summary>
    class MetricSpec {
        /// <summary>
        /// type is the type of metric source.  It should be one of "Object", "Pods" or "Resource",
        /// each mapping to a matching field in the object.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
        public Input<Autoscaling.V2Beta2.ExternalMetricSource>? External { get; set; }

        /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
        public Input<Autoscaling.V2Beta2.ObjectMetricSource>? Object { get; set; }

        /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
        public Input<Autoscaling.V2Beta2.PodsMetricSource>? Pods { get; set; }

        /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
        public Input<Autoscaling.V2Beta2.ResourceMetricSource>? Resource { get; set; }

    }

    /// <summary>
    /// MetricStatus describes the last-read state of a single metric.
    /// </summary>
    class MetricStatus {
        /// <summary>
        /// type is the type of metric source.  It will be one of "Object", "Pods" or "Resource",
        /// each corresponds to a matching field in the object.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
        public Input<Autoscaling.V2Beta2.ExternalMetricStatus>? External { get; set; }

        /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
        public Input<Autoscaling.V2Beta2.ObjectMetricStatus>? Object { get; set; }

        /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
        public Input<Autoscaling.V2Beta2.PodsMetricStatus>? Pods { get; set; }

        /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
        public Input<Autoscaling.V2Beta2.ResourceMetricStatus>? Resource { get; set; }

    }

    /// <summary>
    /// MetricTarget defines the target value, average value, or average utilization of a specific
    /// metric
    /// </summary>
    class MetricTarget {
        /// <summary>
        /// type represents whether the metric type is Utilization, Value, or AverageValue
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// averageUtilization is the target value of the average of the resource metric across all
        /// relevant pods, represented as a percentage of the requested value of the resource for
        /// the pods. Currently only valid for Resource metric source type
        /// </summary>
        public Input<int>? AverageUtilization { get; set; }

        /// <summary>
        /// averageValue is the target value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
        public Input<string>? AverageValue { get; set; }

        /// <summary>
        /// value is the target value of the metric (as a quantity).
        /// </summary>
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// MetricValueStatus holds the current value for a metric
    /// </summary>
    class MetricValueStatus {
        /// <summary>
        /// currentAverageUtilization is the current value of the average of the resource metric
        /// across all relevant pods, represented as a percentage of the requested value of the
        /// resource for the pods.
        /// </summary>
        public Input<int>? AverageUtilization { get; set; }

        /// <summary>
        /// averageValue is the current value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
        public Input<string>? AverageValue { get; set; }

        /// <summary>
        /// value is the current value of the metric (as a quantity).
        /// </summary>
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for
    /// example, hits-per-second on an Ingress object).
    /// </summary>
    class ObjectMetricSource {
        
        public Input<Autoscaling.V2Beta2.CrossVersionObjectReference> DescribedObject { get; set; } = null!;

        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricIdentifier> Metric { get; set; } = null!;

        /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricTarget> Target { get; set; } = null!;

    }

    /// <summary>
    /// ObjectMetricStatus indicates the current value of a metric describing a kubernetes object
    /// (for example, hits-per-second on an Ingress object).
    /// </summary>
    class ObjectMetricStatus {
        /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricValueStatus> Current { get; set; } = null!;

        
        public Input<Autoscaling.V2Beta2.CrossVersionObjectReference> DescribedObject { get; set; } = null!;

        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricIdentifier> Metric { get; set; } = null!;

    }

    /// <summary>
    /// PodsMetricSource indicates how to scale on a metric describing each pod in the current scale
    /// target (for example, transactions-processed-per-second). The values will be averaged
    /// together before being compared to the target value.
    /// </summary>
    class PodsMetricSource {
        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricIdentifier> Metric { get; set; } = null!;

        /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricTarget> Target { get; set; } = null!;

    }

    /// <summary>
    /// PodsMetricStatus indicates the current value of a metric describing each pod in the current
    /// scale target (for example, transactions-processed-per-second).
    /// </summary>
    class PodsMetricStatus {
        /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricValueStatus> Current { get; set; } = null!;

        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricIdentifier> Metric { get; set; } = null!;

    }

    /// <summary>
    /// ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as
    /// specified in requests and limits, describing each pod in the current scale target (e.g. CPU
    /// or memory).  The values will be averaged together before being compared to the target.  Such
    /// metrics are built in to Kubernetes, and have special scaling options on top of those
    /// available to normal per-pod metrics using the "pods" source.  Only one "target" type should
    /// be set.
    /// </summary>
    class ResourceMetricSource {
        /// <summary>
        /// name is the name of the resource in question.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricTarget> Target { get; set; } = null!;

    }

    /// <summary>
    /// ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes,
    /// as specified in requests and limits, describing each pod in the current scale target (e.g.
    /// CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options
    /// on top of those available to normal per-pod metrics using the "pods" source.
    /// </summary>
    class ResourceMetricStatus {
        /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
        public Input<Autoscaling.V2Beta2.MetricValueStatus> Current { get; set; } = null!;

        /// <summary>
        /// Name is the name of the resource in question.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Batch {
  namespace V1 {
    /// <summary>
    /// Job represents the configuration of a single job.
    /// </summary>
    class Job {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of a job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Batch.V1.JobSpec>? Spec { get; set; }

    }

    /// <summary>
    /// JobCondition describes current state of a job.
    /// </summary>
    class JobCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of job condition, Complete or Failed.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition was checked.
        /// </summary>
        public Input<string>? LastProbeTime { get; set; }

        /// <summary>
        /// Last time the condition transit from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human readable message indicating details about last transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// (brief) reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// JobList is a collection of jobs.
    /// </summary>
    class JobList {
        /// <summary>
        /// items is the list of Jobs.
        /// </summary>
        public Input<Input<Batch.V1.Job>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// JobSpec describes how the job execution will look like.
    /// </summary>
    class JobSpec {
        /// <summary>
        /// Describes the pod that will be created when executing a job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// Specifies the duration in seconds relative to the startTime that the job may be active
        /// before the system tries to terminate it; value must be positive integer
        /// </summary>
        public Input<int>? ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// Specifies the number of retries before marking this job failed. Defaults to 6
        /// </summary>
        public Input<int>? BackoffLimit { get; set; }

        /// <summary>
        /// Specifies the desired number of successfully finished pods the job should be run with.
        /// Setting to nil means that the success of any pod signals the success of all pods, and
        /// allows parallelism to have any positive value.  Setting to 1 means that parallelism is
        /// limited to 1 and the success of that pod signals the success of the job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        public Input<int>? Completions { get; set; }

        /// <summary>
        /// manualSelector controls generation of pod labels and pod selectors. Leave
        /// `manualSelector` unset unless you are certain what you are doing. When false or unset,
        /// the system pick labels unique to this job and appends those labels to the pod template.
        /// When true, the user is responsible for picking unique labels and specifying the
        /// selector.  Failure to pick a unique label may cause this and other jobs to not function
        /// correctly.  However, You may see `manualSelector=true` in jobs that were created with
        /// the old `extensions/v1beta1` API. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
        /// </summary>
        public Input<bool>? ManualSelector { get; set; }

        /// <summary>
        /// Specifies the maximum desired number of pods the job should run at any given time. The
        /// actual number of pods running in steady state will be less than this number when
        /// ((.spec.completions - .status.successful) &lt; .spec.parallelism), i.e. when the work
        /// left to do is less than max parallelism. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        public Input<int>? Parallelism { get; set; }

        /// <summary>
        /// A label query over pods that should match the pod count. Normally, the system sets this
        /// field for you. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

        /// <summary>
        /// ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either
        /// Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job
        /// finishes, it is eligible to be automatically deleted. When the Job is being deleted, its
        /// lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job
        /// won't be automatically deleted. If this field is set to zero, the Job becomes eligible
        /// to be deleted immediately after it finishes. This field is alpha-level and is only
        /// honored by servers that enable the TTLAfterFinished feature.
        /// </summary>
        public Input<int>? TtlSecondsAfterFinished { get; set; }

    }

    /// <summary>
    /// JobStatus represents the current state of a Job.
    /// </summary>
    class JobStatus {
        /// <summary>
        /// The number of actively running pods.
        /// </summary>
        public Input<int>? Active { get; set; }

        /// <summary>
        /// Represents time when the job was completed. It is not guaranteed to be set in
        /// happens-before order across separate operations. It is represented in RFC3339 form and
        /// is in UTC.
        /// </summary>
        public Input<string>? CompletionTime { get; set; }

        /// <summary>
        /// The latest available observations of an object's current state. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        public Input<Input<Batch.V1.JobCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The number of pods which reached phase Failed.
        /// </summary>
        public Input<int>? Failed { get; set; }

        /// <summary>
        /// Represents time when the job was acknowledged by the job controller. It is not
        /// guaranteed to be set in happens-before order across separate operations. It is
        /// represented in RFC3339 form and is in UTC.
        /// </summary>
        public Input<string>? StartTime { get; set; }

        /// <summary>
        /// The number of pods which reached phase Succeeded.
        /// </summary>
        public Input<int>? Succeeded { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// CronJob represents the configuration of a single cron job.
    /// </summary>
    class CronJob {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of a cron job, including the schedule. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Batch.V1Beta1.CronJobSpec>? Spec { get; set; }

    }

    /// <summary>
    /// CronJobList is a collection of cron jobs.
    /// </summary>
    class CronJobList {
        /// <summary>
        /// items is the list of CronJobs.
        /// </summary>
        public Input<Input<Batch.V1Beta1.CronJob>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CronJobSpec describes how the job execution will look like and when it will actually run.
    /// </summary>
    class CronJobSpec {
        /// <summary>
        /// Specifies the job that will be created when executing a CronJob.
        /// </summary>
        public Input<Batch.V1Beta1.JobTemplateSpec> JobTemplate { get; set; } = null!;

        /// <summary>
        /// The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
        /// </summary>
        public Input<string> Schedule { get; set; } = null!;

        /// <summary>
        /// Specifies how to treat concurrent executions of a Job. Valid values are: - "Allow"
        /// (default): allows CronJobs to run concurrently; - "Forbid": forbids concurrent runs,
        /// skipping next run if previous run hasn't finished yet; - "Replace": cancels currently
        /// running job and replaces it with a new one
        /// </summary>
        public Input<string>? ConcurrencyPolicy { get; set; }

        /// <summary>
        /// The number of failed finished jobs to retain. This is a pointer to distinguish between
        /// explicit zero and not specified. Defaults to 1.
        /// </summary>
        public Input<int>? FailedJobsHistoryLimit { get; set; }

        /// <summary>
        /// Optional deadline in seconds for starting the job if it misses scheduled time for any
        /// reason.  Missed jobs executions will be counted as failed ones.
        /// </summary>
        public Input<int>? StartingDeadlineSeconds { get; set; }

        /// <summary>
        /// The number of successful finished jobs to retain. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 3.
        /// </summary>
        public Input<int>? SuccessfulJobsHistoryLimit { get; set; }

        /// <summary>
        /// This flag tells the controller to suspend subsequent executions, it does not apply to
        /// already started executions.  Defaults to false.
        /// </summary>
        public Input<bool>? Suspend { get; set; }

    }

    /// <summary>
    /// CronJobStatus represents the current state of a cron job.
    /// </summary>
    class CronJobStatus {
        /// <summary>
        /// A list of pointers to currently running jobs.
        /// </summary>
        public Input<Input<Core.V1.ObjectReference>[]>? Active { get; set; }

        /// <summary>
        /// Information when was the last time the job was successfully scheduled.
        /// </summary>
        public Input<string>? LastScheduleTime { get; set; }

    }

    /// <summary>
    /// JobTemplateSpec describes the data a Job should have when created from a template
    /// </summary>
    class JobTemplateSpec {
        /// <summary>
        /// Standard object's metadata of the jobs created from this template. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Batch.V1.JobSpec>? Spec { get; set; }

    }

  }

  namespace V2Alpha1 {
    /// <summary>
    /// CronJob represents the configuration of a single cron job.
    /// </summary>
    class CronJob {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of a cron job, including the schedule. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Batch.V2Alpha1.CronJobSpec>? Spec { get; set; }

    }

    /// <summary>
    /// CronJobList is a collection of cron jobs.
    /// </summary>
    class CronJobList {
        /// <summary>
        /// items is the list of CronJobs.
        /// </summary>
        public Input<Input<Batch.V2Alpha1.CronJob>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CronJobSpec describes how the job execution will look like and when it will actually run.
    /// </summary>
    class CronJobSpec {
        /// <summary>
        /// Specifies the job that will be created when executing a CronJob.
        /// </summary>
        public Input<Batch.V2Alpha1.JobTemplateSpec> JobTemplate { get; set; } = null!;

        /// <summary>
        /// The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
        /// </summary>
        public Input<string> Schedule { get; set; } = null!;

        /// <summary>
        /// Specifies how to treat concurrent executions of a Job. Valid values are: - "Allow"
        /// (default): allows CronJobs to run concurrently; - "Forbid": forbids concurrent runs,
        /// skipping next run if previous run hasn't finished yet; - "Replace": cancels currently
        /// running job and replaces it with a new one
        /// </summary>
        public Input<string>? ConcurrencyPolicy { get; set; }

        /// <summary>
        /// The number of failed finished jobs to retain. This is a pointer to distinguish between
        /// explicit zero and not specified.
        /// </summary>
        public Input<int>? FailedJobsHistoryLimit { get; set; }

        /// <summary>
        /// Optional deadline in seconds for starting the job if it misses scheduled time for any
        /// reason.  Missed jobs executions will be counted as failed ones.
        /// </summary>
        public Input<int>? StartingDeadlineSeconds { get; set; }

        /// <summary>
        /// The number of successful finished jobs to retain. This is a pointer to distinguish
        /// between explicit zero and not specified.
        /// </summary>
        public Input<int>? SuccessfulJobsHistoryLimit { get; set; }

        /// <summary>
        /// This flag tells the controller to suspend subsequent executions, it does not apply to
        /// already started executions.  Defaults to false.
        /// </summary>
        public Input<bool>? Suspend { get; set; }

    }

    /// <summary>
    /// CronJobStatus represents the current state of a cron job.
    /// </summary>
    class CronJobStatus {
        /// <summary>
        /// A list of pointers to currently running jobs.
        /// </summary>
        public Input<Input<Core.V1.ObjectReference>[]>? Active { get; set; }

        /// <summary>
        /// Information when was the last time the job was successfully scheduled.
        /// </summary>
        public Input<string>? LastScheduleTime { get; set; }

    }

    /// <summary>
    /// JobTemplateSpec describes the data a Job should have when created from a template
    /// </summary>
    class JobTemplateSpec {
        /// <summary>
        /// Standard object's metadata of the jobs created from this template. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Batch.V1.JobSpec>? Spec { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Certificates {
  namespace V1Beta1 {
    /// <summary>
    /// Describes a certificate signing request
    /// </summary>
    class CertificateSigningRequest {
        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// The certificate request itself and any additional information.
        /// </summary>
        public Input<Certificates.V1Beta1.CertificateSigningRequestSpec>? Spec { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    class CertificateSigningRequestCondition {
        /// <summary>
        /// request approval state, currently Approved or Denied.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// timestamp for the last update to this condition
        /// </summary>
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// human readable message with details about the request state
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// brief reason for the request state
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    class CertificateSigningRequestList {
        
        public Input<Input<Certificates.V1Beta1.CertificateSigningRequest>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// This information is immutable after the request is created. Only the Request and Usages
    /// fields can be set on creation, other fields are derived by Kubernetes and cannot be modified
    /// by users.
    /// </summary>
    class CertificateSigningRequestSpec {
        /// <summary>
        /// Base64-encoded PKCS#10 CSR data
        /// </summary>
        public Input<string> Request { get; set; } = null!;

        /// <summary>
        /// Extra information about the requesting user. See user.Info interface for details.
        /// </summary>
        public Input<object>? Extra { get; set; }

        /// <summary>
        /// Group information about the requesting user. See user.Info interface for details.
        /// </summary>
        public Input<Input<string>[]>? Groups { get; set; }

        /// <summary>
        /// UID information about the requesting user. See user.Info interface for details.
        /// </summary>
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// allowedUsages specifies a set of usage contexts the key will be valid for. See:
        /// https://tools.ietf.org/html/rfc5280#section-4.2.1.3
        ///      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
        /// </summary>
        public Input<Input<string>[]>? Usages { get; set; }

        /// <summary>
        /// Information about the requesting user. See user.Info interface for details.
        /// </summary>
        public Input<string>? Username { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    class CertificateSigningRequestStatus {
        /// <summary>
        /// If request was approved, the controller will place the issued certificate here.
        /// </summary>
        public Input<string>? Certificate { get; set; }

        /// <summary>
        /// Conditions applied to the request, such as approval or denial.
        /// </summary>
        public Input<Input<Certificates.V1Beta1.CertificateSigningRequestCondition>[]>? Conditions { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Coordination {
  namespace V1 {
    /// <summary>
    /// Lease defines a lease concept.
    /// </summary>
    class Lease {
        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the Lease. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Coordination.V1.LeaseSpec>? Spec { get; set; }

    }

    /// <summary>
    /// LeaseList is a list of Lease objects.
    /// </summary>
    class LeaseList {
        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public Input<Input<Coordination.V1.Lease>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// LeaseSpec is a specification of a Lease.
    /// </summary>
    class LeaseSpec {
        /// <summary>
        /// acquireTime is a time when the current lease was acquired.
        /// </summary>
        public Input<string>? AcquireTime { get; set; }

        /// <summary>
        /// holderIdentity contains the identity of the holder of a current lease.
        /// </summary>
        public Input<string>? HolderIdentity { get; set; }

        /// <summary>
        /// leaseDurationSeconds is a duration that candidates for a lease need to wait to force
        /// acquire it. This is measure against time of last observed RenewTime.
        /// </summary>
        public Input<int>? LeaseDurationSeconds { get; set; }

        /// <summary>
        /// leaseTransitions is the number of transitions of a lease between holders.
        /// </summary>
        public Input<int>? LeaseTransitions { get; set; }

        /// <summary>
        /// renewTime is a time when the current holder of a lease has last updated the lease.
        /// </summary>
        public Input<string>? RenewTime { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// Lease defines a lease concept.
    /// </summary>
    class Lease {
        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the Lease. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Coordination.V1Beta1.LeaseSpec>? Spec { get; set; }

    }

    /// <summary>
    /// LeaseList is a list of Lease objects.
    /// </summary>
    class LeaseList {
        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public Input<Input<Coordination.V1Beta1.Lease>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// LeaseSpec is a specification of a Lease.
    /// </summary>
    class LeaseSpec {
        /// <summary>
        /// acquireTime is a time when the current lease was acquired.
        /// </summary>
        public Input<string>? AcquireTime { get; set; }

        /// <summary>
        /// holderIdentity contains the identity of the holder of a current lease.
        /// </summary>
        public Input<string>? HolderIdentity { get; set; }

        /// <summary>
        /// leaseDurationSeconds is a duration that candidates for a lease need to wait to force
        /// acquire it. This is measure against time of last observed RenewTime.
        /// </summary>
        public Input<int>? LeaseDurationSeconds { get; set; }

        /// <summary>
        /// leaseTransitions is the number of transitions of a lease between holders.
        /// </summary>
        public Input<int>? LeaseTransitions { get; set; }

        /// <summary>
        /// renewTime is a time when the current holder of a lease has last updated the lease.
        /// </summary>
        public Input<string>? RenewTime { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Core {
  namespace V1 {
    /// <summary>
    /// Represents a Persistent Disk resource in AWS.
    /// 
    /// An AWS EBS disk must exist before mounting to a container. The disk must also be in the same
    /// AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS
    /// volumes support ownership management and SELinux relabeling.
    /// </summary>
    class AWSElasticBlockStoreVolumeSource {
        /// <summary>
        /// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        public Input<string> VolumeID { get; set; } = null!;

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// The partition in the volume that you want to mount. If omitted, the default is to mount
        /// by volume name. Examples: For volume /dev/sda1, you specify the partition as "1".
        /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property
        /// empty).
        /// </summary>
        public Input<int>? Partition { get; set; }

        /// <summary>
        /// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If
        /// omitted, the default is "false". More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Affinity is a group of affinity scheduling rules.
    /// </summary>
    class Affinity {
        /// <summary>
        /// Describes node affinity scheduling rules for the pod.
        /// </summary>
        public Input<Core.V1.NodeAffinity>? NodeAffinity { get; set; }

        /// <summary>
        /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
        /// etc. as some other pod(s)).
        /// </summary>
        public Input<Core.V1.PodAffinity>? PodAffinity { get; set; }

        /// <summary>
        /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same
        /// node, zone, etc. as some other pod(s)).
        /// </summary>
        public Input<Core.V1.PodAntiAffinity>? PodAntiAffinity { get; set; }

    }

    /// <summary>
    /// AttachedVolume describes a volume attached to a node
    /// </summary>
    class AttachedVolume {
        /// <summary>
        /// DevicePath represents the device path where the volume should be available
        /// </summary>
        public Input<string> DevicePath { get; set; } = null!;

        /// <summary>
        /// Name of the attached volume
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// </summary>
    class AzureDiskVolumeSource {
        /// <summary>
        /// The Name of the data disk in the blob storage
        /// </summary>
        public Input<string> DiskName { get; set; } = null!;

        /// <summary>
        /// The URI the data disk in the blob storage
        /// </summary>
        public Input<string> DiskURI { get; set; } = null!;

        /// <summary>
        /// Host Caching mode: None, Read Only, Read Write.
        /// </summary>
        public Input<string>? CachingMode { get; set; }

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// </summary>
    class AzureFilePersistentVolumeSource {
        /// <summary>
        /// the name of secret that contains Azure Storage Account Name and Key
        /// </summary>
        public Input<string> SecretName { get; set; } = null!;

        /// <summary>
        /// Share Name
        /// </summary>
        public Input<string> ShareName { get; set; } = null!;

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// the namespace of the secret that contains Azure Storage Account Name and Key default is
        /// the same as the Pod
        /// </summary>
        public Input<string>? SecretNamespace { get; set; }

    }

    /// <summary>
    /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// </summary>
    class AzureFileVolumeSource {
        /// <summary>
        /// the name of secret that contains Azure Storage Account Name and Key
        /// </summary>
        public Input<string> SecretName { get; set; } = null!;

        /// <summary>
        /// Share Name
        /// </summary>
        public Input<string> ShareName { get; set; } = null!;

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
    /// Deprecated in 1.7, please use the bindings subresource of pods instead.
    /// </summary>
    class Binding {
        /// <summary>
        /// The target object that you want to bind to the standard object.
        /// </summary>
        public Input<Core.V1.ObjectReference> Target { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// Represents storage that is managed by an external CSI volume driver (Beta feature)
    /// </summary>
    class CSIPersistentVolumeSource {
        /// <summary>
        /// Driver is the name of the driver to use for this volume. Required.
        /// </summary>
        public Input<string> Driver { get; set; } = null!;

        /// <summary>
        /// VolumeHandle is the unique volume name returned by the CSI volume plugin’s
        /// CreateVolume to refer to the volume on all subsequent calls. Required.
        /// </summary>
        public Input<string> VolumeHandle { get; set; } = null!;

        /// <summary>
        /// ControllerExpandSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI ControllerExpandVolume call.
        /// This is an alpha field and requires enabling ExpandCSIVolumes feature gate. This field
        /// is optional, and may be empty if no secret is required. If the secret object contains
        /// more than one secret, all secrets are passed.
        /// </summary>
        public Input<Core.V1.SecretReference>? ControllerExpandSecretRef { get; set; }

        /// <summary>
        /// ControllerPublishSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI ControllerPublishVolume and
        /// ControllerUnpublishVolume calls. This field is optional, and may be empty if no secret
        /// is required. If the secret object contains more than one secret, all secrets are passed.
        /// </summary>
        public Input<Core.V1.SecretReference>? ControllerPublishSecretRef { get; set; }

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs".
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// NodePublishSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI NodePublishVolume and
        /// NodeUnpublishVolume calls. This field is optional, and may be empty if no secret is
        /// required. If the secret object contains more than one secret, all secrets are passed.
        /// </summary>
        public Input<Core.V1.SecretReference>? NodePublishSecretRef { get; set; }

        /// <summary>
        /// NodeStageSecretRef is a reference to the secret object containing sensitive information
        /// to pass to the CSI driver to complete the CSI NodeStageVolume and NodeStageVolume and
        /// NodeUnstageVolume calls. This field is optional, and may be empty if no secret is
        /// required. If the secret object contains more than one secret, all secrets are passed.
        /// </summary>
        public Input<Core.V1.SecretReference>? NodeStageSecretRef { get; set; }

        /// <summary>
        /// Optional: The value to pass to ControllerPublishVolumeRequest. Defaults to false
        /// (read/write).
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Attributes of the volume to publish.
        /// </summary>
        public InputMap<string>? VolumeAttributes { get; set; }

    }

    /// <summary>
    /// Represents a source location of a volume to mount, managed by an external CSI driver
    /// </summary>
    class CSIVolumeSource {
        /// <summary>
        /// Driver is the name of the CSI driver that handles this volume. Consult with your admin
        /// for the correct name as registered in the cluster.
        /// </summary>
        public Input<string> Driver { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is
        /// passed to the associated CSI driver which will determine the default filesystem to
        /// apply.
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// NodePublishSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI NodePublishVolume and
        /// NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is
        /// required. If the secret object contains more than one secret, all secret references are
        /// passed.
        /// </summary>
        public Input<Core.V1.LocalObjectReference>? NodePublishSecretRef { get; set; }

        /// <summary>
        /// Specifies a read-only configuration for the volume. Defaults to false (read/write).
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// VolumeAttributes stores driver-specific properties that are passed to the CSI driver.
        /// Consult your driver's documentation for supported values.
        /// </summary>
        public InputMap<string>? VolumeAttributes { get; set; }

    }

    /// <summary>
    /// Adds and removes POSIX capabilities from running containers.
    /// </summary>
    class Capabilities {
        /// <summary>
        /// Added capabilities
        /// </summary>
        public Input<Input<string>[]>? Add { get; set; }

        /// <summary>
        /// Removed capabilities
        /// </summary>
        public Input<Input<string>[]>? Drop { get; set; }

    }

    /// <summary>
    /// Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    class CephFSPersistentVolumeSource {
        /// <summary>
        /// Required: Monitors is a collection of Ceph monitors More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<Input<string>[]> Monitors { get; set; } = null!;

        /// <summary>
        /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<string>? SecretFile { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the authentication secret for User, default is
        /// empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<Core.V1.SecretReference>? SecretRef { get; set; }

        /// <summary>
        /// Optional: User is the rados user name, default is admin More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    class CephFSVolumeSource {
        /// <summary>
        /// Required: Monitors is a collection of Ceph monitors More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<Input<string>[]> Monitors { get; set; } = null!;

        /// <summary>
        /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<string>? SecretFile { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the authentication secret for User, default is
        /// empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<Core.V1.LocalObjectReference>? SecretRef { get; set; }

        /// <summary>
        /// Optional: User is the rados user name, default is admin More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting
    /// to a container. The volume must also be in the same region as the kubelet. Cinder volumes
    /// support ownership management and SELinux relabeling.
    /// </summary>
    class CinderPersistentVolumeSource {
        /// <summary>
        /// volume id used to identify the volume in cinder. More info:
        /// https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        public Input<string> VolumeID { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
        /// unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: points to a secret object containing parameters used to connect to OpenStack.
        /// </summary>
        public Input<Core.V1.SecretReference>? SecretRef { get; set; }

    }

    /// <summary>
    /// Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting
    /// to a container. The volume must also be in the same region as the kubelet. Cinder volumes
    /// support ownership management and SELinux relabeling.
    /// </summary>
    class CinderVolumeSource {
        /// <summary>
        /// volume id used to identify the volume in cinder. More info:
        /// https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        public Input<string> VolumeID { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
        /// unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: points to a secret object containing parameters used to connect to OpenStack.
        /// </summary>
        public Input<Core.V1.LocalObjectReference>? SecretRef { get; set; }

    }

    /// <summary>
    /// ClientIPConfig represents the configurations of Client IP based session affinity.
    /// </summary>
    class ClientIPConfig {
        /// <summary>
        /// timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value
        /// must be &gt;0 && &lt;=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value
        /// is 10800(for 3 hours).
        /// </summary>
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// Information about the condition of a component.
    /// </summary>
    class ComponentCondition {
        /// <summary>
        /// Status of the condition for a component. Valid values for "Healthy": "True", "False", or
        /// "Unknown".
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of condition for a component. Valid value: "Healthy"
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Condition error code for a component. For example, a health check error code.
        /// </summary>
        public Input<string>? Error { get; set; }

        /// <summary>
        /// Message about the condition for a component. For example, information about a health
        /// check.
        /// </summary>
        public Input<string>? Message { get; set; }

    }

    /// <summary>
    /// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
    /// </summary>
    class ComponentStatus {
        /// <summary>
        /// List of component conditions observed
        /// </summary>
        public Input<Input<Core.V1.ComponentCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// Status of all the conditions for the component as a list of ComponentStatus objects.
    /// </summary>
    class ComponentStatusList {
        /// <summary>
        /// List of ComponentStatus objects.
        /// </summary>
        public Input<Input<Core.V1.ComponentStatus>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ConfigMap holds configuration data for pods to consume.
    /// </summary>
    class ConfigMap {
        /// <summary>
        /// BinaryData contains the binary data. Each key must consist of alphanumeric characters,
        /// '-', '_' or '.'. BinaryData can contain byte sequences that are not in the UTF-8 range.
        /// The keys stored in BinaryData must not overlap with the ones in the Data field, this is
        /// enforced during validation process. Using this field will require 1.10+ apiserver and
        /// kubelet.
        /// </summary>
        public Input<object>? BinaryData { get; set; }

        /// <summary>
        /// Data contains the configuration data. Each key must consist of alphanumeric characters,
        /// '-', '_' or '.'. Values with non-UTF-8 byte sequences must use the BinaryData field. The
        /// keys stored in Data must not overlap with the keys in the BinaryData field, this is
        /// enforced during validation process.
        /// </summary>
        public InputMap<string>? Data { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.
    /// 
    /// The contents of the target ConfigMap's Data field will represent the key-value pairs as
    /// environment variables.
    /// </summary>
    class ConfigMapEnvSource {
        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap must be defined
        /// </summary>
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// Selects a key from a ConfigMap.
    /// </summary>
    class ConfigMapKeySelector {
        /// <summary>
        /// The key to select.
        /// </summary>
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap or its key must be defined
        /// </summary>
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// ConfigMapList is a resource containing a list of ConfigMap objects.
    /// </summary>
    class ConfigMapList {
        /// <summary>
        /// Items is the list of ConfigMaps.
        /// </summary>
        public Input<Input<Core.V1.ConfigMap>[]> Items { get; set; } = null!;

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config
    /// source for the Node.
    /// </summary>
    class ConfigMapNodeConfigSource {
        /// <summary>
        /// KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the
        /// KubeletConfiguration structure This field is required in all cases.
        /// </summary>
        public Input<string> KubeletConfigKey { get; set; } = null!;

        /// <summary>
        /// Name is the metadata.name of the referenced ConfigMap. This field is required in all
        /// cases.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Namespace is the metadata.namespace of the referenced ConfigMap. This field is required
        /// in all cases.
        /// </summary>
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap. This field
        /// is forbidden in Node.Spec, and required in Node.Status.
        /// </summary>
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// UID is the metadata.UID of the referenced ConfigMap. This field is forbidden in
        /// Node.Spec, and required in Node.Status.
        /// </summary>
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// Adapts a ConfigMap into a projected volume.
    /// 
    /// The contents of the target ConfigMap's Data field will be presented in a projected volume as
    /// files using the keys in the Data field as the file names, unless the items element is
    /// populated with specific mappings of keys to paths. Note that this is identical to a
    /// configmap volume source without the default mode.
    /// </summary>
    class ConfigMapProjection {
        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will
        /// be projected into the volume as a file whose name is the key and content is the value.
        /// If specified, the listed keys will be projected into the specified paths, and unlisted
        /// keys will not be present. If a key is specified which is not present in the ConfigMap,
        /// the volume setup will error unless it is marked optional. Paths must be relative and may
        /// not contain the '..' path or start with '..'.
        /// </summary>
        public Input<Input<Core.V1.KeyToPath>[]>? Items { get; set; }

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap or its keys must be defined
        /// </summary>
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// Adapts a ConfigMap into a volume.
    /// 
    /// The contents of the target ConfigMap's Data field will be presented in a volume as files
    /// using the keys in the Data field as the file names, unless the items element is populated
    /// with specific mappings of keys to paths. ConfigMap volumes support ownership management and
    /// SELinux relabeling.
    /// </summary>
    class ConfigMapVolumeSource {
        /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a value between 0 and
        /// 0777. Defaults to 0644. Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file mode, like fsGroup,
        /// and the result can be other mode bits set.
        /// </summary>
        public Input<int>? DefaultMode { get; set; }

        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will
        /// be projected into the volume as a file whose name is the key and content is the value.
        /// If specified, the listed keys will be projected into the specified paths, and unlisted
        /// keys will not be present. If a key is specified which is not present in the ConfigMap,
        /// the volume setup will error unless it is marked optional. Paths must be relative and may
        /// not contain the '..' path or start with '..'.
        /// </summary>
        public Input<Input<Core.V1.KeyToPath>[]>? Items { get; set; }

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap or its keys must be defined
        /// </summary>
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// A single application container that you want to run within a pod.
    /// </summary>
    class Container {
        /// <summary>
        /// Name of the container specified as a DNS_LABEL. Each container in a pod must have a
        /// unique name (DNS_LABEL). Cannot be updated.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a
        /// variable cannot be resolved, the reference in the input string will be unchanged. The
        /// $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references
        /// will never be expanded, regardless of whether the variable exists or not. Cannot be
        /// updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        public Input<Input<string>[]>? Args { get; set; }

        /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if
        /// this is not provided. Variable references $(VAR_NAME) are expanded using the container's
        /// environment. If a variable cannot be resolved, the reference in the input string will be
        /// unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
        /// Escaped references will never be expanded, regardless of whether the variable exists or
        /// not. Cannot be updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        public Input<Input<string>[]>? Command { get; set; }

        /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
        public Input<Input<Core.V1.EnvVar>[]>? Env { get; set; }

        /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined
        /// within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event
        /// when the container is starting. When a key exists in multiple sources, the value
        /// associated with the last source will take precedence. Values defined by an Env with a
        /// duplicate key will take precedence. Cannot be updated.
        /// </summary>
        public Input<Input<Core.V1.EnvFromSource>[]>? EnvFrom { get; set; }

        /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This
        /// field is optional to allow higher level config management to default or override
        /// container images in workload controllers like Deployments and StatefulSets.
        /// </summary>
        public Input<string>? Image { get; set; }

        /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag
        /// is specified, or IfNotPresent otherwise. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
        public Input<string>? ImagePullPolicy { get; set; }

        /// <summary>
        /// Actions that the management system should take in response to container lifecycle
        /// events. Cannot be updated.
        /// </summary>
        public Input<Core.V1.Lifecycle>? Lifecycle { get; set; }

        /// <summary>
        /// Periodic probe of container liveness. Container will be restarted if the probe fails.
        /// Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        public Input<Core.V1.Probe>? LivenessProbe { get; set; }

        /// <summary>
        /// List of ports to expose from the container. Exposing a port here gives the system
        /// additional information about the network connections a container uses, but is primarily
        /// informational. Not specifying a port here DOES NOT prevent that port from being exposed.
        /// Any port which is listening on the default "0.0.0.0" address inside a container will be
        /// accessible from the network. Cannot be updated.
        /// </summary>
        public Input<Input<Core.V1.ContainerPort>[]>? Ports { get; set; }

        /// <summary>
        /// Periodic probe of container service readiness. Container will be removed from service
        /// endpoints if the probe fails. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        public Input<Core.V1.Probe>? ReadinessProbe { get; set; }

        /// <summary>
        /// Compute Resources required by this container. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
        public Input<Core.V1.ResourceRequirements>? Resources { get; set; }

        /// <summary>
        /// Security options the pod should run with. More info:
        /// https://kubernetes.io/docs/concepts/policy/security-context/ More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        public Input<Core.V1.SecurityContext>? SecurityContext { get; set; }

        /// <summary>
        /// StartupProbe indicates that the Pod has successfully initialized. If specified, no other
        /// probes are executed until this completes successfully. If this probe fails, the Pod will
        /// be restarted, just as if the livenessProbe failed. This can be used to provide different
        /// probe parameters at the beginning of a Pod's lifecycle, when it might take a long time
        /// to load data or warm a cache, than during steady-state operation. This cannot be
        /// updated. This is an alpha feature enabled by the StartupProbe feature flag. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        public Input<Core.V1.Probe>? StartupProbe { get; set; }

        /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If
        /// this is not set, reads from stdin in the container will always result in EOF. Default is
        /// false.
        /// </summary>
        public Input<bool>? Stdin { get; set; }

        /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by
        /// a single attach. When stdin is true the stdin stream will remain open across multiple
        /// attach sessions. If stdinOnce is set to true, stdin is opened on container start, is
        /// empty until the first client attaches to stdin, and then remains open and accepts data
        /// until the client disconnects, at which time stdin is closed and remains closed until the
        /// container is restarted. If this flag is false, a container processes that reads from
        /// stdin will never receive an EOF. Default is false
        /// </summary>
        public Input<bool>? StdinOnce { get; set; }

        /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be
        /// written is mounted into the container's filesystem. Message written is intended to be
        /// brief final status, such as an assertion failure message. Will be truncated by the node
        /// if greater than 4096 bytes. The total message length across all containers will be
        /// limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
        public Input<string>? TerminationMessagePath { get; set; }

        /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of
        /// terminationMessagePath to populate the container status message on both success and
        /// failure. FallbackToLogsOnError will use the last chunk of container log output if the
        /// termination message file is empty and the container exited with an error. The log output
        /// is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be
        /// updated.
        /// </summary>
        public Input<string>? TerminationMessagePolicy { get; set; }

        /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be
        /// true. Default is false.
        /// </summary>
        public Input<bool>? Tty { get; set; }

        /// <summary>
        /// volumeDevices is the list of block devices to be used by the container. This is a beta
        /// feature.
        /// </summary>
        public Input<Input<Core.V1.VolumeDevice>[]>? VolumeDevices { get; set; }

        /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
        public Input<Input<Core.V1.VolumeMount>[]>? VolumeMounts { get; set; }

        /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be
        /// used, which might be configured in the container image. Cannot be updated.
        /// </summary>
        public Input<string>? WorkingDir { get; set; }

    }

    /// <summary>
    /// Describe a container image
    /// </summary>
    class ContainerImage {
        /// <summary>
        /// Names by which this image is known. e.g. ["k8s.gcr.io/hyperkube:v1.0.7",
        /// "dockerhub.io/google_containers/hyperkube:v1.0.7"]
        /// </summary>
        public Input<Input<string>[]> Names { get; set; } = null!;

        /// <summary>
        /// The size of the image in bytes.
        /// </summary>
        public Input<int>? SizeBytes { get; set; }

    }

    /// <summary>
    /// ContainerPort represents a network port in a single container.
    /// </summary>
    class ContainerPort {
        /// <summary>
        /// Number of port to expose on the pod's IP address. This must be a valid port number, 0
        /// &lt; x &lt; 65536.
        /// </summary>
        public Input<int> ContainerPort { get; set; } = null!;

        /// <summary>
        /// What host IP to bind the external port to.
        /// </summary>
        public Input<string>? HostIP { get; set; }

        /// <summary>
        /// Number of port to expose on the host. If specified, this must be a valid port number, 0
        /// &lt; x &lt; 65536. If HostNetwork is specified, this must match ContainerPort. Most
        /// containers do not need this.
        /// </summary>
        public Input<int>? HostPort { get; set; }

        /// <summary>
        /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port
        /// in a pod must have a unique name. Name for the port that can be referred to by services.
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
        /// </summary>
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// ContainerState holds a possible state of container. Only one of its members may be
    /// specified. If none of them is specified, the default one is ContainerStateWaiting.
    /// </summary>
    class ContainerState {
        /// <summary>
        /// Details about a running container
        /// </summary>
        public Input<Core.V1.ContainerStateRunning>? Running { get; set; }

        /// <summary>
        /// Details about a terminated container
        /// </summary>
        public Input<Core.V1.ContainerStateTerminated>? Terminated { get; set; }

        /// <summary>
        /// Details about a waiting container
        /// </summary>
        public Input<Core.V1.ContainerStateWaiting>? Waiting { get; set; }

    }

    /// <summary>
    /// ContainerStateRunning is a running state of a container.
    /// </summary>
    class ContainerStateRunning {
        /// <summary>
        /// Time at which the container was last (re-)started
        /// </summary>
        public Input<string>? StartedAt { get; set; }

    }

    /// <summary>
    /// ContainerStateTerminated is a terminated state of a container.
    /// </summary>
    class ContainerStateTerminated {
        /// <summary>
        /// Exit status from the last termination of the container
        /// </summary>
        public Input<int> ExitCode { get; set; } = null!;

        /// <summary>
        /// Container's ID in the format 'docker://&lt;container_id&gt;'
        /// </summary>
        public Input<string>? ContainerID { get; set; }

        /// <summary>
        /// Time at which the container last terminated
        /// </summary>
        public Input<string>? FinishedAt { get; set; }

        /// <summary>
        /// Message regarding the last termination of the container
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// (brief) reason from the last termination of the container
        /// </summary>
        public Input<string>? Reason { get; set; }

        /// <summary>
        /// Signal from the last termination of the container
        /// </summary>
        public Input<int>? Signal { get; set; }

        /// <summary>
        /// Time at which previous execution of the container started
        /// </summary>
        public Input<string>? StartedAt { get; set; }

    }

    /// <summary>
    /// ContainerStateWaiting is a waiting state of a container.
    /// </summary>
    class ContainerStateWaiting {
        /// <summary>
        /// Message regarding why the container is not yet running.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// (brief) reason the container is not yet running.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ContainerStatus contains details for the current status of this container.
    /// </summary>
    class ContainerStatus {
        /// <summary>
        /// The image the container is running. More info:
        /// https://kubernetes.io/docs/concepts/containers/images
        /// </summary>
        public Input<string> Image { get; set; } = null!;

        /// <summary>
        /// ImageID of the container's image.
        /// </summary>
        public Input<string> ImageID { get; set; } = null!;

        /// <summary>
        /// This must be a DNS_LABEL. Each container in a pod must have a unique name. Cannot be
        /// updated.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Specifies whether the container has passed its readiness probe.
        /// </summary>
        public Input<bool> Ready { get; set; } = null!;

        /// <summary>
        /// The number of times the container has been restarted, currently based on the number of
        /// dead containers that have not yet been removed. Note that this is calculated from dead
        /// containers. But those containers are subject to garbage collection. This value will get
        /// capped at 5 by GC.
        /// </summary>
        public Input<int> RestartCount { get; set; } = null!;

        /// <summary>
        /// Container's ID in the format 'docker://&lt;container_id&gt;'.
        /// </summary>
        public Input<string>? ContainerID { get; set; }

        /// <summary>
        /// Details about the container's last termination condition.
        /// </summary>
        public Input<Core.V1.ContainerState>? LastState { get; set; }

        /// <summary>
        /// Specifies whether the container has passed its startup probe. Initialized as false,
        /// becomes true after startupProbe is considered successful. Resets to false when the
        /// container is restarted, or if kubelet loses state temporarily. Is always true when no
        /// startupProbe is defined.
        /// </summary>
        public Input<bool>? Started { get; set; }

        /// <summary>
        /// Details about the container's current condition.
        /// </summary>
        public Input<Core.V1.ContainerState>? State { get; set; }

    }

    /// <summary>
    /// DaemonEndpoint contains information about a single Daemon endpoint.
    /// </summary>
    class DaemonEndpoint {
        /// <summary>
        /// Port number of the given endpoint.
        /// </summary>
        public Input<int> Port { get; set; } = null!;

    }

    /// <summary>
    /// Represents downward API info for projecting into a projected volume. Note that this is
    /// identical to a downwardAPI volume source without the default mode.
    /// </summary>
    class DownwardAPIProjection {
        /// <summary>
        /// Items is a list of DownwardAPIVolume file
        /// </summary>
        public Input<Input<Core.V1.DownwardAPIVolumeFile>[]>? Items { get; set; }

    }

    /// <summary>
    /// DownwardAPIVolumeFile represents information to create the file containing the pod field
    /// </summary>
    class DownwardAPIVolumeFile {
        /// <summary>
        /// Required: Path is  the relative path name of the file to be created. Must not be
        /// absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative
        /// path must not start with '..'
        /// </summary>
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Required: Selects a field of the pod: only annotations, labels, name and namespace are
        /// supported.
        /// </summary>
        public Input<Core.V1.ObjectFieldSelector>? FieldRef { get; set; }

        /// <summary>
        /// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not
        /// specified, the volume defaultMode will be used. This might be in conflict with other
        /// options that affect the file mode, like fsGroup, and the result can be other mode bits
        /// set.
        /// </summary>
        public Input<int>? Mode { get; set; }

        /// <summary>
        /// Selects a resource of the container: only resources limits and requests (limits.cpu,
        /// limits.memory, requests.cpu and requests.memory) are currently supported.
        /// </summary>
        public Input<Core.V1.ResourceFieldSelector>? ResourceFieldRef { get; set; }

    }

    /// <summary>
    /// DownwardAPIVolumeSource represents a volume containing downward API info. Downward API
    /// volumes support ownership management and SELinux relabeling.
    /// </summary>
    class DownwardAPIVolumeSource {
        /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a value between 0 and
        /// 0777. Defaults to 0644. Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file mode, like fsGroup,
        /// and the result can be other mode bits set.
        /// </summary>
        public Input<int>? DefaultMode { get; set; }

        /// <summary>
        /// Items is a list of downward API volume file
        /// </summary>
        public Input<Input<Core.V1.DownwardAPIVolumeFile>[]>? Items { get; set; }

    }

    /// <summary>
    /// Represents an empty directory for a pod. Empty directory volumes support ownership
    /// management and SELinux relabeling.
    /// </summary>
    class EmptyDirVolumeSource {
        /// <summary>
        /// What type of storage medium should back this directory. The default is "" which means to
        /// use the node's default medium. Must be an empty string (default) or Memory. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        /// </summary>
        public Input<string>? Medium { get; set; }

        /// <summary>
        /// Total amount of local storage required for this EmptyDir volume. The size limit is also
        /// applicable for memory medium. The maximum usage on memory medium EmptyDir would be the
        /// minimum value between the SizeLimit specified here and the sum of memory limits of all
        /// containers in a pod. The default is nil which means that the limit is undefined. More
        /// info: http://kubernetes.io/docs/user-guide/volumes#emptydir
        /// </summary>
        public Input<string>? SizeLimit { get; set; }

    }

    /// <summary>
    /// EndpointAddress is a tuple that describes single IP address.
    /// </summary>
    class EndpointAddress {
        /// <summary>
        /// The IP of this endpoint. May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
        /// or link-local multicast ((224.0.0.0/24). IPv6 is also accepted but not fully supported
        /// on all platforms. Also, certain kubernetes components, like kube-proxy, are not IPv6
        /// ready.
        /// </summary>
        public Input<string> Ip { get; set; } = null!;

        /// <summary>
        /// The Hostname of this endpoint
        /// </summary>
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a
        /// node.
        /// </summary>
        public Input<string>? NodeName { get; set; }

        /// <summary>
        /// Reference to object providing the endpoint.
        /// </summary>
        public Input<Core.V1.ObjectReference>? TargetRef { get; set; }

    }

    /// <summary>
    /// EndpointPort is a tuple that describes a single port.
    /// </summary>
    class EndpointPort {
        /// <summary>
        /// The port number of the endpoint.
        /// </summary>
        public Input<int> Port { get; set; } = null!;

        /// <summary>
        /// The name of this port.  This must match the 'name' field in the corresponding
        /// ServicePort. Must be a DNS_LABEL. Optional only if one port is defined.
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
        /// </summary>
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// EndpointSubset is a group of addresses with a common set of ports. The expanded set of
    /// endpoints is the Cartesian product of Addresses x Ports. For example, given:
    ///   {
    ///     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
    ///     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
    ///   }
    /// The resulting set of endpoints can be viewed as:
    ///     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
    ///     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
    /// </summary>
    class EndpointSubset {
        /// <summary>
        /// IP addresses which offer the related ports that are marked as ready. These endpoints
        /// should be considered safe for load balancers and clients to utilize.
        /// </summary>
        public Input<Input<Core.V1.EndpointAddress>[]>? Addresses { get; set; }

        /// <summary>
        /// IP addresses which offer the related ports but are not currently marked as ready because
        /// they have not yet finished starting, have recently failed a readiness check, or have
        /// recently failed a liveness check.
        /// </summary>
        public Input<Input<Core.V1.EndpointAddress>[]>? NotReadyAddresses { get; set; }

        /// <summary>
        /// Port numbers available on the related IP addresses.
        /// </summary>
        public Input<Input<Core.V1.EndpointPort>[]>? Ports { get; set; }

    }

    /// <summary>
    /// Endpoints is a collection of endpoints that implement the actual service. Example:
    ///   Name: "mysvc",
    ///   Subsets: [
    ///     {
    ///       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
    ///       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
    ///     },
    ///     {
    ///       Addresses: [{"ip": "10.10.3.3"}],
    ///       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
    ///     },
    ///  ]
    /// </summary>
    class Endpoints {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// The set of all endpoints is the union of all subsets. Addresses are placed into subsets
        /// according to the IPs they share. A single address with multiple ports, some of which are
        /// ready and some of which are not (because they come from different containers) will
        /// result in the address being displayed in different subsets for the different ports. No
        /// address will appear in both Addresses and NotReadyAddresses in the same subset. Sets of
        /// addresses and ports that comprise a service.
        /// </summary>
        public Input<Input<Core.V1.EndpointSubset>[]>? Subsets { get; set; }

    }

    /// <summary>
    /// EndpointsList is a list of endpoints.
    /// </summary>
    class EndpointsList {
        /// <summary>
        /// List of endpoints.
        /// </summary>
        public Input<Input<Core.V1.Endpoints>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// EnvFromSource represents the source of a set of ConfigMaps
    /// </summary>
    class EnvFromSource {
        /// <summary>
        /// The ConfigMap to select from
        /// </summary>
        public Input<Core.V1.ConfigMapEnvSource>? ConfigMapRef { get; set; }

        /// <summary>
        /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        /// </summary>
        public Input<string>? Prefix { get; set; }

        /// <summary>
        /// The Secret to select from
        /// </summary>
        public Input<Core.V1.SecretEnvSource>? SecretRef { get; set; }

    }

    /// <summary>
    /// EnvVar represents an environment variable present in a Container.
    /// </summary>
    class EnvVar {
        /// <summary>
        /// Name of the environment variable. Must be a C_IDENTIFIER.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Variable references $(VAR_NAME) are expanded using the previous defined environment
        /// variables in the container and any service environment variables. If a variable cannot
        /// be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
        /// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be
        /// expanded, regardless of whether the variable exists or not. Defaults to "".
        /// </summary>
        public Input<string>? Value { get; set; }

        /// <summary>
        /// Source for the environment variable's value. Cannot be used if value is not empty.
        /// </summary>
        public Input<Core.V1.EnvVarSource>? ValueFrom { get; set; }

    }

    /// <summary>
    /// EnvVarSource represents a source for the value of an EnvVar.
    /// </summary>
    class EnvVarSource {
        /// <summary>
        /// Selects a key of a ConfigMap.
        /// </summary>
        public Input<Core.V1.ConfigMapKeySelector>? ConfigMapKeyRef { get; set; }

        /// <summary>
        /// Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels,
        /// metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP,
        /// status.podIP.
        /// </summary>
        public Input<Core.V1.ObjectFieldSelector>? FieldRef { get; set; }

        /// <summary>
        /// Selects a resource of the container: only resources limits and requests (limits.cpu,
        /// limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and
        /// requests.ephemeral-storage) are currently supported.
        /// </summary>
        public Input<Core.V1.ResourceFieldSelector>? ResourceFieldRef { get; set; }

        /// <summary>
        /// Selects a key of a secret in the pod's namespace
        /// </summary>
        public Input<Core.V1.SecretKeySelector>? SecretKeyRef { get; set; }

    }

    /// <summary>
    /// An EphemeralContainer is a container that may be added temporarily to an existing pod for
    /// user-initiated activities such as debugging. Ephemeral containers have no resource or
    /// scheduling guarantees, and they will not be restarted when they exit or when a pod is
    /// removed or restarted. If an ephemeral container causes a pod to exceed its resource
    /// allocation, the pod may be evicted. Ephemeral containers may not be added by directly
    /// updating the pod spec. They must be added via the pod's ephemeralcontainers subresource, and
    /// they will appear in the pod spec once added. This is an alpha feature enabled by the
    /// EphemeralContainers feature flag.
    /// </summary>
    class EphemeralContainer {
        /// <summary>
        /// Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among
        /// all containers, init containers and ephemeral containers.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a
        /// variable cannot be resolved, the reference in the input string will be unchanged. The
        /// $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references
        /// will never be expanded, regardless of whether the variable exists or not. Cannot be
        /// updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        public Input<Input<string>[]>? Args { get; set; }

        /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if
        /// this is not provided. Variable references $(VAR_NAME) are expanded using the container's
        /// environment. If a variable cannot be resolved, the reference in the input string will be
        /// unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
        /// Escaped references will never be expanded, regardless of whether the variable exists or
        /// not. Cannot be updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        public Input<Input<string>[]>? Command { get; set; }

        /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
        public Input<Input<Core.V1.EnvVar>[]>? Env { get; set; }

        /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined
        /// within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event
        /// when the container is starting. When a key exists in multiple sources, the value
        /// associated with the last source will take precedence. Values defined by an Env with a
        /// duplicate key will take precedence. Cannot be updated.
        /// </summary>
        public Input<Input<Core.V1.EnvFromSource>[]>? EnvFrom { get; set; }

        /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
        /// </summary>
        public Input<string>? Image { get; set; }

        /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag
        /// is specified, or IfNotPresent otherwise. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
        public Input<string>? ImagePullPolicy { get; set; }

        /// <summary>
        /// Lifecycle is not allowed for ephemeral containers.
        /// </summary>
        public Input<Core.V1.Lifecycle>? Lifecycle { get; set; }

        /// <summary>
        /// Probes are not allowed for ephemeral containers.
        /// </summary>
        public Input<Core.V1.Probe>? LivenessProbe { get; set; }

        /// <summary>
        /// Ports are not allowed for ephemeral containers.
        /// </summary>
        public Input<Input<Core.V1.ContainerPort>[]>? Ports { get; set; }

        /// <summary>
        /// Probes are not allowed for ephemeral containers.
        /// </summary>
        public Input<Core.V1.Probe>? ReadinessProbe { get; set; }

        /// <summary>
        /// Resources are not allowed for ephemeral containers. Ephemeral containers use spare
        /// resources already allocated to the pod.
        /// </summary>
        public Input<Core.V1.ResourceRequirements>? Resources { get; set; }

        /// <summary>
        /// SecurityContext is not allowed for ephemeral containers.
        /// </summary>
        public Input<Core.V1.SecurityContext>? SecurityContext { get; set; }

        /// <summary>
        /// Probes are not allowed for ephemeral containers.
        /// </summary>
        public Input<Core.V1.Probe>? StartupProbe { get; set; }

        /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If
        /// this is not set, reads from stdin in the container will always result in EOF. Default is
        /// false.
        /// </summary>
        public Input<bool>? Stdin { get; set; }

        /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by
        /// a single attach. When stdin is true the stdin stream will remain open across multiple
        /// attach sessions. If stdinOnce is set to true, stdin is opened on container start, is
        /// empty until the first client attaches to stdin, and then remains open and accepts data
        /// until the client disconnects, at which time stdin is closed and remains closed until the
        /// container is restarted. If this flag is false, a container processes that reads from
        /// stdin will never receive an EOF. Default is false
        /// </summary>
        public Input<bool>? StdinOnce { get; set; }

        /// <summary>
        /// If set, the name of the container from PodSpec that this ephemeral container targets.
        /// The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
        /// If not set then the ephemeral container is run in whatever namespaces are shared for the
        /// pod. Note that the container runtime must support this feature.
        /// </summary>
        public Input<string>? TargetContainerName { get; set; }

        /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be
        /// written is mounted into the container's filesystem. Message written is intended to be
        /// brief final status, such as an assertion failure message. Will be truncated by the node
        /// if greater than 4096 bytes. The total message length across all containers will be
        /// limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
        public Input<string>? TerminationMessagePath { get; set; }

        /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of
        /// terminationMessagePath to populate the container status message on both success and
        /// failure. FallbackToLogsOnError will use the last chunk of container log output if the
        /// termination message file is empty and the container exited with an error. The log output
        /// is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be
        /// updated.
        /// </summary>
        public Input<string>? TerminationMessagePolicy { get; set; }

        /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be
        /// true. Default is false.
        /// </summary>
        public Input<bool>? Tty { get; set; }

        /// <summary>
        /// volumeDevices is the list of block devices to be used by the container. This is a beta
        /// feature.
        /// </summary>
        public Input<Input<Core.V1.VolumeDevice>[]>? VolumeDevices { get; set; }

        /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
        public Input<Input<Core.V1.VolumeMount>[]>? VolumeMounts { get; set; }

        /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be
        /// used, which might be configured in the container image. Cannot be updated.
        /// </summary>
        public Input<string>? WorkingDir { get; set; }

    }

    /// <summary>
    /// Event is a report of an event somewhere in the cluster.
    /// </summary>
    class Event {
        /// <summary>
        /// The object that this event is about.
        /// </summary>
        public Input<Core.V1.ObjectReference> InvolvedObject { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta> Metadata { get; set; } = null!;

        /// <summary>
        /// What action was taken/failed regarding to the Regarding object.
        /// </summary>
        public Input<string>? Action { get; set; }

        /// <summary>
        /// The number of times this event has occurred.
        /// </summary>
        public Input<int>? Count { get; set; }

        /// <summary>
        /// Time when this Event was first observed.
        /// </summary>
        public Input<string>? EventTime { get; set; }

        /// <summary>
        /// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
        /// </summary>
        public Input<string>? FirstTimestamp { get; set; }

        /// <summary>
        /// The time at which the most recent occurrence of this event was recorded.
        /// </summary>
        public Input<string>? LastTimestamp { get; set; }

        /// <summary>
        /// A human-readable description of the status of this operation.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// This should be a short, machine understandable string that gives the reason for the
        /// transition into the object's current status.
        /// </summary>
        public Input<string>? Reason { get; set; }

        /// <summary>
        /// Optional secondary object for more complex actions.
        /// </summary>
        public Input<Core.V1.ObjectReference>? Related { get; set; }

        /// <summary>
        /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
        /// </summary>
        public Input<string>? ReportingComponent { get; set; }

        /// <summary>
        /// ID of the controller instance, e.g. `kubelet-xyzf`.
        /// </summary>
        public Input<string>? ReportingInstance { get; set; }

        /// <summary>
        /// Data about the Event series this event represents or nil if it's a singleton Event.
        /// </summary>
        public Input<Core.V1.EventSeries>? Series { get; set; }

        /// <summary>
        /// The component reporting this event. Should be a short machine understandable string.
        /// </summary>
        public Input<Core.V1.EventSource>? Source { get; set; }

        /// <summary>
        /// Type of this event (Normal, Warning), new types could be added in the future
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// EventList is a list of events.
    /// </summary>
    class EventList {
        /// <summary>
        /// List of events
        /// </summary>
        public Input<Input<Core.V1.Event>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// EventSeries contain information on series of events, i.e. thing that was/is happening
    /// continuously for some time.
    /// </summary>
    class EventSeries {
        /// <summary>
        /// Number of occurrences in this series up to the last heartbeat time
        /// </summary>
        public Input<int>? Count { get; set; }

        /// <summary>
        /// Time of the last occurrence observed
        /// </summary>
        public Input<string>? LastObservedTime { get; set; }

        /// <summary>
        /// State of this Series: Ongoing or Finished Deprecated. Planned removal for 1.18
        /// </summary>
        public Input<string>? State { get; set; }

    }

    /// <summary>
    /// EventSource contains information for an event.
    /// </summary>
    class EventSource {
        /// <summary>
        /// Component from which the event is generated.
        /// </summary>
        public Input<string>? Component { get; set; }

        /// <summary>
        /// Node name on which the event is generated.
        /// </summary>
        public Input<string>? Host { get; set; }

    }

    /// <summary>
    /// ExecAction describes a "run in container" action.
    /// </summary>
    class ExecAction {
        /// <summary>
        /// Command is the command line to execute inside the container, the working directory for
        /// the command  is root ('/') in the container's filesystem. The command is simply exec'd,
        /// it is not run inside a shell, so traditional shell instructions ('|', etc) won't work.
        /// To use a shell, you need to explicitly call out to that shell. Exit status of 0 is
        /// treated as live/healthy and non-zero is unhealthy.
        /// </summary>
        public Input<Input<string>[]>? Command { get; set; }

    }

    /// <summary>
    /// Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write
    /// once. Fibre Channel volumes support ownership management and SELinux relabeling.
    /// </summary>
    class FCVolumeSource {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Optional: FC target lun number
        /// </summary>
        public Input<int>? Lun { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: FC target worldwide names (WWNs)
        /// </summary>
        public Input<Input<string>[]>? TargetWWNs { get; set; }

        /// <summary>
        /// Optional: FC volume world wide identifiers (wwids) Either wwids or combination of
        /// targetWWNs and lun must be set, but not both simultaneously.
        /// </summary>
        public Input<Input<string>[]>? Wwids { get; set; }

    }

    /// <summary>
    /// FlexPersistentVolumeSource represents a generic persistent volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// </summary>
    class FlexPersistentVolumeSource {
        /// <summary>
        /// Driver is the name of the driver to use for this volume.
        /// </summary>
        public Input<string> Driver { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Optional: Extra command options if any.
        /// </summary>
        public InputMap<string>? Options { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the secret object containing sensitive information
        /// to pass to the plugin scripts. This may be empty if no secret object is specified. If
        /// the secret object contains more than one secret, all secrets are passed to the plugin
        /// scripts.
        /// </summary>
        public Input<Core.V1.SecretReference>? SecretRef { get; set; }

    }

    /// <summary>
    /// FlexVolume represents a generic volume resource that is provisioned/attached using an exec
    /// based plugin.
    /// </summary>
    class FlexVolumeSource {
        /// <summary>
        /// Driver is the name of the driver to use for this volume.
        /// </summary>
        public Input<string> Driver { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Optional: Extra command options if any.
        /// </summary>
        public InputMap<string>? Options { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the secret object containing sensitive information
        /// to pass to the plugin scripts. This may be empty if no secret object is specified. If
        /// the secret object contains more than one secret, all secrets are passed to the plugin
        /// scripts.
        /// </summary>
        public Input<Core.V1.LocalObjectReference>? SecretRef { get; set; }

    }

    /// <summary>
    /// Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName
    /// and datasetUUID should be set. Flocker volumes do not support ownership management or
    /// SELinux relabeling.
    /// </summary>
    class FlockerVolumeSource {
        /// <summary>
        /// Name of the dataset stored as metadata -&gt; name on the dataset for Flocker should be
        /// considered as deprecated
        /// </summary>
        public Input<string>? DatasetName { get; set; }

        /// <summary>
        /// UUID of the dataset. This is unique identifier of a Flocker dataset
        /// </summary>
        public Input<string>? DatasetUUID { get; set; }

    }

    /// <summary>
    /// Represents a Persistent Disk resource in Google Compute Engine.
    /// 
    /// A GCE PD must exist before mounting to a container. The disk must also be in the same GCE
    /// project and zone as the kubelet. A GCE PD can only be mounted as read/write once or
    /// read-only many times. GCE PDs support ownership management and SELinux relabeling.
    /// </summary>
    class GCEPersistentDiskVolumeSource {
        /// <summary>
        /// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        public Input<string> PdName { get; set; } = null!;

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// The partition in the volume that you want to mount. If omitted, the default is to mount
        /// by volume name. Examples: For volume /dev/sda1, you specify the partition as "1".
        /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property
        /// empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        public Input<int>? Partition { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
        /// info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Represents a volume that is populated with the contents of a git repository. Git repo
    /// volumes do not support ownership management. Git repo volumes support SELinux relabeling.
    /// 
    /// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into
    /// the Pod's container.
    /// </summary>
    class GitRepoVolumeSource {
        /// <summary>
        /// Repository URL
        /// </summary>
        public Input<string> Repository { get; set; } = null!;

        /// <summary>
        /// Target directory name. Must not contain or start with '..'.  If '.' is supplied, the
        /// volume directory will be the git repository.  Otherwise, if specified, the volume will
        /// contain the git repository in the subdirectory with the given name.
        /// </summary>
        public Input<string>? Directory { get; set; }

        /// <summary>
        /// Commit hash for the specified revision.
        /// </summary>
        public Input<string>? Revision { get; set; }

    }

    /// <summary>
    /// Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    class GlusterfsPersistentVolumeSource {
        /// <summary>
        /// EndpointsName is the endpoint name that details Glusterfs topology. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        public Input<string> Endpoints { get; set; } = null!;

        /// <summary>
        /// Path is the Glusterfs volume path. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// EndpointsNamespace is the namespace that contains Glusterfs endpoint. If this field is
        /// empty, the EndpointNamespace defaults to the same namespace as the bound PVC. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        public Input<string>? EndpointsNamespace { get; set; }

        /// <summary>
        /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
        /// Defaults to false. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    class GlusterfsVolumeSource {
        /// <summary>
        /// EndpointsName is the endpoint name that details Glusterfs topology. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        public Input<string> Endpoints { get; set; } = null!;

        /// <summary>
        /// Path is the Glusterfs volume path. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
        /// Defaults to false. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// HTTPGetAction describes an action based on HTTP Get requests.
    /// </summary>
    class HTTPGetAction {
        /// <summary>
        /// Name or number of the port to access on the container. Number must be in the range 1 to
        /// 65535. Name must be an IANA_SVC_NAME.
        /// </summary>
        public Input<int /* TODO: or string */> Port { get; set; } = null!;

        /// <summary>
        /// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in
        /// httpHeaders instead.
        /// </summary>
        public Input<string>? Host { get; set; }

        /// <summary>
        /// Custom headers to set in the request. HTTP allows repeated headers.
        /// </summary>
        public Input<Input<Core.V1.HTTPHeader>[]>? HttpHeaders { get; set; }

        /// <summary>
        /// Path to access on the HTTP server.
        /// </summary>
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Scheme to use for connecting to the host. Defaults to HTTP.
        /// </summary>
        public Input<string>? Scheme { get; set; }

    }

    /// <summary>
    /// HTTPHeader describes a custom header to be used in HTTP probes
    /// </summary>
    class HTTPHeader {
        /// <summary>
        /// The header field name
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// The header field value
        /// </summary>
        public Input<string> Value { get; set; } = null!;

    }

    /// <summary>
    /// Handler defines a specific action that should be taken
    /// </summary>
    class Handler {
        /// <summary>
        /// One and only one of the following should be specified. Exec specifies the action to
        /// take.
        /// </summary>
        public Input<Core.V1.ExecAction>? Exec { get; set; }

        /// <summary>
        /// HTTPGet specifies the http request to perform.
        /// </summary>
        public Input<Core.V1.HTTPGetAction>? HttpGet { get; set; }

        /// <summary>
        /// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        /// </summary>
        public Input<Core.V1.TCPSocketAction>? TcpSocket { get; set; }

    }

    /// <summary>
    /// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in
    /// the pod's hosts file.
    /// </summary>
    class HostAlias {
        /// <summary>
        /// Hostnames for the above IP address.
        /// </summary>
        public Input<Input<string>[]>? Hostnames { get; set; }

        /// <summary>
        /// IP address of the host file entry.
        /// </summary>
        public Input<string>? Ip { get; set; }

    }

    /// <summary>
    /// Represents a host path mapped into a pod. Host path volumes do not support ownership
    /// management or SELinux relabeling.
    /// </summary>
    class HostPathVolumeSource {
        /// <summary>
        /// Path of the directory on the host. If the path is a symlink, it will follow the link to
        /// the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Type for HostPath Volume Defaults to "" More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// ISCSIPersistentVolumeSource represents an ISCSI disk. ISCSI volumes can only be mounted as
    /// read/write once. ISCSI volumes support ownership management and SELinux relabeling.
    /// </summary>
    class ISCSIPersistentVolumeSource {
        /// <summary>
        /// Target iSCSI Qualified Name.
        /// </summary>
        public Input<string> Iqn { get; set; } = null!;

        /// <summary>
        /// iSCSI Target Lun number.
        /// </summary>
        public Input<int> Lun { get; set; } = null!;

        /// <summary>
        /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other
        /// than default (typically TCP ports 860 and 3260).
        /// </summary>
        public Input<string> TargetPortal { get; set; } = null!;

        /// <summary>
        /// whether support iSCSI Discovery CHAP authentication
        /// </summary>
        public Input<bool>? ChapAuthDiscovery { get; set; }

        /// <summary>
        /// whether support iSCSI Session CHAP authentication
        /// </summary>
        public Input<bool>? ChapAuthSession { get; set; }

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
        /// simultaneously, new iSCSI interface &lt;target portal&gt;:&lt;volume name&gt; will be
        /// created for the connection.
        /// </summary>
        public Input<string>? InitiatorName { get; set; }

        /// <summary>
        /// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
        /// </summary>
        public Input<string>? IscsiInterface { get; set; }

        /// <summary>
        /// iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port is
        /// other than default (typically TCP ports 860 and 3260).
        /// </summary>
        public Input<Input<string>[]>? Portals { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// CHAP Secret for iSCSI target and initiator authentication
        /// </summary>
        public Input<Core.V1.SecretReference>? SecretRef { get; set; }

    }

    /// <summary>
    /// Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI
    /// volumes support ownership management and SELinux relabeling.
    /// </summary>
    class ISCSIVolumeSource {
        /// <summary>
        /// Target iSCSI Qualified Name.
        /// </summary>
        public Input<string> Iqn { get; set; } = null!;

        /// <summary>
        /// iSCSI Target Lun number.
        /// </summary>
        public Input<int> Lun { get; set; } = null!;

        /// <summary>
        /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other
        /// than default (typically TCP ports 860 and 3260).
        /// </summary>
        public Input<string> TargetPortal { get; set; } = null!;

        /// <summary>
        /// whether support iSCSI Discovery CHAP authentication
        /// </summary>
        public Input<bool>? ChapAuthDiscovery { get; set; }

        /// <summary>
        /// whether support iSCSI Session CHAP authentication
        /// </summary>
        public Input<bool>? ChapAuthSession { get; set; }

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
        /// simultaneously, new iSCSI interface &lt;target portal&gt;:&lt;volume name&gt; will be
        /// created for the connection.
        /// </summary>
        public Input<string>? InitiatorName { get; set; }

        /// <summary>
        /// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
        /// </summary>
        public Input<string>? IscsiInterface { get; set; }

        /// <summary>
        /// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is
        /// other than default (typically TCP ports 860 and 3260).
        /// </summary>
        public Input<Input<string>[]>? Portals { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// CHAP Secret for iSCSI target and initiator authentication
        /// </summary>
        public Input<Core.V1.LocalObjectReference>? SecretRef { get; set; }

    }

    /// <summary>
    /// Maps a string key to a path within a volume.
    /// </summary>
    class KeyToPath {
        /// <summary>
        /// The key to project.
        /// </summary>
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// The relative path of the file to map the key to. May not be an absolute path. May not
        /// contain the path element '..'. May not start with the string '..'.
        /// </summary>
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not
        /// specified, the volume defaultMode will be used. This might be in conflict with other
        /// options that affect the file mode, like fsGroup, and the result can be other mode bits
        /// set.
        /// </summary>
        public Input<int>? Mode { get; set; }

    }

    /// <summary>
    /// Lifecycle describes actions that the management system should take in response to container
    /// lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the
    /// container blocks until the action is complete, unless the container process fails, in which
    /// case the handler is aborted.
    /// </summary>
    class Lifecycle {
        /// <summary>
        /// PostStart is called immediately after a container is created. If the handler fails, the
        /// container is terminated and restarted according to its restart policy. Other management
        /// of the container blocks until the hook completes. More info:
        /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        /// </summary>
        public Input<Core.V1.Handler>? PostStart { get; set; }

        /// <summary>
        /// PreStop is called immediately before a container is terminated due to an API request or
        /// management event such as liveness/startup probe failure, preemption, resource
        /// contention, etc. The handler is not called if the container crashes or exits. The reason
        /// for termination is passed to the handler. The Pod's termination grace period countdown
        /// begins before the PreStop hooked is executed. Regardless of the outcome of the handler,
        /// the container will eventually terminate within the Pod's termination grace period. Other
        /// management of the container blocks until the hook completes or until the termination
        /// grace period is reached. More info:
        /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        /// </summary>
        public Input<Core.V1.Handler>? PreStop { get; set; }

    }

    /// <summary>
    /// LimitRange sets resource usage limits for each kind of resource in a Namespace.
    /// </summary>
    class LimitRange {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the limits enforced. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Core.V1.LimitRangeSpec>? Spec { get; set; }

    }

    /// <summary>
    /// LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
    /// </summary>
    class LimitRangeItem {
        /// <summary>
        /// Default resource requirement limit value by resource name if resource limit is omitted.
        /// </summary>
        public Input<object>? Default { get; set; }

        /// <summary>
        /// DefaultRequest is the default resource requirement request value by resource name if
        /// resource request is omitted.
        /// </summary>
        public Input<object>? DefaultRequest { get; set; }

        /// <summary>
        /// Max usage constraints on this kind by resource name.
        /// </summary>
        public Input<object>? Max { get; set; }

        /// <summary>
        /// MaxLimitRequestRatio if specified, the named resource must have a request and limit that
        /// are both non-zero where limit divided by request is less than or equal to the enumerated
        /// value; this represents the max burst for the named resource.
        /// </summary>
        public Input<object>? MaxLimitRequestRatio { get; set; }

        /// <summary>
        /// Min usage constraints on this kind by resource name.
        /// </summary>
        public Input<object>? Min { get; set; }

        /// <summary>
        /// Type of resource that this limit applies to.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// LimitRangeList is a list of LimitRange items.
    /// </summary>
    class LimitRangeList {
        /// <summary>
        /// Items is a list of LimitRange objects. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
        public Input<Input<Core.V1.LimitRange>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// LimitRangeSpec defines a min/max usage limit for resources that match on kind.
    /// </summary>
    class LimitRangeSpec {
        /// <summary>
        /// Limits is the list of LimitRangeItem objects that are enforced.
        /// </summary>
        public Input<Input<Core.V1.LimitRangeItem>[]> Limits { get; set; } = null!;

    }

    /// <summary>
    /// LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended
    /// for the service should be sent to an ingress point.
    /// </summary>
    class LoadBalancerIngress {
        /// <summary>
        /// Hostname is set for load-balancer ingress points that are DNS based (typically AWS
        /// load-balancers)
        /// </summary>
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack
        /// load-balancers)
        /// </summary>
        public Input<string>? Ip { get; set; }

    }

    /// <summary>
    /// LoadBalancerStatus represents the status of a load-balancer.
    /// </summary>
    class LoadBalancerStatus {
        /// <summary>
        /// Ingress is a list containing ingress points for the load-balancer. Traffic intended for
        /// the service should be sent to these ingress points.
        /// </summary>
        public Input<Input<Core.V1.LoadBalancerIngress>[]>? Ingress { get; set; }

    }

    /// <summary>
    /// LocalObjectReference contains enough information to let you locate the referenced object
    /// inside the same namespace.
    /// </summary>
    class LocalObjectReference {
        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string>? Name { get; set; }

    }

    /// <summary>
    /// Local represents directly-attached storage with node affinity (Beta feature)
    /// </summary>
    class LocalVolumeSource {
        /// <summary>
        /// The full path to the volume on the node. It can be either a directory or block device
        /// (disk, partition, ...).
        /// </summary>
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. It applies only when the Path is a block device. Must be a
        /// filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The
        /// default value is to auto-select a fileystem if unspecified.
        /// </summary>
        public Input<string>? FsType { get; set; }

    }

    /// <summary>
    /// Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support
    /// ownership management or SELinux relabeling.
    /// </summary>
    class NFSVolumeSource {
        /// <summary>
        /// Path that is exported by the NFS server. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Server is the hostname or IP address of the NFS server. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        public Input<string> Server { get; set; } = null!;

        /// <summary>
        /// ReadOnly here will force the NFS export to be mounted with read-only permissions.
        /// Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Namespace provides a scope for Names. Use of multiple namespaces is optional.
    /// </summary>
    class Namespace {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the behavior of the Namespace. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Core.V1.NamespaceSpec>? Spec { get; set; }

    }

    /// <summary>
    /// NamespaceCondition contains details about state of namespace.
    /// </summary>
    class NamespaceCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of namespace controller condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        
        public Input<string>? LastTransitionTime { get; set; }

        
        public Input<string>? Message { get; set; }

        
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// NamespaceList is a list of Namespaces.
    /// </summary>
    class NamespaceList {
        /// <summary>
        /// Items is the list of Namespace objects in the list. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        /// </summary>
        public Input<Input<Core.V1.Namespace>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// NamespaceSpec describes the attributes on a Namespace.
    /// </summary>
    class NamespaceSpec {
        /// <summary>
        /// Finalizers is an opaque list of values that must be empty to permanently remove object
        /// from storage. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
        /// </summary>
        public Input<Input<string>[]>? Finalizers { get; set; }

    }

    /// <summary>
    /// NamespaceStatus is information about the current status of a Namespace.
    /// </summary>
    class NamespaceStatus {
        /// <summary>
        /// Represents the latest available observations of a namespace's current state.
        /// </summary>
        public Input<Input<Core.V1.NamespaceCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// Phase is the current lifecycle phase of the namespace. More info:
        /// https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
        /// </summary>
        public Input<string>? Phase { get; set; }

    }

    /// <summary>
    /// Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache
    /// (i.e. in etcd).
    /// </summary>
    class Node {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the behavior of a node.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Core.V1.NodeSpec>? Spec { get; set; }

    }

    /// <summary>
    /// NodeAddress contains information for the node's address.
    /// </summary>
    class NodeAddress {
        /// <summary>
        /// The node address.
        /// </summary>
        public Input<string> Address { get; set; } = null!;

        /// <summary>
        /// Node address type, one of Hostname, ExternalIP or InternalIP.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

    }

    /// <summary>
    /// Node affinity is a group of node affinity scheduling rules.
    /// </summary>
    class NodeAffinity {
        /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity
        /// expressions specified by this field, but it may choose a node that violates one or more
        /// of the expressions. The node that is most preferred is the one with the greatest sum of
        /// weights, i.e. for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling affinity expressions, etc.), compute a sum by
        /// iterating through the elements of this field and adding "weight" to the sum if the node
        /// matches the corresponding matchExpressions; the node(s) with the highest sum are the
        /// most preferred.
        /// </summary>
        public Input<Input<Core.V1.PreferredSchedulingTerm>[]>? PreferredDuringSchedulingIgnoredDuringExecution { get; set; }

        /// <summary>
        /// If the affinity requirements specified by this field are not met at scheduling time, the
        /// pod will not be scheduled onto the node. If the affinity requirements specified by this
        /// field cease to be met at some point during pod execution (e.g. due to an update), the
        /// system may or may not try to eventually evict the pod from its node.
        /// </summary>
        public Input<Core.V1.NodeSelector>? RequiredDuringSchedulingIgnoredDuringExecution { get; set; }

    }

    /// <summary>
    /// NodeCondition contains condition information for a node.
    /// </summary>
    class NodeCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of node condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time we got an update on a given condition.
        /// </summary>
        public Input<string>? LastHeartbeatTime { get; set; }

        /// <summary>
        /// Last time the condition transit from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human readable message indicating details about last transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// (brief) reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding
    /// metadata) must be non-nil.
    /// </summary>
    class NodeConfigSource {
        /// <summary>
        /// ConfigMap is a reference to a Node's ConfigMap
        /// </summary>
        public Input<Core.V1.ConfigMapNodeConfigSource>? ConfigMap { get; set; }

    }

    /// <summary>
    /// NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
    /// </summary>
    class NodeConfigStatus {
        /// <summary>
        /// Active reports the checkpointed config the node is actively using. Active will represent
        /// either the current version of the Assigned config, or the current LastKnownGood config,
        /// depending on whether attempting to use the Assigned config results in an error.
        /// </summary>
        public Input<Core.V1.NodeConfigSource>? Active { get; set; }

        /// <summary>
        /// Assigned reports the checkpointed config the node will try to use. When
        /// Node.Spec.ConfigSource is updated, the node checkpoints the associated config payload to
        /// local disk, along with a record indicating intended config. The node refers to this
        /// record to choose its config checkpoint, and reports this record in Assigned. Assigned
        /// only updates in the status after the record has been checkpointed to disk. When the
        /// Kubelet is restarted, it tries to make the Assigned config the Active config by loading
        /// and validating the checkpointed payload identified by Assigned.
        /// </summary>
        public Input<Core.V1.NodeConfigSource>? Assigned { get; set; }

        /// <summary>
        /// Error describes any problems reconciling the Spec.ConfigSource to the Active config.
        /// Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local
        /// Assigned record, attempting to checkpoint the payload associated with Spec.ConfigSource,
        /// attempting to load or validate the Assigned config, etc. Errors may occur at different
        /// points while syncing config. Earlier errors (e.g. download or checkpointing errors) will
        /// not result in a rollback to LastKnownGood, and may resolve across Kubelet retries. Later
        /// errors (e.g. loading or validating a checkpointed config) will result in a rollback to
        /// LastKnownGood. In the latter case, it is usually possible to resolve the error by fixing
        /// the config assigned in Spec.ConfigSource. You can find additional information for
        /// debugging by searching the error message in the Kubelet log. Error is a human-readable
        /// description of the error state; machines can check whether or not Error is empty, but
        /// should not rely on the stability of the Error text across Kubelet versions.
        /// </summary>
        public Input<string>? Error { get; set; }

        /// <summary>
        /// LastKnownGood reports the checkpointed config the node will fall back to when it
        /// encounters an error attempting to use the Assigned config. The Assigned config becomes
        /// the LastKnownGood config when the node determines that the Assigned config is stable and
        /// correct. This is currently implemented as a 10-minute soak period starting when the
        /// local record of Assigned config is updated. If the Assigned config is Active at the end
        /// of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is reset to
        /// nil (use local defaults), the LastKnownGood is also immediately reset to nil, because
        /// the local default config is always assumed good. You should not make assumptions about
        /// the node's method of determining config stability and correctness, as this may change or
        /// become configurable in the future.
        /// </summary>
        public Input<Core.V1.NodeConfigSource>? LastKnownGood { get; set; }

    }

    /// <summary>
    /// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
    /// </summary>
    class NodeDaemonEndpoints {
        /// <summary>
        /// Endpoint on which Kubelet is listening.
        /// </summary>
        public Input<Core.V1.DaemonEndpoint>? KubeletEndpoint { get; set; }

    }

    /// <summary>
    /// NodeList is the whole list of all Nodes which have been registered with master.
    /// </summary>
    class NodeList {
        /// <summary>
        /// List of nodes
        /// </summary>
        public Input<Input<Core.V1.Node>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// A node selector represents the union of the results of one or more label queries over a set
    /// of nodes; that is, it represents the OR of the selectors represented by the node selector
    /// terms.
    /// </summary>
    class NodeSelector {
        /// <summary>
        /// Required. A list of node selector terms. The terms are ORed.
        /// </summary>
        public Input<Input<Core.V1.NodeSelectorTerm>[]> NodeSelectorTerms { get; set; } = null!;

    }

    /// <summary>
    /// A node selector requirement is a selector that contains values, a key, and an operator that
    /// relates the key and values.
    /// </summary>
    class NodeSelectorRequirement {
        /// <summary>
        /// The label key that the selector applies to.
        /// </summary>
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// Represents a key's relationship to a set of values. Valid operators are In, NotIn,
        /// Exists, DoesNotExist. Gt, and Lt.
        /// </summary>
        public Input<string> Operator { get; set; } = null!;

        /// <summary>
        /// An array of string values. If the operator is In or NotIn, the values array must be
        /// non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If
        /// the operator is Gt or Lt, the values array must have a single element, which will be
        /// interpreted as an integer. This array is replaced during a strategic merge patch.
        /// </summary>
        public Input<Input<string>[]>? Values { get; set; }

    }

    /// <summary>
    /// A null or empty node selector term matches no objects. The requirements of them are ANDed.
    /// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
    /// </summary>
    class NodeSelectorTerm {
        /// <summary>
        /// A list of node selector requirements by node's labels.
        /// </summary>
        public Input<Input<Core.V1.NodeSelectorRequirement>[]>? MatchExpressions { get; set; }

        /// <summary>
        /// A list of node selector requirements by node's fields.
        /// </summary>
        public Input<Input<Core.V1.NodeSelectorRequirement>[]>? MatchFields { get; set; }

    }

    /// <summary>
    /// NodeSpec describes the attributes that a node is created with.
    /// </summary>
    class NodeSpec {
        /// <summary>
        /// If specified, the source to get node configuration from The DynamicKubeletConfig feature
        /// gate must be enabled for the Kubelet to use this field
        /// </summary>
        public Input<Core.V1.NodeConfigSource>? ConfigSource { get; set; }

        /// <summary>
        /// Deprecated. Not all kubelets will set this field. Remove field after 1.13. see:
        /// https://issues.k8s.io/61966
        /// </summary>
        public Input<string>? ExternalID { get; set; }

        /// <summary>
        /// PodCIDR represents the pod IP range assigned to the node.
        /// </summary>
        public Input<string>? PodCIDR { get; set; }

        /// <summary>
        /// podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node.
        /// If this field is specified, the 0th entry must match the podCIDR field. It may contain
        /// at most 1 value for each of IPv4 and IPv6.
        /// </summary>
        public Input<Input<string>[]>? PodCIDRs { get; set; }

        /// <summary>
        /// ID of the node assigned by the cloud provider in the format:
        /// &lt;ProviderName&gt;://&lt;ProviderSpecificNodeID&gt;
        /// </summary>
        public Input<string>? ProviderID { get; set; }

        /// <summary>
        /// If specified, the node's taints.
        /// </summary>
        public Input<Input<Core.V1.Taint>[]>? Taints { get; set; }

        /// <summary>
        /// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
        /// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
        /// </summary>
        public Input<bool>? Unschedulable { get; set; }

    }

    /// <summary>
    /// NodeStatus is information about the current status of a node.
    /// </summary>
    class NodeStatus {
        /// <summary>
        /// List of addresses reachable to the node. Queried from cloud provider, if available. More
        /// info: https://kubernetes.io/docs/concepts/nodes/node/#addresses Note: This field is
        /// declared as mergeable, but the merge key is not sufficiently unique, which can cause
        /// data corruption when it is merged. Callers should instead use a full-replacement patch.
        /// See http://pr.k8s.io/79391 for an example.
        /// </summary>
        public Input<Input<Core.V1.NodeAddress>[]>? Addresses { get; set; }

        /// <summary>
        /// Allocatable represents the resources of a node that are available for scheduling.
        /// Defaults to Capacity.
        /// </summary>
        public Input<object>? Allocatable { get; set; }

        /// <summary>
        /// Capacity represents the total resources of a node. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </summary>
        public Input<object>? Capacity { get; set; }

        /// <summary>
        /// Conditions is an array of current observed node conditions. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#condition
        /// </summary>
        public Input<Input<Core.V1.NodeCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// Status of the config assigned to the node via the dynamic Kubelet config feature.
        /// </summary>
        public Input<Core.V1.NodeConfigStatus>? Config { get; set; }

        /// <summary>
        /// Endpoints of daemons running on the Node.
        /// </summary>
        public Input<Core.V1.NodeDaemonEndpoints>? DaemonEndpoints { get; set; }

        /// <summary>
        /// List of container images on this node
        /// </summary>
        public Input<Input<Core.V1.ContainerImage>[]>? Images { get; set; }

        /// <summary>
        /// Set of ids/uuids to uniquely identify the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#info
        /// </summary>
        public Input<Core.V1.NodeSystemInfo>? NodeInfo { get; set; }

        /// <summary>
        /// NodePhase is the recently observed lifecycle phase of the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and
        /// now is deprecated.
        /// </summary>
        public Input<string>? Phase { get; set; }

        /// <summary>
        /// List of volumes that are attached to the node.
        /// </summary>
        public Input<Input<Core.V1.AttachedVolume>[]>? VolumesAttached { get; set; }

        /// <summary>
        /// List of attachable volumes in use (mounted) by the node.
        /// </summary>
        public Input<Input<string>[]>? VolumesInUse { get; set; }

    }

    /// <summary>
    /// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
    /// </summary>
    class NodeSystemInfo {
        /// <summary>
        /// The Architecture reported by the node
        /// </summary>
        public Input<string> Architecture { get; set; } = null!;

        /// <summary>
        /// Boot ID reported by the node.
        /// </summary>
        public Input<string> BootID { get; set; } = null!;

        /// <summary>
        /// ContainerRuntime Version reported by the node through runtime remote API (e.g.
        /// docker://1.5.0).
        /// </summary>
        public Input<string> ContainerRuntimeVersion { get; set; } = null!;

        /// <summary>
        /// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
        /// </summary>
        public Input<string> KernelVersion { get; set; } = null!;

        /// <summary>
        /// KubeProxy Version reported by the node.
        /// </summary>
        public Input<string> KubeProxyVersion { get; set; } = null!;

        /// <summary>
        /// Kubelet Version reported by the node.
        /// </summary>
        public Input<string> KubeletVersion { get; set; } = null!;

        /// <summary>
        /// MachineID reported by the node. For unique machine identification in the cluster this
        /// field is preferred. Learn more from man(5) machine-id:
        /// http://man7.org/linux/man-pages/man5/machine-id.5.html
        /// </summary>
        public Input<string> MachineID { get; set; } = null!;

        /// <summary>
        /// The Operating System reported by the node
        /// </summary>
        public Input<string> OperatingSystem { get; set; } = null!;

        /// <summary>
        /// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
        /// </summary>
        public Input<string> OsImage { get; set; } = null!;

        /// <summary>
        /// SystemUUID reported by the node. For unique machine identification MachineID is
        /// preferred. This field is specific to Red Hat hosts
        /// https://access.redhat.com/documentation/en-US/Red_Hat_Subscription_Management/1/html/RHSM/getting-system-uuid.html
        /// </summary>
        public Input<string> SystemUUID { get; set; } = null!;

    }

    /// <summary>
    /// ObjectFieldSelector selects an APIVersioned field of an object.
    /// </summary>
    class ObjectFieldSelector {
        /// <summary>
        /// Path of the field to select in the specified API version.
        /// </summary>
        public Input<string> FieldPath { get; set; } = null!;

    }

    /// <summary>
    /// ObjectReference contains enough information to let you inspect or modify the referred
    /// object.
    /// </summary>
    class ObjectReference {
        /// <summary>
        /// If referring to a piece of an object instead of an entire object, this string should
        /// contain a valid JSON/Go field access statement, such as
        /// desiredState.manifest.containers[2]. For example, if the object reference is to a
        /// container within a pod, this would take on a value like: "spec.containers{name}" (where
        /// "name" refers to the name of the container that triggered the event) or if no container
        /// name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax
        /// is chosen only to have some well-defined way of referencing a part of an object.
        /// </summary>
        public Input<string>? FieldPath { get; set; }

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        /// </summary>
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Specific resourceVersion to which this reference is made, if any. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// UID of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        /// </summary>
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous
    /// to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
    /// </summary>
    class PersistentVolume {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines a specification of a persistent volume owned by the cluster. Provisioned by
        /// an administrator. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
        /// </summary>
        public Input<Core.V1.PersistentVolumeSpec>? Spec { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaim is a user's request for and claim to a persistent volume
    /// </summary>
    class PersistentVolumeClaim {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired characteristics of a volume requested by a pod author. More
        /// info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        public Input<Core.V1.PersistentVolumeClaimSpec>? Spec { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimCondition contails details about state of pvc
    /// </summary>
    class PersistentVolumeClaimCondition {
        
        public Input<string> Status { get; set; } = null!;

        
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time we probed the condition.
        /// </summary>
        public Input<string>? LastProbeTime { get; set; }

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Unique, this should be a short, machine understandable string that gives the reason for
        /// condition's last transition. If it reports "ResizeStarted" that means the underlying
        /// persistent volume is being resized.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
    /// </summary>
    class PersistentVolumeClaimList {
        /// <summary>
        /// A list of persistent volume claims. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        public Input<Input<Core.V1.PersistentVolumeClaim>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a
    /// Source for provider-specific attributes
    /// </summary>
    class PersistentVolumeClaimSpec {
        /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        public Input<Input<string>[]>? AccessModes { get; set; }

        /// <summary>
        /// This field requires the VolumeSnapshotDataSource alpha feature gate to be enabled and
        /// currently VolumeSnapshot is the only supported data source. If the provisioner can
        /// support VolumeSnapshot data source, it will create a new volume and data will be
        /// restored to the volume at the same time. If the provisioner does not support
        /// VolumeSnapshot data source, volume will not be created and the failure will be reported
        /// as an event. In the future, we plan to support more data source types and the behavior
        /// of the provisioner may change.
        /// </summary>
        public Input<Core.V1.TypedLocalObjectReference>? DataSource { get; set; }

        /// <summary>
        /// Resources represents the minimum resources the volume should have. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        /// </summary>
        public Input<Core.V1.ResourceRequirements>? Resources { get; set; }

        /// <summary>
        /// A label query over volumes to consider for binding.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

        /// <summary>
        /// Name of the StorageClass required by the claim. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
        public Input<string>? StorageClassName { get; set; }

        /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is
        /// implied when not included in claim spec. This is a beta feature.
        /// </summary>
        public Input<string>? VolumeMode { get; set; }

        /// <summary>
        /// VolumeName is the binding reference to the PersistentVolume backing this claim.
        /// </summary>
        public Input<string>? VolumeName { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
    /// </summary>
    class PersistentVolumeClaimStatus {
        /// <summary>
        /// AccessModes contains the actual access modes the volume backing the PVC has. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        public Input<Input<string>[]>? AccessModes { get; set; }

        /// <summary>
        /// Represents the actual resources of the underlying volume.
        /// </summary>
        public Input<object>? Capacity { get; set; }

        /// <summary>
        /// Current Condition of persistent volume claim. If underlying persistent volume is being
        /// resized then the Condition will be set to 'ResizeStarted'.
        /// </summary>
        public Input<Input<Core.V1.PersistentVolumeClaimCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// Phase represents the current phase of PersistentVolumeClaim.
        /// </summary>
        public Input<string>? Phase { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This
    /// volume finds the bound PV and mounts that volume for the pod. A
    /// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume
    /// that is owned by someone else (the system).
    /// </summary>
    class PersistentVolumeClaimVolumeSource {
        /// <summary>
        /// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using
        /// this volume. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        public Input<string> ClaimName { get; set; } = null!;

        /// <summary>
        /// Will force the ReadOnly setting in VolumeMounts. Default false.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// PersistentVolumeList is a list of PersistentVolume items.
    /// </summary>
    class PersistentVolumeList {
        /// <summary>
        /// List of persistent volumes. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes
        /// </summary>
        public Input<Input<Core.V1.PersistentVolume>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PersistentVolumeSpec is the specification of a persistent volume.
    /// </summary>
    class PersistentVolumeSpec {
        /// <summary>
        /// AccessModes contains all ways the volume can be mounted. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
        /// </summary>
        public Input<Input<string>[]>? AccessModes { get; set; }

        /// <summary>
        /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's
        /// host machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        public Input<Core.V1.AWSElasticBlockStoreVolumeSource>? AwsElasticBlockStore { get; set; }

        /// <summary>
        /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
        /// </summary>
        public Input<Core.V1.AzureDiskVolumeSource>? AzureDisk { get; set; }

        /// <summary>
        /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
        /// </summary>
        public Input<Core.V1.AzureFilePersistentVolumeSource>? AzureFile { get; set; }

        /// <summary>
        /// A description of the persistent volume's resources and capacity. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </summary>
        public Input<object>? Capacity { get; set; }

        /// <summary>
        /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
        /// </summary>
        public Input<Core.V1.CephFSPersistentVolumeSource>? Cephfs { get; set; }

        /// <summary>
        /// Cinder represents a cinder volume attached and mounted on kubelets host machine. More
        /// info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        public Input<Core.V1.CinderPersistentVolumeSource>? Cinder { get; set; }

        /// <summary>
        /// ClaimRef is part of a bi-directional binding between PersistentVolume and
        /// PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the
        /// authoritative bind between PV and PVC. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
        /// </summary>
        public Input<Core.V1.ObjectReference>? ClaimRef { get; set; }

        /// <summary>
        /// CSI represents storage that is handled by an external CSI driver (Beta feature).
        /// </summary>
        public Input<Core.V1.CSIPersistentVolumeSource>? Csi { get; set; }

        /// <summary>
        /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and
        /// then exposed to the pod.
        /// </summary>
        public Input<Core.V1.FCVolumeSource>? Fc { get; set; }

        /// <summary>
        /// FlexVolume represents a generic volume resource that is provisioned/attached using an
        /// exec based plugin.
        /// </summary>
        public Input<Core.V1.FlexPersistentVolumeSource>? FlexVolume { get; set; }

        /// <summary>
        /// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to
        /// the pod for its usage. This depends on the Flocker control service being running
        /// </summary>
        public Input<Core.V1.FlockerVolumeSource>? Flocker { get; set; }

        /// <summary>
        /// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host
        /// machine and then exposed to the pod. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        public Input<Core.V1.GCEPersistentDiskVolumeSource>? GcePersistentDisk { get; set; }

        /// <summary>
        /// Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the
        /// pod. Provisioned by an admin. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md
        /// </summary>
        public Input<Core.V1.GlusterfsPersistentVolumeSource>? Glusterfs { get; set; }

        /// <summary>
        /// HostPath represents a directory on the host. Provisioned by a developer or tester. This
        /// is useful for single-node development and testing only! On-host storage is not supported
        /// in any way and WILL NOT WORK in a multi-node cluster. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        public Input<Core.V1.HostPathVolumeSource>? HostPath { get; set; }

        /// <summary>
        /// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and
        /// then exposed to the pod. Provisioned by an admin.
        /// </summary>
        public Input<Core.V1.ISCSIPersistentVolumeSource>? Iscsi { get; set; }

        /// <summary>
        /// Local represents directly-attached storage with node affinity
        /// </summary>
        public Input<Core.V1.LocalVolumeSource>? Local { get; set; }

        /// <summary>
        /// A list of mount options, e.g. ["ro", "soft"]. Not validated - mount will simply fail if
        /// one is invalid. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
        /// </summary>
        public Input<Input<string>[]>? MountOptions { get; set; }

        /// <summary>
        /// NFS represents an NFS mount on the host. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        public Input<Core.V1.NFSVolumeSource>? Nfs { get; set; }

        /// <summary>
        /// NodeAffinity defines constraints that limit what nodes this volume can be accessed from.
        /// This field influences the scheduling of pods that use this volume.
        /// </summary>
        public Input<Core.V1.VolumeNodeAffinity>? NodeAffinity { get; set; }

        /// <summary>
        /// What happens to a persistent volume when released from its claim. Valid options are
        /// Retain (default for manually created PersistentVolumes), Delete (default for dynamically
        /// provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by
        /// the volume plugin underlying this PersistentVolume. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
        /// </summary>
        public Input<string>? PersistentVolumeReclaimPolicy { get; set; }

        /// <summary>
        /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted
        /// on kubelets host machine
        /// </summary>
        public Input<Core.V1.PhotonPersistentDiskVolumeSource>? PhotonPersistentDisk { get; set; }

        /// <summary>
        /// PortworxVolume represents a portworx volume attached and mounted on kubelets host
        /// machine
        /// </summary>
        public Input<Core.V1.PortworxVolumeSource>? PortworxVolume { get; set; }

        /// <summary>
        /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        /// </summary>
        public Input<Core.V1.QuobyteVolumeSource>? Quobyte { get; set; }

        /// <summary>
        /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md
        /// </summary>
        public Input<Core.V1.RBDPersistentVolumeSource>? Rbd { get; set; }

        /// <summary>
        /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
        /// </summary>
        public Input<Core.V1.ScaleIOPersistentVolumeSource>? ScaleIO { get; set; }

        /// <summary>
        /// Name of StorageClass to which this persistent volume belongs. Empty value means that
        /// this volume does not belong to any StorageClass.
        /// </summary>
        public Input<string>? StorageClassName { get; set; }

        /// <summary>
        /// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine
        /// and mounted into the pod More info: https://examples.k8s.io/volumes/storageos/README.md
        /// </summary>
        public Input<Core.V1.StorageOSPersistentVolumeSource>? Storageos { get; set; }

        /// <summary>
        /// volumeMode defines if a volume is intended to be used with a formatted filesystem or to
        /// remain in raw block state. Value of Filesystem is implied when not included in spec.
        /// This is a beta feature.
        /// </summary>
        public Input<string>? VolumeMode { get; set; }

        /// <summary>
        /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
        /// </summary>
        public Input<Core.V1.VsphereVirtualDiskVolumeSource>? VsphereVolume { get; set; }

    }

    /// <summary>
    /// PersistentVolumeStatus is the current status of a persistent volume.
    /// </summary>
    class PersistentVolumeStatus {
        /// <summary>
        /// A human-readable message indicating details about why the volume is in this state.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Phase indicates if a volume is available, bound to a claim, or released by a claim. More
        /// info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
        /// </summary>
        public Input<string>? Phase { get; set; }

        /// <summary>
        /// Reason is a brief CamelCase string that describes any failure and is meant for machine
        /// parsing and tidy display in the CLI.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// Represents a Photon Controller persistent disk resource.
    /// </summary>
    class PhotonPersistentDiskVolumeSource {
        /// <summary>
        /// ID that identifies Photon Controller persistent disk
        /// </summary>
        public Input<string> PdID { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        public Input<string>? FsType { get; set; }

    }

    /// <summary>
    /// Pod is a collection of containers that can run on a host. This resource is created by
    /// clients and scheduled onto hosts.
    /// </summary>
    class Pod {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the pod. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Core.V1.PodSpec>? Spec { get; set; }

    }

    /// <summary>
    /// Pod affinity is a group of inter pod affinity scheduling rules.
    /// </summary>
    class PodAffinity {
        /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity
        /// expressions specified by this field, but it may choose a node that violates one or more
        /// of the expressions. The node that is most preferred is the one with the greatest sum of
        /// weights, i.e. for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling affinity expressions, etc.), compute a sum by
        /// iterating through the elements of this field and adding "weight" to the sum if the node
        /// has pods which matches the corresponding podAffinityTerm; the node(s) with the highest
        /// sum are the most preferred.
        /// </summary>
        public Input<Input<Core.V1.WeightedPodAffinityTerm>[]>? PreferredDuringSchedulingIgnoredDuringExecution { get; set; }

        /// <summary>
        /// If the affinity requirements specified by this field are not met at scheduling time, the
        /// pod will not be scheduled onto the node. If the affinity requirements specified by this
        /// field cease to be met at some point during pod execution (e.g. due to a pod label
        /// update), the system may or may not try to eventually evict the pod from its node. When
        /// there are multiple elements, the lists of nodes corresponding to each podAffinityTerm
        /// are intersected, i.e. all terms must be satisfied.
        /// </summary>
        public Input<Input<Core.V1.PodAffinityTerm>[]>? RequiredDuringSchedulingIgnoredDuringExecution { get; set; }

    }

    /// <summary>
    /// Defines a set of pods (namely those matching the labelSelector relative to the given
    /// namespace(s)) that this pod should be co-located (affinity) or not co-located
    /// (anti-affinity) with, where co-located is defined as running on a node whose value of the
    /// label with key &lt;topologyKey&gt; matches that of any node on which a pod of the set of
    /// pods is running
    /// </summary>
    class PodAffinityTerm {
        /// <summary>
        /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods
        /// matching the labelSelector in the specified namespaces, where co-located is defined as
        /// running on a node whose value of the label with key topologyKey matches that of any node
        /// on which any of the selected pods is running. Empty topologyKey is not allowed.
        /// </summary>
        public Input<string> TopologyKey { get; set; } = null!;

        /// <summary>
        /// A label query over a set of resources, in this case pods.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? LabelSelector { get; set; }

        /// <summary>
        /// namespaces specifies which namespaces the labelSelector applies to (matches against);
        /// null or empty list means "this pod's namespace"
        /// </summary>
        public Input<Input<string>[]>? Namespaces { get; set; }

    }

    /// <summary>
    /// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
    /// </summary>
    class PodAntiAffinity {
        /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity
        /// expressions specified by this field, but it may choose a node that violates one or more
        /// of the expressions. The node that is most preferred is the one with the greatest sum of
        /// weights, i.e. for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by
        /// iterating through the elements of this field and adding "weight" to the sum if the node
        /// has pods which matches the corresponding podAffinityTerm; the node(s) with the highest
        /// sum are the most preferred.
        /// </summary>
        public Input<Input<Core.V1.WeightedPodAffinityTerm>[]>? PreferredDuringSchedulingIgnoredDuringExecution { get; set; }

        /// <summary>
        /// If the anti-affinity requirements specified by this field are not met at scheduling
        /// time, the pod will not be scheduled onto the node. If the anti-affinity requirements
        /// specified by this field cease to be met at some point during pod execution (e.g. due to
        /// a pod label update), the system may or may not try to eventually evict the pod from its
        /// node. When there are multiple elements, the lists of nodes corresponding to each
        /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
        /// </summary>
        public Input<Input<Core.V1.PodAffinityTerm>[]>? RequiredDuringSchedulingIgnoredDuringExecution { get; set; }

    }

    /// <summary>
    /// PodCondition contains details for the current condition of this pod.
    /// </summary>
    class PodCondition {
        /// <summary>
        /// Status is the status of the condition. Can be True, False, Unknown. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type is the type of the condition. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time we probed the condition.
        /// </summary>
        public Input<string>? LastProbeTime { get; set; }

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// PodDNSConfig defines the DNS parameters of a pod in addition to those generated from
    /// DNSPolicy.
    /// </summary>
    class PodDNSConfig {
        /// <summary>
        /// A list of DNS name server IP addresses. This will be appended to the base nameservers
        /// generated from DNSPolicy. Duplicated nameservers will be removed.
        /// </summary>
        public Input<Input<string>[]>? Nameservers { get; set; }

        /// <summary>
        /// A list of DNS resolver options. This will be merged with the base options generated from
        /// DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will
        /// override those that appear in the base DNSPolicy.
        /// </summary>
        public Input<Input<Core.V1.PodDNSConfigOption>[]>? Options { get; set; }

        /// <summary>
        /// A list of DNS search domains for host-name lookup. This will be appended to the base
        /// search paths generated from DNSPolicy. Duplicated search paths will be removed.
        /// </summary>
        public Input<Input<string>[]>? Searches { get; set; }

    }

    /// <summary>
    /// PodDNSConfigOption defines DNS resolver options of a pod.
    /// </summary>
    class PodDNSConfigOption {
        /// <summary>
        /// Required.
        /// </summary>
        public Input<string>? Name { get; set; }

        
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// IP address information for entries in the (plural) PodIPs field. Each entry includes:
    ///    IP: An IP address allocated to the pod. Routable at least within the cluster.
    /// </summary>
    class PodIP {
        /// <summary>
        /// ip is an IP address (IPv4 or IPv6) assigned to the pod
        /// </summary>
        public Input<string>? Ip { get; set; }

    }

    /// <summary>
    /// PodList is a list of Pods.
    /// </summary>
    class PodList {
        /// <summary>
        /// List of pods. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
        /// </summary>
        public Input<Input<Core.V1.Pod>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PodReadinessGate contains the reference to a pod condition
    /// </summary>
    class PodReadinessGate {
        /// <summary>
        /// ConditionType refers to a condition in the pod's condition list with matching type.
        /// </summary>
        public Input<string> ConditionType { get; set; } = null!;

    }

    /// <summary>
    /// PodSecurityContext holds pod-level security attributes and common container settings. Some
    /// fields are also present in container.securityContext.  Field values of
    /// container.securityContext take precedence over field values of PodSecurityContext.
    /// </summary>
    class PodSecurityContext {
        /// <summary>
        /// A special supplemental group that applies to all containers in a pod. Some volume types
        /// allow the Kubelet to change the ownership of that volume to be owned by the pod:
        /// 
        /// 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the
        /// volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
        /// 
        /// If unset, the Kubelet will not modify the ownership and permissions of any volume.
        /// </summary>
        public Input<int>? FsGroup { get; set; }

        /// <summary>
        /// The GID to run the entrypoint of the container process. Uses runtime default if unset.
        /// May also be set in SecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence for that
        /// container.
        /// </summary>
        public Input<int>? RunAsGroup { get; set; }

        /// <summary>
        /// Indicates that the container must run as a non-root user. If true, the Kubelet will
        /// validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to
        /// start the container if it does. If unset or false, no such validation will be performed.
        /// May also be set in SecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        public Input<bool>? RunAsNonRoot { get; set; }

        /// <summary>
        /// The UID to run the entrypoint of the container process. Defaults to user specified in
        /// image metadata if unspecified. May also be set in SecurityContext.  If set in both
        /// SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
        /// precedence for that container.
        /// </summary>
        public Input<int>? RunAsUser { get; set; }

        /// <summary>
        /// The SELinux context to be applied to all containers. If unspecified, the container
        /// runtime will allocate a random SELinux context for each container.  May also be set in
        /// SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value
        /// specified in SecurityContext takes precedence for that container.
        /// </summary>
        public Input<Core.V1.SELinuxOptions>? SeLinuxOptions { get; set; }

        /// <summary>
        /// A list of groups applied to the first process run in each container, in addition to the
        /// container's primary GID.  If unspecified, no groups will be added to any container.
        /// </summary>
        public Input<Input<int>[]>? SupplementalGroups { get; set; }

        /// <summary>
        /// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
        /// sysctls (by the container runtime) might fail to launch.
        /// </summary>
        public Input<Input<Core.V1.Sysctl>[]>? Sysctls { get; set; }

        /// <summary>
        /// The Windows specific settings applied to all containers. If unspecified, the options
        /// within a container's SecurityContext will be used. If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        public Input<Core.V1.WindowsSecurityContextOptions>? WindowsOptions { get; set; }

    }

    /// <summary>
    /// PodSpec is a description of a pod.
    /// </summary>
    class PodSpec {
        /// <summary>
        /// List of containers belonging to the pod. Containers cannot currently be added or
        /// removed. There must be at least one container in a Pod. Cannot be updated.
        /// </summary>
        public Input<Input<Core.V1.Container>[]> Containers { get; set; } = null!;

        /// <summary>
        /// Optional duration in seconds the pod may be active on the node relative to StartTime
        /// before the system will actively try to mark it failed and kill associated containers.
        /// Value must be a positive integer.
        /// </summary>
        public Input<int>? ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// If specified, the pod's scheduling constraints
        /// </summary>
        public Input<Core.V1.Affinity>? Affinity { get; set; }

        /// <summary>
        /// AutomountServiceAccountToken indicates whether a service account token should be
        /// automatically mounted.
        /// </summary>
        public Input<bool>? AutomountServiceAccountToken { get; set; }

        /// <summary>
        /// Specifies the DNS parameters of a pod. Parameters specified here will be merged to the
        /// generated DNS configuration based on DNSPolicy.
        /// </summary>
        public Input<Core.V1.PodDNSConfig>? DnsConfig { get; set; }

        /// <summary>
        /// Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are
        /// 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in
        /// DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options
        /// set along with hostNetwork, you have to specify DNS policy explicitly to
        /// 'ClusterFirstWithHostNet'.
        /// </summary>
        public Input<string>? DnsPolicy { get; set; }

        /// <summary>
        /// EnableServiceLinks indicates whether information about services should be injected into
        /// pod's environment variables, matching the syntax of Docker links. Optional: Defaults to
        /// true.
        /// </summary>
        public Input<bool>? EnableServiceLinks { get; set; }

        /// <summary>
        /// List of ephemeral containers run in this pod. Ephemeral containers may be run in an
        /// existing pod to perform user-initiated actions such as debugging. This list cannot be
        /// specified when creating a pod, and it cannot be modified by updating the pod spec. In
        /// order to add an ephemeral container to an existing pod, use the pod's
        /// ephemeralcontainers subresource. This field is alpha-level and is only honored by
        /// servers that enable the EphemeralContainers feature.
        /// </summary>
        public Input<Input<Core.V1.EphemeralContainer>[]>? EphemeralContainers { get; set; }

        /// <summary>
        /// HostAliases is an optional list of hosts and IPs that will be injected into the pod's
        /// hosts file if specified. This is only valid for non-hostNetwork pods.
        /// </summary>
        public Input<Input<Core.V1.HostAlias>[]>? HostAliases { get; set; }

        /// <summary>
        /// Use the host's ipc namespace. Optional: Default to false.
        /// </summary>
        public Input<bool>? HostIPC { get; set; }

        /// <summary>
        /// Host networking requested for this pod. Use the host's network namespace. If this option
        /// is set, the ports that will be used must be specified. Default to false.
        /// </summary>
        public Input<bool>? HostNetwork { get; set; }

        /// <summary>
        /// Use the host's pid namespace. Optional: Default to false.
        /// </summary>
        public Input<bool>? HostPID { get; set; }

        /// <summary>
        /// Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a
        /// system-defined value.
        /// </summary>
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// ImagePullSecrets is an optional list of references to secrets in the same namespace to
        /// use for pulling any of the images used by this PodSpec. If specified, these secrets will
        /// be passed to individual puller implementations for them to use. For example, in the case
        /// of docker, only DockerConfig type secrets are honored. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
        /// </summary>
        public Input<Input<Core.V1.LocalObjectReference>[]>? ImagePullSecrets { get; set; }

        /// <summary>
        /// List of initialization containers belonging to the pod. Init containers are executed in
        /// order prior to containers being started. If any init container fails, the pod is
        /// considered to have failed and is handled according to its restartPolicy. The name for an
        /// init container or normal container must be unique among all containers. Init containers
        /// may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
        /// The resourceRequirements of an init container are taken into account during scheduling
        /// by finding the highest request/limit for each resource type, and then using the max of
        /// of that value or the sum of the normal containers. Limits are applied to init containers
        /// in a similar fashion. Init containers cannot currently be added or removed. Cannot be
        /// updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        /// </summary>
        public Input<Input<Core.V1.Container>[]>? InitContainers { get; set; }

        /// <summary>
        /// NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the
        /// scheduler simply schedules this pod onto that node, assuming that it fits resource
        /// requirements.
        /// </summary>
        public Input<string>? NodeName { get; set; }

        /// <summary>
        /// NodeSelector is a selector which must be true for the pod to fit on a node. Selector
        /// which must match a node's labels for the pod to be scheduled on that node. More info:
        /// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        /// </summary>
        public InputMap<string>? NodeSelector { get; set; }

        /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a given
        /// RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass
        /// admission controller. If the RuntimeClass admission controller is enabled, overhead must
        /// not be set in Pod create requests. The RuntimeClass admission controller will reject Pod
        /// create requests which have the overhead already set. If RuntimeClass is configured and
        /// selected in the PodSpec, Overhead will be set to the value defined in the corresponding
        /// RuntimeClass, otherwise it will remain unset and treated as zero. More info:
        /// https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
        /// alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the
        /// PodOverhead feature.
        /// </summary>
        public Input<object>? Overhead { get; set; }

        /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
        public Input<string>? PreemptionPolicy { get; set; }

        /// <summary>
        /// The priority value. Various system components use this field to find the priority of the
        /// pod. When Priority Admission Controller is enabled, it prevents users from setting this
        /// field. The admission controller populates this field from PriorityClassName. The higher
        /// the value, the higher the priority.
        /// </summary>
        public Input<int>? Priority { get; set; }

        /// <summary>
        /// If specified, indicates the pod's priority. "system-node-critical" and
        /// "system-cluster-critical" are two special keywords which indicate the highest priorities
        /// with the former being the highest priority. Any other name must be defined by creating a
        /// PriorityClass object with that name. If not specified, the pod priority will be default
        /// or zero if there is no default.
        /// </summary>
        public Input<string>? PriorityClassName { get; set; }

        /// <summary>
        /// If specified, all readiness gates will be evaluated for pod readiness. A pod is ready
        /// when all its containers are ready AND all conditions specified in the readiness gates
        /// have status equal to "True" More info:
        /// https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        /// </summary>
        public Input<Input<Core.V1.PodReadinessGate>[]>? ReadinessGates { get; set; }

        /// <summary>
        /// Restart policy for all containers within the pod. One of Always, OnFailure, Never.
        /// Default to Always. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
        /// </summary>
        public Input<string>? RestartPolicy { get; set; }

        /// <summary>
        /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should
        /// be used to run this pod.  If no RuntimeClass resource matches the named class, the pod
        /// will not be run. If unset or empty, the "legacy" RuntimeClass will be used, which is an
        /// implicit class with an empty definition that uses the default runtime handler. More
        /// info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md This is a beta
        /// feature as of Kubernetes v1.14.
        /// </summary>
        public Input<string>? RuntimeClassName { get; set; }

        /// <summary>
        /// If specified, the pod will be dispatched by specified scheduler. If not specified, the
        /// pod will be dispatched by default scheduler.
        /// </summary>
        public Input<string>? SchedulerName { get; set; }

        /// <summary>
        /// SecurityContext holds pod-level security attributes and common container settings.
        /// Optional: Defaults to empty.  See type description for default values of each field.
        /// </summary>
        public Input<Core.V1.PodSecurityContext>? SecurityContext { get; set; }

        /// <summary>
        /// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use
        /// serviceAccountName instead.
        /// </summary>
        public Input<string>? ServiceAccount { get; set; }

        /// <summary>
        /// ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        /// </summary>
        public Input<string>? ServiceAccountName { get; set; }

        /// <summary>
        /// Share a single process namespace between all of the containers in a pod. When this is
        /// set containers will be able to view and signal processes from other containers in the
        /// same pod, and the first process in each container will not be assigned PID 1. HostPID
        /// and ShareProcessNamespace cannot both be set. Optional: Default to false. This field is
        /// beta-level and may be disabled with the PodShareProcessNamespace feature.
        /// </summary>
        public Input<bool>? ShareProcessNamespace { get; set; }

        /// <summary>
        /// If specified, the fully qualified Pod hostname will be
        /// "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
        /// If not specified, the pod will not have a domainname at all.
        /// </summary>
        public Input<string>? Subdomain { get; set; }

        /// <summary>
        /// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in
        /// delete request. Value must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period will be used instead. The
        /// grace period is the duration in seconds after the processes running in the pod are sent
        /// a termination signal and the time when the processes are forcibly halted with a kill
        /// signal. Set this value longer than the expected cleanup time for your process. Defaults
        /// to 30 seconds.
        /// </summary>
        public Input<int>? TerminationGracePeriodSeconds { get; set; }

        /// <summary>
        /// If specified, the pod's tolerations.
        /// </summary>
        public Input<Input<Core.V1.Toleration>[]>? Tolerations { get; set; }

        /// <summary>
        /// TopologySpreadConstraints describes how a group of pods ought to spread across topology
        /// domains. Scheduler will schedule pods in a way which abides by the constraints. This
        /// field is alpha-level and is only honored by clusters that enables the EvenPodsSpread
        /// feature. All topologySpreadConstraints are ANDed.
        /// </summary>
        public Input<Input<Core.V1.TopologySpreadConstraint>[]>? TopologySpreadConstraints { get; set; }

        /// <summary>
        /// List of volumes that can be mounted by containers belonging to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes
        /// </summary>
        public Input<Input<Core.V1.Volume>[]>? Volumes { get; set; }

    }

    /// <summary>
    /// PodStatus represents information about the status of a pod. Status may trail the actual
    /// state of a system, especially if the node that hosts the pod cannot contact the control
    /// plane.
    /// </summary>
    class PodStatus {
        /// <summary>
        /// Current service state of pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
        /// </summary>
        public Input<Input<Core.V1.PodCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The list has one entry per container in the manifest. Each entry is currently the output
        /// of `docker inspect`. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
        /// </summary>
        public Input<Input<Core.V1.ContainerStatus>[]>? ContainerStatuses { get; set; }

        /// <summary>
        /// Status for any ephemeral containers that have run in this pod. This field is alpha-level
        /// and is only populated by servers that enable the EphemeralContainers feature.
        /// </summary>
        public Input<Input<Core.V1.ContainerStatus>[]>? EphemeralContainerStatuses { get; set; }

        /// <summary>
        /// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
        /// </summary>
        public Input<string>? HostIP { get; set; }

        /// <summary>
        /// The list has one entry per init container in the manifest. The most recent successful
        /// init container will have ready = true, the most recently started container will have
        /// startTime set. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
        /// </summary>
        public Input<Input<Core.V1.ContainerStatus>[]>? InitContainerStatuses { get; set; }

        /// <summary>
        /// A human readable message indicating details about why the pod is in this condition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// nominatedNodeName is set only when this pod preempts other pods on the node, but it
        /// cannot be scheduled right away as preemption victims receive their graceful termination
        /// periods. This field does not guarantee that the pod will be scheduled on this node.
        /// Scheduler may decide to place the pod elsewhere if other nodes become available sooner.
        /// Scheduler may also decide to give the resources on this node to a higher priority pod
        /// that is created after preemption. As a result, this field may be different than
        /// PodSpec.nodeName when the pod is scheduled.
        /// </summary>
        public Input<string>? NominatedNodeName { get; set; }

        /// <summary>
        /// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
        /// The conditions array, the reason and message fields, and the individual container status
        /// arrays contain more detail about the pod's status. There are five possible phase values:
        /// 
        /// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
        /// container images has not been created. This includes time before being scheduled as well
        /// as time spent downloading images over the network, which could take a while. Running:
        /// The pod has been bound to a node, and all of the containers have been created. At least
        /// one container is still running, or is in the process of starting or restarting.
        /// Succeeded: All containers in the pod have terminated in success, and will not be
        /// restarted. Failed: All containers in the pod have terminated, and at least one container
        /// has terminated in failure. The container either exited with non-zero status or was
        /// terminated by the system. Unknown: For some reason the state of the pod could not be
        /// obtained, typically due to an error in communicating with the host of the pod.
        /// 
        /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
        /// </summary>
        public Input<string>? Phase { get; set; }

        /// <summary>
        /// IP address allocated to the pod. Routable at least within the cluster. Empty if not yet
        /// allocated.
        /// </summary>
        public Input<string>? PodIP { get; set; }

        /// <summary>
        /// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th
        /// entry must match the podIP field. Pods may be allocated at most 1 value for each of IPv4
        /// and IPv6. This list is empty if no IPs have been allocated yet.
        /// </summary>
        public Input<Input<Core.V1.PodIP>[]>? PodIPs { get; set; }

        /// <summary>
        /// The Quality of Service (QOS) classification assigned to the pod based on resource
        /// requirements See PodQOSClass type for available QOS classes More info:
        /// https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
        /// </summary>
        public Input<string>? QosClass { get; set; }

        /// <summary>
        /// A brief CamelCase message indicating details about why the pod is in this state. e.g.
        /// 'Evicted'
        /// </summary>
        public Input<string>? Reason { get; set; }

        /// <summary>
        /// RFC 3339 date and time at which the object was acknowledged by the Kubelet. This is
        /// before the Kubelet pulled the container image(s) for the pod.
        /// </summary>
        public Input<string>? StartTime { get; set; }

    }

    /// <summary>
    /// PodTemplate describes a template for creating copies of a predefined pod.
    /// </summary>
    class PodTemplate {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Template defines the pods that will be created from this pod template.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Core.V1.PodTemplateSpec>? Template { get; set; }

    }

    /// <summary>
    /// PodTemplateList is a list of PodTemplates.
    /// </summary>
    class PodTemplateList {
        /// <summary>
        /// List of pod templates
        /// </summary>
        public Input<Input<Core.V1.PodTemplate>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PodTemplateSpec describes the data a pod should have when created from a template
    /// </summary>
    class PodTemplateSpec {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the pod. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Core.V1.PodSpec>? Spec { get; set; }

    }

    /// <summary>
    /// PortworxVolumeSource represents a Portworx volume resource.
    /// </summary>
    class PortworxVolumeSource {
        /// <summary>
        /// VolumeID uniquely identifies a Portworx volume
        /// </summary>
        public Input<string> VolumeID { get; set; } = null!;

        /// <summary>
        /// FSType represents the filesystem type to mount Must be a filesystem type supported by
        /// the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if
        /// unspecified.
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a
    /// no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
    /// </summary>
    class PreferredSchedulingTerm {
        /// <summary>
        /// A node selector term, associated with the corresponding weight.
        /// </summary>
        public Input<Core.V1.NodeSelectorTerm> Preference { get; set; } = null!;

        /// <summary>
        /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        /// </summary>
        public Input<int> Weight { get; set; } = null!;

    }

    /// <summary>
    /// Probe describes a health check to be performed against a container to determine whether it
    /// is alive or ready to receive traffic.
    /// </summary>
    class Probe {
        /// <summary>
        /// One and only one of the following should be specified. Exec specifies the action to
        /// take.
        /// </summary>
        public Input<Core.V1.ExecAction>? Exec { get; set; }

        /// <summary>
        /// Minimum consecutive failures for the probe to be considered failed after having
        /// succeeded. Defaults to 3. Minimum value is 1.
        /// </summary>
        public Input<int>? FailureThreshold { get; set; }

        /// <summary>
        /// HTTPGet specifies the http request to perform.
        /// </summary>
        public Input<Core.V1.HTTPGetAction>? HttpGet { get; set; }

        /// <summary>
        /// Number of seconds after the container has started before liveness probes are initiated.
        /// More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        public Input<int>? InitialDelaySeconds { get; set; }

        /// <summary>
        /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        /// </summary>
        public Input<int>? PeriodSeconds { get; set; }

        /// <summary>
        /// Minimum consecutive successes for the probe to be considered successful after having
        /// failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
        /// </summary>
        public Input<int>? SuccessThreshold { get; set; }

        /// <summary>
        /// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        /// </summary>
        public Input<Core.V1.TCPSocketAction>? TcpSocket { get; set; }

        /// <summary>
        /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value
        /// is 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// Represents a projected volume source
    /// </summary>
    class ProjectedVolumeSource {
        /// <summary>
        /// list of volume projections
        /// </summary>
        public Input<Input<Core.V1.VolumeProjection>[]> Sources { get; set; } = null!;

        /// <summary>
        /// Mode bits to use on created files by default. Must be a value between 0 and 0777.
        /// Directories within the path are not affected by this setting. This might be in conflict
        /// with other options that affect the file mode, like fsGroup, and the result can be other
        /// mode bits set.
        /// </summary>
        public Input<int>? DefaultMode { get; set; }

    }

    /// <summary>
    /// Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support
    /// ownership management or SELinux relabeling.
    /// </summary>
    class QuobyteVolumeSource {
        /// <summary>
        /// Registry represents a single or multiple Quobyte Registry services specified as a string
        /// as host:port pair (multiple entries are separated with commas) which acts as the central
        /// registry for volumes
        /// </summary>
        public Input<string> Registry { get; set; } = null!;

        /// <summary>
        /// Volume is a string that references an already created Quobyte volume by name.
        /// </summary>
        public Input<string> Volume { get; set; } = null!;

        /// <summary>
        /// Group to map volume access to Default is no group
        /// </summary>
        public Input<string>? Group { get; set; }

        /// <summary>
        /// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
        /// Defaults to false.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned
        /// Quobyte volumes, value is set by the plugin
        /// </summary>
        public Input<string>? Tenant { get; set; }

        /// <summary>
        /// User to map volume access to Defaults to serivceaccount user
        /// </summary>
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support
    /// ownership management and SELinux relabeling.
    /// </summary>
    class RBDPersistentVolumeSource {
        /// <summary>
        /// The rados image name. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<string> Image { get; set; } = null!;

        /// <summary>
        /// A collection of Ceph monitors. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<Input<string>[]> Monitors { get; set; } = null!;

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#rbd
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<string>? Keyring { get; set; }

        /// <summary>
        /// The rados pool name. Default is rbd. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<string>? Pool { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef is name of the authentication secret for RBDUser. If provided overrides
        /// keyring. Default is nil. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<Core.V1.SecretReference>? SecretRef { get; set; }

        /// <summary>
        /// The rados user name. Default is admin. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support
    /// ownership management and SELinux relabeling.
    /// </summary>
    class RBDVolumeSource {
        /// <summary>
        /// The rados image name. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<string> Image { get; set; } = null!;

        /// <summary>
        /// A collection of Ceph monitors. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<Input<string>[]> Monitors { get; set; } = null!;

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#rbd
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<string>? Keyring { get; set; }

        /// <summary>
        /// The rados pool name. Default is rbd. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<string>? Pool { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef is name of the authentication secret for RBDUser. If provided overrides
        /// keyring. Default is nil. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<Core.V1.LocalObjectReference>? SecretRef { get; set; }

        /// <summary>
        /// The rados user name. Default is admin. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// ReplicationController represents the configuration of a replication controller.
    /// </summary>
    class ReplicationController {
        /// <summary>
        /// If the Labels of a ReplicationController are empty, they are defaulted to be the same as
        /// the Pod(s) that the replication controller manages. Standard object's metadata. More
        /// info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the specification of the desired behavior of the replication controller.
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Core.V1.ReplicationControllerSpec>? Spec { get; set; }

    }

    /// <summary>
    /// ReplicationControllerCondition describes the state of a replication controller at a certain
    /// point.
    /// </summary>
    class ReplicationControllerCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of replication controller condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ReplicationControllerList is a collection of replication controllers.
    /// </summary>
    class ReplicationControllerList {
        /// <summary>
        /// List of replication controllers. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
        public Input<Input<Core.V1.ReplicationController>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ReplicationControllerSpec is the specification of a replication controller.
    /// </summary>
    class ReplicationControllerSpec {
        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Selector is a label query over pods that should match the Replicas count. If Selector is
        /// empty, it is defaulted to the labels present on the Pod template. Label keys and values
        /// that must match in order to be controlled by this replication controller, if empty
        /// defaulted to labels on Pod template. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public InputMap<string>? Selector { get; set; }

        /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. This takes precedence over a TemplateRef. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        public Input<Core.V1.PodTemplateSpec>? Template { get; set; }

    }

    /// <summary>
    /// ReplicationControllerStatus represents the current status of a replication controller.
    /// </summary>
    class ReplicationControllerStatus {
        /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this
        /// replication controller.
        /// </summary>
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Represents the latest available observations of a replication controller's current
        /// state.
        /// </summary>
        public Input<Input<Core.V1.ReplicationControllerCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replication controller.
        /// </summary>
        public Input<int>? FullyLabeledReplicas { get; set; }

        /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed replication
        /// controller.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The number of ready replicas for this replication controller.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

    }

    /// <summary>
    /// ResourceFieldSelector represents container resources (cpu, memory) and their output format
    /// </summary>
    class ResourceFieldSelector {
        /// <summary>
        /// Required: resource to select
        /// </summary>
        public Input<string> Resource { get; set; } = null!;

        /// <summary>
        /// Container name: required for volumes, optional for env vars
        /// </summary>
        public Input<string>? ContainerName { get; set; }

        /// <summary>
        /// Specifies the output format of the exposed resources, defaults to "1"
        /// </summary>
        public Input<string>? Divisor { get; set; }

    }

    /// <summary>
    /// ResourceQuota sets aggregate quota restrictions enforced per namespace
    /// </summary>
    class ResourceQuota {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired quota.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Core.V1.ResourceQuotaSpec>? Spec { get; set; }

    }

    /// <summary>
    /// ResourceQuotaList is a list of ResourceQuota items.
    /// </summary>
    class ResourceQuotaList {
        /// <summary>
        /// Items is a list of ResourceQuota objects. More info:
        /// https://kubernetes.io/docs/concepts/policy/resource-quotas/
        /// </summary>
        public Input<Input<Core.V1.ResourceQuota>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
    /// </summary>
    class ResourceQuotaSpec {
        /// <summary>
        /// hard is the set of desired hard limits for each named resource. More info:
        /// https://kubernetes.io/docs/concepts/policy/resource-quotas/
        /// </summary>
        public Input<object>? Hard { get; set; }

        /// <summary>
        /// scopeSelector is also a collection of filters like scopes that must match each object
        /// tracked by a quota but expressed using ScopeSelectorOperator in combination with
        /// possible values. For a resource to match, both scopes AND scopeSelector (if specified in
        /// spec), must be matched.
        /// </summary>
        public Input<Core.V1.ScopeSelector>? ScopeSelector { get; set; }

        /// <summary>
        /// A collection of filters that must match each object tracked by a quota. If not
        /// specified, the quota matches all objects.
        /// </summary>
        public Input<Input<string>[]>? Scopes { get; set; }

    }

    /// <summary>
    /// ResourceQuotaStatus defines the enforced hard limits and observed use.
    /// </summary>
    class ResourceQuotaStatus {
        /// <summary>
        /// Hard is the set of enforced hard limits for each named resource. More info:
        /// https://kubernetes.io/docs/concepts/policy/resource-quotas/
        /// </summary>
        public Input<object>? Hard { get; set; }

        /// <summary>
        /// Used is the current observed total usage of the resource in the namespace.
        /// </summary>
        public Input<object>? Used { get; set; }

    }

    /// <summary>
    /// ResourceRequirements describes the compute resource requirements.
    /// </summary>
    class ResourceRequirements {
        /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
        public Input<object>? Limits { get; set; }

        /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is
        /// omitted for a container, it defaults to Limits if that is explicitly specified,
        /// otherwise to an implementation-defined value. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
        public Input<object>? Requests { get; set; }

    }

    /// <summary>
    /// SELinuxOptions are the labels to be applied to the container
    /// </summary>
    class SELinuxOptions {
        /// <summary>
        /// Level is SELinux level label that applies to the container.
        /// </summary>
        public Input<string>? Level { get; set; }

        /// <summary>
        /// Role is a SELinux role label that applies to the container.
        /// </summary>
        public Input<string>? Role { get; set; }

        /// <summary>
        /// Type is a SELinux type label that applies to the container.
        /// </summary>
        public Input<string>? Type { get; set; }

        /// <summary>
        /// User is a SELinux user label that applies to the container.
        /// </summary>
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
    /// </summary>
    class ScaleIOPersistentVolumeSource {
        /// <summary>
        /// The host address of the ScaleIO API Gateway.
        /// </summary>
        public Input<string> Gateway { get; set; } = null!;

        /// <summary>
        /// SecretRef references to the secret for ScaleIO user and other sensitive information. If
        /// this is not provided, Login operation will fail.
        /// </summary>
        public Input<Core.V1.SecretReference> SecretRef { get; set; } = null!;

        /// <summary>
        /// The name of the storage system as configured in ScaleIO.
        /// </summary>
        public Input<string> System { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Default is "xfs"
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// The name of the ScaleIO Protection Domain for the configured storage.
        /// </summary>
        public Input<string>? ProtectionDomain { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Flag to enable/disable SSL communication with Gateway, default false
        /// </summary>
        public Input<bool>? SslEnabled { get; set; }

        /// <summary>
        /// Indicates whether the storage for a volume should be ThickProvisioned or
        /// ThinProvisioned. Default is ThinProvisioned.
        /// </summary>
        public Input<string>? StorageMode { get; set; }

        /// <summary>
        /// The ScaleIO Storage Pool associated with the protection domain.
        /// </summary>
        public Input<string>? StoragePool { get; set; }

        /// <summary>
        /// The name of a volume already created in the ScaleIO system that is associated with this
        /// volume source.
        /// </summary>
        public Input<string>? VolumeName { get; set; }

    }

    /// <summary>
    /// ScaleIOVolumeSource represents a persistent ScaleIO volume
    /// </summary>
    class ScaleIOVolumeSource {
        /// <summary>
        /// The host address of the ScaleIO API Gateway.
        /// </summary>
        public Input<string> Gateway { get; set; } = null!;

        /// <summary>
        /// SecretRef references to the secret for ScaleIO user and other sensitive information. If
        /// this is not provided, Login operation will fail.
        /// </summary>
        public Input<Core.V1.LocalObjectReference> SecretRef { get; set; } = null!;

        /// <summary>
        /// The name of the storage system as configured in ScaleIO.
        /// </summary>
        public Input<string> System { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// The name of the ScaleIO Protection Domain for the configured storage.
        /// </summary>
        public Input<string>? ProtectionDomain { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Flag to enable/disable SSL communication with Gateway, default false
        /// </summary>
        public Input<bool>? SslEnabled { get; set; }

        /// <summary>
        /// Indicates whether the storage for a volume should be ThickProvisioned or
        /// ThinProvisioned. Default is ThinProvisioned.
        /// </summary>
        public Input<string>? StorageMode { get; set; }

        /// <summary>
        /// The ScaleIO Storage Pool associated with the protection domain.
        /// </summary>
        public Input<string>? StoragePool { get; set; }

        /// <summary>
        /// The name of a volume already created in the ScaleIO system that is associated with this
        /// volume source.
        /// </summary>
        public Input<string>? VolumeName { get; set; }

    }

    /// <summary>
    /// A scope selector represents the AND of the selectors represented by the scoped-resource
    /// selector requirements.
    /// </summary>
    class ScopeSelector {
        /// <summary>
        /// A list of scope selector requirements by scope of the resources.
        /// </summary>
        public Input<Input<Core.V1.ScopedResourceSelectorRequirement>[]>? MatchExpressions { get; set; }

    }

    /// <summary>
    /// A scoped-resource selector requirement is a selector that contains values, a scope name, and
    /// an operator that relates the scope name and values.
    /// </summary>
    class ScopedResourceSelectorRequirement {
        /// <summary>
        /// Represents a scope's relationship to a set of values. Valid operators are In, NotIn,
        /// Exists, DoesNotExist.
        /// </summary>
        public Input<string> Operator { get; set; } = null!;

        /// <summary>
        /// The name of the scope that the selector applies to.
        /// </summary>
        public Input<string> ScopeName { get; set; } = null!;

        /// <summary>
        /// An array of string values. If the operator is In or NotIn, the values array must be
        /// non-empty. If the operator is Exists or DoesNotExist, the values array must be empty.
        /// This array is replaced during a strategic merge patch.
        /// </summary>
        public Input<Input<string>[]>? Values { get; set; }

    }

    /// <summary>
    /// Secret holds secret data of a certain type. The total bytes of the values in the Data field
    /// must be less than MaxSecretSize bytes.
    /// </summary>
    class Secret {
        /// <summary>
        /// Data contains the secret data. Each key must consist of alphanumeric characters, '-',
        /// '_' or '.'. The serialized form of the secret data is a base64 encoded string,
        /// representing the arbitrary (possibly non-string) data value here. Described in
        /// https://tools.ietf.org/html/rfc4648#section-4
        /// </summary>
        public Input<object>? Data { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// stringData allows specifying non-binary secret data in string form. It is provided as a
        /// write-only convenience method. All keys and values are merged into the data field on
        /// write, overwriting any existing values. It is never output when reading from the API.
        /// </summary>
        public InputMap<string>? StringData { get; set; }

        /// <summary>
        /// Used to facilitate programmatic handling of secret data.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// SecretEnvSource selects a Secret to populate the environment variables with.
    /// 
    /// The contents of the target Secret's Data field will represent the key-value pairs as
    /// environment variables.
    /// </summary>
    class SecretEnvSource {
        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the Secret must be defined
        /// </summary>
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// SecretKeySelector selects a key of a Secret.
    /// </summary>
    class SecretKeySelector {
        /// <summary>
        /// The key of the secret to select from.  Must be a valid secret key.
        /// </summary>
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the Secret or its key must be defined
        /// </summary>
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// SecretList is a list of Secret.
    /// </summary>
    class SecretList {
        /// <summary>
        /// Items is a list of secret objects. More info:
        /// https://kubernetes.io/docs/concepts/configuration/secret
        /// </summary>
        public Input<Input<Core.V1.Secret>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// Adapts a secret into a projected volume.
    /// 
    /// The contents of the target Secret's Data field will be presented in a projected volume as
    /// files using the keys in the Data field as the file names. Note that this is identical to a
    /// secret volume source without the default mode.
    /// </summary>
    class SecretProjection {
        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced Secret will be
        /// projected into the volume as a file whose name is the key and content is the value. If
        /// specified, the listed keys will be projected into the specified paths, and unlisted keys
        /// will not be present. If a key is specified which is not present in the Secret, the
        /// volume setup will error unless it is marked optional. Paths must be relative and may not
        /// contain the '..' path or start with '..'.
        /// </summary>
        public Input<Input<Core.V1.KeyToPath>[]>? Items { get; set; }

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the Secret or its key must be defined
        /// </summary>
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// SecretReference represents a Secret Reference. It has enough information to retrieve secret
    /// in any namespace
    /// </summary>
    class SecretReference {
        /// <summary>
        /// Name is unique within a namespace to reference a secret resource.
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace defines the space within which the secret name must be unique.
        /// </summary>
        public Input<string>? Namespace { get; set; }

    }

    /// <summary>
    /// Adapts a Secret into a volume.
    /// 
    /// The contents of the target Secret's Data field will be presented in a volume as files using
    /// the keys in the Data field as the file names. Secret volumes support ownership management
    /// and SELinux relabeling.
    /// </summary>
    class SecretVolumeSource {
        /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a value between 0 and
        /// 0777. Defaults to 0644. Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file mode, like fsGroup,
        /// and the result can be other mode bits set.
        /// </summary>
        public Input<int>? DefaultMode { get; set; }

        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced Secret will be
        /// projected into the volume as a file whose name is the key and content is the value. If
        /// specified, the listed keys will be projected into the specified paths, and unlisted keys
        /// will not be present. If a key is specified which is not present in the Secret, the
        /// volume setup will error unless it is marked optional. Paths must be relative and may not
        /// contain the '..' path or start with '..'.
        /// </summary>
        public Input<Input<Core.V1.KeyToPath>[]>? Items { get; set; }

        /// <summary>
        /// Specify whether the Secret or its keys must be defined
        /// </summary>
        public Input<bool>? Optional { get; set; }

        /// <summary>
        /// Name of the secret in the pod's namespace to use. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#secret
        /// </summary>
        public Input<string>? SecretName { get; set; }

    }

    /// <summary>
    /// SecurityContext holds security configuration that will be applied to a container. Some
    /// fields are present in both SecurityContext and PodSecurityContext.  When both are set, the
    /// values in SecurityContext take precedence.
    /// </summary>
    class SecurityContext {
        /// <summary>
        /// AllowPrivilegeEscalation controls whether a process can gain more privileges than its
        /// parent process. This bool directly controls if the no_new_privs flag will be set on the
        /// container process. AllowPrivilegeEscalation is true always when the container is: 1) run
        /// as Privileged 2) has CAP_SYS_ADMIN
        /// </summary>
        public Input<bool>? AllowPrivilegeEscalation { get; set; }

        /// <summary>
        /// The capabilities to add/drop when running containers. Defaults to the default set of
        /// capabilities granted by the container runtime.
        /// </summary>
        public Input<Core.V1.Capabilities>? Capabilities { get; set; }

        /// <summary>
        /// Run container in privileged mode. Processes in privileged containers are essentially
        /// equivalent to root on the host. Defaults to false.
        /// </summary>
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// procMount denotes the type of proc mount to use for the containers. The default is
        /// DefaultProcMount which uses the container runtime defaults for readonly paths and masked
        /// paths. This requires the ProcMountType feature flag to be enabled.
        /// </summary>
        public Input<string>? ProcMount { get; set; }

        /// <summary>
        /// Whether this container has a read-only root filesystem. Default is false.
        /// </summary>
        public Input<bool>? ReadOnlyRootFilesystem { get; set; }

        /// <summary>
        /// The GID to run the entrypoint of the container process. Uses runtime default if unset.
        /// May also be set in PodSecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        public Input<int>? RunAsGroup { get; set; }

        /// <summary>
        /// Indicates that the container must run as a non-root user. If true, the Kubelet will
        /// validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to
        /// start the container if it does. If unset or false, no such validation will be performed.
        /// May also be set in PodSecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        public Input<bool>? RunAsNonRoot { get; set; }

        /// <summary>
        /// The UID to run the entrypoint of the container process. Defaults to user specified in
        /// image metadata if unspecified. May also be set in PodSecurityContext.  If set in both
        /// SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
        /// precedence.
        /// </summary>
        public Input<int>? RunAsUser { get; set; }

        /// <summary>
        /// The SELinux context to be applied to the container. If unspecified, the container
        /// runtime will allocate a random SELinux context for each container.  May also be set in
        /// PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value
        /// specified in SecurityContext takes precedence.
        /// </summary>
        public Input<Core.V1.SELinuxOptions>? SeLinuxOptions { get; set; }

        /// <summary>
        /// The Windows specific settings applied to all containers. If unspecified, the options
        /// from the PodSecurityContext will be used. If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        public Input<Core.V1.WindowsSecurityContextOptions>? WindowsOptions { get; set; }

    }

    /// <summary>
    /// Service is a named abstraction of software service (for example, mysql) consisting of local
    /// port (for example 3306) that the proxy listens on, and the selector that determines which
    /// pods will answer requests sent through the proxy.
    /// </summary>
    class Service {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the behavior of a service.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Core.V1.ServiceSpec>? Spec { get; set; }

    }

    /// <summary>
    /// ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral
    /// systems, for an identity * a principal that can be authenticated and authorized * a set of
    /// secrets
    /// </summary>
    class ServiceAccount {
        /// <summary>
        /// AutomountServiceAccountToken indicates whether pods running as this service account
        /// should have an API token automatically mounted. Can be overridden at the pod level.
        /// </summary>
        public Input<bool>? AutomountServiceAccountToken { get; set; }

        /// <summary>
        /// ImagePullSecrets is a list of references to secrets in the same namespace to use for
        /// pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are
        /// distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets
        /// are only accessed by the kubelet. More info:
        /// https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        /// </summary>
        public Input<Input<Core.V1.LocalObjectReference>[]>? ImagePullSecrets { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Secrets is the list of secrets allowed to be used by pods running using this
        /// ServiceAccount. More info: https://kubernetes.io/docs/concepts/configuration/secret
        /// </summary>
        public Input<Input<Core.V1.ObjectReference>[]>? Secrets { get; set; }

    }

    /// <summary>
    /// ServiceAccountList is a list of ServiceAccount objects
    /// </summary>
    class ServiceAccountList {
        /// <summary>
        /// List of ServiceAccounts. More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        /// </summary>
        public Input<Input<Core.V1.ServiceAccount>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ServiceAccountTokenProjection represents a projected service account token volume. This
    /// projection can be used to insert a service account token into the pods runtime filesystem
    /// for use against APIs (Kubernetes API Server or otherwise).
    /// </summary>
    class ServiceAccountTokenProjection {
        /// <summary>
        /// Path is the path relative to the mount point of the file to project the token into.
        /// </summary>
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Audience is the intended audience of the token. A recipient of a token must identify
        /// itself with an identifier specified in the audience of the token, and otherwise should
        /// reject the token. The audience defaults to the identifier of the apiserver.
        /// </summary>
        public Input<string>? Audience { get; set; }

        /// <summary>
        /// ExpirationSeconds is the requested duration of validity of the service account token. As
        /// the token approaches expiration, the kubelet volume plugin will proactively rotate the
        /// service account token. The kubelet will start trying to rotate the token if the token is
        /// older than 80 percent of its time to live or if the token is older than 24
        /// hours.Defaults to 1 hour and must be at least 10 minutes.
        /// </summary>
        public Input<int>? ExpirationSeconds { get; set; }

    }

    /// <summary>
    /// ServiceList holds a list of services.
    /// </summary>
    class ServiceList {
        /// <summary>
        /// List of services
        /// </summary>
        public Input<Input<Core.V1.Service>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ServicePort contains information on service's port.
    /// </summary>
    class ServicePort {
        /// <summary>
        /// The port that will be exposed by this service.
        /// </summary>
        public Input<int> Port { get; set; } = null!;

        /// <summary>
        /// The name of this port within the service. This must be a DNS_LABEL. All ports within a
        /// ServiceSpec must have unique names. When considering the endpoints for a Service, this
        /// must match the 'name' field in the EndpointPort. Optional if only one ServicePort is
        /// defined on this service.
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The port on each node on which this service is exposed when type=NodePort or
        /// LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the
        /// service if unused or else creation of the service will fail. Default is to auto-allocate
        /// a port if the ServiceType of this Service requires one. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
        /// </summary>
        public Input<int>? NodePort { get; set; }

        /// <summary>
        /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
        /// </summary>
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// Number or name of the port to access on the pods targeted by the service. Number must be
        /// in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be
        /// looked up as a named port in the target Pod's container ports. If this is not specified,
        /// the value of the 'port' field is used (an identity map). This field is ignored for
        /// services with clusterIP=None, and should be omitted or set equal to the 'port' field.
        /// More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
        /// </summary>
        public Input<int /* TODO: or string */>? TargetPort { get; set; }

    }

    /// <summary>
    /// ServiceSpec describes the attributes that a user creates on a service.
    /// </summary>
    class ServiceSpec {
        /// <summary>
        /// clusterIP is the IP address of the service and is usually assigned randomly by the
        /// master. If an address is specified manually and is not in use by others, it will be
        /// allocated to the service; otherwise, creation of the service will fail. This field can
        /// not be changed through updates. Valid values are "None", empty string (""), or a valid
        /// IP address. "None" can be specified for headless services when proxying is not required.
        /// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is
        /// ExternalName. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        public Input<string>? ClusterIP { get; set; }

        /// <summary>
        /// externalIPs is a list of IP addresses for which nodes in the cluster will also accept
        /// traffic for this service.  These IPs are not managed by Kubernetes.  The user is
        /// responsible for ensuring that traffic arrives at a node with this IP.  A common example
        /// is external load-balancers that are not part of the Kubernetes system.
        /// </summary>
        public Input<Input<string>[]>? ExternalIPs { get; set; }

        /// <summary>
        /// externalName is the external reference that kubedns or equivalent will return as a CNAME
        /// record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname
        /// (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
        /// </summary>
        public Input<string>? ExternalName { get; set; }

        /// <summary>
        /// externalTrafficPolicy denotes if this Service desires to route external traffic to
        /// node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids
        /// a second hop for LoadBalancer and Nodeport type services, but risks potentially
        /// imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a
        /// second hop to another node, but should have good overall load-spreading.
        /// </summary>
        public Input<string>? ExternalTrafficPolicy { get; set; }

        /// <summary>
        /// healthCheckNodePort specifies the healthcheck nodePort for the service. If not
        /// specified, HealthCheckNodePort is created by the service api backend with the allocated
        /// nodePort. Will use user-specified nodePort value if specified by the client. Only
        /// effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
        /// </summary>
        public Input<int>? HealthCheckNodePort { get; set; }

        /// <summary>
        /// ipFamily specifies whether this Service has a preference for a particular IP family
        /// (e.g. IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be
        /// allocated from that family, if it is available in the cluster.  If no IP family is
        /// requested, the cluster's primary IP family will be used. Other IP fields
        /// (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which allocate
        /// external load-balancers should use the same IP family.  Endpoints for this Service will
        /// be of this family.  This field is immutable after creation. Assigning a ServiceIPFamily
        /// not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and
        /// will fail during clusterIP assignment.
        /// </summary>
        public Input<string>? IpFamily { get; set; }

        /// <summary>
        /// Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP
        /// specified in this field. This feature depends on whether the underlying cloud-provider
        /// supports specifying the loadBalancerIP when a load balancer is created. This field will
        /// be ignored if the cloud-provider does not support the feature.
        /// </summary>
        public Input<string>? LoadBalancerIP { get; set; }

        /// <summary>
        /// If specified and supported by the platform, this will restrict traffic through the
        /// cloud-provider load-balancer will be restricted to the specified client IPs. This field
        /// will be ignored if the cloud-provider does not support the feature." More info:
        /// https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
        /// </summary>
        public Input<Input<string>[]>? LoadBalancerSourceRanges { get; set; }

        /// <summary>
        /// The list of ports that are exposed by this service. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        public Input<Input<Core.V1.ServicePort>[]>? Ports { get; set; }

        /// <summary>
        /// publishNotReadyAddresses, when set to true, indicates that DNS implementations must
        /// publish the notReadyAddresses of subsets for the Endpoints associated with the Service.
        /// The default value is false. The primary use case for setting this field is to use a
        /// StatefulSet's Headless Service to propagate SRV records for its Pods without respect to
        /// their readiness for purpose of peer discovery.
        /// </summary>
        public Input<bool>? PublishNotReadyAddresses { get; set; }

        /// <summary>
        /// Route service traffic to pods with label keys and values matching this selector. If
        /// empty or not present, the service is assumed to have an external process managing its
        /// endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort,
        /// and LoadBalancer. Ignored if type is ExternalName. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/
        /// </summary>
        public InputMap<string>? Selector { get; set; }

        /// <summary>
        /// Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP
        /// based session affinity. Must be ClientIP or None. Defaults to None. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        public Input<string>? SessionAffinity { get; set; }

        /// <summary>
        /// sessionAffinityConfig contains the configurations of session affinity.
        /// </summary>
        public Input<Core.V1.SessionAffinityConfig>? SessionAffinityConfig { get; set; }

        /// <summary>
        /// type determines how the Service is exposed. Defaults to ClusterIP. Valid options are
        /// ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the
        /// specified externalName. "ClusterIP" allocates a cluster-internal IP address for
        /// load-balancing to endpoints. Endpoints are determined by the selector or if that is not
        /// specified, by manual construction of an Endpoints object. If clusterIP is "None", no
        /// virtual IP is allocated and the endpoints are published as a set of endpoints rather
        /// than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node
        /// which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external
        /// load-balancer (if supported in the current cloud) which routes to the clusterIP. More
        /// info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// ServiceStatus represents the current status of a service.
    /// </summary>
    class ServiceStatus {
        /// <summary>
        /// LoadBalancer contains the current status of the load-balancer, if one is present.
        /// </summary>
        public Input<Core.V1.LoadBalancerStatus>? LoadBalancer { get; set; }

    }

    /// <summary>
    /// SessionAffinityConfig represents the configurations of session affinity.
    /// </summary>
    class SessionAffinityConfig {
        /// <summary>
        /// clientIP contains the configurations of Client IP based session affinity.
        /// </summary>
        public Input<Core.V1.ClientIPConfig>? ClientIP { get; set; }

    }

    /// <summary>
    /// Represents a StorageOS persistent volume resource.
    /// </summary>
    class StorageOSPersistentVolumeSource {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If
        /// not specified, default values will be attempted.
        /// </summary>
        public Input<Core.V1.ObjectReference>? SecretRef { get; set; }

        /// <summary>
        /// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only
        /// unique within a namespace.
        /// </summary>
        public Input<string>? VolumeName { get; set; }

        /// <summary>
        /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is
        /// specified then the Pod's namespace will be used.  This allows the Kubernetes name
        /// scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any
        /// name to override the default behaviour. Set to "default" if you are not using namespaces
        /// within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
        /// </summary>
        public Input<string>? VolumeNamespace { get; set; }

    }

    /// <summary>
    /// Represents a StorageOS persistent volume resource.
    /// </summary>
    class StorageOSVolumeSource {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If
        /// not specified, default values will be attempted.
        /// </summary>
        public Input<Core.V1.LocalObjectReference>? SecretRef { get; set; }

        /// <summary>
        /// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only
        /// unique within a namespace.
        /// </summary>
        public Input<string>? VolumeName { get; set; }

        /// <summary>
        /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is
        /// specified then the Pod's namespace will be used.  This allows the Kubernetes name
        /// scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any
        /// name to override the default behaviour. Set to "default" if you are not using namespaces
        /// within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
        /// </summary>
        public Input<string>? VolumeNamespace { get; set; }

    }

    /// <summary>
    /// Sysctl defines a kernel parameter to be set
    /// </summary>
    class Sysctl {
        /// <summary>
        /// Name of a property to set
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Value of a property to set
        /// </summary>
        public Input<string> Value { get; set; } = null!;

    }

    /// <summary>
    /// TCPSocketAction describes an action based on opening a socket
    /// </summary>
    class TCPSocketAction {
        /// <summary>
        /// Number or name of the port to access on the container. Number must be in the range 1 to
        /// 65535. Name must be an IANA_SVC_NAME.
        /// </summary>
        public Input<int /* TODO: or string */> Port { get; set; } = null!;

        /// <summary>
        /// Optional: Host name to connect to, defaults to the pod IP.
        /// </summary>
        public Input<string>? Host { get; set; }

    }

    /// <summary>
    /// The node this Taint is attached to has the "effect" on any pod that does not tolerate the
    /// Taint.
    /// </summary>
    class Taint {
        /// <summary>
        /// Required. The effect of the taint on pods that do not tolerate the taint. Valid effects
        /// are NoSchedule, PreferNoSchedule and NoExecute.
        /// </summary>
        public Input<string> Effect { get; set; } = null!;

        /// <summary>
        /// Required. The taint key to be applied to a node.
        /// </summary>
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// TimeAdded represents the time at which the taint was added. It is only written for
        /// NoExecute taints.
        /// </summary>
        public Input<string>? TimeAdded { get; set; }

        /// <summary>
        /// Required. The taint value corresponding to the taint key.
        /// </summary>
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// The pod this Toleration is attached to tolerates any taint that matches the triple
    /// &lt;key,value,effect&gt; using the matching operator &lt;operator&gt;.
    /// </summary>
    class Toleration {
        /// <summary>
        /// Effect indicates the taint effect to match. Empty means match all taint effects. When
        /// specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        /// </summary>
        public Input<string>? Effect { get; set; }

        /// <summary>
        /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
        /// If the key is empty, operator must be Exists; this combination means to match all values
        /// and all keys.
        /// </summary>
        public Input<string>? Key { get; set; }

        /// <summary>
        /// Operator represents a key's relationship to the value. Valid operators are Exists and
        /// Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can
        /// tolerate all taints of a particular category.
        /// </summary>
        public Input<string>? Operator { get; set; }

        /// <summary>
        /// TolerationSeconds represents the period of time the toleration (which must be of effect
        /// NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not
        /// set, which means tolerate the taint forever (do not evict). Zero and negative values
        /// will be treated as 0 (evict immediately) by the system.
        /// </summary>
        public Input<int>? TolerationSeconds { get; set; }

        /// <summary>
        /// Value is the taint value the toleration matches to. If the operator is Exists, the value
        /// should be empty, otherwise just a regular string.
        /// </summary>
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// A topology selector requirement is a selector that matches given label. This is an alpha
    /// feature and may change in the future.
    /// </summary>
    class TopologySelectorLabelRequirement {
        /// <summary>
        /// The label key that the selector applies to.
        /// </summary>
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// An array of string values. One value must match the label to be selected. Each entry in
        /// Values is ORed.
        /// </summary>
        public Input<Input<string>[]> Values { get; set; } = null!;

    }

    /// <summary>
    /// A topology selector term represents the result of label queries. A null or empty topology
    /// selector term matches no objects. The requirements of them are ANDed. It provides a subset
    /// of functionality as NodeSelectorTerm. This is an alpha feature and may change in the future.
    /// </summary>
    class TopologySelectorTerm {
        /// <summary>
        /// A list of topology selector requirements by labels.
        /// </summary>
        public Input<Input<Core.V1.TopologySelectorLabelRequirement>[]>? MatchLabelExpressions { get; set; }

    }

    /// <summary>
    /// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
    /// </summary>
    class TopologySpreadConstraint {
        /// <summary>
        /// MaxSkew describes the degree to which pods may be unevenly distributed. It's the maximum
        /// permitted difference between the number of matching pods in any two topology domains of
        /// a given topology type. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods
        /// with the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |
        /// | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
        /// scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate
        /// MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. It's a
        /// required field. Default value is 1 and 0 is not allowed.
        /// </summary>
        public Input<int> MaxSkew { get; set; } = null!;

        /// <summary>
        /// TopologyKey is the key of node labels. Nodes that have a label with this key and
        /// identical values are considered to be in the same topology. We consider each &lt;key,
        /// value&gt; as a "bucket", and try to put balanced number of pods into each bucket. It's a
        /// required field.
        /// </summary>
        public Input<string> TopologyKey { get; set; } = null!;

        /// <summary>
        /// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread
        /// constraint. - DoNotSchedule (default) tells the scheduler not to schedule it -
        /// ScheduleAnyway tells the scheduler to still schedule it It's considered as
        /// "Unsatisfiable" if and only if placing incoming pod on any topology violates "MaxSkew".
        /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
        /// labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If
        /// WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to
        /// zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
        /// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't
        /// make it *more* imbalanced. It's a required field.
        /// </summary>
        public Input<string> WhenUnsatisfiable { get; set; } = null!;

        /// <summary>
        /// LabelSelector is used to find matching pods. Pods that match this label selector are
        /// counted to determine the number of pods in their corresponding topology domain.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? LabelSelector { get; set; }

    }

    /// <summary>
    /// TypedLocalObjectReference contains enough information to let you locate the typed referenced
    /// object inside the same namespace.
    /// </summary>
    class TypedLocalObjectReference {
        /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified,
        /// the specified Kind must be in the core API group. For any other third-party types,
        /// APIGroup is required.
        /// </summary>
        public Input<string>? ApiGroup { get; set; }

    }

    /// <summary>
    /// Volume represents a named volume in a pod that may be accessed by any container in the pod.
    /// </summary>
    class Volume {
        /// <summary>
        /// Volume's name. Must be a DNS_LABEL and unique within the pod. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's
        /// host machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        public Input<Core.V1.AWSElasticBlockStoreVolumeSource>? AwsElasticBlockStore { get; set; }

        /// <summary>
        /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
        /// </summary>
        public Input<Core.V1.AzureDiskVolumeSource>? AzureDisk { get; set; }

        /// <summary>
        /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
        /// </summary>
        public Input<Core.V1.AzureFileVolumeSource>? AzureFile { get; set; }

        /// <summary>
        /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
        /// </summary>
        public Input<Core.V1.CephFSVolumeSource>? Cephfs { get; set; }

        /// <summary>
        /// Cinder represents a cinder volume attached and mounted on kubelets host machine. More
        /// info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        public Input<Core.V1.CinderVolumeSource>? Cinder { get; set; }

        /// <summary>
        /// ConfigMap represents a configMap that should populate this volume
        /// </summary>
        public Input<Core.V1.ConfigMapVolumeSource>? ConfigMap { get; set; }

        /// <summary>
        /// CSI (Container Storage Interface) represents storage that is handled by an external CSI
        /// driver (Alpha feature).
        /// </summary>
        public Input<Core.V1.CSIVolumeSource>? Csi { get; set; }

        /// <summary>
        /// DownwardAPI represents downward API about the pod that should populate this volume
        /// </summary>
        public Input<Core.V1.DownwardAPIVolumeSource>? DownwardAPI { get; set; }

        /// <summary>
        /// EmptyDir represents a temporary directory that shares a pod's lifetime. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        /// </summary>
        public Input<Core.V1.EmptyDirVolumeSource>? EmptyDir { get; set; }

        /// <summary>
        /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and
        /// then exposed to the pod.
        /// </summary>
        public Input<Core.V1.FCVolumeSource>? Fc { get; set; }

        /// <summary>
        /// FlexVolume represents a generic volume resource that is provisioned/attached using an
        /// exec based plugin.
        /// </summary>
        public Input<Core.V1.FlexVolumeSource>? FlexVolume { get; set; }

        /// <summary>
        /// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends
        /// on the Flocker control service being running
        /// </summary>
        public Input<Core.V1.FlockerVolumeSource>? Flocker { get; set; }

        /// <summary>
        /// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host
        /// machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        public Input<Core.V1.GCEPersistentDiskVolumeSource>? GcePersistentDisk { get; set; }

        /// <summary>
        /// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is
        /// deprecated. To provision a container with a git repo, mount an EmptyDir into an
        /// InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's
        /// container.
        /// </summary>
        public Input<Core.V1.GitRepoVolumeSource>? GitRepo { get; set; }

        /// <summary>
        /// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More
        /// info: https://examples.k8s.io/volumes/glusterfs/README.md
        /// </summary>
        public Input<Core.V1.GlusterfsVolumeSource>? Glusterfs { get; set; }

        /// <summary>
        /// HostPath represents a pre-existing file or directory on the host machine that is
        /// directly exposed to the container. This is generally used for system agents or other
        /// privileged things that are allowed to see the host machine. Most containers will NOT
        /// need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        public Input<Core.V1.HostPathVolumeSource>? HostPath { get; set; }

        /// <summary>
        /// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and
        /// then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
        /// </summary>
        public Input<Core.V1.ISCSIVolumeSource>? Iscsi { get; set; }

        /// <summary>
        /// NFS represents an NFS mount on the host that shares a pod's lifetime More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        public Input<Core.V1.NFSVolumeSource>? Nfs { get; set; }

        /// <summary>
        /// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in
        /// the same namespace. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        public Input<Core.V1.PersistentVolumeClaimVolumeSource>? PersistentVolumeClaim { get; set; }

        /// <summary>
        /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted
        /// on kubelets host machine
        /// </summary>
        public Input<Core.V1.PhotonPersistentDiskVolumeSource>? PhotonPersistentDisk { get; set; }

        /// <summary>
        /// PortworxVolume represents a portworx volume attached and mounted on kubelets host
        /// machine
        /// </summary>
        public Input<Core.V1.PortworxVolumeSource>? PortworxVolume { get; set; }

        /// <summary>
        /// Items for all in one resources secrets, configmaps, and downward API
        /// </summary>
        public Input<Core.V1.ProjectedVolumeSource>? Projected { get; set; }

        /// <summary>
        /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        /// </summary>
        public Input<Core.V1.QuobyteVolumeSource>? Quobyte { get; set; }

        /// <summary>
        /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md
        /// </summary>
        public Input<Core.V1.RBDVolumeSource>? Rbd { get; set; }

        /// <summary>
        /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
        /// </summary>
        public Input<Core.V1.ScaleIOVolumeSource>? ScaleIO { get; set; }

        /// <summary>
        /// Secret represents a secret that should populate this volume. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#secret
        /// </summary>
        public Input<Core.V1.SecretVolumeSource>? Secret { get; set; }

        /// <summary>
        /// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
        /// </summary>
        public Input<Core.V1.StorageOSVolumeSource>? Storageos { get; set; }

        /// <summary>
        /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
        /// </summary>
        public Input<Core.V1.VsphereVirtualDiskVolumeSource>? VsphereVolume { get; set; }

    }

    /// <summary>
    /// volumeDevice describes a mapping of a raw block device within a container.
    /// </summary>
    class VolumeDevice {
        /// <summary>
        /// devicePath is the path inside of the container that the device will be mapped to.
        /// </summary>
        public Input<string> DevicePath { get; set; } = null!;

        /// <summary>
        /// name must match the name of a persistentVolumeClaim in the pod
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// VolumeMount describes a mounting of a Volume within a container.
    /// </summary>
    class VolumeMount {
        /// <summary>
        /// Path within the container at which the volume should be mounted.  Must not contain ':'.
        /// </summary>
        public Input<string> MountPath { get; set; } = null!;

        /// <summary>
        /// This must match the Name of a Volume.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// mountPropagation determines how mounts are propagated from the host to container and the
        /// other way around. When not set, MountPropagationNone is used. This field is beta in
        /// 1.10.
        /// </summary>
        public Input<string>? MountPropagation { get; set; }

        /// <summary>
        /// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to
        /// false.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Path within the volume from which the container's volume should be mounted. Defaults to
        /// "" (volume's root).
        /// </summary>
        public Input<string>? SubPath { get; set; }

        /// <summary>
        /// Expanded path within the volume from which the container's volume should be mounted.
        /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are
        /// expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr
        /// and SubPath are mutually exclusive. This field is beta in 1.15.
        /// </summary>
        public Input<string>? SubPathExpr { get; set; }

    }

    /// <summary>
    /// VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed
    /// from.
    /// </summary>
    class VolumeNodeAffinity {
        /// <summary>
        /// Required specifies hard node constraints that must be met.
        /// </summary>
        public Input<Core.V1.NodeSelector>? Required { get; set; }

    }

    /// <summary>
    /// Projection that may be projected along with other supported volume types
    /// </summary>
    class VolumeProjection {
        /// <summary>
        /// information about the configMap data to project
        /// </summary>
        public Input<Core.V1.ConfigMapProjection>? ConfigMap { get; set; }

        /// <summary>
        /// information about the downwardAPI data to project
        /// </summary>
        public Input<Core.V1.DownwardAPIProjection>? DownwardAPI { get; set; }

        /// <summary>
        /// information about the secret data to project
        /// </summary>
        public Input<Core.V1.SecretProjection>? Secret { get; set; }

        /// <summary>
        /// information about the serviceAccountToken data to project
        /// </summary>
        public Input<Core.V1.ServiceAccountTokenProjection>? ServiceAccountToken { get; set; }

    }

    /// <summary>
    /// Represents a vSphere volume resource.
    /// </summary>
    class VsphereVirtualDiskVolumeSource {
        /// <summary>
        /// Path that identifies vSphere volume vmdk
        /// </summary>
        public Input<string> VolumePath { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
        /// </summary>
        public Input<string>? StoragePolicyID { get; set; }

        /// <summary>
        /// Storage Policy Based Management (SPBM) profile name.
        /// </summary>
        public Input<string>? StoragePolicyName { get; set; }

    }

    /// <summary>
    /// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find
    /// the most preferred node(s)
    /// </summary>
    class WeightedPodAffinityTerm {
        /// <summary>
        /// Required. A pod affinity term, associated with the corresponding weight.
        /// </summary>
        public Input<Core.V1.PodAffinityTerm> PodAffinityTerm { get; set; } = null!;

        /// <summary>
        /// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        /// </summary>
        public Input<int> Weight { get; set; } = null!;

    }

    /// <summary>
    /// WindowsSecurityContextOptions contain Windows-specific options and credentials.
    /// </summary>
    class WindowsSecurityContextOptions {
        /// <summary>
        /// GMSACredentialSpec is where the GMSA admission webhook
        /// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA
        /// credential spec named by the GMSACredentialSpecName field. This field is alpha-level and
        /// is only honored by servers that enable the WindowsGMSA feature flag.
        /// </summary>
        public Input<string>? GmsaCredentialSpec { get; set; }

        /// <summary>
        /// GMSACredentialSpecName is the name of the GMSA credential spec to use. This field is
        /// alpha-level and is only honored by servers that enable the WindowsGMSA feature flag.
        /// </summary>
        public Input<string>? GmsaCredentialSpecName { get; set; }

        /// <summary>
        /// The UserName in Windows to run the entrypoint of the container process. Defaults to the
        /// user specified in image metadata if unspecified. May also be set in PodSecurityContext.
        /// If set in both SecurityContext and PodSecurityContext, the value specified in
        /// SecurityContext takes precedence. This field is alpha-level and it is only honored by
        /// servers that enable the WindowsRunAsUserName feature flag.
        /// </summary>
        public Input<string>? RunAsUserName { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Discovery {
  namespace V1Alpha1 {
    /// <summary>
    /// Endpoint represents a single logical "backend" implementing a service.
    /// </summary>
    class Endpoint {
        /// <summary>
        /// addresses of this endpoint. The contents of this field are interpreted according to the
        /// corresponding EndpointSlice addressType field. This allows for cases like dual-stack
        /// (IPv4 and IPv6) networking. Consumers (e.g. kube-proxy) must handle different types of
        /// addresses in the context of their own capabilities. This must contain at least one
        /// address but no more than 100.
        /// </summary>
        public Input<Input<string>[]> Addresses { get; set; } = null!;

        /// <summary>
        /// conditions contains information about the current status of the endpoint.
        /// </summary>
        public Input<Discovery.V1Alpha1.EndpointConditions>? Conditions { get; set; }

        /// <summary>
        /// hostname of this endpoint. This field may be used by consumers of endpoints to
        /// distinguish endpoints from each other (e.g. in DNS names). Multiple endpoints which use
        /// the same hostname should be considered fungible (e.g. multiple A values in DNS). Must
        /// pass DNS Label (RFC 1123) validation.
        /// </summary>
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// targetRef is a reference to a Kubernetes object that represents this endpoint.
        /// </summary>
        public Input<Core.V1.ObjectReference>? TargetRef { get; set; }

        /// <summary>
        /// topology contains arbitrary topology information associated with the endpoint. These
        /// key/value pairs must conform with the label format.
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels Topology may
        /// include a maximum of 16 key/value pairs. This includes, but is not limited to the
        /// following well known keys: * kubernetes.io/hostname: the value indicates the hostname of
        /// the node
        ///   where the endpoint is located. This should match the corresponding
        ///   node label.
        /// * topology.kubernetes.io/zone: the value indicates the zone where the
        ///   endpoint is located. This should match the corresponding node label.
        /// * topology.kubernetes.io/region: the value indicates the region where the
        ///   endpoint is located. This should match the corresponding node label.
        /// </summary>
        public InputMap<string>? Topology { get; set; }

    }

    /// <summary>
    /// EndpointConditions represents the current condition of an endpoint.
    /// </summary>
    class EndpointConditions {
        /// <summary>
        /// ready indicates that this endpoint is prepared to receive traffic, according to whatever
        /// system is managing the endpoint. A nil value indicates an unknown state. In most cases
        /// consumers should interpret this unknown state as ready.
        /// </summary>
        public Input<bool>? Ready { get; set; }

    }

    /// <summary>
    /// EndpointPort represents a Port used by an EndpointSlice
    /// </summary>
    class EndpointPort {
        /// <summary>
        /// The name of this port. All ports in an EndpointSlice must have a unique name. If the
        /// EndpointSlice is dervied from a Kubernetes service, this corresponds to the
        /// Service.ports[].name. Name must either be an empty string or pass IANA_SVC_NAME
        /// validation: * must be no more than 15 characters long * may contain only [-a-z0-9] *
        /// must contain at least one letter [a-z] * it must not start or end with a hyphen, nor
        /// contain adjacent hyphens Default is empty string.
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The port number of the endpoint. If this is not specified, ports are not restricted and
        /// must be interpreted in the context of the specific consumer.
        /// </summary>
        public Input<int>? Port { get; set; }

        /// <summary>
        /// The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
        /// </summary>
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// EndpointSlice represents a subset of the endpoints that implement a service. For a given
    /// service there may be multiple EndpointSlice objects, selected by labels, which must be
    /// joined to produce the full set of endpoints.
    /// </summary>
    class EndpointSlice {
        /// <summary>
        /// endpoints is a list of unique endpoints in this slice. Each slice may include a maximum
        /// of 1000 endpoints.
        /// </summary>
        public Input<Input<Discovery.V1Alpha1.Endpoint>[]> Endpoints { get; set; } = null!;

        /// <summary>
        /// addressType specifies the type of address carried by this EndpointSlice. All addresses
        /// in this slice must be the same type. Default is IP
        /// </summary>
        public Input<string>? AddressType { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// ports specifies the list of network ports exposed by each endpoint in this slice. Each
        /// port must have a unique name. When ports is empty, it indicates that there are no
        /// defined ports. When a port is defined with a nil port value, it indicates "all ports".
        /// Each slice may include a maximum of 100 ports.
        /// </summary>
        public Input<Input<Discovery.V1Alpha1.EndpointPort>[]>? Ports { get; set; }

    }

    /// <summary>
    /// EndpointSliceList represents a list of endpoint slices
    /// </summary>
    class EndpointSliceList {
        /// <summary>
        /// List of endpoint slices
        /// </summary>
        public Input<Input<Discovery.V1Alpha1.EndpointSlice>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Events {
  namespace V1Beta1 {
    /// <summary>
    /// Event is a report of an event somewhere in the cluster. It generally denotes some state
    /// change in the system.
    /// </summary>
    class Event {
        /// <summary>
        /// Required. Time when this Event was first observed.
        /// </summary>
        public Input<string> EventTime { get; set; } = null!;

        /// <summary>
        /// What action was taken/failed regarding to the regarding object.
        /// </summary>
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
        public Input<int>? DeprecatedCount { get; set; }

        /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
        public Input<string>? DeprecatedFirstTimestamp { get; set; }

        /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
        public Input<string>? DeprecatedLastTimestamp { get; set; }

        /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
        public Input<Core.V1.EventSource>? DeprecatedSource { get; set; }

        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Optional. A human-readable description of the status of this operation. Maximal length
        /// of the note is 1kB, but libraries should be prepared to handle values up to 64kB.
        /// </summary>
        public Input<string>? Note { get; set; }

        /// <summary>
        /// Why the action was taken.
        /// </summary>
        public Input<string>? Reason { get; set; }

        /// <summary>
        /// The object this Event is about. In most cases it's an Object reporting controller
        /// implements. E.g. ReplicaSetController implements ReplicaSets and this event is emitted
        /// because it acts on some changes in a ReplicaSet object.
        /// </summary>
        public Input<Core.V1.ObjectReference>? Regarding { get; set; }

        /// <summary>
        /// Optional secondary object for more complex actions. E.g. when regarding object triggers
        /// a creation or deletion of related object.
        /// </summary>
        public Input<Core.V1.ObjectReference>? Related { get; set; }

        /// <summary>
        /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
        /// </summary>
        public Input<string>? ReportingController { get; set; }

        /// <summary>
        /// ID of the controller instance, e.g. `kubelet-xyzf`.
        /// </summary>
        public Input<string>? ReportingInstance { get; set; }

        /// <summary>
        /// Data about the Event series this event represents or nil if it's a singleton Event.
        /// </summary>
        public Input<Events.V1Beta1.EventSeries>? Series { get; set; }

        /// <summary>
        /// Type of this event (Normal, Warning), new types could be added in the future.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// EventList is a list of Event objects.
    /// </summary>
    class EventList {
        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public Input<Input<Events.V1Beta1.Event>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// EventSeries contain information on series of events, i.e. thing that was/is happening
    /// continuously for some time.
    /// </summary>
    class EventSeries {
        /// <summary>
        /// Number of occurrences in this series up to the last heartbeat time
        /// </summary>
        public Input<int> Count { get; set; } = null!;

        /// <summary>
        /// Time when last Event from the series was seen before last heartbeat.
        /// </summary>
        public Input<string> LastObservedTime { get; set; } = null!;

        /// <summary>
        /// Information whether this series is ongoing or finished. Deprecated. Planned removal for
        /// 1.18
        /// </summary>
        public Input<string> State { get; set; } = null!;

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Extensions {
  namespace V1Beta1 {
    /// <summary>
    /// AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
    /// </summary>
    class AllowedCSIDriver {
        /// <summary>
        /// Name is the registered name of the CSI driver
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// AllowedFlexVolume represents a single Flexvolume that is allowed to be used. Deprecated: use
    /// AllowedFlexVolume from policy API Group instead.
    /// </summary>
    class AllowedFlexVolume {
        /// <summary>
        /// driver is the name of the Flexvolume driver.
        /// </summary>
        public Input<string> Driver { get; set; } = null!;

    }

    /// <summary>
    /// AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods
    /// to use. It requires the path prefix to be defined. Deprecated: use AllowedHostPath from
    /// policy API Group instead.
    /// </summary>
    class AllowedHostPath {
        /// <summary>
        /// pathPrefix is the path prefix that the host volume must match. It does not support `*`.
        /// Trailing slashes are trimmed when validating the path prefix with a host path.
        /// 
        /// Examples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo` would not allow
        /// `/food` or `/etc/foo`
        /// </summary>
        public Input<string>? PathPrefix { get; set; }

        /// <summary>
        /// when set to true, will allow host volumes matching the pathPrefix only if all volume
        /// mounts are readOnly.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// DEPRECATED - extensions/v1beta1/DaemonSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/DaemonSet instead.
    /// 
    /// DaemonSet represents the configuration of a daemon set.
    /// </summary>
    class DaemonSet {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// The desired behavior of this daemon set. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Extensions.V1Beta1.DaemonSetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// DaemonSetCondition describes the state of a DaemonSet at a certain point.
    /// </summary>
    class DaemonSetCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of DaemonSet condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DaemonSetList is a collection of daemon sets.
    /// </summary>
    class DaemonSetList {
        /// <summary>
        /// A list of daemon sets.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.DaemonSet>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DaemonSetSpec is the specification of a daemon set.
    /// </summary>
    class DaemonSetSpec {
        /// <summary>
        /// An object that describes the pod that will be created. The DaemonSet will create exactly
        /// one copy of this pod on every node that matches the template's node selector (or on
        /// every node if no node selector is specified). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// The minimum number of seconds for which a newly created DaemonSet pod should be ready
        /// without any of its container crashing, for it to be considered available. Defaults to 0
        /// (pod will be considered available as soon as it is ready).
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// The number of old history to retain to allow rollback. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 10.
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// A label query over pods that are managed by the daemon set. Must match in order to be
        /// controlled. If empty, defaulted to labels on Pod template. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

        /// <summary>
        /// DEPRECATED. A sequence number representing a specific generation of the template.
        /// Populated by the system. It can be set only during the creation.
        /// </summary>
        public Input<int>? TemplateGeneration { get; set; }

        /// <summary>
        /// An update strategy to replace existing DaemonSet pods with new pods.
        /// </summary>
        public Input<Extensions.V1Beta1.DaemonSetUpdateStrategy>? UpdateStrategy { get; set; }

    }

    /// <summary>
    /// DaemonSetStatus represents the current status of a daemon set.
    /// </summary>
    class DaemonSetStatus {
        /// <summary>
        /// The number of nodes that are running at least 1 daemon pod and are supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        public Input<int> CurrentNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The total number of nodes that should be running the daemon pod (including nodes
        /// correctly running the daemon pod). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        public Input<int> DesiredNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that are running the daemon pod, but are not supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        public Input<int> NumberMisscheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and ready.
        /// </summary>
        public Input<int> NumberReady { get; set; } = null!;

        /// <summary>
        /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as
        /// a collision avoidance mechanism when it needs to create the name for the newest
        /// ControllerRevision.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a DaemonSet's current state.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.DaemonSetCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        public Input<int>? NumberAvailable { get; set; }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have none of the daemon
        /// pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        public Input<int>? NumberUnavailable { get; set; }

        /// <summary>
        /// The most recent generation observed by the daemon set controller.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The total number of nodes that are running updated daemon pod
        /// </summary>
        public Input<int>? UpdatedNumberScheduled { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    class DaemonSetUpdateStrategy {
        /// <summary>
        /// Rolling update config params. Present only if type = "RollingUpdate".
        /// </summary>
        public Input<Extensions.V1Beta1.RollingUpdateDaemonSet>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is OnDelete.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// DEPRECATED - extensions/v1beta1/Deployment is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/Deployment instead.
    /// 
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    class Deployment {
        /// <summary>
        /// Standard object metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
        public Input<Extensions.V1Beta1.DeploymentSpec>? Spec { get; set; }

    }

    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    class DeploymentCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of deployment condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// The last time this condition was updated.
        /// </summary>
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    class DeploymentList {
        /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.Deployment>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
    /// </summary>
    class DeploymentRollback {
        /// <summary>
        /// Required: This must match the Name of a deployment.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// The config of this deployment rollback.
        /// </summary>
        public Input<Extensions.V1Beta1.RollbackConfig> RollbackTo { get; set; } = null!;

        /// <summary>
        /// The annotations to be updated to a deployment
        /// </summary>
        public InputMap<string>? UpdatedAnnotations { get; set; }

    }

    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    class DeploymentSpec {
        /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
        public Input<Core.V1.PodTemplateSpec> Template { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Indicates that the deployment is paused and will not be processed by the deployment
        /// controller.
        /// </summary>
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// This is set to the max value of int32 (i.e. 2147483647) by default, which means "no
        /// deadline".
        /// </summary>
        public Input<int>? ProgressDeadlineSeconds { get; set; }

        /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. This is set to the max value of
        /// int32 (i.e. 2147483647) by default, which means "retaining all old RelicaSets".
        /// </summary>
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// DEPRECATED. The config this deployment is rolling back to. Will be cleared after
        /// rollback is done.
        /// </summary>
        public Input<Extensions.V1Beta1.RollbackConfig>? RollbackTo { get; set; }

        /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

        /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
        public Input<Extensions.V1Beta1.DeploymentStrategy>? Strategy { get; set; }

    }

    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    class DeploymentStatus {
        /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
        public Input<int>? CollisionCount { get; set; }

        /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.DeploymentCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
        public Input<int>? UnavailableReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    class DeploymentStrategy {
        /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
        public Input<Extensions.V1Beta1.RollingUpdateDeployment>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
    /// Deprecated: use FSGroupStrategyOptions from policy API Group instead.
    /// </summary>
    class FSGroupStrategyOptions {
        /// <summary>
        /// ranges are the allowed ranges of fs groups.  If you would like to force a single fs
        /// group then supply a single range with the same start and end. Required for MustRunAs.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.IDRange>[]>? Ranges { get; set; }

        /// <summary>
        /// rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
        /// </summary>
        public Input<string>? Rule { get; set; }

    }

    /// <summary>
    /// HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are
    /// forwarded to the backend.
    /// </summary>
    class HTTPIngressPath {
        /// <summary>
        /// Backend defines the referenced service endpoint to which the traffic will be forwarded
        /// to.
        /// </summary>
        public Input<Extensions.V1Beta1.IngressBackend> Backend { get; set; } = null!;

        /// <summary>
        /// Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the
        /// egrep/unix syntax, not the perl syntax) matched against the path of an incoming request.
        /// Currently it can contain characters disallowed from the conventional "path" part of a
        /// URL as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path
        /// defaults to a catch all sending traffic to the backend.
        /// </summary>
        public Input<string>? Path { get; set; }

    }

    /// <summary>
    /// HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example:
    /// http://&lt;host&gt;/&lt;path&gt;?&lt;searchpart&gt; -&gt; backend where where parts of the
    /// url correspond to RFC 3986, this resource will be used to match against everything after the
    /// last '/' and before the first '?' or '#'.
    /// </summary>
    class HTTPIngressRuleValue {
        /// <summary>
        /// A collection of paths that map requests to backends.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.HTTPIngressPath>[]> Paths { get; set; } = null!;

    }

    /// <summary>
    /// HostPortRange defines a range of host ports that will be enabled by a policy for pods to
    /// use.  It requires both the start and end to be defined. Deprecated: use HostPortRange from
    /// policy API Group instead.
    /// </summary>
    class HostPortRange {
        /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
        public Input<int> Max { get; set; } = null!;

        /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
        public Input<int> Min { get; set; } = null!;

    }

    /// <summary>
    /// IDRange provides a min/max of an allowed range of IDs. Deprecated: use IDRange from policy
    /// API Group instead.
    /// </summary>
    class IDRange {
        /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
        public Input<int> Max { get; set; } = null!;

        /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
        public Input<int> Min { get; set; } = null!;

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of IPBlock is deprecated by networking/v1/IPBlock.
    /// IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
    /// matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
    /// not be included within this rule.
    /// </summary>
    class IPBlock {
        /// <summary>
        /// CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24"
        /// </summary>
        public Input<string> Cidr { get; set; } = null!;

        /// <summary>
        /// Except is a slice of CIDRs that should not be included within an IP Block Valid examples
        /// are "192.168.1.1/24" Except values will be rejected if they are outside the CIDR range
        /// </summary>
        public Input<Input<string>[]>? Except { get; set; }

    }

    /// <summary>
    /// DEPRECATED - extensions/v1beta1/Ingress is not supported by Kubernetes 1.16+ clusters. Use
    /// networking/v1beta1/Ingress instead.
    /// 
    /// Ingress is a collection of rules that allow inbound connections to reach the endpoints
    /// defined by a backend. An Ingress can be configured to give services externally-reachable
    /// urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. 
    /// </summary>
    class Ingress {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec is the desired state of the Ingress. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Extensions.V1Beta1.IngressSpec>? Spec { get; set; }

    }

    /// <summary>
    /// IngressBackend describes all endpoints for a given service and port.
    /// </summary>
    class IngressBackend {
        /// <summary>
        /// Specifies the name of the referenced service.
        /// </summary>
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// Specifies the port of the referenced service.
        /// </summary>
        public Input<int /* TODO: or string */> ServicePort { get; set; } = null!;

    }

    /// <summary>
    /// IngressList is a collection of Ingress.
    /// </summary>
    class IngressList {
        /// <summary>
        /// Items is the list of Ingress.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.Ingress>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// IngressRule represents the rules mapping the paths under a specified host to the related
    /// backend services. Incoming requests are first evaluated for a host match, then routed to the
    /// backend associated with the matching IngressRuleValue.
    /// </summary>
    class IngressRule {
        /// <summary>
        /// Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note
        /// the following deviations from the "host" part of the URI as defined in the RFC: 1. IPs
        /// are not allowed. Currently an IngressRuleValue can only apply to the
        /// 	  IP in the Spec of the parent Ingress.
        /// 2. The `:` delimiter is not respected because ports are not allowed.
        /// 	  Currently the port of an Ingress is implicitly :80 for http and
        /// 	  :443 for https.
        /// Both these may change in the future. Incoming requests are matched against the host
        /// before the IngressRuleValue. If the host is unspecified, the Ingress routes all traffic
        /// based on the specified IngressRuleValue.
        /// </summary>
        public Input<string>? Host { get; set; }

        
        public Input<Extensions.V1Beta1.HTTPIngressRuleValue>? Http { get; set; }

    }

    /// <summary>
    /// IngressSpec describes the Ingress the user wishes to exist.
    /// </summary>
    class IngressSpec {
        /// <summary>
        /// A default backend capable of servicing requests that don't match any rule. At least one
        /// of 'backend' or 'rules' must be specified. This field is optional to allow the
        /// loadbalancer controller or defaulting logic to specify a global default.
        /// </summary>
        public Input<Extensions.V1Beta1.IngressBackend>? Backend { get; set; }

        /// <summary>
        /// A list of host rules used to configure the Ingress. If unspecified, or no rule matches,
        /// all traffic is sent to the default backend.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.IngressRule>[]>? Rules { get; set; }

        /// <summary>
        /// TLS configuration. Currently the Ingress only supports a single TLS port, 443. If
        /// multiple members of this list specify different hosts, they will be multiplexed on the
        /// same port according to the hostname specified through the SNI TLS extension, if the
        /// ingress controller fulfilling the ingress supports SNI.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.IngressTLS>[]>? Tls { get; set; }

    }

    /// <summary>
    /// IngressStatus describe the current state of the Ingress.
    /// </summary>
    class IngressStatus {
        /// <summary>
        /// LoadBalancer contains the current status of the load-balancer.
        /// </summary>
        public Input<Core.V1.LoadBalancerStatus>? LoadBalancer { get; set; }

    }

    /// <summary>
    /// IngressTLS describes the transport layer security associated with an Ingress.
    /// </summary>
    class IngressTLS {
        /// <summary>
        /// Hosts are a list of hosts included in the TLS certificate. The values in this list must
        /// match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the
        /// loadbalancer controller fulfilling this Ingress, if left unspecified.
        /// </summary>
        public Input<Input<string>[]>? Hosts { get; set; }

        /// <summary>
        /// SecretName is the name of the secret used to terminate SSL traffic on 443. Field is left
        /// optional to allow SSL routing based on SNI hostname alone. If the SNI host in a listener
        /// conflicts with the "Host" header field used by an IngressRule, the SNI host is used for
        /// termination and value of the Host header is used for routing.
        /// </summary>
        public Input<string>? SecretName { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by
    /// networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a
    /// set of Pods
    /// </summary>
    class NetworkPolicy {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior for this NetworkPolicy.
        /// </summary>
        public Input<Extensions.V1Beta1.NetworkPolicySpec>? Spec { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyEgressRule is deprecated by
    /// networking/v1/NetworkPolicyEgressRule. NetworkPolicyEgressRule describes a particular set of
    /// traffic that is allowed out of pods matched by a NetworkPolicySpec's podSelector. The
    /// traffic must match both ports and to. This type is beta-level in 1.8
    /// </summary>
    class NetworkPolicyEgressRule {
        /// <summary>
        /// List of destination ports for outgoing traffic. Each item in this list is combined using
        /// a logical OR. If this field is empty or missing, this rule matches all ports (traffic
        /// not restricted by port). If this field is present and contains at least one item, then
        /// this rule allows traffic only if the traffic matches at least one port in the list.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.NetworkPolicyPort>[]>? Ports { get; set; }

        /// <summary>
        /// List of destinations for outgoing traffic of pods selected for this rule. Items in this
        /// list are combined using a logical OR operation. If this field is empty or missing, this
        /// rule matches all destinations (traffic not restricted by destination). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the to list.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.NetworkPolicyPeer>[]>? To { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyIngressRule is deprecated by
    /// networking/v1/NetworkPolicyIngressRule. This NetworkPolicyIngressRule matches traffic if and
    /// only if the traffic matches both ports AND from.
    /// </summary>
    class NetworkPolicyIngressRule {
        /// <summary>
        /// List of sources which should be able to access the pods selected for this rule. Items in
        /// this list are combined using a logical OR operation. If this field is empty or missing,
        /// this rule matches all sources (traffic not restricted by source). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the from list.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.NetworkPolicyPeer>[]>? From { get; set; }

        /// <summary>
        /// List of ports which should be made accessible on the pods selected for this rule. Each
        /// item in this list is combined using a logical OR. If this field is empty or missing,
        /// this rule matches all ports (traffic not restricted by port). If this field is present
        /// and contains at least one item, then this rule allows traffic only if the traffic
        /// matches at least one port in the list.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.NetworkPolicyPort>[]>? Ports { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyList is deprecated by
    /// networking/v1/NetworkPolicyList. Network Policy List is a list of NetworkPolicy objects.
    /// </summary>
    class NetworkPolicyList {
        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.NetworkPolicy>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyPeer is deprecated by
    /// networking/v1/NetworkPolicyPeer.
    /// </summary>
    class NetworkPolicyPeer {
        /// <summary>
        /// IPBlock defines policy on a particular IPBlock. If this field is set then neither of the
        /// other fields can be.
        /// </summary>
        public Input<Extensions.V1Beta1.IPBlock>? IpBlock { get; set; }

        /// <summary>
        /// Selects Namespaces using cluster-scoped labels. This field follows standard label
        /// selector semantics; if present but empty, it selects all namespaces.
        /// 
        /// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects all Pods in the Namespaces selected by NamespaceSelector.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? NamespaceSelector { get; set; }

        /// <summary>
        /// This is a label selector which selects Pods. This field follows standard label selector
        /// semantics; if present but empty, it selects all pods.
        /// 
        /// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects the Pods matching PodSelector in the policy's own Namespace.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? PodSelector { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyPort is deprecated by
    /// networking/v1/NetworkPolicyPort.
    /// </summary>
    class NetworkPolicyPort {
        /// <summary>
        /// If specified, the port on the given protocol.  This can either be a numerical or named
        /// port on a pod.  If this field is not provided, this matches all port names and numbers.
        /// If present, only traffic on the specified protocol AND port will be matched.
        /// </summary>
        public Input<int /* TODO: or string */>? Port { get; set; }

        /// <summary>
        /// Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified,
        /// this field defaults to TCP.
        /// </summary>
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicySpec is deprecated by
    /// networking/v1/NetworkPolicySpec.
    /// </summary>
    class NetworkPolicySpec {
        /// <summary>
        /// Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
        /// is applied to any pods selected by this field. Multiple network policies can select the
        /// same set of pods.  In this case, the ingress rules for each are combined additively.
        /// This field is NOT optional and follows standard label selector semantics. An empty
        /// podSelector matches all pods in this namespace.
        /// </summary>
        public Input<Meta.V1.LabelSelector> PodSelector { get; set; } = null!;

        /// <summary>
        /// List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if
        /// there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
        /// traffic), OR if the traffic matches at least one egress rule across all of the
        /// NetworkPolicy objects whose podSelector matches the pod. If this field is empty then
        /// this NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the
        /// pods it selects are isolated by default). This field is beta-level in 1.8
        /// </summary>
        public Input<Input<Extensions.V1Beta1.NetworkPolicyEgressRule>[]>? Egress { get; set; }

        /// <summary>
        /// List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if
        /// there are no NetworkPolicies selecting the pod OR if the traffic source is the pod's
        /// local node, OR if the traffic matches at least one ingress rule across all of the
        /// NetworkPolicy objects whose podSelector matches the pod. If this field is empty then
        /// this NetworkPolicy does not allow any traffic (and serves solely to ensure that the pods
        /// it selects are isolated by default).
        /// </summary>
        public Input<Input<Extensions.V1Beta1.NetworkPolicyIngressRule>[]>? Ingress { get; set; }

        /// <summary>
        /// List of rule types that the NetworkPolicy relates to. Valid options are "Ingress",
        /// "Egress", or "Ingress,Egress". If this field is not specified, it will default based on
        /// the existence of Ingress or Egress rules; policies that contain an Egress section are
        /// assumed to affect Egress, and all policies (whether or not they contain an Ingress
        /// section) are assumed to affect Ingress. If you want to write an egress-only policy, you
        /// must explicitly specify policyTypes [ "Egress" ]. Likewise, if you want to write a
        /// policy that specifies that no egress is allowed, you must specify a policyTypes value
        /// that include "Egress" (since such a policy would not include an Egress section and would
        /// otherwise default to just [ "Ingress" ]). This field is beta-level in 1.8
        /// </summary>
        public Input<Input<string>[]>? PolicyTypes { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicy governs the ability to make requests that affect the Security Context that
    /// will be applied to a pod and container. Deprecated: use PodSecurityPolicy from policy API
    /// Group instead.
    /// </summary>
    class PodSecurityPolicy {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// spec defines the policy enforced.
        /// </summary>
        public Input<Extensions.V1Beta1.PodSecurityPolicySpec>? Spec { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicyList is a list of PodSecurityPolicy objects. Deprecated: use
    /// PodSecurityPolicyList from policy API Group instead.
    /// </summary>
    class PodSecurityPolicyList {
        /// <summary>
        /// items is a list of schema objects.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.PodSecurityPolicy>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicySpec defines the policy enforced. Deprecated: use PodSecurityPolicySpec
    /// from policy API Group instead.
    /// </summary>
    class PodSecurityPolicySpec {
        /// <summary>
        /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
        public Input<Extensions.V1Beta1.FSGroupStrategyOptions> FsGroup { get; set; } = null!;

        /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be
        /// set.
        /// </summary>
        public Input<Extensions.V1Beta1.RunAsUserStrategyOptions> RunAsUser { get; set; } = null!;

        /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        public Input<Extensions.V1Beta1.SELinuxStrategyOptions> SeLinux { get; set; } = null!;

        /// <summary>
        /// supplementalGroups is the strategy that will dictate what supplemental groups are used
        /// by the SecurityContext.
        /// </summary>
        public Input<Extensions.V1Beta1.SupplementalGroupsStrategyOptions> SupplementalGroups { get; set; } = null!;

        /// <summary>
        /// allowPrivilegeEscalation determines if a pod can request to allow privilege escalation.
        /// If unspecified, defaults to true.
        /// </summary>
        public Input<bool>? AllowPrivilegeEscalation { get; set; }

        /// <summary>
        /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be
        /// embedded within a pod spec. An empty value indicates that any CSI driver can be used for
        /// inline ephemeral volumes.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.AllowedCSIDriver>[]>? AllowedCSIDrivers { get; set; }

        /// <summary>
        /// allowedCapabilities is a list of capabilities that can be requested to add to the
        /// container. Capabilities in this field may be added at the pod author's discretion. You
        /// must not list a capability in both allowedCapabilities and requiredDropCapabilities.
        /// </summary>
        public Input<Input<string>[]>? AllowedCapabilities { get; set; }

        /// <summary>
        /// allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that
        /// all Flexvolumes may be used.  This parameter is effective only when the usage of the
        /// Flexvolumes is allowed in the "volumes" field.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.AllowedFlexVolume>[]>? AllowedFlexVolumes { get; set; }

        /// <summary>
        /// allowedHostPaths is a white list of allowed host paths. Empty indicates that all host
        /// paths may be used.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.AllowedHostPath>[]>? AllowedHostPaths { get; set; }

        /// <summary>
        /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates
        /// that only the DefaultProcMountType may be used. This requires the ProcMountType feature
        /// flag to be enabled.
        /// </summary>
        public Input<Input<string>[]>? AllowedProcMountTypes { get; set; }

        /// <summary>
        /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
        /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
        /// as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet
        /// has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
        /// 
        /// Examples: e.g. "foo/*" allows "foo/bar", "foo/baz", etc. e.g. "foo.*" allows "foo.bar",
        /// "foo.baz", etc.
        /// </summary>
        public Input<Input<string>[]>? AllowedUnsafeSysctls { get; set; }

        /// <summary>
        /// defaultAddCapabilities is the default set of capabilities that will be added to the
        /// container unless the pod spec specifically drops the capability.  You may not list a
        /// capability in both defaultAddCapabilities and requiredDropCapabilities. Capabilities
        /// added here are implicitly allowed, and need not be included in the allowedCapabilities
        /// list.
        /// </summary>
        public Input<Input<string>[]>? DefaultAddCapabilities { get; set; }

        /// <summary>
        /// defaultAllowPrivilegeEscalation controls the default setting for whether a process can
        /// gain more privileges than its parent process.
        /// </summary>
        public Input<bool>? DefaultAllowPrivilegeEscalation { get; set; }

        /// <summary>
        /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry
        /// is either a plain sysctl name or ends in "*" in which case it is considered as a prefix
        /// of forbidden sysctls. Single * means all sysctls are forbidden.
        /// 
        /// Examples: e.g. "foo/*" forbids "foo/bar", "foo/baz", etc. e.g. "foo.*" forbids
        /// "foo.bar", "foo.baz", etc.
        /// </summary>
        public Input<Input<string>[]>? ForbiddenSysctls { get; set; }

        /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
        public Input<bool>? HostIPC { get; set; }

        /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
        public Input<bool>? HostNetwork { get; set; }

        /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
        public Input<bool>? HostPID { get; set; }

        /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.HostPortRange>[]>? HostPorts { get; set; }

        /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// readOnlyRootFilesystem when set to true will force containers to run with a read only
        /// root file system.  If the container specifically requests to run with a non-read only
        /// root file system the PSP should deny the pod. If set to false the container may run with
        /// a read only root file system if it wishes but it will not be forced to.
        /// </summary>
        public Input<bool>? ReadOnlyRootFilesystem { get; set; }

        /// <summary>
        /// requiredDropCapabilities are the capabilities that will be dropped from the container.
        /// These are required to be dropped and cannot be added.
        /// </summary>
        public Input<Input<string>[]>? RequiredDropCapabilities { get; set; }

        /// <summary>
        /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be
        /// set. If this field is omitted, the pod's RunAsGroup can take any value. This field
        /// requires the RunAsGroup feature gate to be enabled.
        /// </summary>
        public Input<Extensions.V1Beta1.RunAsGroupStrategyOptions>? RunAsGroup { get; set; }

        /// <summary>
        /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
        /// If this field is omitted, the pod's runtimeClassName field is unrestricted. Enforcement
        /// of this field depends on the RuntimeClass feature gate being enabled.
        /// </summary>
        public Input<Extensions.V1Beta1.RuntimeClassStrategyOptions>? RuntimeClass { get; set; }

        /// <summary>
        /// volumes is a white list of allowed volume plugins. Empty indicates that no volumes may
        /// be used. To allow all volumes you may use '*'.
        /// </summary>
        public Input<Input<string>[]>? Volumes { get; set; }

    }

    /// <summary>
    /// DEPRECATED - extensions/v1beta1/ReplicaSet is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/ReplicaSet instead.
    /// 
    /// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
    /// </summary>
    class ReplicaSet {
        /// <summary>
        /// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
        /// that the ReplicaSet manages. Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the specification of the desired behavior of the ReplicaSet. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Extensions.V1Beta1.ReplicaSetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// ReplicaSetCondition describes the state of a replica set at a certain point.
    /// </summary>
    class ReplicaSetCondition {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of replica set condition.
        /// </summary>
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ReplicaSetList is a collection of ReplicaSets.
    /// </summary>
    class ReplicaSetList {
        /// <summary>
        /// List of ReplicaSets. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
        public Input<Input<Extensions.V1Beta1.ReplicaSet>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ReplicaSetSpec is the specification of a ReplicaSet.
    /// </summary>
    class ReplicaSetSpec {
        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Selector is a label query over pods that should match the replica count. If the selector
        /// is empty, it is defaulted to the labels present on the pod template. Label keys and
        /// values that must match in order to be controlled by this replica set. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

        /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        public Input<Core.V1.PodTemplateSpec>? Template { get; set; }

    }

    /// <summary>
    /// ReplicaSetStatus represents the current status of a ReplicaSet.
    /// </summary>
    class ReplicaSetStatus {
        /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this replica
        /// set.
        /// </summary>
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Represents the latest available observations of a replica set's current state.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.ReplicaSetCondition>[]>? Conditions { get; set; }

        /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replicaset.
        /// </summary>
        public Input<int>? FullyLabeledReplicas { get; set; }

        /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The number of ready replicas for this replica set.
        /// </summary>
        public Input<int>? ReadyReplicas { get; set; }

    }

    /// <summary>
    /// DEPRECATED.
    /// </summary>
    class RollbackConfig {
        /// <summary>
        /// The revision to rollback to. If set to 0, rollback to the last revision.
        /// </summary>
        public Input<int>? Revision { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of daemon set rolling update.
    /// </summary>
    class RollingUpdateDaemonSet {
        /// <summary>
        /// The maximum number of DaemonSet pods that can be unavailable during the update. Value
        /// can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at
        /// the start of the update (ex: 10%). Absolute number is calculated from percentage by
        /// rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at
        /// most 30% of the total number of nodes that should be running the daemon pod (i.e.
        /// status.desiredNumberScheduled) can have their pods stopped for an update at any given
        /// time. The update starts by stopping at most 30% of those DaemonSet pods and then brings
        /// up new DaemonSet pods in their place. Once the new pods are available, it then proceeds
        /// onto other DaemonSet pods, thus ensuring that at least 70% of original number of
        /// DaemonSet pods are available at all times during the update.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    class RollingUpdateDeployment {
        /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. By default, a value of 1 is used. Example: when this is set to 30%, the new
        /// RC can be scaled up immediately when the rolling update starts, such that the total
        /// number of old and new pods do not exceed 130% of desired pods. Once old pods have been
        /// killed, new RC can be scaled up further, ensuring that total number of pods running at
        /// any time during the update is at most 130% of desired pods.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxSurge { get; set; }

        /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. By
        /// default, a fixed value of 1 is used. Example: when this is set to 30%, the old RC can be
        /// scaled down to 70% of desired pods immediately when the rolling update starts. Once new
        /// pods are ready, old RC can be scaled down further, followed by scaling up the new RC,
        /// ensuring that the total number of pods available at all times during the update is at
        /// least 70% of desired pods.
        /// </summary>
        public Input<int /* TODO: or string */>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// RunAsGroupStrategyOptions defines the strategy type and any options used to create the
    /// strategy. Deprecated: use RunAsGroupStrategyOptions from policy API Group instead.
    /// </summary>
    class RunAsGroupStrategyOptions {
        /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
        /// </summary>
        public Input<string> Rule { get; set; } = null!;

        /// <summary>
        /// ranges are the allowed ranges of gids that may be used. If you would like to force a
        /// single gid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.IDRange>[]>? Ranges { get; set; }

    }

    /// <summary>
    /// RunAsUserStrategyOptions defines the strategy type and any options used to create the
    /// strategy. Deprecated: use RunAsUserStrategyOptions from policy API Group instead.
    /// </summary>
    class RunAsUserStrategyOptions {
        /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
        public Input<string> Rule { get; set; } = null!;

        /// <summary>
        /// ranges are the allowed ranges of uids that may be used. If you would like to force a
        /// single uid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.IDRange>[]>? Ranges { get; set; }

    }

    /// <summary>
    /// RuntimeClassStrategyOptions define the strategy that will dictate the allowable
    /// RuntimeClasses for a pod.
    /// </summary>
    class RuntimeClassStrategyOptions {
        /// <summary>
        /// allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a
        /// pod. A value of "*" means that any RuntimeClass name is allowed, and must be the only
        /// item in the list. An empty list requires the RuntimeClassName field to be unset.
        /// </summary>
        public Input<Input<string>[]> AllowedRuntimeClassNames { get; set; } = null!;

        /// <summary>
        /// defaultRuntimeClassName is the default RuntimeClassName to set on the pod. The default
        /// MUST be allowed by the allowedRuntimeClassNames list. A value of nil does not mutate the
        /// Pod.
        /// </summary>
        public Input<string>? DefaultRuntimeClassName { get; set; }

    }

    /// <summary>
    /// SELinuxStrategyOptions defines the strategy type and any options used to create the
    /// strategy. Deprecated: use SELinuxStrategyOptions from policy API Group instead.
    /// </summary>
    class SELinuxStrategyOptions {
        /// <summary>
        /// rule is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        public Input<string> Rule { get; set; } = null!;

        /// <summary>
        /// seLinuxOptions required to run as; required for MustRunAs More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        public Input<Core.V1.SELinuxOptions>? SeLinuxOptions { get; set; }

    }

    /// <summary>
    /// represents a scaling request for a resource.
    /// </summary>
    class Scale {
        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        public Input<Extensions.V1Beta1.ScaleSpec>? Spec { get; set; }

    }

    /// <summary>
    /// describes the attributes of a scale subresource
    /// </summary>
    class ScaleSpec {
        /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
        public Input<int>? Replicas { get; set; }

    }

    /// <summary>
    /// represents the current status of a scale subresource.
    /// </summary>
    class ScaleStatus {
        /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// label query over pods that should match the replicas count. More info:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
        public InputMap<string>? Selector { get; set; }

        /// <summary>
        /// label selector for pods that should match the replicas count. This is a serializated
        /// version of both map-based and more expressive set-based selectors. This is done to avoid
        /// introspection in the clients. The string will be in the same format as the query-param
        /// syntax. If the target type only supports map-based selectors, both this field and
        /// map-based selector field are populated. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public Input<string>? TargetSelector { get; set; }

    }

    /// <summary>
    /// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the
    /// strategy. Deprecated: use SupplementalGroupsStrategyOptions from policy API Group instead.
    /// </summary>
    class SupplementalGroupsStrategyOptions {
        /// <summary>
        /// ranges are the allowed ranges of supplemental groups.  If you would like to force a
        /// single supplemental group then supply a single range with the same start and end.
        /// Required for MustRunAs.
        /// </summary>
        public Input<Input<Extensions.V1Beta1.IDRange>[]>? Ranges { get; set; }

        /// <summary>
        /// rule is the strategy that will dictate what supplemental groups is used in the
        /// SecurityContext.
        /// </summary>
        public Input<string>? Rule { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Meta {
  namespace V1 {
    /// <summary>
    /// APIGroup contains the name, the supported versions, and the preferred version of a group.
    /// </summary>
    class APIGroup {
        /// <summary>
        /// name is the name of the group.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// versions are the versions supported in this group.
        /// </summary>
        public Input<Input<Meta.V1.GroupVersionForDiscovery>[]> Versions { get; set; } = null!;

        /// <summary>
        /// preferredVersion is the version preferred by the API server, which probably is the
        /// storage version.
        /// </summary>
        public Input<Meta.V1.GroupVersionForDiscovery>? PreferredVersion { get; set; }

        /// <summary>
        /// a map of client CIDR to server address that is serving this group. This is to help
        /// clients reach servers in the most network-efficient way possible. Clients can use the
        /// appropriate server address as per the CIDR that they match. In case of multiple matches,
        /// clients should use the longest matching CIDR. The server returns only those CIDRs that
        /// it thinks that the client can match. For example: the master will return an internal IP
        /// CIDR only, if the client reaches the server using an internal IP. Server looks at
        /// X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get
        /// the client IP.
        /// </summary>
        public Input<Input<Meta.V1.ServerAddressByClientCIDR>[]>? ServerAddressByClientCIDRs { get; set; }

    }

    /// <summary>
    /// APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis.
    /// </summary>
    class APIGroupList {
        /// <summary>
        /// groups is a list of APIGroup.
        /// </summary>
        public Input<Input<Meta.V1.APIGroup>[]> Groups { get; set; } = null!;

    }

    /// <summary>
    /// APIResource specifies the name of a resource and whether it is namespaced.
    /// </summary>
    class APIResource {
        /// <summary>
        /// name is the plural name of the resource.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// namespaced indicates if a resource is namespaced or not.
        /// </summary>
        public Input<bool> Namespaced { get; set; } = null!;

        /// <summary>
        /// singularName is the singular name of the resource.  This allows clients to handle plural
        /// and singular opaquely. The singularName is more correct for reporting status on a single
        /// item and both singular and plural are allowed from the kubectl CLI interface.
        /// </summary>
        public Input<string> SingularName { get; set; } = null!;

        /// <summary>
        /// verbs is a list of supported kube verbs (this includes get, list, watch, create, update,
        /// patch, delete, deletecollection, and proxy)
        /// </summary>
        public Input<Input<string>[]> Verbs { get; set; } = null!;

        /// <summary>
        /// categories is a list of the grouped resources this resource belongs to (e.g. 'all')
        /// </summary>
        public Input<Input<string>[]>? Categories { get; set; }

        /// <summary>
        /// group is the preferred group of the resource.  Empty implies the group of the containing
        /// resource list. For subresources, this may have a different value, for example: Scale".
        /// </summary>
        public Input<string>? Group { get; set; }

        /// <summary>
        /// shortNames is a list of suggested short names of the resource.
        /// </summary>
        public Input<Input<string>[]>? ShortNames { get; set; }

        /// <summary>
        /// The hash value of the storage version, the version this resource is converted to when
        /// written to the data store. Value must be treated as opaque by clients. Only equality
        /// comparison on the value is valid. This is an alpha feature and may change or be removed
        /// in the future. The field is populated by the apiserver only if the StorageVersionHash
        /// feature gate is enabled. This field will remain optional even if it graduates.
        /// </summary>
        public Input<string>? StorageVersionHash { get; set; }

        /// <summary>
        /// version is the preferred version of the resource.  Empty implies the version of the
        /// containing resource list For subresources, this may have a different value, for example:
        /// v1 (while inside a v1beta1 version of the core resource's group)".
        /// </summary>
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// APIResourceList is a list of APIResource, it is used to expose the name of the resources
    /// supported in a specific group and version, and if the resource is namespaced.
    /// </summary>
    class APIResourceList {
        /// <summary>
        /// groupVersion is the group and version this APIResourceList is for.
        /// </summary>
        public Input<string> GroupVersion { get; set; } = null!;

        /// <summary>
        /// resources contains the name of the resources and if they are namespaced.
        /// </summary>
        public Input<Input<Meta.V1.APIResource>[]> Resources { get; set; } = null!;

    }

    /// <summary>
    /// APIVersions lists the versions that are available, to allow clients to discover the API at
    /// /api, which is the root path of the legacy v1 API.
    /// </summary>
    class APIVersions {
        /// <summary>
        /// a map of client CIDR to server address that is serving this group. This is to help
        /// clients reach servers in the most network-efficient way possible. Clients can use the
        /// appropriate server address as per the CIDR that they match. In case of multiple matches,
        /// clients should use the longest matching CIDR. The server returns only those CIDRs that
        /// it thinks that the client can match. For example: the master will return an internal IP
        /// CIDR only, if the client reaches the server using an internal IP. Server looks at
        /// X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get
        /// the client IP.
        /// </summary>
        public Input<Input<Meta.V1.ServerAddressByClientCIDR>[]> ServerAddressByClientCIDRs { get; set; } = null!;

        /// <summary>
        /// versions are the api versions that are available.
        /// </summary>
        public Input<Input<string>[]> Versions { get; set; } = null!;

    }

    /// <summary>
    /// DeleteOptions may be provided when deleting an API object.
    /// </summary>
    class DeleteOptions {
        /// <summary>
        /// When present, indicates that modifications should not be persisted. An invalid or
        /// unrecognized dryRun directive will result in an error response and no further processing
        /// of the request. Valid values are: - All: all dry run stages will be processed
        /// </summary>
        public Input<Input<string>[]>? DryRun { get; set; }

        /// <summary>
        /// The duration in seconds before the object should be deleted. Value must be non-negative
        /// integer. The value zero indicates delete immediately. If this value is nil, the default
        /// grace period for the specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </summary>
        public Input<int>? GracePeriodSeconds { get; set; }

        /// <summary>
        /// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be
        /// added to/removed from the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </summary>
        public Input<bool>? OrphanDependents { get; set; }

        /// <summary>
        /// Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict
        /// status will be returned.
        /// </summary>
        public Input<Meta.V1.Preconditions>? Preconditions { get; set; }

        /// <summary>
        /// Whether and how garbage collection will be performed. Either this field or
        /// OrphanDependents may be set, but not both. The default policy is decided by the existing
        /// finalizer set in the metadata.finalizers and the resource-specific default policy.
        /// Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the
        /// garbage collector to delete the dependents in the background; 'Foreground' - a cascading
        /// policy that deletes all dependents in the foreground.
        /// </summary>
        public Input<string>? PropagationPolicy { get; set; }

    }

    /// <summary>
    /// GroupVersion contains the "group/version" and "version" string of a version. It is made a
    /// struct to keep extensibility.
    /// </summary>
    class GroupVersionForDiscovery {
        /// <summary>
        /// groupVersion specifies the API group and version in the form "group/version"
        /// </summary>
        public Input<string> GroupVersion { get; set; } = null!;

        /// <summary>
        /// version specifies the version in the form of "version". This is to save the clients the
        /// trouble of splitting the GroupVersion.
        /// </summary>
        public Input<string> Version { get; set; } = null!;

    }

    /// <summary>
    /// A label selector is a label query over a set of resources. The result of matchLabels and
    /// matchExpressions are ANDed. An empty label selector matches all objects. A null label
    /// selector matches no objects.
    /// </summary>
    class LabelSelector {
        /// <summary>
        /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
        public Input<Input<Meta.V1.LabelSelectorRequirement>[]>? MatchExpressions { get; set; }

        /// <summary>
        /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map
        /// is equivalent to an element of matchExpressions, whose key field is "key", the operator
        /// is "In", and the values array contains only "value". The requirements are ANDed.
        /// </summary>
        public InputMap<string>? MatchLabels { get; set; }

    }

    /// <summary>
    /// A label selector requirement is a selector that contains values, a key, and an operator that
    /// relates the key and values.
    /// </summary>
    class LabelSelectorRequirement {
        /// <summary>
        /// key is the label key that the selector applies to.
        /// </summary>
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// operator represents a key's relationship to a set of values. Valid operators are In,
        /// NotIn, Exists and DoesNotExist.
        /// </summary>
        public Input<string> Operator { get; set; } = null!;

        /// <summary>
        /// values is an array of string values. If the operator is In or NotIn, the values array
        /// must be non-empty. If the operator is Exists or DoesNotExist, the values array must be
        /// empty. This array is replaced during a strategic merge patch.
        /// </summary>
        public Input<Input<string>[]>? Values { get; set; }

    }

    /// <summary>
    /// ListMeta describes metadata that synthetic resources must have, including lists and various
    /// status objects. A resource may have only one of {ObjectMeta, ListMeta}.
    /// </summary>
    class ListMeta {
        /// <summary>
        /// continue may be set if the user set a limit on the number of items returned, and
        /// indicates that the server has more data available. The value is opaque and may be used
        /// to issue another request to the endpoint that served this list to retrieve the next set
        /// of available objects. Continuing a consistent list may not be possible if the server
        /// configuration has changed or more than a few minutes have passed. The resourceVersion
        /// field returned when using this continue value will be identical to the value in the
        /// first response, unless you have received this token from an error message.
        /// </summary>
        public Input<string>? Continue { get; set; }

        /// <summary>
        /// remainingItemCount is the number of subsequent items in the list which are not included
        /// in this list response. If the list request contained label or field selectors, then the
        /// number of remaining items is unknown and the field will be left unset and omitted during
        /// serialization. If the list is complete (either because it is not chunking or because
        /// this is the last chunk), then there are no more remaining items and this field will be
        /// left unset and omitted during serialization. Servers older than v1.15 do not set this
        /// field. The intended use of the remainingItemCount is *estimating* the size of a
        /// collection. Clients should not rely on the remainingItemCount to be set or to be exact.
        /// </summary>
        public Input<int>? RemainingItemCount { get; set; }

        /// <summary>
        /// String that identifies the server's internal version of this object that can be used by
        /// clients to determine when objects have changed. Value must be treated as opaque by
        /// clients and passed unmodified back to the server. Populated by the system. Read-only.
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// selfLink is a URL representing this object. Populated by the system. Read-only.
        /// 
        /// DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is
        /// planned to be removed in 1.21 release.
        /// </summary>
        public Input<string>? SelfLink { get; set; }

    }

    /// <summary>
    /// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that
    /// the fieldset applies to.
    /// </summary>
    class ManagedFieldsEntry {
        /// <summary>
        /// FieldsType is the discriminator for the different fields format and version. There is
        /// currently only one possible value: "FieldsV1"
        /// </summary>
        public Input<string>? FieldsType { get; set; }

        /// <summary>
        /// FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
        /// </summary>
        public Input<object>? FieldsV1 { get; set; }

        /// <summary>
        /// Manager is an identifier of the workflow managing these fields.
        /// </summary>
        public Input<string>? Manager { get; set; }

        /// <summary>
        /// Operation is the type of operation which lead to this ManagedFieldsEntry being created.
        /// The only valid values for this field are 'Apply' and 'Update'.
        /// </summary>
        public Input<string>? Operation { get; set; }

        /// <summary>
        /// Time is timestamp of when these fields were set. It should always be empty if Operation
        /// is 'Apply'
        /// </summary>
        public Input<string>? Time { get; set; }

    }

    /// <summary>
    /// ObjectMeta is metadata that all persisted resources must have, which includes all objects
    /// users must create.
    /// </summary>
    class ObjectMeta {
        /// <summary>
        /// Annotations is an unstructured key value map stored with a resource that may be set by
        /// external tools to store and retrieve arbitrary metadata. They are not queryable and
        /// should be preserved when modifying objects. More info:
        /// http://kubernetes.io/docs/user-guide/annotations
        /// </summary>
        public InputMap<string>? Annotations { get; set; }

        /// <summary>
        /// The name of the cluster which the object belongs to. This is used to distinguish
        /// resources with same name and namespace in different clusters. This field is not set
        /// anywhere right now and apiserver is going to ignore it if set in create or update
        /// request.
        /// </summary>
        public Input<string>? ClusterName { get; set; }

        /// <summary>
        /// CreationTimestamp is a timestamp representing the server time when this object was
        /// created. It is not guaranteed to be set in happens-before order across separate
        /// operations. Clients may not set this value. It is represented in RFC3339 form and is in
        /// UTC.
        /// 
        /// Populated by the system. Read-only. Null for lists. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<string>? CreationTimestamp { get; set; }

        /// <summary>
        /// Number of seconds allowed for this object to gracefully terminate before it will be
        /// removed from the system. Only set when deletionTimestamp is also set. May only be
        /// shortened. Read-only.
        /// </summary>
        public Input<int>? DeletionGracePeriodSeconds { get; set; }

        /// <summary>
        /// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
        /// field is set by the server when a graceful deletion is requested by the user, and is not
        /// directly settable by a client. The resource is expected to be deleted (no longer visible
        /// from resource lists, and not reachable by name) after the time in this field, once the
        /// finalizers list is empty. As long as the finalizers list contains items, deletion is
        /// blocked. Once the deletionTimestamp is set, this value may not be unset or be set
        /// further into the future, although it may be shortened or the resource may be deleted
        /// prior to this time. For example, a user may request that a pod is deleted in 30 seconds.
        /// The Kubelet will react by sending a graceful termination signal to the containers in the
        /// pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to
        /// the container and after cleanup, remove the pod from the API. In the presence of network
        /// partitions, this object may still exist after this timestamp, until an administrator or
        /// automated process can determine the resource is fully terminated. If not set, graceful
        /// deletion of the object has not been requested.
        /// 
        /// Populated by the system when a graceful deletion is requested. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<string>? DeletionTimestamp { get; set; }

        /// <summary>
        /// Must be empty before the object is deleted from the registry. Each entry is an
        /// identifier for the responsible component that will remove the entry from the list. If
        /// the deletionTimestamp of the object is non-nil, entries in this list can only be
        /// removed.
        /// </summary>
        public Input<Input<string>[]>? Finalizers { get; set; }

        /// <summary>
        /// GenerateName is an optional prefix, used by the server, to generate a unique name ONLY
        /// IF the Name field has not been provided. If this field is used, the name returned to the
        /// client will be different than the name passed. This value will also be combined with a
        /// unique suffix. The provided value has the same validation rules as the Name field, and
        /// may be truncated by the length of the suffix required to make the value unique on the
        /// server.
        /// 
        /// If this field is specified and the generated name exists, the server will NOT return a
        /// 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout
        /// indicating a unique name could not be found in the time allotted, and the client should
        /// retry (optionally after the time indicated in the Retry-After header).
        /// 
        /// Applied only if Name is not specified. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
        /// </summary>
        public Input<string>? GenerateName { get; set; }

        /// <summary>
        /// A sequence number representing a specific generation of the desired state. Populated by
        /// the system. Read-only.
        /// </summary>
        public Input<int>? Generation { get; set; }

        /// <summary>
        /// Map of string keys and values that can be used to organize and categorize (scope and
        /// select) objects. May match selectors of replication controllers and services. More info:
        /// http://kubernetes.io/docs/user-guide/labels
        /// </summary>
        public InputMap<string>? Labels { get; set; }

        /// <summary>
        /// ManagedFields maps workflow-id and version to the set of fields that are managed by that
        /// workflow. This is mostly for internal housekeeping, and users typically shouldn't need
        /// to set or understand this field. A workflow can be the user's name, a controller's name,
        /// or the name of a specific apply path like "ci-cd". The set of fields is always in the
        /// version that the workflow used when modifying the object.
        /// </summary>
        public Input<Input<Meta.V1.ManagedFieldsEntry>[]>? ManagedFields { get; set; }

        /// <summary>
        /// Name must be unique within a namespace. Is required when creating resources, although
        /// some resources may allow a client to request the generation of an appropriate name
        /// automatically. Name is primarily intended for creation idempotence and configuration
        /// definition. Cannot be updated. More info:
        /// http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace defines the space within each name must be unique. An empty namespace is
        /// equivalent to the "default" namespace, but "default" is the canonical representation.
        /// Not all objects are required to be scoped to a namespace - the value of this field for
        /// those objects will be empty.
        /// 
        /// Must be a DNS_LABEL. Cannot be updated. More info:
        /// http://kubernetes.io/docs/user-guide/namespaces
        /// </summary>
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// List of objects depended by this object. If ALL objects in the list have been deleted,
        /// this object will be garbage collected. If this object is managed by a controller, then
        /// an entry in this list will point to this controller, with the controller field set to
        /// true. There cannot be more than one managing controller.
        /// </summary>
        public Input<Input<Meta.V1.OwnerReference>[]>? OwnerReferences { get; set; }

        /// <summary>
        /// An opaque value that represents the internal version of this object that can be used by
        /// clients to determine when objects have changed. May be used for optimistic concurrency,
        /// change detection, and the watch operation on a resource or set of resources. Clients
        /// must treat these values as opaque and passed unmodified back to the server. They may
        /// only be valid for a particular resource or set of resources.
        /// 
        /// Populated by the system. Read-only. Value must be treated as opaque by clients and .
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// SelfLink is a URL representing this object. Populated by the system. Read-only.
        /// 
        /// DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is
        /// planned to be removed in 1.21 release.
        /// </summary>
        public Input<string>? SelfLink { get; set; }

        /// <summary>
        /// UID is the unique in time and space value for this object. It is typically generated by
        /// the server on successful creation of a resource and is not allowed to change on PUT
        /// operations.
        /// 
        /// Populated by the system. Read-only. More info:
        /// http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// OwnerReference contains enough information to let you identify an owning object. An owning
    /// object must be in the same namespace as the dependent, or be cluster-scoped, so there is no
    /// namespace field.
    /// </summary>
    class OwnerReference {
        /// <summary>
        /// Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
        public Input<string> Uid { get; set; } = null!;

        /// <summary>
        /// If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot
        /// be deleted from the key-value store until this reference is removed. Defaults to false.
        /// To set this field, a user needs "delete" permission of the owner, otherwise 422
        /// (Unprocessable Entity) will be returned.
        /// </summary>
        public Input<bool>? BlockOwnerDeletion { get; set; }

        /// <summary>
        /// If true, this reference points to the managing controller.
        /// </summary>
        public Input<bool>? Controller { get; set; }

    }

    /// <summary>
    /// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
    /// </summary>
    class Preconditions {
        /// <summary>
        /// Specifies the target ResourceVersion
        /// </summary>
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// Specifies the target UID.
        /// </summary>
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// ServerAddressByClientCIDR helps the client to determine the server address that they should
    /// use, depending on the clientCIDR that they match.
    /// </summary>
    class ServerAddressByClientCIDR {
        /// <summary>
        /// The CIDR with which clients can match their IP to figure out the server address that
        /// they should use.
        /// </summary>
        public Input<string> ClientCIDR { get; set; } = null!;

        /// <summary>
        /// Address of this server, suitable for a client that matches the above CIDR. This can be a
        /// hostname, hostname:port, IP or IP:port.
        /// </summary>
        public Input<string> ServerAddress { get; set; } = null!;

    }

    /// <summary>
    /// Status is a return value for calls that don't return other objects.
    /// </summary>
    class Status {
        /// <summary>
        /// Suggested HTTP return code for this status, 0 if not set.
        /// </summary>
        public Input<int>? Code { get; set; }

        /// <summary>
        /// Extended data associated with the reason.  Each reason may define its own extended
        /// details. This field is optional and the data returned is not guaranteed to conform to
        /// any schema except that defined by the reason type.
        /// </summary>
        public Input<Meta.V1.StatusDetails>? Details { get; set; }

        /// <summary>
        /// A human-readable description of the status of this operation.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

        /// <summary>
        /// A machine-readable description of why this operation is in the "Failure" status. If this
        /// value is empty there is no information available. A Reason clarifies an HTTP status code
        /// but does not override it.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatusCause provides more information about an api.Status failure, including cases when
    /// multiple errors are encountered.
    /// </summary>
    class StatusCause {
        /// <summary>
        /// The field of the resource that has caused this error, as named by its JSON
        /// serialization. May include dot and postfix notation for nested attributes. Arrays are
        /// zero-indexed.  Fields may appear more than once in an array of causes due to fields
        /// having multiple errors. Optional.
        /// 
        /// Examples:
        ///   "name" - the field "name" on the current resource
        ///   "items[0].name" - the field "name" on the first array entry in "items"
        /// </summary>
        public Input<string>? Field { get; set; }

        /// <summary>
        /// A human-readable description of the cause of the error.  This field may be presented
        /// as-is to a reader.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// A machine-readable description of the cause of the error. If this value is empty there
        /// is no information available.
        /// </summary>
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatusDetails is a set of additional properties that MAY be set by the server to provide
    /// additional information about a response. The Reason field of a Status object defines what
    /// attributes will be set. Clients must ignore fields that do not match the defined type of
    /// each attribute, and should assume that any attribute may be empty, invalid, or under
    /// defined.
    /// </summary>
    class StatusDetails {
        /// <summary>
        /// The Causes array includes more details associated with the StatusReason failure. Not all
        /// StatusReasons may provide detailed causes.
        /// </summary>
        public Input<Input<Meta.V1.StatusCause>[]>? Causes { get; set; }

        /// <summary>
        /// The group attribute of the resource associated with the status StatusReason.
        /// </summary>
        public Input<string>? Group { get; set; }

        /// <summary>
        /// The name attribute of the resource associated with the status StatusReason (when there
        /// is a single name which can be described).
        /// </summary>
        public Input<string>? Name { get; set; }

        /// <summary>
        /// If specified, the time in seconds before the operation should be retried. Some errors
        /// may indicate the client must take an alternate action - for those errors this field may
        /// indicate how long to wait before taking the alternate action.
        /// </summary>
        public Input<int>? RetryAfterSeconds { get; set; }

        /// <summary>
        /// UID of the resource. (when there is a single resource which can be described). More
        /// info: http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// Event represents a single event to a watched resource.
    /// </summary>
    class WatchEvent {
        /// <summary>
        /// Object is:
        ///  * If Type is Added or Modified: the new state of the object.
        ///  * If Type is Deleted: the state of the object immediately before deletion.
        ///  * If Type is Error: *Status is recommended; other types may make sense
        ///    depending on context.
        /// </summary>
        public Input<object> Object { get; set; } = null!;

        
        public Input<string> Type { get; set; } = null!;

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Networking {
  namespace V1 {
    /// <summary>
    /// IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
    /// matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
    /// not be included within this rule.
    /// </summary>
    class IPBlock {
        /// <summary>
        /// CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24"
        /// </summary>
        public Input<string> Cidr { get; set; } = null!;

        /// <summary>
        /// Except is a slice of CIDRs that should not be included within an IP Block Valid examples
        /// are "192.168.1.1/24" Except values will be rejected if they are outside the CIDR range
        /// </summary>
        public Input<Input<string>[]>? Except { get; set; }

    }

    /// <summary>
    /// NetworkPolicy describes what network traffic is allowed for a set of Pods
    /// </summary>
    class NetworkPolicy {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior for this NetworkPolicy.
        /// </summary>
        public Input<Networking.V1.NetworkPolicySpec>? Spec { get; set; }

    }

    /// <summary>
    /// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
    /// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to. This
    /// type is beta-level in 1.8
    /// </summary>
    class NetworkPolicyEgressRule {
        /// <summary>
        /// List of destination ports for outgoing traffic. Each item in this list is combined using
        /// a logical OR. If this field is empty or missing, this rule matches all ports (traffic
        /// not restricted by port). If this field is present and contains at least one item, then
        /// this rule allows traffic only if the traffic matches at least one port in the list.
        /// </summary>
        public Input<Input<Networking.V1.NetworkPolicyPort>[]>? Ports { get; set; }

        /// <summary>
        /// List of destinations for outgoing traffic of pods selected for this rule. Items in this
        /// list are combined using a logical OR operation. If this field is empty or missing, this
        /// rule matches all destinations (traffic not restricted by destination). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the to list.
        /// </summary>
        public Input<Input<Networking.V1.NetworkPolicyPeer>[]>? To { get; set; }

    }

    /// <summary>
    /// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
    /// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
    /// </summary>
    class NetworkPolicyIngressRule {
        /// <summary>
        /// List of sources which should be able to access the pods selected for this rule. Items in
        /// this list are combined using a logical OR operation. If this field is empty or missing,
        /// this rule matches all sources (traffic not restricted by source). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the from list.
        /// </summary>
        public Input<Input<Networking.V1.NetworkPolicyPeer>[]>? From { get; set; }

        /// <summary>
        /// List of ports which should be made accessible on the pods selected for this rule. Each
        /// item in this list is combined using a logical OR. If this field is empty or missing,
        /// this rule matches all ports (traffic not restricted by port). If this field is present
        /// and contains at least one item, then this rule allows traffic only if the traffic
        /// matches at least one port in the list.
        /// </summary>
        public Input<Input<Networking.V1.NetworkPolicyPort>[]>? Ports { get; set; }

    }

    /// <summary>
    /// NetworkPolicyList is a list of NetworkPolicy objects.
    /// </summary>
    class NetworkPolicyList {
        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public Input<Input<Networking.V1.NetworkPolicy>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// NetworkPolicyPeer describes a peer to allow traffic from. Only certain combinations of
    /// fields are allowed
    /// </summary>
    class NetworkPolicyPeer {
        /// <summary>
        /// IPBlock defines policy on a particular IPBlock. If this field is set then neither of the
        /// other fields can be.
        /// </summary>
        public Input<Networking.V1.IPBlock>? IpBlock { get; set; }

        /// <summary>
        /// Selects Namespaces using cluster-scoped labels. This field follows standard label
        /// selector semantics; if present but empty, it selects all namespaces.
        /// 
        /// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects all Pods in the Namespaces selected by NamespaceSelector.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? NamespaceSelector { get; set; }

        /// <summary>
        /// This is a label selector which selects Pods. This field follows standard label selector
        /// semantics; if present but empty, it selects all pods.
        /// 
        /// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects the Pods matching PodSelector in the policy's own Namespace.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? PodSelector { get; set; }

    }

    /// <summary>
    /// NetworkPolicyPort describes a port to allow traffic on
    /// </summary>
    class NetworkPolicyPort {
        /// <summary>
        /// The port on the given protocol. This can either be a numerical or named port on a pod.
        /// If this field is not provided, this matches all port names and numbers.
        /// </summary>
        public Input<int /* TODO: or string */>? Port { get; set; }

        /// <summary>
        /// The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field
        /// defaults to TCP.
        /// </summary>
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// NetworkPolicySpec provides the specification of a NetworkPolicy
    /// </summary>
    class NetworkPolicySpec {
        /// <summary>
        /// Selects the pods to which this NetworkPolicy object applies. The array of ingress rules
        /// is applied to any pods selected by this field. Multiple network policies can select the
        /// same set of pods. In this case, the ingress rules for each are combined additively. This
        /// field is NOT optional and follows standard label selector semantics. An empty
        /// podSelector matches all pods in this namespace.
        /// </summary>
        public Input<Meta.V1.LabelSelector> PodSelector { get; set; } = null!;

        /// <summary>
        /// List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if
        /// there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
        /// traffic), OR if the traffic matches at least one egress rule across all of the
        /// NetworkPolicy objects whose podSelector matches the pod. If this field is empty then
        /// this NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the
        /// pods it selects are isolated by default). This field is beta-level in 1.8
        /// </summary>
        public Input<Input<Networking.V1.NetworkPolicyEgressRule>[]>? Egress { get; set; }

        /// <summary>
        /// List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if
        /// there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
        /// traffic), OR if the traffic source is the pod's local node, OR if the traffic matches at
        /// least one ingress rule across all of the NetworkPolicy objects whose podSelector matches
        /// the pod. If this field is empty then this NetworkPolicy does not allow any traffic (and
        /// serves solely to ensure that the pods it selects are isolated by default)
        /// </summary>
        public Input<Input<Networking.V1.NetworkPolicyIngressRule>[]>? Ingress { get; set; }

        /// <summary>
        /// List of rule types that the NetworkPolicy relates to. Valid options are "Ingress",
        /// "Egress", or "Ingress,Egress". If this field is not specified, it will default based on
        /// the existence of Ingress or Egress rules; policies that contain an Egress section are
        /// assumed to affect Egress, and all policies (whether or not they contain an Ingress
        /// section) are assumed to affect Ingress. If you want to write an egress-only policy, you
        /// must explicitly specify policyTypes [ "Egress" ]. Likewise, if you want to write a
        /// policy that specifies that no egress is allowed, you must specify a policyTypes value
        /// that include "Egress" (since such a policy would not include an Egress section and would
        /// otherwise default to just [ "Ingress" ]). This field is beta-level in 1.8
        /// </summary>
        public Input<Input<string>[]>? PolicyTypes { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are
    /// forwarded to the backend.
    /// </summary>
    class HTTPIngressPath {
        /// <summary>
        /// Backend defines the referenced service endpoint to which the traffic will be forwarded
        /// to.
        /// </summary>
        public Input<Networking.V1Beta1.IngressBackend> Backend { get; set; } = null!;

        /// <summary>
        /// Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the
        /// egrep/unix syntax, not the perl syntax) matched against the path of an incoming request.
        /// Currently it can contain characters disallowed from the conventional "path" part of a
        /// URL as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path
        /// defaults to a catch all sending traffic to the backend.
        /// </summary>
        public Input<string>? Path { get; set; }

    }

    /// <summary>
    /// HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example:
    /// http://&lt;host&gt;/&lt;path&gt;?&lt;searchpart&gt; -&gt; backend where where parts of the
    /// url correspond to RFC 3986, this resource will be used to match against everything after the
    /// last '/' and before the first '?' or '#'.
    /// </summary>
    class HTTPIngressRuleValue {
        /// <summary>
        /// A collection of paths that map requests to backends.
        /// </summary>
        public Input<Input<Networking.V1Beta1.HTTPIngressPath>[]> Paths { get; set; } = null!;

    }

    /// <summary>
    /// Ingress is a collection of rules that allow inbound connections to reach the endpoints
    /// defined by a backend. An Ingress can be configured to give services externally-reachable
    /// urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
    /// </summary>
    class Ingress {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Spec is the desired state of the Ingress. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Networking.V1Beta1.IngressSpec>? Spec { get; set; }

    }

    /// <summary>
    /// IngressBackend describes all endpoints for a given service and port.
    /// </summary>
    class IngressBackend {
        /// <summary>
        /// Specifies the name of the referenced service.
        /// </summary>
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// Specifies the port of the referenced service.
        /// </summary>
        public Input<int /* TODO: or string */> ServicePort { get; set; } = null!;

    }

    /// <summary>
    /// IngressList is a collection of Ingress.
    /// </summary>
    class IngressList {
        /// <summary>
        /// Items is the list of Ingress.
        /// </summary>
        public Input<Input<Networking.V1Beta1.Ingress>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// IngressRule represents the rules mapping the paths under a specified host to the related
    /// backend services. Incoming requests are first evaluated for a host match, then routed to the
    /// backend associated with the matching IngressRuleValue.
    /// </summary>
    class IngressRule {
        /// <summary>
        /// Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note
        /// the following deviations from the "host" part of the URI as defined in the RFC: 1. IPs
        /// are not allowed. Currently an IngressRuleValue can only apply to the
        /// 	  IP in the Spec of the parent Ingress.
        /// 2. The `:` delimiter is not respected because ports are not allowed.
        /// 	  Currently the port of an Ingress is implicitly :80 for http and
        /// 	  :443 for https.
        /// Both these may change in the future. Incoming requests are matched against the host
        /// before the IngressRuleValue. If the host is unspecified, the Ingress routes all traffic
        /// based on the specified IngressRuleValue.
        /// </summary>
        public Input<string>? Host { get; set; }

        
        public Input<Networking.V1Beta1.HTTPIngressRuleValue>? Http { get; set; }

    }

    /// <summary>
    /// IngressSpec describes the Ingress the user wishes to exist.
    /// </summary>
    class IngressSpec {
        /// <summary>
        /// A default backend capable of servicing requests that don't match any rule. At least one
        /// of 'backend' or 'rules' must be specified. This field is optional to allow the
        /// loadbalancer controller or defaulting logic to specify a global default.
        /// </summary>
        public Input<Networking.V1Beta1.IngressBackend>? Backend { get; set; }

        /// <summary>
        /// A list of host rules used to configure the Ingress. If unspecified, or no rule matches,
        /// all traffic is sent to the default backend.
        /// </summary>
        public Input<Input<Networking.V1Beta1.IngressRule>[]>? Rules { get; set; }

        /// <summary>
        /// TLS configuration. Currently the Ingress only supports a single TLS port, 443. If
        /// multiple members of this list specify different hosts, they will be multiplexed on the
        /// same port according to the hostname specified through the SNI TLS extension, if the
        /// ingress controller fulfilling the ingress supports SNI.
        /// </summary>
        public Input<Input<Networking.V1Beta1.IngressTLS>[]>? Tls { get; set; }

    }

    /// <summary>
    /// IngressStatus describe the current state of the Ingress.
    /// </summary>
    class IngressStatus {
        /// <summary>
        /// LoadBalancer contains the current status of the load-balancer.
        /// </summary>
        public Input<Core.V1.LoadBalancerStatus>? LoadBalancer { get; set; }

    }

    /// <summary>
    /// IngressTLS describes the transport layer security associated with an Ingress.
    /// </summary>
    class IngressTLS {
        /// <summary>
        /// Hosts are a list of hosts included in the TLS certificate. The values in this list must
        /// match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the
        /// loadbalancer controller fulfilling this Ingress, if left unspecified.
        /// </summary>
        public Input<Input<string>[]>? Hosts { get; set; }

        /// <summary>
        /// SecretName is the name of the secret used to terminate SSL traffic on 443. Field is left
        /// optional to allow SSL routing based on SNI hostname alone. If the SNI host in a listener
        /// conflicts with the "Host" header field used by an IngressRule, the SNI host is used for
        /// termination and value of the Host header is used for routing.
        /// </summary>
        public Input<string>? SecretName { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Node {
  namespace V1Alpha1 {
    /// <summary>
    /// Overhead structure represents the resource overhead associated with running a pod.
    /// </summary>
    class Overhead {
        /// <summary>
        /// PodFixed represents the fixed resource overhead associated with running a pod.
        /// </summary>
        public Input<object>? PodFixed { get; set; }

    }

    /// <summary>
    /// RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass
    /// is used to determine which container runtime is used to run all containers in a pod.
    /// RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and
    /// referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName
    /// reference before running the pod.  For more details, see
    /// https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
    /// </summary>
    class RuntimeClass {
        /// <summary>
        /// Specification of the RuntimeClass More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        public Input<Node.V1Alpha1.RuntimeClassSpec> Spec { get; set; } = null!;

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RuntimeClassList is a list of RuntimeClass objects.
    /// </summary>
    class RuntimeClassList {
        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public Input<Input<Node.V1Alpha1.RuntimeClass>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RuntimeClassSpec is a specification of a RuntimeClass. It contains parameters that are
    /// required to describe the RuntimeClass to the Container Runtime Interface (CRI)
    /// implementation, as well as any other components that need to understand how the pod will be
    /// run. The RuntimeClassSpec is immutable.
    /// </summary>
    class RuntimeClassSpec {
        /// <summary>
        /// RuntimeHandler specifies the underlying runtime and configuration that the CRI
        /// implementation will use to handle pods of this class. The possible values are specific
        /// to the node & CRI configuration.  It is assumed that all handlers are available on every
        /// node, and handlers of the same name are equivalent on every node. For example, a handler
        /// called "runc" might specify that the runc OCI runtime (using native Linux containers)
        /// will be used to run the containers in a pod. The RuntimeHandler must conform to the DNS
        /// Label (RFC 1123) requirements and is immutable.
        /// </summary>
        public Input<string> RuntimeHandler { get; set; } = null!;

        /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a given
        /// RuntimeClass. For more details, see
        /// https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
        /// alpha-level as of Kubernetes v1.15, and is only honored by servers that enable the
        /// PodOverhead feature.
        /// </summary>
        public Input<Node.V1Alpha1.Overhead>? Overhead { get; set; }

        /// <summary>
        /// Scheduling holds the scheduling constraints to ensure that pods running with this
        /// RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this
        /// RuntimeClass is assumed to be supported by all nodes.
        /// </summary>
        public Input<Node.V1Alpha1.Scheduling>? Scheduling { get; set; }

    }

    /// <summary>
    /// Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.
    /// </summary>
    class Scheduling {
        /// <summary>
        /// nodeSelector lists labels that must be present on nodes that support this RuntimeClass.
        /// Pods using this RuntimeClass can only be scheduled to a node matched by this selector.
        /// The RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any
        /// conflicts will cause the pod to be rejected in admission.
        /// </summary>
        public InputMap<string>? NodeSelector { get; set; }

        /// <summary>
        /// tolerations are appended (excluding duplicates) to pods running with this RuntimeClass
        /// during admission, effectively unioning the set of nodes tolerated by the pod and the
        /// RuntimeClass.
        /// </summary>
        public Input<Input<Core.V1.Toleration>[]>? Tolerations { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// Overhead structure represents the resource overhead associated with running a pod.
    /// </summary>
    class Overhead {
        /// <summary>
        /// PodFixed represents the fixed resource overhead associated with running a pod.
        /// </summary>
        public Input<object>? PodFixed { get; set; }

    }

    /// <summary>
    /// RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass
    /// is used to determine which container runtime is used to run all containers in a pod.
    /// RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and
    /// referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName
    /// reference before running the pod.  For more details, see
    /// https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
    /// </summary>
    class RuntimeClass {
        /// <summary>
        /// Handler specifies the underlying runtime and configuration that the CRI implementation
        /// will use to handle pods of this class. The possible values are specific to the node &
        /// CRI configuration.  It is assumed that all handlers are available on every node, and
        /// handlers of the same name are equivalent on every node. For example, a handler called
        /// "runc" might specify that the runc OCI runtime (using native Linux containers) will be
        /// used to run the containers in a pod. The Handler must conform to the DNS Label (RFC
        /// 1123) requirements, and is immutable.
        /// </summary>
        public Input<string> Handler { get; set; } = null!;

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a given
        /// RuntimeClass. For more details, see
        /// https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
        /// alpha-level as of Kubernetes v1.15, and is only honored by servers that enable the
        /// PodOverhead feature.
        /// </summary>
        public Input<Node.V1Beta1.Overhead>? Overhead { get; set; }

        /// <summary>
        /// Scheduling holds the scheduling constraints to ensure that pods running with this
        /// RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this
        /// RuntimeClass is assumed to be supported by all nodes.
        /// </summary>
        public Input<Node.V1Beta1.Scheduling>? Scheduling { get; set; }

    }

    /// <summary>
    /// RuntimeClassList is a list of RuntimeClass objects.
    /// </summary>
    class RuntimeClassList {
        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public Input<Input<Node.V1Beta1.RuntimeClass>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.
    /// </summary>
    class Scheduling {
        /// <summary>
        /// nodeSelector lists labels that must be present on nodes that support this RuntimeClass.
        /// Pods using this RuntimeClass can only be scheduled to a node matched by this selector.
        /// The RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any
        /// conflicts will cause the pod to be rejected in admission.
        /// </summary>
        public InputMap<string>? NodeSelector { get; set; }

        /// <summary>
        /// tolerations are appended (excluding duplicates) to pods running with this RuntimeClass
        /// during admission, effectively unioning the set of nodes tolerated by the pod and the
        /// RuntimeClass.
        /// </summary>
        public Input<Input<Core.V1.Toleration>[]>? Tolerations { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Pkg {
  namespace Version {
    /// <summary>
    /// Info contains versioning information. how we'll want to distribute that information.
    /// </summary>
    class Info {
        
        public Input<string> BuildDate { get; set; } = null!;

        
        public Input<string> Compiler { get; set; } = null!;

        
        public Input<string> GitCommit { get; set; } = null!;

        
        public Input<string> GitTreeState { get; set; } = null!;

        
        public Input<string> GitVersion { get; set; } = null!;

        
        public Input<string> GoVersion { get; set; } = null!;

        
        public Input<string> Major { get; set; } = null!;

        
        public Input<string> Minor { get; set; } = null!;

        
        public Input<string> Platform { get; set; } = null!;

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Policy {
  namespace V1Beta1 {
    /// <summary>
    /// AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
    /// </summary>
    class AllowedCSIDriver {
        /// <summary>
        /// Name is the registered name of the CSI driver
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
    /// </summary>
    class AllowedFlexVolume {
        /// <summary>
        /// driver is the name of the Flexvolume driver.
        /// </summary>
        public Input<string> Driver { get; set; } = null!;

    }

    /// <summary>
    /// AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods
    /// to use. It requires the path prefix to be defined.
    /// </summary>
    class AllowedHostPath {
        /// <summary>
        /// pathPrefix is the path prefix that the host volume must match. It does not support `*`.
        /// Trailing slashes are trimmed when validating the path prefix with a host path.
        /// 
        /// Examples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo` would not allow
        /// `/food` or `/etc/foo`
        /// </summary>
        public Input<string>? PathPrefix { get; set; }

        /// <summary>
        /// when set to true, will allow host volumes matching the pathPrefix only if all volume
        /// mounts are readOnly.
        /// </summary>
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Eviction evicts a pod from its node subject to certain policies and safety constraints. This
    /// is a subresource of Pod.  A request to cause such an eviction is created by POSTing to
    /// .../pods/&lt;pod name&gt;/evictions.
    /// </summary>
    class Eviction {
        /// <summary>
        /// DeleteOptions may be provided
        /// </summary>
        public Input<Meta.V1.DeleteOptions>? DeleteOptions { get; set; }

        /// <summary>
        /// ObjectMeta describes the pod that is being evicted.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
    /// </summary>
    class FSGroupStrategyOptions {
        /// <summary>
        /// ranges are the allowed ranges of fs groups.  If you would like to force a single fs
        /// group then supply a single range with the same start and end. Required for MustRunAs.
        /// </summary>
        public Input<Input<Policy.V1Beta1.IDRange>[]>? Ranges { get; set; }

        /// <summary>
        /// rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
        /// </summary>
        public Input<string>? Rule { get; set; }

    }

    /// <summary>
    /// HostPortRange defines a range of host ports that will be enabled by a policy for pods to
    /// use.  It requires both the start and end to be defined.
    /// </summary>
    class HostPortRange {
        /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
        public Input<int> Max { get; set; } = null!;

        /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
        public Input<int> Min { get; set; } = null!;

    }

    /// <summary>
    /// IDRange provides a min/max of an allowed range of IDs.
    /// </summary>
    class IDRange {
        /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
        public Input<int> Max { get; set; } = null!;

        /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
        public Input<int> Min { get; set; } = null!;

    }

    /// <summary>
    /// PodDisruptionBudget is an object to define the max disruption that can be caused to a
    /// collection of pods
    /// </summary>
    class PodDisruptionBudget {
        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the PodDisruptionBudget.
        /// </summary>
        public Input<Policy.V1Beta1.PodDisruptionBudgetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
    /// </summary>
    class PodDisruptionBudgetList {
        
        public Input<Input<Policy.V1Beta1.PodDisruptionBudget>[]> Items { get; set; } = null!;

        
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
    /// </summary>
    class PodDisruptionBudgetSpec {
        /// <summary>
        /// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are
        /// unavailable after the eviction, i.e. even in absence of the evicted pod. For example,
        /// one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive
        /// setting with "minAvailable".
        /// </summary>
        public Input<int /* TODO: or string */>? MaxUnavailable { get; set; }

        /// <summary>
        /// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still
        /// be available after the eviction, i.e. even in the absence of the evicted pod.  So for
        /// example you can prevent all voluntary evictions by specifying "100%".
        /// </summary>
        public Input<int /* TODO: or string */>? MinAvailable { get; set; }

        /// <summary>
        /// Label query over pods whose evictions are managed by the disruption budget.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

    }

    /// <summary>
    /// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget.
    /// Status may trail the actual state of a system.
    /// </summary>
    class PodDisruptionBudgetStatus {
        /// <summary>
        /// current number of healthy pods
        /// </summary>
        public Input<int> CurrentHealthy { get; set; } = null!;

        /// <summary>
        /// minimum desired number of healthy pods
        /// </summary>
        public Input<int> DesiredHealthy { get; set; } = null!;

        /// <summary>
        /// Number of pod disruptions that are currently allowed.
        /// </summary>
        public Input<int> DisruptionsAllowed { get; set; } = null!;

        /// <summary>
        /// total number of pods counted by this disruption budget
        /// </summary>
        public Input<int> ExpectedPods { get; set; } = null!;

        /// <summary>
        /// DisruptedPods contains information about pods whose eviction was processed by the API
        /// server eviction subresource handler but has not yet been observed by the
        /// PodDisruptionBudget controller. A pod will be in this map from the time when the API
        /// server processed the eviction request to the time when the pod is seen by PDB controller
        /// as having been marked for deletion (or after a timeout). The key in the map is the name
        /// of the pod and the value is the time when the API server processed the eviction request.
        /// If the deletion didn't occur and a pod is still there it will be removed from the list
        /// automatically by PodDisruptionBudget controller after some time. If everything goes
        /// smooth this map should be empty for the most of the time. Large number of entries in the
        /// map may indicate problems with pod deletions.
        /// </summary>
        public Input<object>? DisruptedPods { get; set; }

        /// <summary>
        /// Most recent generation observed when updating this PDB status. PodDisruptionsAllowed and
        /// other status informatio is valid only if observedGeneration equals to PDB's object
        /// generation.
        /// </summary>
        public Input<int>? ObservedGeneration { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicy governs the ability to make requests that affect the Security Context that
    /// will be applied to a pod and container.
    /// </summary>
    class PodSecurityPolicy {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// spec defines the policy enforced.
        /// </summary>
        public Input<Policy.V1Beta1.PodSecurityPolicySpec>? Spec { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicyList is a list of PodSecurityPolicy objects.
    /// </summary>
    class PodSecurityPolicyList {
        /// <summary>
        /// items is a list of schema objects.
        /// </summary>
        public Input<Input<Policy.V1Beta1.PodSecurityPolicy>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicySpec defines the policy enforced.
    /// </summary>
    class PodSecurityPolicySpec {
        /// <summary>
        /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
        public Input<Policy.V1Beta1.FSGroupStrategyOptions> FsGroup { get; set; } = null!;

        /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be
        /// set.
        /// </summary>
        public Input<Policy.V1Beta1.RunAsUserStrategyOptions> RunAsUser { get; set; } = null!;

        /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        public Input<Policy.V1Beta1.SELinuxStrategyOptions> SeLinux { get; set; } = null!;

        /// <summary>
        /// supplementalGroups is the strategy that will dictate what supplemental groups are used
        /// by the SecurityContext.
        /// </summary>
        public Input<Policy.V1Beta1.SupplementalGroupsStrategyOptions> SupplementalGroups { get; set; } = null!;

        /// <summary>
        /// allowPrivilegeEscalation determines if a pod can request to allow privilege escalation.
        /// If unspecified, defaults to true.
        /// </summary>
        public Input<bool>? AllowPrivilegeEscalation { get; set; }

        /// <summary>
        /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be
        /// embedded within a pod spec. An empty value indicates that any CSI driver can be used for
        /// inline ephemeral volumes. This is an alpha field, and is only honored if the API server
        /// enables the CSIInlineVolume feature gate.
        /// </summary>
        public Input<Input<Policy.V1Beta1.AllowedCSIDriver>[]>? AllowedCSIDrivers { get; set; }

        /// <summary>
        /// allowedCapabilities is a list of capabilities that can be requested to add to the
        /// container. Capabilities in this field may be added at the pod author's discretion. You
        /// must not list a capability in both allowedCapabilities and requiredDropCapabilities.
        /// </summary>
        public Input<Input<string>[]>? AllowedCapabilities { get; set; }

        /// <summary>
        /// allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that
        /// all Flexvolumes may be used.  This parameter is effective only when the usage of the
        /// Flexvolumes is allowed in the "volumes" field.
        /// </summary>
        public Input<Input<Policy.V1Beta1.AllowedFlexVolume>[]>? AllowedFlexVolumes { get; set; }

        /// <summary>
        /// allowedHostPaths is a white list of allowed host paths. Empty indicates that all host
        /// paths may be used.
        /// </summary>
        public Input<Input<Policy.V1Beta1.AllowedHostPath>[]>? AllowedHostPaths { get; set; }

        /// <summary>
        /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates
        /// that only the DefaultProcMountType may be used. This requires the ProcMountType feature
        /// flag to be enabled.
        /// </summary>
        public Input<Input<string>[]>? AllowedProcMountTypes { get; set; }

        /// <summary>
        /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
        /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
        /// as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet
        /// has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
        /// 
        /// Examples: e.g. "foo/*" allows "foo/bar", "foo/baz", etc. e.g. "foo.*" allows "foo.bar",
        /// "foo.baz", etc.
        /// </summary>
        public Input<Input<string>[]>? AllowedUnsafeSysctls { get; set; }

        /// <summary>
        /// defaultAddCapabilities is the default set of capabilities that will be added to the
        /// container unless the pod spec specifically drops the capability.  You may not list a
        /// capability in both defaultAddCapabilities and requiredDropCapabilities. Capabilities
        /// added here are implicitly allowed, and need not be included in the allowedCapabilities
        /// list.
        /// </summary>
        public Input<Input<string>[]>? DefaultAddCapabilities { get; set; }

        /// <summary>
        /// defaultAllowPrivilegeEscalation controls the default setting for whether a process can
        /// gain more privileges than its parent process.
        /// </summary>
        public Input<bool>? DefaultAllowPrivilegeEscalation { get; set; }

        /// <summary>
        /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry
        /// is either a plain sysctl name or ends in "*" in which case it is considered as a prefix
        /// of forbidden sysctls. Single * means all sysctls are forbidden.
        /// 
        /// Examples: e.g. "foo/*" forbids "foo/bar", "foo/baz", etc. e.g. "foo.*" forbids
        /// "foo.bar", "foo.baz", etc.
        /// </summary>
        public Input<Input<string>[]>? ForbiddenSysctls { get; set; }

        /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
        public Input<bool>? HostIPC { get; set; }

        /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
        public Input<bool>? HostNetwork { get; set; }

        /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
        public Input<bool>? HostPID { get; set; }

        /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
        public Input<Input<Policy.V1Beta1.HostPortRange>[]>? HostPorts { get; set; }

        /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// readOnlyRootFilesystem when set to true will force containers to run with a read only
        /// root file system.  If the container specifically requests to run with a non-read only
        /// root file system the PSP should deny the pod. If set to false the container may run with
        /// a read only root file system if it wishes but it will not be forced to.
        /// </summary>
        public Input<bool>? ReadOnlyRootFilesystem { get; set; }

        /// <summary>
        /// requiredDropCapabilities are the capabilities that will be dropped from the container.
        /// These are required to be dropped and cannot be added.
        /// </summary>
        public Input<Input<string>[]>? RequiredDropCapabilities { get; set; }

        /// <summary>
        /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be
        /// set. If this field is omitted, the pod's RunAsGroup can take any value. This field
        /// requires the RunAsGroup feature gate to be enabled.
        /// </summary>
        public Input<Policy.V1Beta1.RunAsGroupStrategyOptions>? RunAsGroup { get; set; }

        /// <summary>
        /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
        /// If this field is omitted, the pod's runtimeClassName field is unrestricted. Enforcement
        /// of this field depends on the RuntimeClass feature gate being enabled.
        /// </summary>
        public Input<Policy.V1Beta1.RuntimeClassStrategyOptions>? RuntimeClass { get; set; }

        /// <summary>
        /// volumes is a white list of allowed volume plugins. Empty indicates that no volumes may
        /// be used. To allow all volumes you may use '*'.
        /// </summary>
        public Input<Input<string>[]>? Volumes { get; set; }

    }

    /// <summary>
    /// RunAsGroupStrategyOptions defines the strategy type and any options used to create the
    /// strategy.
    /// </summary>
    class RunAsGroupStrategyOptions {
        /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
        /// </summary>
        public Input<string> Rule { get; set; } = null!;

        /// <summary>
        /// ranges are the allowed ranges of gids that may be used. If you would like to force a
        /// single gid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
        public Input<Input<Policy.V1Beta1.IDRange>[]>? Ranges { get; set; }

    }

    /// <summary>
    /// RunAsUserStrategyOptions defines the strategy type and any options used to create the
    /// strategy.
    /// </summary>
    class RunAsUserStrategyOptions {
        /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
        public Input<string> Rule { get; set; } = null!;

        /// <summary>
        /// ranges are the allowed ranges of uids that may be used. If you would like to force a
        /// single uid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
        public Input<Input<Policy.V1Beta1.IDRange>[]>? Ranges { get; set; }

    }

    /// <summary>
    /// RuntimeClassStrategyOptions define the strategy that will dictate the allowable
    /// RuntimeClasses for a pod.
    /// </summary>
    class RuntimeClassStrategyOptions {
        /// <summary>
        /// allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a
        /// pod. A value of "*" means that any RuntimeClass name is allowed, and must be the only
        /// item in the list. An empty list requires the RuntimeClassName field to be unset.
        /// </summary>
        public Input<Input<string>[]> AllowedRuntimeClassNames { get; set; } = null!;

        /// <summary>
        /// defaultRuntimeClassName is the default RuntimeClassName to set on the pod. The default
        /// MUST be allowed by the allowedRuntimeClassNames list. A value of nil does not mutate the
        /// Pod.
        /// </summary>
        public Input<string>? DefaultRuntimeClassName { get; set; }

    }

    /// <summary>
    /// SELinuxStrategyOptions defines the strategy type and any options used to create the
    /// strategy.
    /// </summary>
    class SELinuxStrategyOptions {
        /// <summary>
        /// rule is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        public Input<string> Rule { get; set; } = null!;

        /// <summary>
        /// seLinuxOptions required to run as; required for MustRunAs More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        public Input<Core.V1.SELinuxOptions>? SeLinuxOptions { get; set; }

    }

    /// <summary>
    /// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the
    /// strategy.
    /// </summary>
    class SupplementalGroupsStrategyOptions {
        /// <summary>
        /// ranges are the allowed ranges of supplemental groups.  If you would like to force a
        /// single supplemental group then supply a single range with the same start and end.
        /// Required for MustRunAs.
        /// </summary>
        public Input<Input<Policy.V1Beta1.IDRange>[]>? Ranges { get; set; }

        /// <summary>
        /// rule is the strategy that will dictate what supplemental groups is used in the
        /// SecurityContext.
        /// </summary>
        public Input<string>? Rule { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Rbac {
  namespace V1 {
    /// <summary>
    /// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
    /// </summary>
    class AggregationRule {
        /// <summary>
        /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles
        /// and create the rules. If any of the selectors match, then the ClusterRole's permissions
        /// will be added
        /// </summary>
        public Input<Input<Meta.V1.LabelSelector>[]>? ClusterRoleSelectors { get; set; }

    }

    /// <summary>
    /// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
    /// unit by a RoleBinding or ClusterRoleBinding.
    /// </summary>
    class ClusterRole {
        /// <summary>
        /// AggregationRule is an optional field that describes how to build the Rules for this
        /// ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
        /// changes to Rules will be stomped by the controller.
        /// </summary>
        public Input<Rbac.V1.AggregationRule>? AggregationRule { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Rules holds all the PolicyRules for this ClusterRole
        /// </summary>
        public Input<Input<Rbac.V1.PolicyRule>[]>? Rules { get; set; }

    }

    /// <summary>
    /// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
    /// ClusterRole in the global namespace, and adds who information via Subject.
    /// </summary>
    class ClusterRoleBinding {
        /// <summary>
        /// RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot
        /// be resolved, the Authorizer must return an error.
        /// </summary>
        public Input<Rbac.V1.RoleRef> RoleRef { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public Input<Input<Rbac.V1.Subject>[]>? Subjects { get; set; }

    }

    /// <summary>
    /// ClusterRoleBindingList is a collection of ClusterRoleBindings
    /// </summary>
    class ClusterRoleBindingList {
        /// <summary>
        /// Items is a list of ClusterRoleBindings
        /// </summary>
        public Input<Input<Rbac.V1.ClusterRoleBinding>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ClusterRoleList is a collection of ClusterRoles
    /// </summary>
    class ClusterRoleList {
        /// <summary>
        /// Items is a list of ClusterRoles
        /// </summary>
        public Input<Input<Rbac.V1.ClusterRole>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PolicyRule holds information that describes a policy rule, but does not contain information
    /// about who the rule applies to or which namespace the rule applies to.
    /// </summary>
    class PolicyRule {
        /// <summary>
        /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
        /// contained in this rule.  VerbAll represents all kinds.
        /// </summary>
        public Input<Input<string>[]> Verbs { get; set; } = null!;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.
        /// </summary>
        public Input<Input<string>[]>? ApiGroups { get; set; }

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path Since non-resource URLs are not
        /// namespaced, this field is only applicable for ClusterRoles referenced from a
        /// ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or
        /// "secrets") or non-resource URL paths (such as "/api"),  but not both.
        /// </summary>
        public Input<Input<string>[]>? NonResourceURLs { get; set; }

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.
        /// </summary>
        public Input<Input<string>[]>? ResourceNames { get; set; }

        /// <summary>
        /// Resources is a list of resources this rule applies to.  ResourceAll represents all
        /// resources.
        /// </summary>
        public Input<Input<string>[]>? Resources { get; set; }

    }

    /// <summary>
    /// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
    /// RoleBinding.
    /// </summary>
    class Role {
        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Rules holds all the PolicyRules for this Role
        /// </summary>
        public Input<Input<Rbac.V1.PolicyRule>[]>? Rules { get; set; }

    }

    /// <summary>
    /// RoleBinding references a role, but does not contain it.  It can reference a Role in the same
    /// namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
    /// namespace information by which namespace it exists in.  RoleBindings in a given namespace
    /// only have effect in that namespace.
    /// </summary>
    class RoleBinding {
        /// <summary>
        /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global
        /// namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
        /// </summary>
        public Input<Rbac.V1.RoleRef> RoleRef { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public Input<Input<Rbac.V1.Subject>[]>? Subjects { get; set; }

    }

    /// <summary>
    /// RoleBindingList is a collection of RoleBindings
    /// </summary>
    class RoleBindingList {
        /// <summary>
        /// Items is a list of RoleBindings
        /// </summary>
        public Input<Input<Rbac.V1.RoleBinding>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleList is a collection of Roles
    /// </summary>
    class RoleList {
        /// <summary>
        /// Items is a list of Roles
        /// </summary>
        public Input<Input<Rbac.V1.Role>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleRef contains information that points to the role being used
    /// </summary>
    class RoleRef {
        /// <summary>
        /// APIGroup is the group for the resource being referenced
        /// </summary>
        public Input<string> ApiGroup { get; set; } = null!;

        /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// Subject contains a reference to the object or user identities a role binding applies to.
    /// This can either hold a direct API object reference, or a value for non-objects such as user
    /// and group names.
    /// </summary>
    class Subject {
        /// <summary>
        /// Name of the object being referenced.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// APIGroup holds the API group of the referenced subject. Defaults to "" for
        /// ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group
        /// subjects.
        /// </summary>
        public Input<string>? ApiGroup { get; set; }

        /// <summary>
        /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User"
        /// or "Group", and this value is not empty the Authorizer should report an error.
        /// </summary>
        public Input<string>? Namespace { get; set; }

    }

  }

  namespace V1Alpha1 {
    /// <summary>
    /// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
    /// </summary>
    class AggregationRule {
        /// <summary>
        /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles
        /// and create the rules. If any of the selectors match, then the ClusterRole's permissions
        /// will be added
        /// </summary>
        public Input<Input<Meta.V1.LabelSelector>[]>? ClusterRoleSelectors { get; set; }

    }

    /// <summary>
    /// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
    /// unit by a RoleBinding or ClusterRoleBinding.
    /// </summary>
    class ClusterRole {
        /// <summary>
        /// AggregationRule is an optional field that describes how to build the Rules for this
        /// ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
        /// changes to Rules will be stomped by the controller.
        /// </summary>
        public Input<Rbac.V1Alpha1.AggregationRule>? AggregationRule { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Rules holds all the PolicyRules for this ClusterRole
        /// </summary>
        public Input<Input<Rbac.V1Alpha1.PolicyRule>[]>? Rules { get; set; }

    }

    /// <summary>
    /// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
    /// ClusterRole in the global namespace, and adds who information via Subject.
    /// </summary>
    class ClusterRoleBinding {
        /// <summary>
        /// RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot
        /// be resolved, the Authorizer must return an error.
        /// </summary>
        public Input<Rbac.V1Alpha1.RoleRef> RoleRef { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public Input<Input<Rbac.V1Alpha1.Subject>[]>? Subjects { get; set; }

    }

    /// <summary>
    /// ClusterRoleBindingList is a collection of ClusterRoleBindings
    /// </summary>
    class ClusterRoleBindingList {
        /// <summary>
        /// Items is a list of ClusterRoleBindings
        /// </summary>
        public Input<Input<Rbac.V1Alpha1.ClusterRoleBinding>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ClusterRoleList is a collection of ClusterRoles
    /// </summary>
    class ClusterRoleList {
        /// <summary>
        /// Items is a list of ClusterRoles
        /// </summary>
        public Input<Input<Rbac.V1Alpha1.ClusterRole>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PolicyRule holds information that describes a policy rule, but does not contain information
    /// about who the rule applies to or which namespace the rule applies to.
    /// </summary>
    class PolicyRule {
        /// <summary>
        /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
        /// contained in this rule.  VerbAll represents all kinds.
        /// </summary>
        public Input<Input<string>[]> Verbs { get; set; } = null!;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.
        /// </summary>
        public Input<Input<string>[]>? ApiGroups { get; set; }

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path This name is intentionally
        /// different than the internal type so that the DefaultConvert works nicely and because the
        /// ordering may be different. Since non-resource URLs are not namespaced, this field is
        /// only applicable for ClusterRoles referenced from a ClusterRoleBinding. Rules can either
        /// apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as
        /// "/api"),  but not both.
        /// </summary>
        public Input<Input<string>[]>? NonResourceURLs { get; set; }

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.
        /// </summary>
        public Input<Input<string>[]>? ResourceNames { get; set; }

        /// <summary>
        /// Resources is a list of resources this rule applies to.  ResourceAll represents all
        /// resources.
        /// </summary>
        public Input<Input<string>[]>? Resources { get; set; }

    }

    /// <summary>
    /// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
    /// RoleBinding.
    /// </summary>
    class Role {
        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Rules holds all the PolicyRules for this Role
        /// </summary>
        public Input<Input<Rbac.V1Alpha1.PolicyRule>[]>? Rules { get; set; }

    }

    /// <summary>
    /// RoleBinding references a role, but does not contain it.  It can reference a Role in the same
    /// namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
    /// namespace information by which namespace it exists in.  RoleBindings in a given namespace
    /// only have effect in that namespace.
    /// </summary>
    class RoleBinding {
        /// <summary>
        /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global
        /// namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
        /// </summary>
        public Input<Rbac.V1Alpha1.RoleRef> RoleRef { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public Input<Input<Rbac.V1Alpha1.Subject>[]>? Subjects { get; set; }

    }

    /// <summary>
    /// RoleBindingList is a collection of RoleBindings
    /// </summary>
    class RoleBindingList {
        /// <summary>
        /// Items is a list of RoleBindings
        /// </summary>
        public Input<Input<Rbac.V1Alpha1.RoleBinding>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleList is a collection of Roles
    /// </summary>
    class RoleList {
        /// <summary>
        /// Items is a list of Roles
        /// </summary>
        public Input<Input<Rbac.V1Alpha1.Role>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleRef contains information that points to the role being used
    /// </summary>
    class RoleRef {
        /// <summary>
        /// APIGroup is the group for the resource being referenced
        /// </summary>
        public Input<string> ApiGroup { get; set; } = null!;

        /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// Subject contains a reference to the object or user identities a role binding applies to.
    /// This can either hold a direct API object reference, or a value for non-objects such as user
    /// and group names.
    /// </summary>
    class Subject {
        /// <summary>
        /// Name of the object being referenced.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User"
        /// or "Group", and this value is not empty the Authorizer should report an error.
        /// </summary>
        public Input<string>? Namespace { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
    /// </summary>
    class AggregationRule {
        /// <summary>
        /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles
        /// and create the rules. If any of the selectors match, then the ClusterRole's permissions
        /// will be added
        /// </summary>
        public Input<Input<Meta.V1.LabelSelector>[]>? ClusterRoleSelectors { get; set; }

    }

    /// <summary>
    /// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
    /// unit by a RoleBinding or ClusterRoleBinding.
    /// </summary>
    class ClusterRole {
        /// <summary>
        /// AggregationRule is an optional field that describes how to build the Rules for this
        /// ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
        /// changes to Rules will be stomped by the controller.
        /// </summary>
        public Input<Rbac.V1Beta1.AggregationRule>? AggregationRule { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Rules holds all the PolicyRules for this ClusterRole
        /// </summary>
        public Input<Input<Rbac.V1Beta1.PolicyRule>[]>? Rules { get; set; }

    }

    /// <summary>
    /// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
    /// ClusterRole in the global namespace, and adds who information via Subject.
    /// </summary>
    class ClusterRoleBinding {
        /// <summary>
        /// RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot
        /// be resolved, the Authorizer must return an error.
        /// </summary>
        public Input<Rbac.V1Beta1.RoleRef> RoleRef { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public Input<Input<Rbac.V1Beta1.Subject>[]>? Subjects { get; set; }

    }

    /// <summary>
    /// ClusterRoleBindingList is a collection of ClusterRoleBindings
    /// </summary>
    class ClusterRoleBindingList {
        /// <summary>
        /// Items is a list of ClusterRoleBindings
        /// </summary>
        public Input<Input<Rbac.V1Beta1.ClusterRoleBinding>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// ClusterRoleList is a collection of ClusterRoles
    /// </summary>
    class ClusterRoleList {
        /// <summary>
        /// Items is a list of ClusterRoles
        /// </summary>
        public Input<Input<Rbac.V1Beta1.ClusterRole>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PolicyRule holds information that describes a policy rule, but does not contain information
    /// about who the rule applies to or which namespace the rule applies to.
    /// </summary>
    class PolicyRule {
        /// <summary>
        /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
        /// contained in this rule.  VerbAll represents all kinds.
        /// </summary>
        public Input<Input<string>[]> Verbs { get; set; } = null!;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.
        /// </summary>
        public Input<Input<string>[]>? ApiGroups { get; set; }

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path Since non-resource URLs are not
        /// namespaced, this field is only applicable for ClusterRoles referenced from a
        /// ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or
        /// "secrets") or non-resource URL paths (such as "/api"),  but not both.
        /// </summary>
        public Input<Input<string>[]>? NonResourceURLs { get; set; }

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.
        /// </summary>
        public Input<Input<string>[]>? ResourceNames { get; set; }

        /// <summary>
        /// Resources is a list of resources this rule applies to.  '*' represents all resources in
        /// the specified apiGroups. '*/foo' represents the subresource 'foo' for all resources in
        /// the specified apiGroups.
        /// </summary>
        public Input<Input<string>[]>? Resources { get; set; }

    }

    /// <summary>
    /// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
    /// RoleBinding.
    /// </summary>
    class Role {
        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Rules holds all the PolicyRules for this Role
        /// </summary>
        public Input<Input<Rbac.V1Beta1.PolicyRule>[]>? Rules { get; set; }

    }

    /// <summary>
    /// RoleBinding references a role, but does not contain it.  It can reference a Role in the same
    /// namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
    /// namespace information by which namespace it exists in.  RoleBindings in a given namespace
    /// only have effect in that namespace.
    /// </summary>
    class RoleBinding {
        /// <summary>
        /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global
        /// namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
        /// </summary>
        public Input<Rbac.V1Beta1.RoleRef> RoleRef { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public Input<Input<Rbac.V1Beta1.Subject>[]>? Subjects { get; set; }

    }

    /// <summary>
    /// RoleBindingList is a collection of RoleBindings
    /// </summary>
    class RoleBindingList {
        /// <summary>
        /// Items is a list of RoleBindings
        /// </summary>
        public Input<Input<Rbac.V1Beta1.RoleBinding>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleList is a collection of Roles
    /// </summary>
    class RoleList {
        /// <summary>
        /// Items is a list of Roles
        /// </summary>
        public Input<Input<Rbac.V1Beta1.Role>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleRef contains information that points to the role being used
    /// </summary>
    class RoleRef {
        /// <summary>
        /// APIGroup is the group for the resource being referenced
        /// </summary>
        public Input<string> ApiGroup { get; set; } = null!;

        /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// Subject contains a reference to the object or user identities a role binding applies to.
    /// This can either hold a direct API object reference, or a value for non-objects such as user
    /// and group names.
    /// </summary>
    class Subject {
        /// <summary>
        /// Name of the object being referenced.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// APIGroup holds the API group of the referenced subject. Defaults to "" for
        /// ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group
        /// subjects.
        /// </summary>
        public Input<string>? ApiGroup { get; set; }

        /// <summary>
        /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User"
        /// or "Group", and this value is not empty the Authorizer should report an error.
        /// </summary>
        public Input<string>? Namespace { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Scheduling {
  namespace V1 {
    /// <summary>
    /// PriorityClass defines mapping from a priority class name to the priority integer value. The
    /// value can be any valid integer.
    /// </summary>
    class PriorityClass {
        /// <summary>
        /// The value of this priority class. This is the actual priority that pods receive when
        /// they have the name of this class in their pod spec.
        /// </summary>
        public Input<int> Value { get; set; } = null!;

        /// <summary>
        /// description is an arbitrary string that usually provides guidelines on when this
        /// priority class should be used.
        /// </summary>
        public Input<string>? Description { get; set; }

        /// <summary>
        /// globalDefault specifies whether this PriorityClass should be considered as the default
        /// priority for pods that do not have any priority class. Only one PriorityClass can be
        /// marked as `globalDefault`. However, if more than one PriorityClasses exists with their
        /// `globalDefault` field set to true, the smallest value of such global default
        /// PriorityClasses will be used as the default priority.
        /// </summary>
        public Input<bool>? GlobalDefault { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
        public Input<string>? PreemptionPolicy { get; set; }

    }

    /// <summary>
    /// PriorityClassList is a collection of priority classes.
    /// </summary>
    class PriorityClassList {
        /// <summary>
        /// items is the list of PriorityClasses
        /// </summary>
        public Input<Input<Scheduling.V1.PriorityClass>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

  }

  namespace V1Alpha1 {
    /// <summary>
    /// DEPRECATED - This group version of PriorityClass is deprecated by
    /// scheduling.k8s.io/v1/PriorityClass. PriorityClass defines mapping from a priority class name
    /// to the priority integer value. The value can be any valid integer.
    /// </summary>
    class PriorityClass {
        /// <summary>
        /// The value of this priority class. This is the actual priority that pods receive when
        /// they have the name of this class in their pod spec.
        /// </summary>
        public Input<int> Value { get; set; } = null!;

        /// <summary>
        /// description is an arbitrary string that usually provides guidelines on when this
        /// priority class should be used.
        /// </summary>
        public Input<string>? Description { get; set; }

        /// <summary>
        /// globalDefault specifies whether this PriorityClass should be considered as the default
        /// priority for pods that do not have any priority class. Only one PriorityClass can be
        /// marked as `globalDefault`. However, if more than one PriorityClasses exists with their
        /// `globalDefault` field set to true, the smallest value of such global default
        /// PriorityClasses will be used as the default priority.
        /// </summary>
        public Input<bool>? GlobalDefault { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
        public Input<string>? PreemptionPolicy { get; set; }

    }

    /// <summary>
    /// PriorityClassList is a collection of priority classes.
    /// </summary>
    class PriorityClassList {
        /// <summary>
        /// items is the list of PriorityClasses
        /// </summary>
        public Input<Input<Scheduling.V1Alpha1.PriorityClass>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// DEPRECATED - This group version of PriorityClass is deprecated by
    /// scheduling.k8s.io/v1/PriorityClass. PriorityClass defines mapping from a priority class name
    /// to the priority integer value. The value can be any valid integer.
    /// </summary>
    class PriorityClass {
        /// <summary>
        /// The value of this priority class. This is the actual priority that pods receive when
        /// they have the name of this class in their pod spec.
        /// </summary>
        public Input<int> Value { get; set; } = null!;

        /// <summary>
        /// description is an arbitrary string that usually provides guidelines on when this
        /// priority class should be used.
        /// </summary>
        public Input<string>? Description { get; set; }

        /// <summary>
        /// globalDefault specifies whether this PriorityClass should be considered as the default
        /// priority for pods that do not have any priority class. Only one PriorityClass can be
        /// marked as `globalDefault`. However, if more than one PriorityClasses exists with their
        /// `globalDefault` field set to true, the smallest value of such global default
        /// PriorityClasses will be used as the default priority.
        /// </summary>
        public Input<bool>? GlobalDefault { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
        public Input<string>? PreemptionPolicy { get; set; }

    }

    /// <summary>
    /// PriorityClassList is a collection of priority classes.
    /// </summary>
    class PriorityClassList {
        /// <summary>
        /// items is the list of PriorityClasses
        /// </summary>
        public Input<Input<Scheduling.V1Beta1.PriorityClass>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Settings {
  namespace V1Alpha1 {
    /// <summary>
    /// PodPreset is a policy resource that defines additional runtime requirements for a Pod.
    /// </summary>
    class PodPreset {
        
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        
        public Input<Settings.V1Alpha1.PodPresetSpec>? Spec { get; set; }

    }

    /// <summary>
    /// PodPresetList is a list of PodPreset objects.
    /// </summary>
    class PodPresetList {
        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public Input<Input<Settings.V1Alpha1.PodPreset>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// PodPresetSpec is a description of a pod preset.
    /// </summary>
    class PodPresetSpec {
        /// <summary>
        /// Env defines the collection of EnvVar to inject into containers.
        /// </summary>
        public Input<Input<Core.V1.EnvVar>[]>? Env { get; set; }

        /// <summary>
        /// EnvFrom defines the collection of EnvFromSource to inject into containers.
        /// </summary>
        public Input<Input<Core.V1.EnvFromSource>[]>? EnvFrom { get; set; }

        /// <summary>
        /// Selector is a label query over a set of resources, in this case pods. Required.
        /// </summary>
        public Input<Meta.V1.LabelSelector>? Selector { get; set; }

        /// <summary>
        /// VolumeMounts defines the collection of VolumeMount to inject into containers.
        /// </summary>
        public Input<Input<Core.V1.VolumeMount>[]>? VolumeMounts { get; set; }

        /// <summary>
        /// Volumes defines the collection of Volume to inject into the pod.
        /// </summary>
        public Input<Input<Core.V1.Volume>[]>? Volumes { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Storage {
  namespace V1 {
    /// <summary>
    /// StorageClass describes the parameters for a class of storage for which PersistentVolumes can
    /// be dynamically provisioned.
    /// 
    /// StorageClasses are non-namespaced; the name of the storage class according to etcd is in
    /// ObjectMeta.Name.
    /// </summary>
    class StorageClass {
        /// <summary>
        /// Provisioner indicates the type of the provisioner.
        /// </summary>
        public Input<string> Provisioner { get; set; } = null!;

        /// <summary>
        /// AllowVolumeExpansion shows whether the storage class allow volume expand
        /// </summary>
        public Input<bool>? AllowVolumeExpansion { get; set; }

        /// <summary>
        /// Restrict the node topologies where volumes can be dynamically provisioned. Each volume
        /// plugin defines its own supported topology specifications. An empty TopologySelectorTerm
        /// list means there is no topology restriction. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
        public Input<Input<Core.V1.TopologySelectorTerm>[]>? AllowedTopologies { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with these
        /// mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if
        /// one is invalid.
        /// </summary>
        public Input<Input<string>[]>? MountOptions { get; set; }

        /// <summary>
        /// Parameters holds the parameters for the provisioner that should create volumes of this
        /// storage class.
        /// </summary>
        public InputMap<string>? Parameters { get; set; }

        /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with this
        /// reclaimPolicy. Defaults to Delete.
        /// </summary>
        public Input<string>? ReclaimPolicy { get; set; }

        /// <summary>
        /// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.
        /// When unset, VolumeBindingImmediate is used. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
        public Input<string>? VolumeBindingMode { get; set; }

    }

    /// <summary>
    /// StorageClassList is a collection of storage classes.
    /// </summary>
    class StorageClassList {
        /// <summary>
        /// Items is the list of StorageClasses
        /// </summary>
        public Input<Input<Storage.V1.StorageClass>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachment captures the intent to attach or detach the specified volume to/from the
    /// specified node.
    /// 
    /// VolumeAttachment objects are non-namespaced.
    /// </summary>
    class VolumeAttachment {
        /// <summary>
        /// Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
        /// system.
        /// </summary>
        public Input<Storage.V1.VolumeAttachmentSpec> Spec { get; set; } = null!;

        /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentList is a collection of VolumeAttachment objects.
    /// </summary>
    class VolumeAttachmentList {
        /// <summary>
        /// Items is the list of VolumeAttachments
        /// </summary>
        public Input<Input<Storage.V1.VolumeAttachment>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSource represents a volume that should be attached. Right now only
    /// PersistenVolumes can be attached via external attacher, in future we may allow also inline
    /// volumes in pods. Exactly one member can be set.
    /// </summary>
    class VolumeAttachmentSource {
        /// <summary>
        /// inlineVolumeSpec contains all the information necessary to attach a persistent volume
        /// defined by a pod's inline VolumeSource. This field is populated only for the
        /// CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to
        /// a PersistentVolumeSpec. This field is alpha-level and is only honored by servers that
        /// enabled the CSIMigration feature.
        /// </summary>
        public Input<Core.V1.PersistentVolumeSpec>? InlineVolumeSpec { get; set; }

        /// <summary>
        /// Name of the persistent volume to attach.
        /// </summary>
        public Input<string>? PersistentVolumeName { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
    /// </summary>
    class VolumeAttachmentSpec {
        /// <summary>
        /// Attacher indicates the name of the volume driver that MUST handle this request. This is
        /// the name returned by GetPluginName().
        /// </summary>
        public Input<string> Attacher { get; set; } = null!;

        /// <summary>
        /// The node that the volume should be attached to.
        /// </summary>
        public Input<string> NodeName { get; set; } = null!;

        /// <summary>
        /// Source represents the volume that should be attached.
        /// </summary>
        public Input<Storage.V1.VolumeAttachmentSource> Source { get; set; } = null!;

    }

    /// <summary>
    /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
    /// </summary>
    class VolumeAttachmentStatus {
        /// <summary>
        /// Indicates the volume is successfully attached. This field must only be set by the entity
        /// completing the attach operation, i.e. the external-attacher.
        /// </summary>
        public Input<bool> Attached { get; set; } = null!;

        /// <summary>
        /// The last error encountered during attach operation, if any. This field must only be set
        /// by the entity completing the attach operation, i.e. the external-attacher.
        /// </summary>
        public Input<Storage.V1.VolumeError>? AttachError { get; set; }

        /// <summary>
        /// Upon successful attach, this field is populated with any information returned by the
        /// attach operation that must be passed into subsequent WaitForAttach or Mount calls. This
        /// field must only be set by the entity completing the attach operation, i.e. the
        /// external-attacher.
        /// </summary>
        public InputMap<string>? AttachmentMetadata { get; set; }

        /// <summary>
        /// The last error encountered during detach operation, if any. This field must only be set
        /// by the entity completing the detach operation, i.e. the external-attacher.
        /// </summary>
        public Input<Storage.V1.VolumeError>? DetachError { get; set; }

    }

    /// <summary>
    /// VolumeError captures an error encountered during a volume operation.
    /// </summary>
    class VolumeError {
        /// <summary>
        /// String detailing the error encountered during Attach or Detach operation. This string
        /// may be logged, so it should not contain sensitive information.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Time the error was encountered.
        /// </summary>
        public Input<string>? Time { get; set; }

    }

  }

  namespace V1Alpha1 {
    /// <summary>
    /// VolumeAttachment captures the intent to attach or detach the specified volume to/from the
    /// specified node.
    /// 
    /// VolumeAttachment objects are non-namespaced.
    /// </summary>
    class VolumeAttachment {
        /// <summary>
        /// Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
        /// system.
        /// </summary>
        public Input<Storage.V1Alpha1.VolumeAttachmentSpec> Spec { get; set; } = null!;

        /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentList is a collection of VolumeAttachment objects.
    /// </summary>
    class VolumeAttachmentList {
        /// <summary>
        /// Items is the list of VolumeAttachments
        /// </summary>
        public Input<Input<Storage.V1Alpha1.VolumeAttachment>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSource represents a volume that should be attached. Right now only
    /// PersistenVolumes can be attached via external attacher, in future we may allow also inline
    /// volumes in pods. Exactly one member can be set.
    /// </summary>
    class VolumeAttachmentSource {
        /// <summary>
        /// inlineVolumeSpec contains all the information necessary to attach a persistent volume
        /// defined by a pod's inline VolumeSource. This field is populated only for the
        /// CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to
        /// a PersistentVolumeSpec. This field is alpha-level and is only honored by servers that
        /// enabled the CSIMigration feature.
        /// </summary>
        public Input<Core.V1.PersistentVolumeSpec>? InlineVolumeSpec { get; set; }

        /// <summary>
        /// Name of the persistent volume to attach.
        /// </summary>
        public Input<string>? PersistentVolumeName { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
    /// </summary>
    class VolumeAttachmentSpec {
        /// <summary>
        /// Attacher indicates the name of the volume driver that MUST handle this request. This is
        /// the name returned by GetPluginName().
        /// </summary>
        public Input<string> Attacher { get; set; } = null!;

        /// <summary>
        /// The node that the volume should be attached to.
        /// </summary>
        public Input<string> NodeName { get; set; } = null!;

        /// <summary>
        /// Source represents the volume that should be attached.
        /// </summary>
        public Input<Storage.V1Alpha1.VolumeAttachmentSource> Source { get; set; } = null!;

    }

    /// <summary>
    /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
    /// </summary>
    class VolumeAttachmentStatus {
        /// <summary>
        /// Indicates the volume is successfully attached. This field must only be set by the entity
        /// completing the attach operation, i.e. the external-attacher.
        /// </summary>
        public Input<bool> Attached { get; set; } = null!;

        /// <summary>
        /// The last error encountered during attach operation, if any. This field must only be set
        /// by the entity completing the attach operation, i.e. the external-attacher.
        /// </summary>
        public Input<Storage.V1Alpha1.VolumeError>? AttachError { get; set; }

        /// <summary>
        /// Upon successful attach, this field is populated with any information returned by the
        /// attach operation that must be passed into subsequent WaitForAttach or Mount calls. This
        /// field must only be set by the entity completing the attach operation, i.e. the
        /// external-attacher.
        /// </summary>
        public InputMap<string>? AttachmentMetadata { get; set; }

        /// <summary>
        /// The last error encountered during detach operation, if any. This field must only be set
        /// by the entity completing the detach operation, i.e. the external-attacher.
        /// </summary>
        public Input<Storage.V1Alpha1.VolumeError>? DetachError { get; set; }

    }

    /// <summary>
    /// VolumeError captures an error encountered during a volume operation.
    /// </summary>
    class VolumeError {
        /// <summary>
        /// String detailing the error encountered during Attach or Detach operation. This string
        /// maybe logged, so it should not contain sensitive information.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Time the error was encountered.
        /// </summary>
        public Input<string>? Time { get; set; }

    }

  }

  namespace V1Beta1 {
    /// <summary>
    /// CSIDriver captures information about a Container Storage Interface (CSI) volume driver
    /// deployed on the cluster. CSI drivers do not need to create the CSIDriver object directly.
    /// Instead they may use the cluster-driver-registrar sidecar container. When deployed with a
    /// CSI driver it automatically creates a CSIDriver object representing the driver. Kubernetes
    /// attach detach controller uses this object to determine whether attach is required. Kubelet
    /// uses this object to determine whether pod information needs to be passed on mount. CSIDriver
    /// objects are non-namespaced.
    /// </summary>
    class CSIDriver {
        /// <summary>
        /// Specification of the CSI Driver.
        /// </summary>
        public Input<Storage.V1Beta1.CSIDriverSpec> Spec { get; set; } = null!;

        /// <summary>
        /// Standard object metadata. metadata.Name indicates the name of the CSI driver that this
        /// object refers to; it MUST be the same name returned by the CSI GetPluginName() call for
        /// that driver. The driver name must be 63 characters or less, beginning and ending with an
        /// alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and alphanumerics
        /// between. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CSIDriverList is a collection of CSIDriver objects.
    /// </summary>
    class CSIDriverList {
        /// <summary>
        /// items is the list of CSIDriver
        /// </summary>
        public Input<Input<Storage.V1Beta1.CSIDriver>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CSIDriverSpec is the specification of a CSIDriver.
    /// </summary>
    class CSIDriverSpec {
        /// <summary>
        /// attachRequired indicates this CSI volume driver requires an attach operation (because it
        /// implements the CSI ControllerPublishVolume() method), and that the Kubernetes attach
        /// detach controller should call the attach volume interface which checks the
        /// volumeattachment status and waits until the volume is attached before proceeding to
        /// mounting. The CSI external-attacher coordinates with CSI volume driver and updates the
        /// volumeattachment status when the attach operation is complete. If the CSIDriverRegistry
        /// feature gate is enabled and the value is specified to false, the attach operation will
        /// be skipped. Otherwise the attach operation will be called.
        /// </summary>
        public Input<bool>? AttachRequired { get; set; }

        /// <summary>
        /// If set to true, podInfoOnMount indicates this CSI volume driver requires additional pod
        /// information (like podName, podUID, etc.) during mount operations. If set to false, pod
        /// information will not be passed on mount. Default is false. The CSI driver specifies
        /// podInfoOnMount as part of driver deployment. If true, Kubelet will pass pod information
        /// as VolumeContext in the CSI NodePublishVolume() calls. The CSI driver is responsible for
        /// parsing and validating the information passed in as VolumeContext. The following
        /// VolumeConext will be passed if podInfoOnMount is set to true. This list might grow, but
        /// the prefix will be used. "csi.storage.k8s.io/pod.name": pod.Name
        /// "csi.storage.k8s.io/pod.namespace": pod.Namespace "csi.storage.k8s.io/pod.uid":
        /// string(pod.UID) "csi.storage.k8s.io/ephemeral": "true" iff the volume is an ephemeral
        /// inline volume
        ///                                 defined by a CSIVolumeSource, otherwise "false"
        /// 
        /// "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only required
        /// for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
        /// Other drivers can leave pod info disabled and/or ignore this field. As Kubernetes 1.15
        /// doesn't support this field, drivers can only support one mode when deployed on such a
        /// cluster and the deployment determines which mode that is, for example via a command line
        /// parameter of the driver.
        /// </summary>
        public Input<bool>? PodInfoOnMount { get; set; }

        /// <summary>
        /// VolumeLifecycleModes defines what kind of volumes this CSI volume driver supports. The
        /// default if the list is empty is "Persistent", which is the usage defined by the CSI
        /// specification and implemented in Kubernetes via the usual PV/PVC mechanism. The other
        /// mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec with
        /// CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod. A driver has
        /// to be aware of this because it is only going to get a NodePublishVolume call for such a
        /// volume. For more information about implementing this mode, see
        /// https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html A driver can support
        /// one or more of these modes and more modes may be added in the future.
        /// </summary>
        public Input<Input<string>[]>? VolumeLifecycleModes { get; set; }

    }

    /// <summary>
    /// CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need
    /// to create the CSINode object directly. As long as they use the node-driver-registrar sidecar
    /// container, the kubelet will automatically populate the CSINode object for the CSI driver as
    /// part of kubelet plugin registration. CSINode has the same name as a node. If the object is
    /// missing, it means either there are no CSI Drivers available on the node, or the Kubelet
    /// version is low enough that it doesn't create this object. CSINode has an OwnerReference that
    /// points to the corresponding node object.
    /// </summary>
    class CSINode {
        /// <summary>
        /// spec is the specification of CSINode
        /// </summary>
        public Input<Storage.V1Beta1.CSINodeSpec> Spec { get; set; } = null!;

        /// <summary>
        /// metadata.name must be the Kubernetes node name.
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CSINodeDriver holds information about the specification of one CSI driver installed on a
    /// node
    /// </summary>
    class CSINodeDriver {
        /// <summary>
        /// This is the name of the CSI driver that this object refers to. This MUST be the same
        /// name returned by the CSI GetPluginName() call for that driver.
        /// </summary>
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// nodeID of the node from the driver point of view. This field enables Kubernetes to
        /// communicate with storage systems that do not share the same nomenclature for nodes. For
        /// example, Kubernetes may refer to a given node as "node1", but the storage system may
        /// refer to the same node as "nodeA". When Kubernetes issues a command to the storage
        /// system to attach a volume to a specific node, it can use this field to refer to the node
        /// name using the ID that the storage system will understand, e.g. "nodeA" instead of
        /// "node1". This field is required.
        /// </summary>
        public Input<string> NodeID { get; set; } = null!;

        /// <summary>
        /// allocatable represents the volume resources of a node that are available for scheduling.
        /// </summary>
        public Input<Storage.V1Beta1.VolumeNodeResources>? Allocatable { get; set; }

        /// <summary>
        /// topologyKeys is the list of keys supported by the driver. When a driver is initialized
        /// on a cluster, it provides a set of topology keys that it understands (e.g.
        /// "company.com/zone", "company.com/region"). When a driver is initialized on a node, it
        /// provides the same topology keys along with values. Kubelet will expose these topology
        /// keys as labels on its own node object. When Kubernetes does topology aware provisioning,
        /// it can use this list to determine which labels it should retrieve from the node object
        /// and pass back to the driver. It is possible for different nodes to use different
        /// topology keys. This can be empty if driver does not support topology.
        /// </summary>
        public Input<Input<string>[]>? TopologyKeys { get; set; }

    }

    /// <summary>
    /// CSINodeList is a collection of CSINode objects.
    /// </summary>
    class CSINodeList {
        /// <summary>
        /// items is the list of CSINode
        /// </summary>
        public Input<Input<Storage.V1Beta1.CSINode>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// CSINodeSpec holds information about the specification of all CSI drivers installed on a node
    /// </summary>
    class CSINodeSpec {
        /// <summary>
        /// drivers is a list of information of all CSI Drivers existing on a node. If all drivers
        /// in the list are uninstalled, this can become empty.
        /// </summary>
        public Input<Input<Storage.V1Beta1.CSINodeDriver>[]> Drivers { get; set; } = null!;

    }

    /// <summary>
    /// StorageClass describes the parameters for a class of storage for which PersistentVolumes can
    /// be dynamically provisioned.
    /// 
    /// StorageClasses are non-namespaced; the name of the storage class according to etcd is in
    /// ObjectMeta.Name.
    /// </summary>
    class StorageClass {
        /// <summary>
        /// Provisioner indicates the type of the provisioner.
        /// </summary>
        public Input<string> Provisioner { get; set; } = null!;

        /// <summary>
        /// AllowVolumeExpansion shows whether the storage class allow volume expand
        /// </summary>
        public Input<bool>? AllowVolumeExpansion { get; set; }

        /// <summary>
        /// Restrict the node topologies where volumes can be dynamically provisioned. Each volume
        /// plugin defines its own supported topology specifications. An empty TopologySelectorTerm
        /// list means there is no topology restriction. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
        public Input<Input<Core.V1.TopologySelectorTerm>[]>? AllowedTopologies { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

        /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with these
        /// mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if
        /// one is invalid.
        /// </summary>
        public Input<Input<string>[]>? MountOptions { get; set; }

        /// <summary>
        /// Parameters holds the parameters for the provisioner that should create volumes of this
        /// storage class.
        /// </summary>
        public InputMap<string>? Parameters { get; set; }

        /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with this
        /// reclaimPolicy. Defaults to Delete.
        /// </summary>
        public Input<string>? ReclaimPolicy { get; set; }

        /// <summary>
        /// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.
        /// When unset, VolumeBindingImmediate is used. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
        public Input<string>? VolumeBindingMode { get; set; }

    }

    /// <summary>
    /// StorageClassList is a collection of storage classes.
    /// </summary>
    class StorageClassList {
        /// <summary>
        /// Items is the list of StorageClasses
        /// </summary>
        public Input<Input<Storage.V1Beta1.StorageClass>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachment captures the intent to attach or detach the specified volume to/from the
    /// specified node.
    /// 
    /// VolumeAttachment objects are non-namespaced.
    /// </summary>
    class VolumeAttachment {
        /// <summary>
        /// Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
        /// system.
        /// </summary>
        public Input<Storage.V1Beta1.VolumeAttachmentSpec> Spec { get; set; } = null!;

        /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ObjectMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentList is a collection of VolumeAttachment objects.
    /// </summary>
    class VolumeAttachmentList {
        /// <summary>
        /// Items is the list of VolumeAttachments
        /// </summary>
        public Input<Input<Storage.V1Beta1.VolumeAttachment>[]> Items { get; set; } = null!;

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        public Input<Meta.V1.ListMeta>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSource represents a volume that should be attached. Right now only
    /// PersistenVolumes can be attached via external attacher, in future we may allow also inline
    /// volumes in pods. Exactly one member can be set.
    /// </summary>
    class VolumeAttachmentSource {
        /// <summary>
        /// inlineVolumeSpec contains all the information necessary to attach a persistent volume
        /// defined by a pod's inline VolumeSource. This field is populated only for the
        /// CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to
        /// a PersistentVolumeSpec. This field is alpha-level and is only honored by servers that
        /// enabled the CSIMigration feature.
        /// </summary>
        public Input<Core.V1.PersistentVolumeSpec>? InlineVolumeSpec { get; set; }

        /// <summary>
        /// Name of the persistent volume to attach.
        /// </summary>
        public Input<string>? PersistentVolumeName { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
    /// </summary>
    class VolumeAttachmentSpec {
        /// <summary>
        /// Attacher indicates the name of the volume driver that MUST handle this request. This is
        /// the name returned by GetPluginName().
        /// </summary>
        public Input<string> Attacher { get; set; } = null!;

        /// <summary>
        /// The node that the volume should be attached to.
        /// </summary>
        public Input<string> NodeName { get; set; } = null!;

        /// <summary>
        /// Source represents the volume that should be attached.
        /// </summary>
        public Input<Storage.V1Beta1.VolumeAttachmentSource> Source { get; set; } = null!;

    }

    /// <summary>
    /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
    /// </summary>
    class VolumeAttachmentStatus {
        /// <summary>
        /// Indicates the volume is successfully attached. This field must only be set by the entity
        /// completing the attach operation, i.e. the external-attacher.
        /// </summary>
        public Input<bool> Attached { get; set; } = null!;

        /// <summary>
        /// The last error encountered during attach operation, if any. This field must only be set
        /// by the entity completing the attach operation, i.e. the external-attacher.
        /// </summary>
        public Input<Storage.V1Beta1.VolumeError>? AttachError { get; set; }

        /// <summary>
        /// Upon successful attach, this field is populated with any information returned by the
        /// attach operation that must be passed into subsequent WaitForAttach or Mount calls. This
        /// field must only be set by the entity completing the attach operation, i.e. the
        /// external-attacher.
        /// </summary>
        public InputMap<string>? AttachmentMetadata { get; set; }

        /// <summary>
        /// The last error encountered during detach operation, if any. This field must only be set
        /// by the entity completing the detach operation, i.e. the external-attacher.
        /// </summary>
        public Input<Storage.V1Beta1.VolumeError>? DetachError { get; set; }

    }

    /// <summary>
    /// VolumeError captures an error encountered during a volume operation.
    /// </summary>
    class VolumeError {
        /// <summary>
        /// String detailing the error encountered during Attach or Detach operation. This string
        /// may be logged, so it should not contain sensitive information.
        /// </summary>
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Time the error was encountered.
        /// </summary>
        public Input<string>? Time { get; set; }

    }

    /// <summary>
    /// VolumeNodeResources is a set of resource limits for scheduling of volumes.
    /// </summary>
    class VolumeNodeResources {
        /// <summary>
        /// Maximum number of unique volumes managed by the CSI driver that can be used on a node. A
        /// volume that is both attached and mounted on a node is considered to be used once, not
        /// twice. The same rule applies for a unique volume that is shared among multiple pods on
        /// the same node. If this field is nil, then the supported number of volumes on this node
        /// is unbounded.
        /// </summary>
        public Input<int>? Count { get; set; }

    }

  }

}

