// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.Json;
using GlobExpressions;

#pragma warning disable CS0618

namespace Pulumi.Kubernetes.Yaml
{
    /// <summary>
    /// Base component for containers of Kubernetes resources.
    /// </summary>
    public abstract class CollectionComponentResource : ComponentResource
    {
        internal Output<ImmutableDictionary<string, KubernetesResource>> Resources { get; private set; } = null!;

        protected CollectionComponentResource(string type, string name, ComponentResourceOptions? options = null)
            : base(type, name, options)
        {
        }

        protected void RegisterResources(Output<ImmutableDictionary<string, KubernetesResource>> resources)
        {
            Resources = resources;
            RegisterOutputs(new Dictionary<string, object?> { { "resources", resources } });
        }

        /// <summary>
        /// Returns a resource defined by the given name.
        /// </summary>
        /// <param name="name">Resource name.</param>
        /// <param name="namespaceName">Optional namespace, e.g. "kube-prometheus-exporter-kubernetes".</param>
        /// <typeparam name="T">The type of the resource.</typeparam>
        public Output<T> GetResource<T>(string name, string? namespaceName = null)
            where T : KubernetesResource
        {
            var type = typeof(T);
            var groupVersionKind =
                type == typeof(AdmissionRegistration.V1.MutatingWebhookConfiguration) ? "admissionregistration.k8s.io/v1/MutatingWebhookConfiguration" :
                type == typeof(AdmissionRegistration.V1.MutatingWebhookConfigurationList) ? "admissionregistration.k8s.io/v1/MutatingWebhookConfigurationList" :
                type == typeof(AdmissionRegistration.V1.ValidatingWebhookConfiguration) ? "admissionregistration.k8s.io/v1/ValidatingWebhookConfiguration" :
                type == typeof(AdmissionRegistration.V1.ValidatingWebhookConfigurationList) ? "admissionregistration.k8s.io/v1/ValidatingWebhookConfigurationList" :
                type == typeof(AdmissionRegistration.V1Beta1.MutatingWebhookConfiguration) ? "admissionregistration.k8s.io/v1beta1/MutatingWebhookConfiguration" :
                type == typeof(AdmissionRegistration.V1Beta1.MutatingWebhookConfigurationList) ? "admissionregistration.k8s.io/v1beta1/MutatingWebhookConfigurationList" :
                type == typeof(AdmissionRegistration.V1Beta1.ValidatingWebhookConfiguration) ? "admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfiguration" :
                type == typeof(AdmissionRegistration.V1Beta1.ValidatingWebhookConfigurationList) ? "admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfigurationList" :
                type == typeof(ApiExtensions.V1.CustomResourceDefinition) ? "apiextensions.k8s.io/v1/CustomResourceDefinition" :
                type == typeof(ApiExtensions.V1.CustomResourceDefinitionList) ? "apiextensions.k8s.io/v1/CustomResourceDefinitionList" :
                type == typeof(ApiExtensions.V1Beta1.CustomResourceDefinition) ? "apiextensions.k8s.io/v1beta1/CustomResourceDefinition" :
                type == typeof(ApiExtensions.V1Beta1.CustomResourceDefinitionList) ? "apiextensions.k8s.io/v1beta1/CustomResourceDefinitionList" :
                type == typeof(ApiRegistration.V1.APIService) ? "apiregistration.k8s.io/v1/APIService" :
                type == typeof(ApiRegistration.V1.APIServiceList) ? "apiregistration.k8s.io/v1/APIServiceList" :
                type == typeof(ApiRegistration.V1Beta1.APIService) ? "apiregistration.k8s.io/v1beta1/APIService" :
                type == typeof(ApiRegistration.V1Beta1.APIServiceList) ? "apiregistration.k8s.io/v1beta1/APIServiceList" :
                type == typeof(Apps.V1.ControllerRevision) ? "apps/v1/ControllerRevision" :
                type == typeof(Apps.V1.ControllerRevisionList) ? "apps/v1/ControllerRevisionList" :
                type == typeof(Apps.V1.DaemonSet) ? "apps/v1/DaemonSet" :
                type == typeof(Apps.V1.DaemonSetList) ? "apps/v1/DaemonSetList" :
                type == typeof(Apps.V1.Deployment) ? "apps/v1/Deployment" :
                type == typeof(Apps.V1.DeploymentList) ? "apps/v1/DeploymentList" :
                type == typeof(Apps.V1.ReplicaSet) ? "apps/v1/ReplicaSet" :
                type == typeof(Apps.V1.ReplicaSetList) ? "apps/v1/ReplicaSetList" :
                type == typeof(Apps.V1.StatefulSet) ? "apps/v1/StatefulSet" :
                type == typeof(Apps.V1.StatefulSetList) ? "apps/v1/StatefulSetList" :
                type == typeof(Apps.V1Beta1.ControllerRevision) ? "apps/v1beta1/ControllerRevision" :
                type == typeof(Apps.V1Beta1.ControllerRevisionList) ? "apps/v1beta1/ControllerRevisionList" :
                type == typeof(Apps.V1Beta1.Deployment) ? "apps/v1beta1/Deployment" :
                type == typeof(Apps.V1Beta1.DeploymentList) ? "apps/v1beta1/DeploymentList" :
                type == typeof(Apps.V1Beta1.StatefulSet) ? "apps/v1beta1/StatefulSet" :
                type == typeof(Apps.V1Beta1.StatefulSetList) ? "apps/v1beta1/StatefulSetList" :
                type == typeof(Apps.V1Beta2.ControllerRevision) ? "apps/v1beta2/ControllerRevision" :
                type == typeof(Apps.V1Beta2.ControllerRevisionList) ? "apps/v1beta2/ControllerRevisionList" :
                type == typeof(Apps.V1Beta2.DaemonSet) ? "apps/v1beta2/DaemonSet" :
                type == typeof(Apps.V1Beta2.DaemonSetList) ? "apps/v1beta2/DaemonSetList" :
                type == typeof(Apps.V1Beta2.Deployment) ? "apps/v1beta2/Deployment" :
                type == typeof(Apps.V1Beta2.DeploymentList) ? "apps/v1beta2/DeploymentList" :
                type == typeof(Apps.V1Beta2.ReplicaSet) ? "apps/v1beta2/ReplicaSet" :
                type == typeof(Apps.V1Beta2.ReplicaSetList) ? "apps/v1beta2/ReplicaSetList" :
                type == typeof(Apps.V1Beta2.StatefulSet) ? "apps/v1beta2/StatefulSet" :
                type == typeof(Apps.V1Beta2.StatefulSetList) ? "apps/v1beta2/StatefulSetList" :
                type == typeof(AuditRegistraion.V1Alpha1.AuditSink) ? "auditregistration.k8s.io/v1alpha1/AuditSink" :
                type == typeof(AuditRegistraion.V1Alpha1.AuditSinkList) ? "auditregistration.k8s.io/v1alpha1/AuditSinkList" :
                type == typeof(Authentication.V1.TokenRequest) ? "authentication.k8s.io/v1/TokenRequest" :
                type == typeof(Authentication.V1.TokenReview) ? "authentication.k8s.io/v1/TokenReview" :
                type == typeof(Authentication.V1Beta1.TokenReview) ? "authentication.k8s.io/v1beta1/TokenReview" :
                type == typeof(Authorization.V1.LocalSubjectAccessReview) ? "authorization.k8s.io/v1/LocalSubjectAccessReview" :
                type == typeof(Authorization.V1.SelfSubjectAccessReview) ? "authorization.k8s.io/v1/SelfSubjectAccessReview" :
                type == typeof(Authorization.V1.SelfSubjectRulesReview) ? "authorization.k8s.io/v1/SelfSubjectRulesReview" :
                type == typeof(Authorization.V1.SubjectAccessReview) ? "authorization.k8s.io/v1/SubjectAccessReview" :
                type == typeof(Authorization.V1Beta1.LocalSubjectAccessReview) ? "authorization.k8s.io/v1beta1/LocalSubjectAccessReview" :
                type == typeof(Authorization.V1Beta1.SelfSubjectAccessReview) ? "authorization.k8s.io/v1beta1/SelfSubjectAccessReview" :
                type == typeof(Authorization.V1Beta1.SelfSubjectRulesReview) ? "authorization.k8s.io/v1beta1/SelfSubjectRulesReview" :
                type == typeof(Authorization.V1Beta1.SubjectAccessReview) ? "authorization.k8s.io/v1beta1/SubjectAccessReview" :
                type == typeof(Autoscaling.V1.HorizontalPodAutoscaler) ? "autoscaling/v1/HorizontalPodAutoscaler" :
                type == typeof(Autoscaling.V1.HorizontalPodAutoscalerList) ? "autoscaling/v1/HorizontalPodAutoscalerList" :
                type == typeof(Autoscaling.V2Beta1.HorizontalPodAutoscaler) ? "autoscaling/v2beta1/HorizontalPodAutoscaler" :
                type == typeof(Autoscaling.V2Beta1.HorizontalPodAutoscalerList) ? "autoscaling/v2beta1/HorizontalPodAutoscalerList" :
                type == typeof(Autoscaling.V2Beta2.HorizontalPodAutoscaler) ? "autoscaling/v2beta2/HorizontalPodAutoscaler" :
                type == typeof(Autoscaling.V2Beta2.HorizontalPodAutoscalerList) ? "autoscaling/v2beta2/HorizontalPodAutoscalerList" :
                type == typeof(Batch.V1.Job) ? "batch/v1/Job" :
                type == typeof(Batch.V1.JobList) ? "batch/v1/JobList" :
                type == typeof(Batch.V1Beta1.CronJob) ? "batch/v1beta1/CronJob" :
                type == typeof(Batch.V1Beta1.CronJobList) ? "batch/v1beta1/CronJobList" :
                type == typeof(Batch.V2Alpha1.CronJob) ? "batch/v2alpha1/CronJob" :
                type == typeof(Batch.V2Alpha1.CronJobList) ? "batch/v2alpha1/CronJobList" :
                type == typeof(Certificates.V1.CertificateSigningRequest) ? "certificates.k8s.io/v1/CertificateSigningRequest" :
                type == typeof(Certificates.V1.CertificateSigningRequestList) ? "certificates.k8s.io/v1/CertificateSigningRequestList" :
                type == typeof(Certificates.V1Beta1.CertificateSigningRequest) ? "certificates.k8s.io/v1beta1/CertificateSigningRequest" :
                type == typeof(Certificates.V1Beta1.CertificateSigningRequestList) ? "certificates.k8s.io/v1beta1/CertificateSigningRequestList" :
                type == typeof(Coordination.V1.Lease) ? "coordination.k8s.io/v1/Lease" :
                type == typeof(Coordination.V1.LeaseList) ? "coordination.k8s.io/v1/LeaseList" :
                type == typeof(Coordination.V1Beta1.Lease) ? "coordination.k8s.io/v1beta1/Lease" :
                type == typeof(Coordination.V1Beta1.LeaseList) ? "coordination.k8s.io/v1beta1/LeaseList" :
                type == typeof(Core.V1.Binding) ? "v1/Binding" :
                type == typeof(Core.V1.ConfigMap) ? "v1/ConfigMap" :
                type == typeof(Core.V1.ConfigMapList) ? "v1/ConfigMapList" :
                type == typeof(Core.V1.Endpoints) ? "v1/Endpoints" :
                type == typeof(Core.V1.EndpointsList) ? "v1/EndpointsList" :
                type == typeof(Core.V1.Event) ? "v1/Event" :
                type == typeof(Core.V1.EventList) ? "v1/EventList" :
                type == typeof(Core.V1.LimitRange) ? "v1/LimitRange" :
                type == typeof(Core.V1.LimitRangeList) ? "v1/LimitRangeList" :
                type == typeof(Core.V1.Namespace) ? "v1/Namespace" :
                type == typeof(Core.V1.NamespaceList) ? "v1/NamespaceList" :
                type == typeof(Core.V1.Node) ? "v1/Node" :
                type == typeof(Core.V1.NodeList) ? "v1/NodeList" :
                type == typeof(Core.V1.PersistentVolume) ? "v1/PersistentVolume" :
                type == typeof(Core.V1.PersistentVolumeClaim) ? "v1/PersistentVolumeClaim" :
                type == typeof(Core.V1.PersistentVolumeClaimList) ? "v1/PersistentVolumeClaimList" :
                type == typeof(Core.V1.PersistentVolumeList) ? "v1/PersistentVolumeList" :
                type == typeof(Core.V1.Pod) ? "v1/Pod" :
                type == typeof(Core.V1.PodList) ? "v1/PodList" :
                type == typeof(Core.V1.PodTemplate) ? "v1/PodTemplate" :
                type == typeof(Core.V1.PodTemplateList) ? "v1/PodTemplateList" :
                type == typeof(Core.V1.ReplicationController) ? "v1/ReplicationController" :
                type == typeof(Core.V1.ReplicationControllerList) ? "v1/ReplicationControllerList" :
                type == typeof(Core.V1.ResourceQuota) ? "v1/ResourceQuota" :
                type == typeof(Core.V1.ResourceQuotaList) ? "v1/ResourceQuotaList" :
                type == typeof(Core.V1.Secret) ? "v1/Secret" :
                type == typeof(Core.V1.SecretList) ? "v1/SecretList" :
                type == typeof(Core.V1.Service) ? "v1/Service" :
                type == typeof(Core.V1.ServiceAccount) ? "v1/ServiceAccount" :
                type == typeof(Core.V1.ServiceAccountList) ? "v1/ServiceAccountList" :
                type == typeof(Core.V1.ServiceList) ? "v1/ServiceList" :
                type == typeof(Discovery.V1Beta1.EndpointSlice) ? "discovery.k8s.io/v1beta1/EndpointSlice" :
                type == typeof(Discovery.V1Beta1.EndpointSliceList) ? "discovery.k8s.io/v1beta1/EndpointSliceList" :
                type == typeof(Events.V1.Event) ? "events.k8s.io/v1/Event" :
                type == typeof(Events.V1.EventList) ? "events.k8s.io/v1/EventList" :
                type == typeof(Events.V1Beta1.Event) ? "events.k8s.io/v1beta1/Event" :
                type == typeof(Events.V1Beta1.EventList) ? "events.k8s.io/v1beta1/EventList" :
                type == typeof(Extensions.V1Beta1.DaemonSet) ? "extensions/v1beta1/DaemonSet" :
                type == typeof(Extensions.V1Beta1.DaemonSetList) ? "extensions/v1beta1/DaemonSetList" :
                type == typeof(Extensions.V1Beta1.Deployment) ? "extensions/v1beta1/Deployment" :
                type == typeof(Extensions.V1Beta1.DeploymentList) ? "extensions/v1beta1/DeploymentList" :
                type == typeof(Extensions.V1Beta1.Ingress) ? "extensions/v1beta1/Ingress" :
                type == typeof(Extensions.V1Beta1.IngressList) ? "extensions/v1beta1/IngressList" :
                type == typeof(Extensions.V1Beta1.NetworkPolicy) ? "extensions/v1beta1/NetworkPolicy" :
                type == typeof(Extensions.V1Beta1.NetworkPolicyList) ? "extensions/v1beta1/NetworkPolicyList" :
                type == typeof(Extensions.V1Beta1.PodSecurityPolicy) ? "extensions/v1beta1/PodSecurityPolicy" :
                type == typeof(Extensions.V1Beta1.PodSecurityPolicyList) ? "extensions/v1beta1/PodSecurityPolicyList" :
                type == typeof(Extensions.V1Beta1.ReplicaSet) ? "extensions/v1beta1/ReplicaSet" :
                type == typeof(Extensions.V1Beta1.ReplicaSetList) ? "extensions/v1beta1/ReplicaSetList" :
                type == typeof(FlowControl.V1Alpha1.FlowSchema) ? "flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchema" :
                type == typeof(FlowControl.V1Alpha1.FlowSchemaList) ? "flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchemaList" :
                type == typeof(FlowControl.V1Alpha1.PriorityLevelConfiguration) ? "flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfiguration" :
                type == typeof(FlowControl.V1Alpha1.PriorityLevelConfigurationList) ? "flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfigurationList" :
                type == typeof(FlowControl.V1Beta1.FlowSchema) ? "flowcontrol.apiserver.k8s.io/v1beta1/FlowSchema" :
                type == typeof(FlowControl.V1Beta1.FlowSchemaList) ? "flowcontrol.apiserver.k8s.io/v1beta1/FlowSchemaList" :
                type == typeof(FlowControl.V1Beta1.PriorityLevelConfiguration) ? "flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfiguration" :
                type == typeof(FlowControl.V1Beta1.PriorityLevelConfigurationList) ? "flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfigurationList" :
                type == typeof(Meta.V1.Status) ? "meta/v1/Status" :
                type == typeof(Networking.V1.Ingress) ? "networking.k8s.io/v1/Ingress" :
                type == typeof(Networking.V1.IngressClass) ? "networking.k8s.io/v1/IngressClass" :
                type == typeof(Networking.V1.IngressClassList) ? "networking.k8s.io/v1/IngressClassList" :
                type == typeof(Networking.V1.IngressList) ? "networking.k8s.io/v1/IngressList" :
                type == typeof(Networking.V1.NetworkPolicy) ? "networking.k8s.io/v1/NetworkPolicy" :
                type == typeof(Networking.V1.NetworkPolicyList) ? "networking.k8s.io/v1/NetworkPolicyList" :
                type == typeof(Networking.V1Beta1.Ingress) ? "networking.k8s.io/v1beta1/Ingress" :
                type == typeof(Networking.V1Beta1.IngressClass) ? "networking.k8s.io/v1beta1/IngressClass" :
                type == typeof(Networking.V1Beta1.IngressClassList) ? "networking.k8s.io/v1beta1/IngressClassList" :
                type == typeof(Networking.V1Beta1.IngressList) ? "networking.k8s.io/v1beta1/IngressList" :
                type == typeof(Node.V1.RuntimeClass) ? "node.k8s.io/v1/RuntimeClass" :
                type == typeof(Node.V1.RuntimeClassList) ? "node.k8s.io/v1/RuntimeClassList" :
                type == typeof(Node.V1Alpha1.RuntimeClass) ? "node.k8s.io/v1alpha1/RuntimeClass" :
                type == typeof(Node.V1Alpha1.RuntimeClassList) ? "node.k8s.io/v1alpha1/RuntimeClassList" :
                type == typeof(Node.V1Beta1.RuntimeClass) ? "node.k8s.io/v1beta1/RuntimeClass" :
                type == typeof(Node.V1Beta1.RuntimeClassList) ? "node.k8s.io/v1beta1/RuntimeClassList" :
                type == typeof(Policy.V1Beta1.PodDisruptionBudget) ? "policy/v1beta1/PodDisruptionBudget" :
                type == typeof(Policy.V1Beta1.PodDisruptionBudgetList) ? "policy/v1beta1/PodDisruptionBudgetList" :
                type == typeof(Policy.V1Beta1.PodSecurityPolicy) ? "policy/v1beta1/PodSecurityPolicy" :
                type == typeof(Policy.V1Beta1.PodSecurityPolicyList) ? "policy/v1beta1/PodSecurityPolicyList" :
                type == typeof(Rbac.V1.ClusterRole) ? "rbac.authorization.k8s.io/v1/ClusterRole" :
                type == typeof(Rbac.V1.ClusterRoleBinding) ? "rbac.authorization.k8s.io/v1/ClusterRoleBinding" :
                type == typeof(Rbac.V1.ClusterRoleBindingList) ? "rbac.authorization.k8s.io/v1/ClusterRoleBindingList" :
                type == typeof(Rbac.V1.ClusterRoleList) ? "rbac.authorization.k8s.io/v1/ClusterRoleList" :
                type == typeof(Rbac.V1.Role) ? "rbac.authorization.k8s.io/v1/Role" :
                type == typeof(Rbac.V1.RoleBinding) ? "rbac.authorization.k8s.io/v1/RoleBinding" :
                type == typeof(Rbac.V1.RoleBindingList) ? "rbac.authorization.k8s.io/v1/RoleBindingList" :
                type == typeof(Rbac.V1.RoleList) ? "rbac.authorization.k8s.io/v1/RoleList" :
                type == typeof(Rbac.V1Alpha1.ClusterRole) ? "rbac.authorization.k8s.io/v1alpha1/ClusterRole" :
                type == typeof(Rbac.V1Alpha1.ClusterRoleBinding) ? "rbac.authorization.k8s.io/v1alpha1/ClusterRoleBinding" :
                type == typeof(Rbac.V1Alpha1.ClusterRoleBindingList) ? "rbac.authorization.k8s.io/v1alpha1/ClusterRoleBindingList" :
                type == typeof(Rbac.V1Alpha1.ClusterRoleList) ? "rbac.authorization.k8s.io/v1alpha1/ClusterRoleList" :
                type == typeof(Rbac.V1Alpha1.Role) ? "rbac.authorization.k8s.io/v1alpha1/Role" :
                type == typeof(Rbac.V1Alpha1.RoleBinding) ? "rbac.authorization.k8s.io/v1alpha1/RoleBinding" :
                type == typeof(Rbac.V1Alpha1.RoleBindingList) ? "rbac.authorization.k8s.io/v1alpha1/RoleBindingList" :
                type == typeof(Rbac.V1Alpha1.RoleList) ? "rbac.authorization.k8s.io/v1alpha1/RoleList" :
                type == typeof(Rbac.V1Beta1.ClusterRole) ? "rbac.authorization.k8s.io/v1beta1/ClusterRole" :
                type == typeof(Rbac.V1Beta1.ClusterRoleBinding) ? "rbac.authorization.k8s.io/v1beta1/ClusterRoleBinding" :
                type == typeof(Rbac.V1Beta1.ClusterRoleBindingList) ? "rbac.authorization.k8s.io/v1beta1/ClusterRoleBindingList" :
                type == typeof(Rbac.V1Beta1.ClusterRoleList) ? "rbac.authorization.k8s.io/v1beta1/ClusterRoleList" :
                type == typeof(Rbac.V1Beta1.Role) ? "rbac.authorization.k8s.io/v1beta1/Role" :
                type == typeof(Rbac.V1Beta1.RoleBinding) ? "rbac.authorization.k8s.io/v1beta1/RoleBinding" :
                type == typeof(Rbac.V1Beta1.RoleBindingList) ? "rbac.authorization.k8s.io/v1beta1/RoleBindingList" :
                type == typeof(Rbac.V1Beta1.RoleList) ? "rbac.authorization.k8s.io/v1beta1/RoleList" :
                type == typeof(Scheduling.V1.PriorityClass) ? "scheduling.k8s.io/v1/PriorityClass" :
                type == typeof(Scheduling.V1.PriorityClassList) ? "scheduling.k8s.io/v1/PriorityClassList" :
                type == typeof(Scheduling.V1Alpha1.PriorityClass) ? "scheduling.k8s.io/v1alpha1/PriorityClass" :
                type == typeof(Scheduling.V1Alpha1.PriorityClassList) ? "scheduling.k8s.io/v1alpha1/PriorityClassList" :
                type == typeof(Scheduling.V1Beta1.PriorityClass) ? "scheduling.k8s.io/v1beta1/PriorityClass" :
                type == typeof(Scheduling.V1Beta1.PriorityClassList) ? "scheduling.k8s.io/v1beta1/PriorityClassList" :
                type == typeof(Settings.V1Alpha1.PodPreset) ? "settings.k8s.io/v1alpha1/PodPreset" :
                type == typeof(Settings.V1Alpha1.PodPresetList) ? "settings.k8s.io/v1alpha1/PodPresetList" :
                type == typeof(Storage.V1.CSIDriver) ? "storage.k8s.io/v1/CSIDriver" :
                type == typeof(Storage.V1.CSIDriverList) ? "storage.k8s.io/v1/CSIDriverList" :
                type == typeof(Storage.V1.CSINode) ? "storage.k8s.io/v1/CSINode" :
                type == typeof(Storage.V1.CSINodeList) ? "storage.k8s.io/v1/CSINodeList" :
                type == typeof(Storage.V1.StorageClass) ? "storage.k8s.io/v1/StorageClass" :
                type == typeof(Storage.V1.StorageClassList) ? "storage.k8s.io/v1/StorageClassList" :
                type == typeof(Storage.V1.VolumeAttachment) ? "storage.k8s.io/v1/VolumeAttachment" :
                type == typeof(Storage.V1.VolumeAttachmentList) ? "storage.k8s.io/v1/VolumeAttachmentList" :
                type == typeof(Storage.V1Alpha1.VolumeAttachment) ? "storage.k8s.io/v1alpha1/VolumeAttachment" :
                type == typeof(Storage.V1Alpha1.VolumeAttachmentList) ? "storage.k8s.io/v1alpha1/VolumeAttachmentList" :
                type == typeof(Storage.V1Beta1.CSIDriver) ? "storage.k8s.io/v1beta1/CSIDriver" :
                type == typeof(Storage.V1Beta1.CSIDriverList) ? "storage.k8s.io/v1beta1/CSIDriverList" :
                type == typeof(Storage.V1Beta1.CSINode) ? "storage.k8s.io/v1beta1/CSINode" :
                type == typeof(Storage.V1Beta1.CSINodeList) ? "storage.k8s.io/v1beta1/CSINodeList" :
                type == typeof(Storage.V1Beta1.StorageClass) ? "storage.k8s.io/v1beta1/StorageClass" :
                type == typeof(Storage.V1Beta1.StorageClassList) ? "storage.k8s.io/v1beta1/StorageClassList" :
                type == typeof(Storage.V1Beta1.VolumeAttachment) ? "storage.k8s.io/v1beta1/VolumeAttachment" :
                type == typeof(Storage.V1Beta1.VolumeAttachmentList) ? "storage.k8s.io/v1beta1/VolumeAttachmentList" :
                throw new ArgumentException($"Unknown resource type {typeof(T).FullName}");
            var id = namespaceName != null ? $"{namespaceName}/{name}" : name;
            return Resources.Apply(r =>
            {
                if (!r.TryGetValue($"{groupVersionKind}::{id}", out var value))
                {
                    var existingKeys = string.Join(", ", r.Keys);
                    throw new ArgumentException($"Resource {groupVersionKind}::{id} of type {type.FullName} and id {id} is not found, existing resources are {existingKeys}");
                }

                return (T) value;
            });
        }

        /// <summary>
        /// Returns a custom resource defined by the given group/version/kind and name.
        /// </summary>
        /// <param name="groupVersionKind">Group/version/kind, e.g. "monitoring.coreos.com/v1/ServiceMonitor".
        /// </param>
        /// <param name="name">Resource name.</param>
        /// <param name="namespaceName">Optional namespace, e.g. "kube-prometheus-exporter-kubernetes".</param>
        public Output<CustomResource> GetCustomResource(string groupVersionKind, string name, string? namespaceName = null)
        {
            var id = namespaceName != null ? $"{namespaceName}/{name}" : name;
            return Resources.Apply(r => (CustomResource)r[$"{groupVersionKind}::{id}"]);
        }
    }

    internal static class Parser
    {
        public static Output<ImmutableDictionary<string, KubernetesResource>> Parse(ConfigGroupArgs config, ComponentResourceOptions? options)
        {
            var resources = Output.Create(ImmutableDictionary.Create<string, KubernetesResource>());

            if (config.Files != null)
            {
                var files = new List<string>();
                foreach (var file in config.Files)
                {
                    if (IsUrl(file))
                        files.Add(file);
                    else
                        files.AddRange(Glob.Files(Directory.GetCurrentDirectory(), file));
                }

                foreach (var file in files)
                {
                    var cf = new ConfigFile(
                        file,
                        new ConfigFileArgs
                        {
                            File = file,
                            Transformations = config.Transformations,
                            ResourcePrefix = config.ResourcePrefix
                        },
                        options);
                    resources = Output.Tuple(resources, cf.Resources).Apply(vs => vs.Item1.AddRange(vs.Item2));
                }
            }

            if (config.Yaml != null)
            {
                var yamlResources = config.Yaml.ToOutput().Apply(texts =>
                {
                    var yamls = texts
                        .Select(text =>
                            ParseYamlDocument(new ParseArgs
                            {
                                Objs = Invokes.YamlDecode(new YamlDecodeArgs { Text = text }),
                                Transformations = config.Transformations,
                                ResourcePrefix = config.ResourcePrefix
                            }, options))
                        .Select(output => (Input<ImmutableDictionary<string, KubernetesResource>>)output)
                        .ToImmutableArray();
                    return Output.All(yamls);
                });

                resources = Output.Tuple(resources, yamlResources).Apply(vs =>
                {
                    var builder = ImmutableDictionary.CreateBuilder<string, KubernetesResource>();
                    builder.AddRange(vs.Item1);
                    foreach (var bs in vs.Item2)
                        builder.AddRange(bs);
                    return builder.ToImmutable();
                });
            }

            if (config.Objs != null)
            {
                var docResources = ParseYamlDocument(new ParseArgs
                {
                    Objs = config.Objs,
                    Transformations = config.Transformations,
                    ResourcePrefix = config.ResourcePrefix
                }, options);
                resources = Output.Tuple(resources, docResources).Apply(vs => vs.Item1.AddRange(vs.Item2));
            }

            return resources;

        }

        internal static bool IsUrl(string s) => s.StartsWith("http://") || s.StartsWith("https://");

        internal static Output<ImmutableDictionary<string, KubernetesResource>> ParseYamlDocument(ParseArgs config,
            ComponentResourceOptions? options = null)
        {
            return config.Objs.ToOutput().Apply(objs =>
            {

                var inputs = objs
                    .SelectMany(obj => ParseYamlObject(obj, config.Transformations, config.ResourcePrefix, options))
                    .Select(output => (Input<(string, KubernetesResource)>) output)
                    .ToImmutableArray();

                return Output.All(inputs)
                    .Apply(items =>
                        items.Select(obj => new KeyValuePair<string, KubernetesResource>(obj.Item1, obj.Item2))
                             .ToImmutableDictionary());
            });
        }

        private static Output<(string, KubernetesResource)>[] ParseYamlObject(ImmutableDictionary<string, object> obj,
            List<TransformationAction>? transformations, string? resourcePrefix, ComponentResourceOptions? options = null)
        {
            if (obj == null || obj.Count == 0)
                return new Output<(string, KubernetesResource)>[0];

            // Create custom resource options based on component resource options.
            var opts = new CustomResourceOptions
            {
                Parent = options?.Parent,
                DependsOn = options?.DependsOn ?? new InputList<Resource>(),
                IgnoreChanges = options?.IgnoreChanges ?? new List<string>(),
                Version = options?.Version,
                Provider = options?.Provider,
                CustomTimeouts = options?.CustomTimeouts
            };

            // Allow users to change API objects before any validation.
            if (transformations != null)
            {
                foreach (var transform in transformations)
                    obj = transform(obj, opts);
            }

            if (!(obj.ContainsKey("kind") && obj.ContainsKey("apiVersion")))
            {
                var serialized = JsonSerializer.Serialize(obj);
                throw new FormatException($"Kubernetes resources require a kind and apiVersion: {serialized}");
            }

            var kind = (string)obj["kind"];
            var apiVersion = (string)obj["apiVersion"];
            var gvk = $"{apiVersion}/{kind}";

            // Recursively traverse built-in Kubernetes list types into a single set of "naked" resource
            // definitions that we can register with the Pulumi engine.
            //
            // Kubernetes does not instantiate list types like `v1.List`. When the API server receives
            // a list, it will recursively traverse it and perform the necessary operations on the
            // each "instantiable" resource it finds. For example, `kubectl apply` on a
            // `v1.ConfigMapList` will cause the API server to traverse the list, and `apply` each
            // `v1.ConfigMap` it finds.
            //
            // Since Kubernetes does not instantiate list types directly, Pulumi also traverses lists
            // for resource definitions that can be managed by Kubernetes, and registers those with the
            // engine instead.
            if (
                gvk == "v1/List"
                || gvk == "admissionregistration.k8s.io/v1/MutatingWebhookConfigurationList"
                || gvk == "admissionregistration.k8s.io/v1/ValidatingWebhookConfigurationList"
                || gvk == "admissionregistration.k8s.io/v1beta1/MutatingWebhookConfigurationList"
                || gvk == "admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfigurationList"
                || gvk == "apiextensions.k8s.io/v1/CustomResourceDefinitionList"
                || gvk == "apiextensions.k8s.io/v1beta1/CustomResourceDefinitionList"
                || gvk == "apiregistration.k8s.io/v1/APIServiceList"
                || gvk == "apiregistration.k8s.io/v1beta1/APIServiceList"
                || gvk == "apps/v1/ControllerRevisionList"
                || gvk == "apps/v1/DaemonSetList"
                || gvk == "apps/v1/DeploymentList"
                || gvk == "apps/v1/ReplicaSetList"
                || gvk == "apps/v1/StatefulSetList"
                || gvk == "apps/v1beta1/ControllerRevisionList"
                || gvk == "apps/v1beta1/DeploymentList"
                || gvk == "apps/v1beta1/StatefulSetList"
                || gvk == "apps/v1beta2/ControllerRevisionList"
                || gvk == "apps/v1beta2/DaemonSetList"
                || gvk == "apps/v1beta2/DeploymentList"
                || gvk == "apps/v1beta2/ReplicaSetList"
                || gvk == "apps/v1beta2/StatefulSetList"
                || gvk == "auditregistration.k8s.io/v1alpha1/AuditSinkList"
                || gvk == "autoscaling/v1/HorizontalPodAutoscalerList"
                || gvk == "autoscaling/v2beta1/HorizontalPodAutoscalerList"
                || gvk == "autoscaling/v2beta2/HorizontalPodAutoscalerList"
                || gvk == "batch/v1/JobList"
                || gvk == "batch/v1beta1/CronJobList"
                || gvk == "batch/v2alpha1/CronJobList"
                || gvk == "certificates.k8s.io/v1/CertificateSigningRequestList"
                || gvk == "certificates.k8s.io/v1beta1/CertificateSigningRequestList"
                || gvk == "coordination.k8s.io/v1/LeaseList"
                || gvk == "coordination.k8s.io/v1beta1/LeaseList"
                || gvk == "v1/ConfigMapList"
                || gvk == "v1/EndpointsList"
                || gvk == "v1/EventList"
                || gvk == "v1/LimitRangeList"
                || gvk == "v1/NamespaceList"
                || gvk == "v1/NodeList"
                || gvk == "v1/PersistentVolumeClaimList"
                || gvk == "v1/PersistentVolumeList"
                || gvk == "v1/PodList"
                || gvk == "v1/PodTemplateList"
                || gvk == "v1/ReplicationControllerList"
                || gvk == "v1/ResourceQuotaList"
                || gvk == "v1/SecretList"
                || gvk == "v1/ServiceAccountList"
                || gvk == "v1/ServiceList"
                || gvk == "discovery.k8s.io/v1beta1/EndpointSliceList"
                || gvk == "events.k8s.io/v1/EventList"
                || gvk == "events.k8s.io/v1beta1/EventList"
                || gvk == "extensions/v1beta1/DaemonSetList"
                || gvk == "extensions/v1beta1/DeploymentList"
                || gvk == "extensions/v1beta1/IngressList"
                || gvk == "extensions/v1beta1/NetworkPolicyList"
                || gvk == "extensions/v1beta1/PodSecurityPolicyList"
                || gvk == "extensions/v1beta1/ReplicaSetList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchemaList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfigurationList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1beta1/FlowSchemaList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfigurationList"
                || gvk == "networking.k8s.io/v1/IngressClassList"
                || gvk == "networking.k8s.io/v1/IngressList"
                || gvk == "networking.k8s.io/v1/NetworkPolicyList"
                || gvk == "networking.k8s.io/v1beta1/IngressClassList"
                || gvk == "networking.k8s.io/v1beta1/IngressList"
                || gvk == "node.k8s.io/v1/RuntimeClassList"
                || gvk == "node.k8s.io/v1alpha1/RuntimeClassList"
                || gvk == "node.k8s.io/v1beta1/RuntimeClassList"
                || gvk == "policy/v1beta1/PodDisruptionBudgetList"
                || gvk == "policy/v1beta1/PodSecurityPolicyList"
                || gvk == "rbac.authorization.k8s.io/v1/ClusterRoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1/ClusterRoleList"
                || gvk == "rbac.authorization.k8s.io/v1/RoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1/RoleList"
                || gvk == "rbac.authorization.k8s.io/v1alpha1/ClusterRoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1alpha1/ClusterRoleList"
                || gvk == "rbac.authorization.k8s.io/v1alpha1/RoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1alpha1/RoleList"
                || gvk == "rbac.authorization.k8s.io/v1beta1/ClusterRoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1beta1/ClusterRoleList"
                || gvk == "rbac.authorization.k8s.io/v1beta1/RoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1beta1/RoleList"
                || gvk == "scheduling.k8s.io/v1/PriorityClassList"
                || gvk == "scheduling.k8s.io/v1alpha1/PriorityClassList"
                || gvk == "scheduling.k8s.io/v1beta1/PriorityClassList"
                || gvk == "settings.k8s.io/v1alpha1/PodPresetList"
                || gvk == "storage.k8s.io/v1/CSIDriverList"
                || gvk == "storage.k8s.io/v1/CSINodeList"
                || gvk == "storage.k8s.io/v1/StorageClassList"
                || gvk == "storage.k8s.io/v1/VolumeAttachmentList"
                || gvk == "storage.k8s.io/v1alpha1/VolumeAttachmentList"
                || gvk == "storage.k8s.io/v1beta1/CSIDriverList"
                || gvk == "storage.k8s.io/v1beta1/CSINodeList"
                || gvk == "storage.k8s.io/v1beta1/StorageClassList"
                || gvk == "storage.k8s.io/v1beta1/VolumeAttachmentList"
               )
            {
                var objs = new List<Output<(string, KubernetesResource)>>();
                if (obj["items"] is IEnumerable<ImmutableDictionary<string, object>> items)
                {
                    foreach (var item in items)
                        objs.AddRange(Parser.ParseYamlObject(item, transformations, resourcePrefix));
                }
                return objs.ToArray();
            }

            if (!obj.ContainsKey("metadata") || !(obj["metadata"] is ImmutableDictionary<string, object> metadata)
                || !metadata.ContainsKey("name"))
            {
                var serialized = obj.TryGetValue("metadata", out var m) ? JsonSerializer.Serialize(m) : "<null>";
                throw new FormatException($"YAML object does not have a .metadata.name: {apiVersion}/{kind} {serialized}");
            }

            var meta = (ImmutableDictionary<string, object>)obj["metadata"];
            var id = Output.Create((string)meta["name"]);
            if (meta.TryGetValue("namespace", out object ns))
                id = Output.Format($"{ns}/{id}");
            if (resourcePrefix != null)
                id = Output.Format($"{resourcePrefix}-{id}");

            switch ($"{apiVersion}/{kind}")
            {
                    case "admissionregistration.k8s.io/v1/MutatingWebhookConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1/MutatingWebhookConfiguration::{id}",
                                new AdmissionRegistration.V1.MutatingWebhookConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1/ValidatingWebhookConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1/ValidatingWebhookConfiguration::{id}",
                                new AdmissionRegistration.V1.ValidatingWebhookConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1beta1/MutatingWebhookConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1beta1/MutatingWebhookConfiguration::{id}",
                                new AdmissionRegistration.V1Beta1.MutatingWebhookConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfiguration::{id}",
                                new AdmissionRegistration.V1Beta1.ValidatingWebhookConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "apiextensions.k8s.io/v1/CustomResourceDefinition":
                        return new[]
                        {
                            id.Apply(id => ($"apiextensions.k8s.io/v1/CustomResourceDefinition::{id}",
                                new ApiExtensions.V1.CustomResourceDefinition(id, obj!, opts) as KubernetesResource))
                        };
                    case "apiextensions.k8s.io/v1beta1/CustomResourceDefinition":
                        return new[]
                        {
                            id.Apply(id => ($"apiextensions.k8s.io/v1beta1/CustomResourceDefinition::{id}",
                                new ApiExtensions.V1Beta1.CustomResourceDefinition(id, obj!, opts) as KubernetesResource))
                        };
                    case "apiregistration.k8s.io/v1/APIService":
                        return new[]
                        {
                            id.Apply(id => ($"apiregistration.k8s.io/v1/APIService::{id}",
                                new ApiRegistration.V1.APIService(id, obj!, opts) as KubernetesResource))
                        };
                    case "apiregistration.k8s.io/v1beta1/APIService":
                        return new[]
                        {
                            id.Apply(id => ($"apiregistration.k8s.io/v1beta1/APIService::{id}",
                                new ApiRegistration.V1Beta1.APIService(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/ControllerRevision":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/ControllerRevision::{id}",
                                new Apps.V1.ControllerRevision(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/DaemonSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/DaemonSet::{id}",
                                new Apps.V1.DaemonSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/Deployment":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/Deployment::{id}",
                                new Apps.V1.Deployment(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/ReplicaSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/ReplicaSet::{id}",
                                new Apps.V1.ReplicaSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/StatefulSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/StatefulSet::{id}",
                                new Apps.V1.StatefulSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta1/ControllerRevision":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta1/ControllerRevision::{id}",
                                new Apps.V1Beta1.ControllerRevision(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta1/Deployment":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta1/Deployment::{id}",
                                new Apps.V1Beta1.Deployment(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta1/StatefulSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta1/StatefulSet::{id}",
                                new Apps.V1Beta1.StatefulSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/ControllerRevision":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/ControllerRevision::{id}",
                                new Apps.V1Beta2.ControllerRevision(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/DaemonSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/DaemonSet::{id}",
                                new Apps.V1Beta2.DaemonSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/Deployment":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/Deployment::{id}",
                                new Apps.V1Beta2.Deployment(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/ReplicaSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/ReplicaSet::{id}",
                                new Apps.V1Beta2.ReplicaSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/StatefulSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/StatefulSet::{id}",
                                new Apps.V1Beta2.StatefulSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "auditregistration.k8s.io/v1alpha1/AuditSink":
                        return new[]
                        {
                            id.Apply(id => ($"auditregistration.k8s.io/v1alpha1/AuditSink::{id}",
                                new AuditRegistraion.V1Alpha1.AuditSink(id, obj!, opts) as KubernetesResource))
                        };
                    case "authentication.k8s.io/v1/TokenRequest":
                        return new[]
                        {
                            id.Apply(id => ($"authentication.k8s.io/v1/TokenRequest::{id}",
                                new Authentication.V1.TokenRequest(id, obj!, opts) as KubernetesResource))
                        };
                    case "authentication.k8s.io/v1/TokenReview":
                        return new[]
                        {
                            id.Apply(id => ($"authentication.k8s.io/v1/TokenReview::{id}",
                                new Authentication.V1.TokenReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "authentication.k8s.io/v1beta1/TokenReview":
                        return new[]
                        {
                            id.Apply(id => ($"authentication.k8s.io/v1beta1/TokenReview::{id}",
                                new Authentication.V1Beta1.TokenReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "authorization.k8s.io/v1/LocalSubjectAccessReview":
                        return new[]
                        {
                            id.Apply(id => ($"authorization.k8s.io/v1/LocalSubjectAccessReview::{id}",
                                new Authorization.V1.LocalSubjectAccessReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "authorization.k8s.io/v1/SelfSubjectAccessReview":
                        return new[]
                        {
                            id.Apply(id => ($"authorization.k8s.io/v1/SelfSubjectAccessReview::{id}",
                                new Authorization.V1.SelfSubjectAccessReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "authorization.k8s.io/v1/SelfSubjectRulesReview":
                        return new[]
                        {
                            id.Apply(id => ($"authorization.k8s.io/v1/SelfSubjectRulesReview::{id}",
                                new Authorization.V1.SelfSubjectRulesReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "authorization.k8s.io/v1/SubjectAccessReview":
                        return new[]
                        {
                            id.Apply(id => ($"authorization.k8s.io/v1/SubjectAccessReview::{id}",
                                new Authorization.V1.SubjectAccessReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "authorization.k8s.io/v1beta1/LocalSubjectAccessReview":
                        return new[]
                        {
                            id.Apply(id => ($"authorization.k8s.io/v1beta1/LocalSubjectAccessReview::{id}",
                                new Authorization.V1Beta1.LocalSubjectAccessReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "authorization.k8s.io/v1beta1/SelfSubjectAccessReview":
                        return new[]
                        {
                            id.Apply(id => ($"authorization.k8s.io/v1beta1/SelfSubjectAccessReview::{id}",
                                new Authorization.V1Beta1.SelfSubjectAccessReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "authorization.k8s.io/v1beta1/SelfSubjectRulesReview":
                        return new[]
                        {
                            id.Apply(id => ($"authorization.k8s.io/v1beta1/SelfSubjectRulesReview::{id}",
                                new Authorization.V1Beta1.SelfSubjectRulesReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "authorization.k8s.io/v1beta1/SubjectAccessReview":
                        return new[]
                        {
                            id.Apply(id => ($"authorization.k8s.io/v1beta1/SubjectAccessReview::{id}",
                                new Authorization.V1Beta1.SubjectAccessReview(id, obj!, opts) as KubernetesResource))
                        };
                    case "autoscaling/v1/HorizontalPodAutoscaler":
                        return new[]
                        {
                            id.Apply(id => ($"autoscaling/v1/HorizontalPodAutoscaler::{id}",
                                new Autoscaling.V1.HorizontalPodAutoscaler(id, obj!, opts) as KubernetesResource))
                        };
                    case "autoscaling/v2beta1/HorizontalPodAutoscaler":
                        return new[]
                        {
                            id.Apply(id => ($"autoscaling/v2beta1/HorizontalPodAutoscaler::{id}",
                                new Autoscaling.V2Beta1.HorizontalPodAutoscaler(id, obj!, opts) as KubernetesResource))
                        };
                    case "autoscaling/v2beta2/HorizontalPodAutoscaler":
                        return new[]
                        {
                            id.Apply(id => ($"autoscaling/v2beta2/HorizontalPodAutoscaler::{id}",
                                new Autoscaling.V2Beta2.HorizontalPodAutoscaler(id, obj!, opts) as KubernetesResource))
                        };
                    case "batch/v1/Job":
                        return new[]
                        {
                            id.Apply(id => ($"batch/v1/Job::{id}",
                                new Batch.V1.Job(id, obj!, opts) as KubernetesResource))
                        };
                    case "batch/v1beta1/CronJob":
                        return new[]
                        {
                            id.Apply(id => ($"batch/v1beta1/CronJob::{id}",
                                new Batch.V1Beta1.CronJob(id, obj!, opts) as KubernetesResource))
                        };
                    case "batch/v2alpha1/CronJob":
                        return new[]
                        {
                            id.Apply(id => ($"batch/v2alpha1/CronJob::{id}",
                                new Batch.V2Alpha1.CronJob(id, obj!, opts) as KubernetesResource))
                        };
                    case "certificates.k8s.io/v1/CertificateSigningRequest":
                        return new[]
                        {
                            id.Apply(id => ($"certificates.k8s.io/v1/CertificateSigningRequest::{id}",
                                new Certificates.V1.CertificateSigningRequest(id, obj!, opts) as KubernetesResource))
                        };
                    case "certificates.k8s.io/v1beta1/CertificateSigningRequest":
                        return new[]
                        {
                            id.Apply(id => ($"certificates.k8s.io/v1beta1/CertificateSigningRequest::{id}",
                                new Certificates.V1Beta1.CertificateSigningRequest(id, obj!, opts) as KubernetesResource))
                        };
                    case "coordination.k8s.io/v1/Lease":
                        return new[]
                        {
                            id.Apply(id => ($"coordination.k8s.io/v1/Lease::{id}",
                                new Coordination.V1.Lease(id, obj!, opts) as KubernetesResource))
                        };
                    case "coordination.k8s.io/v1beta1/Lease":
                        return new[]
                        {
                            id.Apply(id => ($"coordination.k8s.io/v1beta1/Lease::{id}",
                                new Coordination.V1Beta1.Lease(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Binding":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Binding::{id}",
                                new Core.V1.Binding(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/ConfigMap":
                        return new[]
                        {
                            id.Apply(id => ($"v1/ConfigMap::{id}",
                                new Core.V1.ConfigMap(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Endpoints":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Endpoints::{id}",
                                new Core.V1.Endpoints(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Event":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Event::{id}",
                                new Core.V1.Event(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/LimitRange":
                        return new[]
                        {
                            id.Apply(id => ($"v1/LimitRange::{id}",
                                new Core.V1.LimitRange(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Namespace":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Namespace::{id}",
                                new Core.V1.Namespace(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Node":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Node::{id}",
                                new Core.V1.Node(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/PersistentVolume":
                        return new[]
                        {
                            id.Apply(id => ($"v1/PersistentVolume::{id}",
                                new Core.V1.PersistentVolume(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/PersistentVolumeClaim":
                        return new[]
                        {
                            id.Apply(id => ($"v1/PersistentVolumeClaim::{id}",
                                new Core.V1.PersistentVolumeClaim(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Pod":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Pod::{id}",
                                new Core.V1.Pod(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/PodTemplate":
                        return new[]
                        {
                            id.Apply(id => ($"v1/PodTemplate::{id}",
                                new Core.V1.PodTemplate(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/ReplicationController":
                        return new[]
                        {
                            id.Apply(id => ($"v1/ReplicationController::{id}",
                                new Core.V1.ReplicationController(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/ResourceQuota":
                        return new[]
                        {
                            id.Apply(id => ($"v1/ResourceQuota::{id}",
                                new Core.V1.ResourceQuota(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Secret":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Secret::{id}",
                                new Core.V1.Secret(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Service":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Service::{id}",
                                new Core.V1.Service(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/ServiceAccount":
                        return new[]
                        {
                            id.Apply(id => ($"v1/ServiceAccount::{id}",
                                new Core.V1.ServiceAccount(id, obj!, opts) as KubernetesResource))
                        };
                    case "discovery.k8s.io/v1beta1/EndpointSlice":
                        return new[]
                        {
                            id.Apply(id => ($"discovery.k8s.io/v1beta1/EndpointSlice::{id}",
                                new Discovery.V1Beta1.EndpointSlice(id, obj!, opts) as KubernetesResource))
                        };
                    case "events.k8s.io/v1/Event":
                        return new[]
                        {
                            id.Apply(id => ($"events.k8s.io/v1/Event::{id}",
                                new Events.V1.Event(id, obj!, opts) as KubernetesResource))
                        };
                    case "events.k8s.io/v1beta1/Event":
                        return new[]
                        {
                            id.Apply(id => ($"events.k8s.io/v1beta1/Event::{id}",
                                new Events.V1Beta1.Event(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/DaemonSet":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/DaemonSet::{id}",
                                new Extensions.V1Beta1.DaemonSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/Deployment":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/Deployment::{id}",
                                new Extensions.V1Beta1.Deployment(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/Ingress":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/Ingress::{id}",
                                new Extensions.V1Beta1.Ingress(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/NetworkPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/NetworkPolicy::{id}",
                                new Extensions.V1Beta1.NetworkPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/PodSecurityPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/PodSecurityPolicy::{id}",
                                new Extensions.V1Beta1.PodSecurityPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/ReplicaSet":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/ReplicaSet::{id}",
                                new Extensions.V1Beta1.ReplicaSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchema":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchema::{id}",
                                new FlowControl.V1Alpha1.FlowSchema(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfiguration::{id}",
                                new FlowControl.V1Alpha1.PriorityLevelConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1beta1/FlowSchema":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1beta1/FlowSchema::{id}",
                                new FlowControl.V1Beta1.FlowSchema(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfiguration::{id}",
                                new FlowControl.V1Beta1.PriorityLevelConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "meta/v1/Status":
                        return new[]
                        {
                            id.Apply(id => ($"meta/v1/Status::{id}",
                                new Meta.V1.Status(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1/Ingress":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1/Ingress::{id}",
                                new Networking.V1.Ingress(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1/IngressClass":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1/IngressClass::{id}",
                                new Networking.V1.IngressClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1/NetworkPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1/NetworkPolicy::{id}",
                                new Networking.V1.NetworkPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1beta1/Ingress":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1beta1/Ingress::{id}",
                                new Networking.V1Beta1.Ingress(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1beta1/IngressClass":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1beta1/IngressClass::{id}",
                                new Networking.V1Beta1.IngressClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "node.k8s.io/v1/RuntimeClass":
                        return new[]
                        {
                            id.Apply(id => ($"node.k8s.io/v1/RuntimeClass::{id}",
                                new Node.V1.RuntimeClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "node.k8s.io/v1alpha1/RuntimeClass":
                        return new[]
                        {
                            id.Apply(id => ($"node.k8s.io/v1alpha1/RuntimeClass::{id}",
                                new Node.V1Alpha1.RuntimeClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "node.k8s.io/v1beta1/RuntimeClass":
                        return new[]
                        {
                            id.Apply(id => ($"node.k8s.io/v1beta1/RuntimeClass::{id}",
                                new Node.V1Beta1.RuntimeClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "policy/v1beta1/PodDisruptionBudget":
                        return new[]
                        {
                            id.Apply(id => ($"policy/v1beta1/PodDisruptionBudget::{id}",
                                new Policy.V1Beta1.PodDisruptionBudget(id, obj!, opts) as KubernetesResource))
                        };
                    case "policy/v1beta1/PodSecurityPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"policy/v1beta1/PodSecurityPolicy::{id}",
                                new Policy.V1Beta1.PodSecurityPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1/ClusterRole":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1/ClusterRole::{id}",
                                new Rbac.V1.ClusterRole(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1/ClusterRoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1/ClusterRoleBinding::{id}",
                                new Rbac.V1.ClusterRoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1/Role":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1/Role::{id}",
                                new Rbac.V1.Role(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1/RoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1/RoleBinding::{id}",
                                new Rbac.V1.RoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1alpha1/ClusterRole":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1alpha1/ClusterRole::{id}",
                                new Rbac.V1Alpha1.ClusterRole(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1alpha1/ClusterRoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1alpha1/ClusterRoleBinding::{id}",
                                new Rbac.V1Alpha1.ClusterRoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1alpha1/Role":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1alpha1/Role::{id}",
                                new Rbac.V1Alpha1.Role(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1alpha1/RoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1alpha1/RoleBinding::{id}",
                                new Rbac.V1Alpha1.RoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1beta1/ClusterRole":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1beta1/ClusterRole::{id}",
                                new Rbac.V1Beta1.ClusterRole(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1beta1/ClusterRoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1beta1/ClusterRoleBinding::{id}",
                                new Rbac.V1Beta1.ClusterRoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1beta1/Role":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1beta1/Role::{id}",
                                new Rbac.V1Beta1.Role(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1beta1/RoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1beta1/RoleBinding::{id}",
                                new Rbac.V1Beta1.RoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "scheduling.k8s.io/v1/PriorityClass":
                        return new[]
                        {
                            id.Apply(id => ($"scheduling.k8s.io/v1/PriorityClass::{id}",
                                new Scheduling.V1.PriorityClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "scheduling.k8s.io/v1alpha1/PriorityClass":
                        return new[]
                        {
                            id.Apply(id => ($"scheduling.k8s.io/v1alpha1/PriorityClass::{id}",
                                new Scheduling.V1Alpha1.PriorityClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "scheduling.k8s.io/v1beta1/PriorityClass":
                        return new[]
                        {
                            id.Apply(id => ($"scheduling.k8s.io/v1beta1/PriorityClass::{id}",
                                new Scheduling.V1Beta1.PriorityClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "settings.k8s.io/v1alpha1/PodPreset":
                        return new[]
                        {
                            id.Apply(id => ($"settings.k8s.io/v1alpha1/PodPreset::{id}",
                                new Settings.V1Alpha1.PodPreset(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1/CSIDriver":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1/CSIDriver::{id}",
                                new Storage.V1.CSIDriver(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1/CSINode":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1/CSINode::{id}",
                                new Storage.V1.CSINode(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1/StorageClass":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1/StorageClass::{id}",
                                new Storage.V1.StorageClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1/VolumeAttachment":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1/VolumeAttachment::{id}",
                                new Storage.V1.VolumeAttachment(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1alpha1/VolumeAttachment":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1alpha1/VolumeAttachment::{id}",
                                new Storage.V1Alpha1.VolumeAttachment(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1beta1/CSIDriver":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1beta1/CSIDriver::{id}",
                                new Storage.V1Beta1.CSIDriver(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1beta1/CSINode":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1beta1/CSINode::{id}",
                                new Storage.V1Beta1.CSINode(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1beta1/StorageClass":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1beta1/StorageClass::{id}",
                                new Storage.V1Beta1.StorageClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1beta1/VolumeAttachment":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1beta1/VolumeAttachment::{id}",
                                new Storage.V1Beta1.VolumeAttachment(id, obj!, opts) as KubernetesResource))
                        };
                default:
                    return new[]
                    {
                        id.Apply(id => ($"{apiVersion}/{kind}::{id}",
                            new ApiExtensions.V1.CustomResourceDefinition(id, obj!, opts) as KubernetesResource))
                    };
            }
        }
    }

    internal class ParseArgs
    {
        /// <summary>
        /// Objects representing Kubernetes resources.
        /// </summary>
        public InputList<ImmutableDictionary<string, object>> Objs { get; set; } = null!;

        private List<TransformationAction>? _transformations;

        /// <summary>
        /// An optional list of transformations to apply to Kubernetes resource definitions before registering
        /// with engine.
        /// </summary>
        public List<TransformationAction> Transformations
        {
            get => _transformations ??= new List<TransformationAction>();
            set => _transformations = value;
        }

        /// <summary>
        /// An optional prefix for the auto-generated resource names.
        /// Example: A resource created with resourcePrefix="foo" would produce a resource named "foo-resourceName".
        /// </summary>
        public string? ResourcePrefix { get; set; }
    }
}
