// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.Json;
using GlobExpressions;
using Pu = Pulumi;

#pragma warning disable CS0618

namespace Pulumi.Kubernetes.Yaml
{
    /// <summary>
    /// Base component for containers of Kubernetes resources.
    /// </summary>
    public abstract class CollectionComponentResource : ComponentResource
    {
        internal Output<ImmutableDictionary<string, KubernetesResource>> Resources { get; private set; } = null!;

        protected CollectionComponentResource(string type, string name, ComponentResourceOptions? options = null)
            : base(type, name, options)
        {
        }

        protected void RegisterResources(Output<ImmutableDictionary<string, KubernetesResource>> resources)
        {
            Resources = resources;
            RegisterOutputs(new Dictionary<string, object?> { { "resources", resources } });
        }

        /// <summary>
        /// Returns a resource defined by the given name.
        /// </summary>
        /// <param name="name">Resource name.</param>
        /// <param name="namespaceName">Optional namespace, e.g. "kube-prometheus-exporter-kubernetes".</param>
        /// <typeparam name="T">The type of the resource.</typeparam>
        public Output<T> GetResource<T>(string name, string? namespaceName = null)
            where T : KubernetesResource
        {
            var type = typeof(T);
            string groupVersionKind;
            switch(type)
            {
                case var t when t == typeof(AdmissionRegistration.V1.MutatingWebhookConfiguration):
                    groupVersionKind = "admissionregistration.k8s.io/v1/MutatingWebhookConfiguration";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1.MutatingWebhookConfigurationList):
                    groupVersionKind = "admissionregistration.k8s.io/v1/MutatingWebhookConfigurationList";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1.ValidatingWebhookConfiguration):
                    groupVersionKind = "admissionregistration.k8s.io/v1/ValidatingWebhookConfiguration";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1.ValidatingWebhookConfigurationList):
                    groupVersionKind = "admissionregistration.k8s.io/v1/ValidatingWebhookConfigurationList";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Alpha1.ValidatingAdmissionPolicy):
                    groupVersionKind = "admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicy";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Alpha1.ValidatingAdmissionPolicyBinding):
                    groupVersionKind = "admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicyBinding";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Alpha1.ValidatingAdmissionPolicyBindingList):
                    groupVersionKind = "admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicyBindingList";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Alpha1.ValidatingAdmissionPolicyList):
                    groupVersionKind = "admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicyList";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Beta1.MutatingWebhookConfiguration):
                    groupVersionKind = "admissionregistration.k8s.io/v1beta1/MutatingWebhookConfiguration";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Beta1.MutatingWebhookConfigurationList):
                    groupVersionKind = "admissionregistration.k8s.io/v1beta1/MutatingWebhookConfigurationList";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Beta1.ValidatingAdmissionPolicy):
                    groupVersionKind = "admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicy";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Beta1.ValidatingAdmissionPolicyBinding):
                    groupVersionKind = "admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicyBinding";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Beta1.ValidatingAdmissionPolicyBindingList):
                    groupVersionKind = "admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicyBindingList";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Beta1.ValidatingAdmissionPolicyList):
                    groupVersionKind = "admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicyList";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Beta1.ValidatingWebhookConfiguration):
                    groupVersionKind = "admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfiguration";
                    break;
                case var t when t == typeof(AdmissionRegistration.V1Beta1.ValidatingWebhookConfigurationList):
                    groupVersionKind = "admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfigurationList";
                    break;
                case var t when t == typeof(ApiExtensions.V1.CustomResourceDefinition):
                    groupVersionKind = "apiextensions.k8s.io/v1/CustomResourceDefinition";
                    break;
                case var t when t == typeof(ApiExtensions.V1.CustomResourceDefinitionList):
                    groupVersionKind = "apiextensions.k8s.io/v1/CustomResourceDefinitionList";
                    break;
                case var t when t == typeof(ApiExtensions.V1Beta1.CustomResourceDefinition):
                    groupVersionKind = "apiextensions.k8s.io/v1beta1/CustomResourceDefinition";
                    break;
                case var t when t == typeof(ApiExtensions.V1Beta1.CustomResourceDefinitionList):
                    groupVersionKind = "apiextensions.k8s.io/v1beta1/CustomResourceDefinitionList";
                    break;
                case var t when t == typeof(ApiRegistration.V1.APIService):
                    groupVersionKind = "apiregistration.k8s.io/v1/APIService";
                    break;
                case var t when t == typeof(ApiRegistration.V1.APIServiceList):
                    groupVersionKind = "apiregistration.k8s.io/v1/APIServiceList";
                    break;
                case var t when t == typeof(ApiRegistration.V1Beta1.APIService):
                    groupVersionKind = "apiregistration.k8s.io/v1beta1/APIService";
                    break;
                case var t when t == typeof(ApiRegistration.V1Beta1.APIServiceList):
                    groupVersionKind = "apiregistration.k8s.io/v1beta1/APIServiceList";
                    break;
                case var t when t == typeof(Apps.V1.ControllerRevision):
                    groupVersionKind = "apps/v1/ControllerRevision";
                    break;
                case var t when t == typeof(Apps.V1.ControllerRevisionList):
                    groupVersionKind = "apps/v1/ControllerRevisionList";
                    break;
                case var t when t == typeof(Apps.V1.DaemonSet):
                    groupVersionKind = "apps/v1/DaemonSet";
                    break;
                case var t when t == typeof(Apps.V1.DaemonSetList):
                    groupVersionKind = "apps/v1/DaemonSetList";
                    break;
                case var t when t == typeof(Apps.V1.Deployment):
                    groupVersionKind = "apps/v1/Deployment";
                    break;
                case var t when t == typeof(Apps.V1.DeploymentList):
                    groupVersionKind = "apps/v1/DeploymentList";
                    break;
                case var t when t == typeof(Apps.V1.ReplicaSet):
                    groupVersionKind = "apps/v1/ReplicaSet";
                    break;
                case var t when t == typeof(Apps.V1.ReplicaSetList):
                    groupVersionKind = "apps/v1/ReplicaSetList";
                    break;
                case var t when t == typeof(Apps.V1.StatefulSet):
                    groupVersionKind = "apps/v1/StatefulSet";
                    break;
                case var t when t == typeof(Apps.V1.StatefulSetList):
                    groupVersionKind = "apps/v1/StatefulSetList";
                    break;
                case var t when t == typeof(Apps.V1Beta1.ControllerRevision):
                    groupVersionKind = "apps/v1beta1/ControllerRevision";
                    break;
                case var t when t == typeof(Apps.V1Beta1.ControllerRevisionList):
                    groupVersionKind = "apps/v1beta1/ControllerRevisionList";
                    break;
                case var t when t == typeof(Apps.V1Beta1.Deployment):
                    groupVersionKind = "apps/v1beta1/Deployment";
                    break;
                case var t when t == typeof(Apps.V1Beta1.DeploymentList):
                    groupVersionKind = "apps/v1beta1/DeploymentList";
                    break;
                case var t when t == typeof(Apps.V1Beta1.StatefulSet):
                    groupVersionKind = "apps/v1beta1/StatefulSet";
                    break;
                case var t when t == typeof(Apps.V1Beta1.StatefulSetList):
                    groupVersionKind = "apps/v1beta1/StatefulSetList";
                    break;
                case var t when t == typeof(Apps.V1Beta2.ControllerRevision):
                    groupVersionKind = "apps/v1beta2/ControllerRevision";
                    break;
                case var t when t == typeof(Apps.V1Beta2.ControllerRevisionList):
                    groupVersionKind = "apps/v1beta2/ControllerRevisionList";
                    break;
                case var t when t == typeof(Apps.V1Beta2.DaemonSet):
                    groupVersionKind = "apps/v1beta2/DaemonSet";
                    break;
                case var t when t == typeof(Apps.V1Beta2.DaemonSetList):
                    groupVersionKind = "apps/v1beta2/DaemonSetList";
                    break;
                case var t when t == typeof(Apps.V1Beta2.Deployment):
                    groupVersionKind = "apps/v1beta2/Deployment";
                    break;
                case var t when t == typeof(Apps.V1Beta2.DeploymentList):
                    groupVersionKind = "apps/v1beta2/DeploymentList";
                    break;
                case var t when t == typeof(Apps.V1Beta2.ReplicaSet):
                    groupVersionKind = "apps/v1beta2/ReplicaSet";
                    break;
                case var t when t == typeof(Apps.V1Beta2.ReplicaSetList):
                    groupVersionKind = "apps/v1beta2/ReplicaSetList";
                    break;
                case var t when t == typeof(Apps.V1Beta2.StatefulSet):
                    groupVersionKind = "apps/v1beta2/StatefulSet";
                    break;
                case var t when t == typeof(Apps.V1Beta2.StatefulSetList):
                    groupVersionKind = "apps/v1beta2/StatefulSetList";
                    break;
                case var t when t == typeof(AuditRegistraion.V1Alpha1.AuditSink):
                    groupVersionKind = "auditregistration.k8s.io/v1alpha1/AuditSink";
                    break;
                case var t when t == typeof(AuditRegistraion.V1Alpha1.AuditSinkList):
                    groupVersionKind = "auditregistration.k8s.io/v1alpha1/AuditSinkList";
                    break;
                case var t when t == typeof(Autoscaling.V1.HorizontalPodAutoscaler):
                    groupVersionKind = "autoscaling/v1/HorizontalPodAutoscaler";
                    break;
                case var t when t == typeof(Autoscaling.V1.HorizontalPodAutoscalerList):
                    groupVersionKind = "autoscaling/v1/HorizontalPodAutoscalerList";
                    break;
                case var t when t == typeof(Autoscaling.V2.HorizontalPodAutoscaler):
                    groupVersionKind = "autoscaling/v2/HorizontalPodAutoscaler";
                    break;
                case var t when t == typeof(Autoscaling.V2.HorizontalPodAutoscalerList):
                    groupVersionKind = "autoscaling/v2/HorizontalPodAutoscalerList";
                    break;
                case var t when t == typeof(Autoscaling.V2Beta1.HorizontalPodAutoscaler):
                    groupVersionKind = "autoscaling/v2beta1/HorizontalPodAutoscaler";
                    break;
                case var t when t == typeof(Autoscaling.V2Beta1.HorizontalPodAutoscalerList):
                    groupVersionKind = "autoscaling/v2beta1/HorizontalPodAutoscalerList";
                    break;
                case var t when t == typeof(Autoscaling.V2Beta2.HorizontalPodAutoscaler):
                    groupVersionKind = "autoscaling/v2beta2/HorizontalPodAutoscaler";
                    break;
                case var t when t == typeof(Autoscaling.V2Beta2.HorizontalPodAutoscalerList):
                    groupVersionKind = "autoscaling/v2beta2/HorizontalPodAutoscalerList";
                    break;
                case var t when t == typeof(Batch.V1.CronJob):
                    groupVersionKind = "batch/v1/CronJob";
                    break;
                case var t when t == typeof(Batch.V1.CronJobList):
                    groupVersionKind = "batch/v1/CronJobList";
                    break;
                case var t when t == typeof(Batch.V1.Job):
                    groupVersionKind = "batch/v1/Job";
                    break;
                case var t when t == typeof(Batch.V1.JobList):
                    groupVersionKind = "batch/v1/JobList";
                    break;
                case var t when t == typeof(Batch.V1Beta1.CronJob):
                    groupVersionKind = "batch/v1beta1/CronJob";
                    break;
                case var t when t == typeof(Batch.V1Beta1.CronJobList):
                    groupVersionKind = "batch/v1beta1/CronJobList";
                    break;
                case var t when t == typeof(Batch.V2Alpha1.CronJob):
                    groupVersionKind = "batch/v2alpha1/CronJob";
                    break;
                case var t when t == typeof(Batch.V2Alpha1.CronJobList):
                    groupVersionKind = "batch/v2alpha1/CronJobList";
                    break;
                case var t when t == typeof(Certificates.V1.CertificateSigningRequest):
                    groupVersionKind = "certificates.k8s.io/v1/CertificateSigningRequest";
                    break;
                case var t when t == typeof(Certificates.V1.CertificateSigningRequestList):
                    groupVersionKind = "certificates.k8s.io/v1/CertificateSigningRequestList";
                    break;
                case var t when t == typeof(Certificates.V1Alpha1.ClusterTrustBundle):
                    groupVersionKind = "certificates.k8s.io/v1alpha1/ClusterTrustBundle";
                    break;
                case var t when t == typeof(Certificates.V1Alpha1.ClusterTrustBundleList):
                    groupVersionKind = "certificates.k8s.io/v1alpha1/ClusterTrustBundleList";
                    break;
                case var t when t == typeof(Certificates.V1Beta1.CertificateSigningRequest):
                    groupVersionKind = "certificates.k8s.io/v1beta1/CertificateSigningRequest";
                    break;
                case var t when t == typeof(Certificates.V1Beta1.CertificateSigningRequestList):
                    groupVersionKind = "certificates.k8s.io/v1beta1/CertificateSigningRequestList";
                    break;
                case var t when t == typeof(Coordination.V1.Lease):
                    groupVersionKind = "coordination.k8s.io/v1/Lease";
                    break;
                case var t when t == typeof(Coordination.V1.LeaseList):
                    groupVersionKind = "coordination.k8s.io/v1/LeaseList";
                    break;
                case var t when t == typeof(Coordination.V1Beta1.Lease):
                    groupVersionKind = "coordination.k8s.io/v1beta1/Lease";
                    break;
                case var t when t == typeof(Coordination.V1Beta1.LeaseList):
                    groupVersionKind = "coordination.k8s.io/v1beta1/LeaseList";
                    break;
                case var t when t == typeof(Core.V1.Binding):
                    groupVersionKind = "v1/Binding";
                    break;
                case var t when t == typeof(Core.V1.ConfigMap):
                    groupVersionKind = "v1/ConfigMap";
                    break;
                case var t when t == typeof(Core.V1.ConfigMapList):
                    groupVersionKind = "v1/ConfigMapList";
                    break;
                case var t when t == typeof(Core.V1.Endpoints):
                    groupVersionKind = "v1/Endpoints";
                    break;
                case var t when t == typeof(Core.V1.EndpointsList):
                    groupVersionKind = "v1/EndpointsList";
                    break;
                case var t when t == typeof(Core.V1.Event):
                    groupVersionKind = "v1/Event";
                    break;
                case var t when t == typeof(Core.V1.EventList):
                    groupVersionKind = "v1/EventList";
                    break;
                case var t when t == typeof(Core.V1.LimitRange):
                    groupVersionKind = "v1/LimitRange";
                    break;
                case var t when t == typeof(Core.V1.LimitRangeList):
                    groupVersionKind = "v1/LimitRangeList";
                    break;
                case var t when t == typeof(Core.V1.Namespace):
                    groupVersionKind = "v1/Namespace";
                    break;
                case var t when t == typeof(Core.V1.NamespaceList):
                    groupVersionKind = "v1/NamespaceList";
                    break;
                case var t when t == typeof(Core.V1.Node):
                    groupVersionKind = "v1/Node";
                    break;
                case var t when t == typeof(Core.V1.NodeList):
                    groupVersionKind = "v1/NodeList";
                    break;
                case var t when t == typeof(Core.V1.PersistentVolume):
                    groupVersionKind = "v1/PersistentVolume";
                    break;
                case var t when t == typeof(Core.V1.PersistentVolumeClaim):
                    groupVersionKind = "v1/PersistentVolumeClaim";
                    break;
                case var t when t == typeof(Core.V1.PersistentVolumeClaimList):
                    groupVersionKind = "v1/PersistentVolumeClaimList";
                    break;
                case var t when t == typeof(Core.V1.PersistentVolumeList):
                    groupVersionKind = "v1/PersistentVolumeList";
                    break;
                case var t when t == typeof(Core.V1.Pod):
                    groupVersionKind = "v1/Pod";
                    break;
                case var t when t == typeof(Core.V1.PodList):
                    groupVersionKind = "v1/PodList";
                    break;
                case var t when t == typeof(Core.V1.PodTemplate):
                    groupVersionKind = "v1/PodTemplate";
                    break;
                case var t when t == typeof(Core.V1.PodTemplateList):
                    groupVersionKind = "v1/PodTemplateList";
                    break;
                case var t when t == typeof(Core.V1.ReplicationController):
                    groupVersionKind = "v1/ReplicationController";
                    break;
                case var t when t == typeof(Core.V1.ReplicationControllerList):
                    groupVersionKind = "v1/ReplicationControllerList";
                    break;
                case var t when t == typeof(Core.V1.ResourceQuota):
                    groupVersionKind = "v1/ResourceQuota";
                    break;
                case var t when t == typeof(Core.V1.ResourceQuotaList):
                    groupVersionKind = "v1/ResourceQuotaList";
                    break;
                case var t when t == typeof(Core.V1.Secret):
                    groupVersionKind = "v1/Secret";
                    break;
                case var t when t == typeof(Core.V1.SecretList):
                    groupVersionKind = "v1/SecretList";
                    break;
                case var t when t == typeof(Core.V1.Service):
                    groupVersionKind = "v1/Service";
                    break;
                case var t when t == typeof(Core.V1.ServiceAccount):
                    groupVersionKind = "v1/ServiceAccount";
                    break;
                case var t when t == typeof(Core.V1.ServiceAccountList):
                    groupVersionKind = "v1/ServiceAccountList";
                    break;
                case var t when t == typeof(Core.V1.ServiceList):
                    groupVersionKind = "v1/ServiceList";
                    break;
                case var t when t == typeof(Discovery.V1.EndpointSlice):
                    groupVersionKind = "discovery.k8s.io/v1/EndpointSlice";
                    break;
                case var t when t == typeof(Discovery.V1.EndpointSliceList):
                    groupVersionKind = "discovery.k8s.io/v1/EndpointSliceList";
                    break;
                case var t when t == typeof(Discovery.V1Beta1.EndpointSlice):
                    groupVersionKind = "discovery.k8s.io/v1beta1/EndpointSlice";
                    break;
                case var t when t == typeof(Discovery.V1Beta1.EndpointSliceList):
                    groupVersionKind = "discovery.k8s.io/v1beta1/EndpointSliceList";
                    break;
                case var t when t == typeof(Events.V1.Event):
                    groupVersionKind = "events.k8s.io/v1/Event";
                    break;
                case var t when t == typeof(Events.V1.EventList):
                    groupVersionKind = "events.k8s.io/v1/EventList";
                    break;
                case var t when t == typeof(Events.V1Beta1.Event):
                    groupVersionKind = "events.k8s.io/v1beta1/Event";
                    break;
                case var t when t == typeof(Events.V1Beta1.EventList):
                    groupVersionKind = "events.k8s.io/v1beta1/EventList";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.DaemonSet):
                    groupVersionKind = "extensions/v1beta1/DaemonSet";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.DaemonSetList):
                    groupVersionKind = "extensions/v1beta1/DaemonSetList";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.Deployment):
                    groupVersionKind = "extensions/v1beta1/Deployment";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.DeploymentList):
                    groupVersionKind = "extensions/v1beta1/DeploymentList";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.Ingress):
                    groupVersionKind = "extensions/v1beta1/Ingress";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.IngressList):
                    groupVersionKind = "extensions/v1beta1/IngressList";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.NetworkPolicy):
                    groupVersionKind = "extensions/v1beta1/NetworkPolicy";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.NetworkPolicyList):
                    groupVersionKind = "extensions/v1beta1/NetworkPolicyList";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.PodSecurityPolicy):
                    groupVersionKind = "extensions/v1beta1/PodSecurityPolicy";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.PodSecurityPolicyList):
                    groupVersionKind = "extensions/v1beta1/PodSecurityPolicyList";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.ReplicaSet):
                    groupVersionKind = "extensions/v1beta1/ReplicaSet";
                    break;
                case var t when t == typeof(Extensions.V1Beta1.ReplicaSetList):
                    groupVersionKind = "extensions/v1beta1/ReplicaSetList";
                    break;
                case var t when t == typeof(FlowControl.V1.FlowSchema):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1/FlowSchema";
                    break;
                case var t when t == typeof(FlowControl.V1.FlowSchemaList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1/FlowSchemaList";
                    break;
                case var t when t == typeof(FlowControl.V1.PriorityLevelConfiguration):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1/PriorityLevelConfiguration";
                    break;
                case var t when t == typeof(FlowControl.V1.PriorityLevelConfigurationList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1/PriorityLevelConfigurationList";
                    break;
                case var t when t == typeof(FlowControl.V1Alpha1.FlowSchema):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchema";
                    break;
                case var t when t == typeof(FlowControl.V1Alpha1.FlowSchemaList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchemaList";
                    break;
                case var t when t == typeof(FlowControl.V1Alpha1.PriorityLevelConfiguration):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfiguration";
                    break;
                case var t when t == typeof(FlowControl.V1Alpha1.PriorityLevelConfigurationList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfigurationList";
                    break;
                case var t when t == typeof(FlowControl.V1Beta1.FlowSchema):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta1/FlowSchema";
                    break;
                case var t when t == typeof(FlowControl.V1Beta1.FlowSchemaList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta1/FlowSchemaList";
                    break;
                case var t when t == typeof(FlowControl.V1Beta1.PriorityLevelConfiguration):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfiguration";
                    break;
                case var t when t == typeof(FlowControl.V1Beta1.PriorityLevelConfigurationList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfigurationList";
                    break;
                case var t when t == typeof(FlowControl.V1Beta2.FlowSchema):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta2/FlowSchema";
                    break;
                case var t when t == typeof(FlowControl.V1Beta2.FlowSchemaList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta2/FlowSchemaList";
                    break;
                case var t when t == typeof(FlowControl.V1Beta2.PriorityLevelConfiguration):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta2/PriorityLevelConfiguration";
                    break;
                case var t when t == typeof(FlowControl.V1Beta2.PriorityLevelConfigurationList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta2/PriorityLevelConfigurationList";
                    break;
                case var t when t == typeof(FlowControl.V1Beta3.FlowSchema):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta3/FlowSchema";
                    break;
                case var t when t == typeof(FlowControl.V1Beta3.FlowSchemaList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta3/FlowSchemaList";
                    break;
                case var t when t == typeof(FlowControl.V1Beta3.PriorityLevelConfiguration):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta3/PriorityLevelConfiguration";
                    break;
                case var t when t == typeof(FlowControl.V1Beta3.PriorityLevelConfigurationList):
                    groupVersionKind = "flowcontrol.apiserver.k8s.io/v1beta3/PriorityLevelConfigurationList";
                    break;
                case var t when t == typeof(Meta.V1.Status):
                    groupVersionKind = "meta/v1/Status";
                    break;
                case var t when t == typeof(Networking.V1.Ingress):
                    groupVersionKind = "networking.k8s.io/v1/Ingress";
                    break;
                case var t when t == typeof(Networking.V1.IngressClass):
                    groupVersionKind = "networking.k8s.io/v1/IngressClass";
                    break;
                case var t when t == typeof(Networking.V1.IngressClassList):
                    groupVersionKind = "networking.k8s.io/v1/IngressClassList";
                    break;
                case var t when t == typeof(Networking.V1.IngressList):
                    groupVersionKind = "networking.k8s.io/v1/IngressList";
                    break;
                case var t when t == typeof(Networking.V1.NetworkPolicy):
                    groupVersionKind = "networking.k8s.io/v1/NetworkPolicy";
                    break;
                case var t when t == typeof(Networking.V1.NetworkPolicyList):
                    groupVersionKind = "networking.k8s.io/v1/NetworkPolicyList";
                    break;
                case var t when t == typeof(Networking.V1Alpha1.ClusterCIDR):
                    groupVersionKind = "networking.k8s.io/v1alpha1/ClusterCIDR";
                    break;
                case var t when t == typeof(Networking.V1Alpha1.ClusterCIDRList):
                    groupVersionKind = "networking.k8s.io/v1alpha1/ClusterCIDRList";
                    break;
                case var t when t == typeof(Networking.V1Alpha1.IPAddress):
                    groupVersionKind = "networking.k8s.io/v1alpha1/IPAddress";
                    break;
                case var t when t == typeof(Networking.V1Alpha1.IPAddressList):
                    groupVersionKind = "networking.k8s.io/v1alpha1/IPAddressList";
                    break;
                case var t when t == typeof(Networking.V1Alpha1.ServiceCIDR):
                    groupVersionKind = "networking.k8s.io/v1alpha1/ServiceCIDR";
                    break;
                case var t when t == typeof(Networking.V1Alpha1.ServiceCIDRList):
                    groupVersionKind = "networking.k8s.io/v1alpha1/ServiceCIDRList";
                    break;
                case var t when t == typeof(Networking.V1Beta1.Ingress):
                    groupVersionKind = "networking.k8s.io/v1beta1/Ingress";
                    break;
                case var t when t == typeof(Networking.V1Beta1.IngressClass):
                    groupVersionKind = "networking.k8s.io/v1beta1/IngressClass";
                    break;
                case var t when t == typeof(Networking.V1Beta1.IngressClassList):
                    groupVersionKind = "networking.k8s.io/v1beta1/IngressClassList";
                    break;
                case var t when t == typeof(Networking.V1Beta1.IngressList):
                    groupVersionKind = "networking.k8s.io/v1beta1/IngressList";
                    break;
                case var t when t == typeof(Node.V1.RuntimeClass):
                    groupVersionKind = "node.k8s.io/v1/RuntimeClass";
                    break;
                case var t when t == typeof(Node.V1.RuntimeClassList):
                    groupVersionKind = "node.k8s.io/v1/RuntimeClassList";
                    break;
                case var t when t == typeof(Node.V1Alpha1.RuntimeClass):
                    groupVersionKind = "node.k8s.io/v1alpha1/RuntimeClass";
                    break;
                case var t when t == typeof(Node.V1Alpha1.RuntimeClassList):
                    groupVersionKind = "node.k8s.io/v1alpha1/RuntimeClassList";
                    break;
                case var t when t == typeof(Node.V1Beta1.RuntimeClass):
                    groupVersionKind = "node.k8s.io/v1beta1/RuntimeClass";
                    break;
                case var t when t == typeof(Node.V1Beta1.RuntimeClassList):
                    groupVersionKind = "node.k8s.io/v1beta1/RuntimeClassList";
                    break;
                case var t when t == typeof(Policy.V1.PodDisruptionBudget):
                    groupVersionKind = "policy/v1/PodDisruptionBudget";
                    break;
                case var t when t == typeof(Policy.V1.PodDisruptionBudgetList):
                    groupVersionKind = "policy/v1/PodDisruptionBudgetList";
                    break;
                case var t when t == typeof(Policy.V1Beta1.PodDisruptionBudget):
                    groupVersionKind = "policy/v1beta1/PodDisruptionBudget";
                    break;
                case var t when t == typeof(Policy.V1Beta1.PodDisruptionBudgetList):
                    groupVersionKind = "policy/v1beta1/PodDisruptionBudgetList";
                    break;
                case var t when t == typeof(Policy.V1Beta1.PodSecurityPolicy):
                    groupVersionKind = "policy/v1beta1/PodSecurityPolicy";
                    break;
                case var t when t == typeof(Policy.V1Beta1.PodSecurityPolicyList):
                    groupVersionKind = "policy/v1beta1/PodSecurityPolicyList";
                    break;
                case var t when t == typeof(Rbac.V1.ClusterRole):
                    groupVersionKind = "rbac.authorization.k8s.io/v1/ClusterRole";
                    break;
                case var t when t == typeof(Rbac.V1.ClusterRoleBinding):
                    groupVersionKind = "rbac.authorization.k8s.io/v1/ClusterRoleBinding";
                    break;
                case var t when t == typeof(Rbac.V1.ClusterRoleBindingList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1/ClusterRoleBindingList";
                    break;
                case var t when t == typeof(Rbac.V1.ClusterRoleList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1/ClusterRoleList";
                    break;
                case var t when t == typeof(Rbac.V1.Role):
                    groupVersionKind = "rbac.authorization.k8s.io/v1/Role";
                    break;
                case var t when t == typeof(Rbac.V1.RoleBinding):
                    groupVersionKind = "rbac.authorization.k8s.io/v1/RoleBinding";
                    break;
                case var t when t == typeof(Rbac.V1.RoleBindingList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1/RoleBindingList";
                    break;
                case var t when t == typeof(Rbac.V1.RoleList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1/RoleList";
                    break;
                case var t when t == typeof(Rbac.V1Alpha1.ClusterRole):
                    groupVersionKind = "rbac.authorization.k8s.io/v1alpha1/ClusterRole";
                    break;
                case var t when t == typeof(Rbac.V1Alpha1.ClusterRoleBinding):
                    groupVersionKind = "rbac.authorization.k8s.io/v1alpha1/ClusterRoleBinding";
                    break;
                case var t when t == typeof(Rbac.V1Alpha1.ClusterRoleBindingList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1alpha1/ClusterRoleBindingList";
                    break;
                case var t when t == typeof(Rbac.V1Alpha1.ClusterRoleList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1alpha1/ClusterRoleList";
                    break;
                case var t when t == typeof(Rbac.V1Alpha1.Role):
                    groupVersionKind = "rbac.authorization.k8s.io/v1alpha1/Role";
                    break;
                case var t when t == typeof(Rbac.V1Alpha1.RoleBinding):
                    groupVersionKind = "rbac.authorization.k8s.io/v1alpha1/RoleBinding";
                    break;
                case var t when t == typeof(Rbac.V1Alpha1.RoleBindingList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1alpha1/RoleBindingList";
                    break;
                case var t when t == typeof(Rbac.V1Alpha1.RoleList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1alpha1/RoleList";
                    break;
                case var t when t == typeof(Rbac.V1Beta1.ClusterRole):
                    groupVersionKind = "rbac.authorization.k8s.io/v1beta1/ClusterRole";
                    break;
                case var t when t == typeof(Rbac.V1Beta1.ClusterRoleBinding):
                    groupVersionKind = "rbac.authorization.k8s.io/v1beta1/ClusterRoleBinding";
                    break;
                case var t when t == typeof(Rbac.V1Beta1.ClusterRoleBindingList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1beta1/ClusterRoleBindingList";
                    break;
                case var t when t == typeof(Rbac.V1Beta1.ClusterRoleList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1beta1/ClusterRoleList";
                    break;
                case var t when t == typeof(Rbac.V1Beta1.Role):
                    groupVersionKind = "rbac.authorization.k8s.io/v1beta1/Role";
                    break;
                case var t when t == typeof(Rbac.V1Beta1.RoleBinding):
                    groupVersionKind = "rbac.authorization.k8s.io/v1beta1/RoleBinding";
                    break;
                case var t when t == typeof(Rbac.V1Beta1.RoleBindingList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1beta1/RoleBindingList";
                    break;
                case var t when t == typeof(Rbac.V1Beta1.RoleList):
                    groupVersionKind = "rbac.authorization.k8s.io/v1beta1/RoleList";
                    break;
                case var t when t == typeof(Resource.V1Alpha1.PodScheduling):
                    groupVersionKind = "resource.k8s.io/v1alpha1/PodScheduling";
                    break;
                case var t when t == typeof(Resource.V1Alpha1.PodSchedulingList):
                    groupVersionKind = "resource.k8s.io/v1alpha1/PodSchedulingList";
                    break;
                case var t when t == typeof(Resource.V1Alpha1.ResourceClaim):
                    groupVersionKind = "resource.k8s.io/v1alpha1/ResourceClaim";
                    break;
                case var t when t == typeof(Resource.V1Alpha1.ResourceClaimList):
                    groupVersionKind = "resource.k8s.io/v1alpha1/ResourceClaimList";
                    break;
                case var t when t == typeof(Resource.V1Alpha1.ResourceClaimTemplate):
                    groupVersionKind = "resource.k8s.io/v1alpha1/ResourceClaimTemplate";
                    break;
                case var t when t == typeof(Resource.V1Alpha1.ResourceClaimTemplateList):
                    groupVersionKind = "resource.k8s.io/v1alpha1/ResourceClaimTemplateList";
                    break;
                case var t when t == typeof(Resource.V1Alpha1.ResourceClass):
                    groupVersionKind = "resource.k8s.io/v1alpha1/ResourceClass";
                    break;
                case var t when t == typeof(Resource.V1Alpha1.ResourceClassList):
                    groupVersionKind = "resource.k8s.io/v1alpha1/ResourceClassList";
                    break;
                case var t when t == typeof(Resource.V1Alpha2.PodSchedulingContext):
                    groupVersionKind = "resource.k8s.io/v1alpha2/PodSchedulingContext";
                    break;
                case var t when t == typeof(Resource.V1Alpha2.PodSchedulingContextList):
                    groupVersionKind = "resource.k8s.io/v1alpha2/PodSchedulingContextList";
                    break;
                case var t when t == typeof(Resource.V1Alpha2.ResourceClaim):
                    groupVersionKind = "resource.k8s.io/v1alpha2/ResourceClaim";
                    break;
                case var t when t == typeof(Resource.V1Alpha2.ResourceClaimList):
                    groupVersionKind = "resource.k8s.io/v1alpha2/ResourceClaimList";
                    break;
                case var t when t == typeof(Resource.V1Alpha2.ResourceClaimTemplate):
                    groupVersionKind = "resource.k8s.io/v1alpha2/ResourceClaimTemplate";
                    break;
                case var t when t == typeof(Resource.V1Alpha2.ResourceClaimTemplateList):
                    groupVersionKind = "resource.k8s.io/v1alpha2/ResourceClaimTemplateList";
                    break;
                case var t when t == typeof(Resource.V1Alpha2.ResourceClass):
                    groupVersionKind = "resource.k8s.io/v1alpha2/ResourceClass";
                    break;
                case var t when t == typeof(Resource.V1Alpha2.ResourceClassList):
                    groupVersionKind = "resource.k8s.io/v1alpha2/ResourceClassList";
                    break;
                case var t when t == typeof(Scheduling.V1.PriorityClass):
                    groupVersionKind = "scheduling.k8s.io/v1/PriorityClass";
                    break;
                case var t when t == typeof(Scheduling.V1.PriorityClassList):
                    groupVersionKind = "scheduling.k8s.io/v1/PriorityClassList";
                    break;
                case var t when t == typeof(Scheduling.V1Alpha1.PriorityClass):
                    groupVersionKind = "scheduling.k8s.io/v1alpha1/PriorityClass";
                    break;
                case var t when t == typeof(Scheduling.V1Alpha1.PriorityClassList):
                    groupVersionKind = "scheduling.k8s.io/v1alpha1/PriorityClassList";
                    break;
                case var t when t == typeof(Scheduling.V1Beta1.PriorityClass):
                    groupVersionKind = "scheduling.k8s.io/v1beta1/PriorityClass";
                    break;
                case var t when t == typeof(Scheduling.V1Beta1.PriorityClassList):
                    groupVersionKind = "scheduling.k8s.io/v1beta1/PriorityClassList";
                    break;
                case var t when t == typeof(Settings.V1Alpha1.PodPreset):
                    groupVersionKind = "settings.k8s.io/v1alpha1/PodPreset";
                    break;
                case var t when t == typeof(Settings.V1Alpha1.PodPresetList):
                    groupVersionKind = "settings.k8s.io/v1alpha1/PodPresetList";
                    break;
                case var t when t == typeof(Storage.V1.CSIDriver):
                    groupVersionKind = "storage.k8s.io/v1/CSIDriver";
                    break;
                case var t when t == typeof(Storage.V1.CSIDriverList):
                    groupVersionKind = "storage.k8s.io/v1/CSIDriverList";
                    break;
                case var t when t == typeof(Storage.V1.CSINode):
                    groupVersionKind = "storage.k8s.io/v1/CSINode";
                    break;
                case var t when t == typeof(Storage.V1.CSINodeList):
                    groupVersionKind = "storage.k8s.io/v1/CSINodeList";
                    break;
                case var t when t == typeof(Storage.V1.CSIStorageCapacity):
                    groupVersionKind = "storage.k8s.io/v1/CSIStorageCapacity";
                    break;
                case var t when t == typeof(Storage.V1.CSIStorageCapacityList):
                    groupVersionKind = "storage.k8s.io/v1/CSIStorageCapacityList";
                    break;
                case var t when t == typeof(Storage.V1.StorageClass):
                    groupVersionKind = "storage.k8s.io/v1/StorageClass";
                    break;
                case var t when t == typeof(Storage.V1.StorageClassList):
                    groupVersionKind = "storage.k8s.io/v1/StorageClassList";
                    break;
                case var t when t == typeof(Storage.V1.VolumeAttachment):
                    groupVersionKind = "storage.k8s.io/v1/VolumeAttachment";
                    break;
                case var t when t == typeof(Storage.V1.VolumeAttachmentList):
                    groupVersionKind = "storage.k8s.io/v1/VolumeAttachmentList";
                    break;
                case var t when t == typeof(Storage.V1Alpha1.VolumeAttachment):
                    groupVersionKind = "storage.k8s.io/v1alpha1/VolumeAttachment";
                    break;
                case var t when t == typeof(Storage.V1Alpha1.VolumeAttachmentList):
                    groupVersionKind = "storage.k8s.io/v1alpha1/VolumeAttachmentList";
                    break;
                case var t when t == typeof(Storage.V1Alpha1.VolumeAttributesClass):
                    groupVersionKind = "storage.k8s.io/v1alpha1/VolumeAttributesClass";
                    break;
                case var t when t == typeof(Storage.V1Alpha1.VolumeAttributesClassList):
                    groupVersionKind = "storage.k8s.io/v1alpha1/VolumeAttributesClassList";
                    break;
                case var t when t == typeof(Storage.V1Beta1.CSIDriver):
                    groupVersionKind = "storage.k8s.io/v1beta1/CSIDriver";
                    break;
                case var t when t == typeof(Storage.V1Beta1.CSIDriverList):
                    groupVersionKind = "storage.k8s.io/v1beta1/CSIDriverList";
                    break;
                case var t when t == typeof(Storage.V1Beta1.CSINode):
                    groupVersionKind = "storage.k8s.io/v1beta1/CSINode";
                    break;
                case var t when t == typeof(Storage.V1Beta1.CSINodeList):
                    groupVersionKind = "storage.k8s.io/v1beta1/CSINodeList";
                    break;
                case var t when t == typeof(Storage.V1Beta1.CSIStorageCapacity):
                    groupVersionKind = "storage.k8s.io/v1beta1/CSIStorageCapacity";
                    break;
                case var t when t == typeof(Storage.V1Beta1.CSIStorageCapacityList):
                    groupVersionKind = "storage.k8s.io/v1beta1/CSIStorageCapacityList";
                    break;
                case var t when t == typeof(Storage.V1Beta1.StorageClass):
                    groupVersionKind = "storage.k8s.io/v1beta1/StorageClass";
                    break;
                case var t when t == typeof(Storage.V1Beta1.StorageClassList):
                    groupVersionKind = "storage.k8s.io/v1beta1/StorageClassList";
                    break;
                case var t when t == typeof(Storage.V1Beta1.VolumeAttachment):
                    groupVersionKind = "storage.k8s.io/v1beta1/VolumeAttachment";
                    break;
                case var t when t == typeof(Storage.V1Beta1.VolumeAttachmentList):
                    groupVersionKind = "storage.k8s.io/v1beta1/VolumeAttachmentList";
                    break;
                default:
                    throw new ArgumentException($"Unknown resource type {typeof(T).FullName}");
            }
            var id = namespaceName != null ? $"{namespaceName}/{name}" : name;
            return Resources.Apply(r =>
            {
                if (!r.TryGetValue($"{groupVersionKind}::{id}", out var value))
                {
                    var existingKeys = string.Join(", ", r.Keys);
                    throw new ArgumentException($"Resource {groupVersionKind}::{id} of type {type.FullName} and id {id} is not found, existing resources are {existingKeys}");
                }

                return (T) value;
            });
        }

        /// <summary>
        /// Returns an array of ready resources to be used by DependsOn.
        /// </summary>
        public Output<ImmutableArray<Pu.Resource>> Ready()
        {
            return Resources.Apply(resources => resources.Values.Cast<Pu.Resource>().ToImmutableArray());
        }

        /// <summary>
        /// Returns a custom resource defined by the given group/version/kind and name.
        /// </summary>
        /// <param name="groupVersionKind">Group/version/kind, e.g. "monitoring.coreos.com/v1/ServiceMonitor".
        /// </param>
        /// <param name="name">Resource name.</param>
        /// <param name="namespaceName">Optional namespace, e.g. "kube-prometheus-exporter-kubernetes".</param>
        public Output<CustomResource> GetCustomResource(string groupVersionKind, string name, string? namespaceName = null)
        {
            var id = namespaceName != null ? $"{namespaceName}/{name}" : name;
            return Resources.Apply(r => (CustomResource)r[$"{groupVersionKind}::{id}"]);
        }

        internal static CustomResourceOptions GetChildOptions(Pu.Resource parent, InputList<Pu.Resource>? extraDependsOn, ComponentResourceOptions? options)
        {
            // Create resource options based on component resource options.
            var dependsOn = new InputList<Pu.Resource>();
            if (extraDependsOn is not null)
                dependsOn.AddRange(extraDependsOn);
            return new CustomResourceOptions
            {
                Parent = parent,
                DependsOn = dependsOn,
                Version = options?.Version,
                PluginDownloadURL = options?.PluginDownloadURL,
            };
        }

        internal static ComponentResourceOptions ConvertChildOptions(CustomResourceOptions options)
        {
            var dependsOn = new InputList<Pu.Resource>();
            if (options is not null)
                dependsOn.AddRange(options.DependsOn);
            return new ComponentResourceOptions
            {
                Aliases = options.Aliases.ToList(),
                DependsOn = dependsOn,
                Parent = options.Parent,
                ResourceTransformations = options.ResourceTransformations.ToList(),
                Version = options.Version,
                PluginDownloadURL = options.PluginDownloadURL,
            };
        }

        internal static InvokeOptions GetInvokeOptions(CustomResourceOptions? options)
        {
            return new InvokeOptions { 
                Parent = options?.Parent,
                Provider = options?.Provider,
                Version = options?.Version,
                PluginDownloadURL = options?.PluginDownloadURL,
            }.WithDefaults();
        }

        internal static ResourceTransformation Aliased(Pulumi.Resource parent, Pulumi.Resource? oldParent = null) {
            return new ResourceTransformation((args) => {
                if (!Object.ReferenceEquals(args.Options?.Parent, parent)) {
                    return null;
                }

                var alias = new Alias { 
                    Parent = oldParent,
                    Name = args.Resource.GetResourceName(),
                    Type = args.Resource.GetResourceType(),
                };
                if (args.Options is ComponentResourceOptions options1)
                {
                    var options = ComponentResourceOptions.Merge(
                        options1,
                        new ComponentResourceOptions { Aliases = {alias} });
                    return new ResourceTransformationResult(args.Args, options);
                }
                if (args.Options is CustomResourceOptions options2)
                {
                    var options = CustomResourceOptions.Merge(
                        options2,
                        new CustomResourceOptions { Aliases = {alias} });
                    return new ResourceTransformationResult(args.Args, options);
                }
                return null;
            });
        }
    }

    internal static class Parser
    {
        public static Output<ImmutableDictionary<string, KubernetesResource>> Parse(ConfigGroupArgs config, CustomResourceOptions options,
            Pulumi.Resource? aliasParent = null)
        {
            var resources = Output.Create(ImmutableDictionary.Create<string, KubernetesResource>());

            var transformations = config.Transformations;
            if (config?.SkipAwait == true)
            {
                transformations.Add(SkipAwait);
            }

            if (config.Files != null)
            {
                var files = new List<string>();
                foreach (var file in config.Files)
                {
                    if (IsUrl(file))
                        files.Add(file);
                    else
                        files.AddRange(Glob.Files(Directory.GetCurrentDirectory(), file));
                }

                foreach (var file in files)
                {
                    var cfOptions = CollectionComponentResource.ConvertChildOptions(options);
                    var cfArgs = new ConfigFileArgs
                    {
                        File = file,
                        Transformations = transformations,
                        ResourcePrefix = config.ResourcePrefix
                    };

                    var cf = new ConfigFile(file, cfArgs, cfOptions, aliasParent);
                    resources = Output.Tuple(resources, cf.Resources).Apply(vs => vs.Item1.AddRange(vs.Item2));
                }
            }

            if (config.Yaml != null)
            {
                var invokeOpts = CollectionComponentResource.GetInvokeOptions(options);
                var yamlResources = config.Yaml.ToOutput().Apply(texts =>
                {
                    var yamls = texts
                        .Select(text =>
                            ParseYamlDocument(new ParseArgs
                            {
                                Objs = Invokes.YamlDecode(new YamlDecodeArgs { Text = text }, invokeOpts),
                                Transformations = transformations,
                                ResourcePrefix = config.ResourcePrefix
                            }, options))
                        .Select(output => (Input<ImmutableDictionary<string, KubernetesResource>>)output)
                        .ToImmutableArray();
                    return Output.All(yamls);
                });

                resources = Output.Tuple(resources, yamlResources).Apply(vs =>
                {
                    var builder = ImmutableDictionary.CreateBuilder<string, KubernetesResource>();
                    builder.AddRange(vs.Item1);
                    foreach (var bs in vs.Item2)
                        builder.AddRange(bs);
                    return builder.ToImmutable();
                });
            }

            if (config.Objs != null)
            {
                var docResources = ParseYamlDocument(new ParseArgs
                {
                    Objs = config.Objs,
                    Transformations = transformations,
                    ResourcePrefix = config.ResourcePrefix
                }, options);
                resources = Output.Tuple(resources, docResources).Apply(vs => vs.Item1.AddRange(vs.Item2));
            }

            return resources;

        }

        // Define a transformation to set the skipAwait annotation on resources.
        internal static ImmutableDictionary<string, object> SkipAwait(ImmutableDictionary<string, object> obj, CustomResourceOptions opts)
        {
            var metadata = (ImmutableDictionary<string, object>)obj["metadata"];
            if (metadata.ContainsKey("annotations"))
            {
                var annotations = (ImmutableDictionary<string, object>)metadata["annotations"];
                annotations = annotations.SetItem("pulumi.com/skipAwait", "true");
                metadata = metadata.SetItem("annotations", annotations);
                obj = obj.SetItem("metadata", metadata);
            }
            else
            {
                var annotations = new Dictionary<string, string> { { "pulumi.com/skipAwait", "true" } }.ToImmutableDictionary();
                metadata = metadata.SetItem("annotations", annotations);
                obj = obj.SetItem("metadata", metadata);
            }

            return obj;
        }

        internal static bool IsUrl(string s)
            => s.StartsWith("http://", StringComparison.Ordinal) || s.StartsWith("https://", StringComparison.Ordinal);

        internal static Output<ImmutableDictionary<string, KubernetesResource>> ParseYamlDocument(ParseArgs config,
            CustomResourceOptions? options = null)
        {
            return config.Objs.ToOutput().Apply(objs =>
            {

                var inputs = objs
                    .SelectMany(obj => ParseYamlObject(obj, config.Transformations, config.ResourcePrefix, options))
                    .Select(output => (Input<(string, KubernetesResource)>) output)
                    .ToImmutableArray();

                return Output.All(inputs)
                    .Apply(items =>
                        items.Select(obj => new KeyValuePair<string, KubernetesResource>(obj.Item1, obj.Item2))
                             .ToImmutableDictionary());
            });
        }

        private static Output<(string, KubernetesResource)>[] ParseYamlObject(ImmutableDictionary<string, object> obj,
            List<TransformationAction>? transformations, string? resourcePrefix, CustomResourceOptions? options = null)
        {
            if (obj == null || obj.Count == 0)
                return new Output<(string, KubernetesResource)>[0];

            // Create a copy of options to pass into potentially mutating transforms that will be applied to this resource.
            var opts = CustomResourceOptions.Merge(null, options);

            // Allow users to change API objects before any validation.
            if (transformations != null)
            {
                foreach (var transform in transformations)
                    obj = transform(obj, opts);
            }

            if (!(obj.ContainsKey("kind") && obj.ContainsKey("apiVersion")))
            {
                var serialized = JsonSerializer.Serialize(obj);
                throw new FormatException($"Kubernetes resources require a kind and apiVersion: {serialized}");
            }

            var kind = (string)obj["kind"];
            var apiVersion = (string)obj["apiVersion"];
            var gvk = $"{apiVersion}/{kind}";

            // Recursively traverse built-in Kubernetes list types into a single set of "naked" resource
            // definitions that we can register with the Pulumi engine.
            //
            // Kubernetes does not instantiate list types like `v1.List`. When the API server receives
            // a list, it will recursively traverse it and perform the necessary operations on the
            // each "instantiable" resource it finds. For example, `kubectl apply` on a
            // `v1.ConfigMapList` will cause the API server to traverse the list, and `apply` each
            // `v1.ConfigMap` it finds.
            //
            // Since Kubernetes does not instantiate list types directly, Pulumi also traverses lists
            // for resource definitions that can be managed by Kubernetes, and registers those with the
            // engine instead.
            if (
                gvk == "v1/List"
                || gvk == "admissionregistration.k8s.io/v1/MutatingWebhookConfigurationList"
                || gvk == "admissionregistration.k8s.io/v1/ValidatingWebhookConfigurationList"
                || gvk == "admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicyBindingList"
                || gvk == "admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicyList"
                || gvk == "admissionregistration.k8s.io/v1beta1/MutatingWebhookConfigurationList"
                || gvk == "admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicyBindingList"
                || gvk == "admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicyList"
                || gvk == "admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfigurationList"
                || gvk == "apiextensions.k8s.io/v1/CustomResourceDefinitionList"
                || gvk == "apiextensions.k8s.io/v1beta1/CustomResourceDefinitionList"
                || gvk == "apiregistration.k8s.io/v1/APIServiceList"
                || gvk == "apiregistration.k8s.io/v1beta1/APIServiceList"
                || gvk == "apps/v1/ControllerRevisionList"
                || gvk == "apps/v1/DaemonSetList"
                || gvk == "apps/v1/DeploymentList"
                || gvk == "apps/v1/ReplicaSetList"
                || gvk == "apps/v1/StatefulSetList"
                || gvk == "apps/v1beta1/ControllerRevisionList"
                || gvk == "apps/v1beta1/DeploymentList"
                || gvk == "apps/v1beta1/StatefulSetList"
                || gvk == "apps/v1beta2/ControllerRevisionList"
                || gvk == "apps/v1beta2/DaemonSetList"
                || gvk == "apps/v1beta2/DeploymentList"
                || gvk == "apps/v1beta2/ReplicaSetList"
                || gvk == "apps/v1beta2/StatefulSetList"
                || gvk == "auditregistration.k8s.io/v1alpha1/AuditSinkList"
                || gvk == "autoscaling/v1/HorizontalPodAutoscalerList"
                || gvk == "autoscaling/v2/HorizontalPodAutoscalerList"
                || gvk == "autoscaling/v2beta1/HorizontalPodAutoscalerList"
                || gvk == "autoscaling/v2beta2/HorizontalPodAutoscalerList"
                || gvk == "batch/v1/CronJobList"
                || gvk == "batch/v1/JobList"
                || gvk == "batch/v1beta1/CronJobList"
                || gvk == "batch/v2alpha1/CronJobList"
                || gvk == "certificates.k8s.io/v1/CertificateSigningRequestList"
                || gvk == "certificates.k8s.io/v1alpha1/ClusterTrustBundleList"
                || gvk == "certificates.k8s.io/v1beta1/CertificateSigningRequestList"
                || gvk == "coordination.k8s.io/v1/LeaseList"
                || gvk == "coordination.k8s.io/v1beta1/LeaseList"
                || gvk == "v1/ConfigMapList"
                || gvk == "v1/EndpointsList"
                || gvk == "v1/EventList"
                || gvk == "v1/LimitRangeList"
                || gvk == "v1/NamespaceList"
                || gvk == "v1/NodeList"
                || gvk == "v1/PersistentVolumeClaimList"
                || gvk == "v1/PersistentVolumeList"
                || gvk == "v1/PodList"
                || gvk == "v1/PodTemplateList"
                || gvk == "v1/ReplicationControllerList"
                || gvk == "v1/ResourceQuotaList"
                || gvk == "v1/SecretList"
                || gvk == "v1/ServiceAccountList"
                || gvk == "v1/ServiceList"
                || gvk == "discovery.k8s.io/v1/EndpointSliceList"
                || gvk == "discovery.k8s.io/v1beta1/EndpointSliceList"
                || gvk == "events.k8s.io/v1/EventList"
                || gvk == "events.k8s.io/v1beta1/EventList"
                || gvk == "extensions/v1beta1/DaemonSetList"
                || gvk == "extensions/v1beta1/DeploymentList"
                || gvk == "extensions/v1beta1/IngressList"
                || gvk == "extensions/v1beta1/NetworkPolicyList"
                || gvk == "extensions/v1beta1/PodSecurityPolicyList"
                || gvk == "extensions/v1beta1/ReplicaSetList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1/FlowSchemaList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1/PriorityLevelConfigurationList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchemaList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfigurationList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1beta1/FlowSchemaList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfigurationList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1beta2/FlowSchemaList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1beta2/PriorityLevelConfigurationList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1beta3/FlowSchemaList"
                || gvk == "flowcontrol.apiserver.k8s.io/v1beta3/PriorityLevelConfigurationList"
                || gvk == "networking.k8s.io/v1/IngressClassList"
                || gvk == "networking.k8s.io/v1/IngressList"
                || gvk == "networking.k8s.io/v1/NetworkPolicyList"
                || gvk == "networking.k8s.io/v1alpha1/ClusterCIDRList"
                || gvk == "networking.k8s.io/v1alpha1/IPAddressList"
                || gvk == "networking.k8s.io/v1alpha1/ServiceCIDRList"
                || gvk == "networking.k8s.io/v1beta1/IngressClassList"
                || gvk == "networking.k8s.io/v1beta1/IngressList"
                || gvk == "node.k8s.io/v1/RuntimeClassList"
                || gvk == "node.k8s.io/v1alpha1/RuntimeClassList"
                || gvk == "node.k8s.io/v1beta1/RuntimeClassList"
                || gvk == "policy/v1/PodDisruptionBudgetList"
                || gvk == "policy/v1beta1/PodDisruptionBudgetList"
                || gvk == "policy/v1beta1/PodSecurityPolicyList"
                || gvk == "rbac.authorization.k8s.io/v1/ClusterRoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1/ClusterRoleList"
                || gvk == "rbac.authorization.k8s.io/v1/RoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1/RoleList"
                || gvk == "rbac.authorization.k8s.io/v1alpha1/ClusterRoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1alpha1/ClusterRoleList"
                || gvk == "rbac.authorization.k8s.io/v1alpha1/RoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1alpha1/RoleList"
                || gvk == "rbac.authorization.k8s.io/v1beta1/ClusterRoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1beta1/ClusterRoleList"
                || gvk == "rbac.authorization.k8s.io/v1beta1/RoleBindingList"
                || gvk == "rbac.authorization.k8s.io/v1beta1/RoleList"
                || gvk == "resource.k8s.io/v1alpha1/PodSchedulingList"
                || gvk == "resource.k8s.io/v1alpha1/ResourceClaimList"
                || gvk == "resource.k8s.io/v1alpha1/ResourceClaimTemplateList"
                || gvk == "resource.k8s.io/v1alpha1/ResourceClassList"
                || gvk == "resource.k8s.io/v1alpha2/PodSchedulingContextList"
                || gvk == "resource.k8s.io/v1alpha2/ResourceClaimList"
                || gvk == "resource.k8s.io/v1alpha2/ResourceClaimTemplateList"
                || gvk == "resource.k8s.io/v1alpha2/ResourceClassList"
                || gvk == "scheduling.k8s.io/v1/PriorityClassList"
                || gvk == "scheduling.k8s.io/v1alpha1/PriorityClassList"
                || gvk == "scheduling.k8s.io/v1beta1/PriorityClassList"
                || gvk == "settings.k8s.io/v1alpha1/PodPresetList"
                || gvk == "storage.k8s.io/v1/CSIDriverList"
                || gvk == "storage.k8s.io/v1/CSINodeList"
                || gvk == "storage.k8s.io/v1/CSIStorageCapacityList"
                || gvk == "storage.k8s.io/v1/StorageClassList"
                || gvk == "storage.k8s.io/v1/VolumeAttachmentList"
                || gvk == "storage.k8s.io/v1alpha1/VolumeAttachmentList"
                || gvk == "storage.k8s.io/v1alpha1/VolumeAttributesClassList"
                || gvk == "storage.k8s.io/v1beta1/CSIDriverList"
                || gvk == "storage.k8s.io/v1beta1/CSINodeList"
                || gvk == "storage.k8s.io/v1beta1/CSIStorageCapacityList"
                || gvk == "storage.k8s.io/v1beta1/StorageClassList"
                || gvk == "storage.k8s.io/v1beta1/VolumeAttachmentList"
               )
            {
                var objs = new List<Output<(string, KubernetesResource)>>();
                if (obj["items"] is IEnumerable<ImmutableDictionary<string, object>> items)
                {
                    foreach (var item in items)
                        objs.AddRange(Parser.ParseYamlObject(item, transformations, resourcePrefix, opts));
                }
                return objs.ToArray();
            }

            if (!obj.ContainsKey("metadata") || !(obj["metadata"] is ImmutableDictionary<string, object> metadata)
                || !metadata.ContainsKey("name"))
            {
                var serialized = obj.TryGetValue("metadata", out var m) ? JsonSerializer.Serialize(m) : "<null>";
                throw new FormatException($"YAML object does not have a .metadata.name: {apiVersion}/{kind} {serialized}");
            }

            var meta = (ImmutableDictionary<string, object>)obj["metadata"];
            var id = Output.Create((string)meta["name"]);
            if (meta.TryGetValue("namespace", out object ns))
                id = Output.Format($"{ns}/{id}");
            if (resourcePrefix != null)
                id = Output.Format($"{resourcePrefix}-{id}");

            if (gvk == "v1/Secret")
            {
                // Always mark these fields as secret to avoid leaking sensitive values from raw YAML.
                foreach (string key in new string[]{"data", "stringData"})
                {
                    if (obj.ContainsKey(key))
                    {
                        obj = obj.SetItem(key, Output.CreateSecret(obj[key]));
                    }
                }
            }

            switch (gvk)
            {
                    case "admissionregistration.k8s.io/v1/MutatingWebhookConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1/MutatingWebhookConfiguration::{id}",
                                new AdmissionRegistration.V1.MutatingWebhookConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1/ValidatingWebhookConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1/ValidatingWebhookConfiguration::{id}",
                                new AdmissionRegistration.V1.ValidatingWebhookConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicy::{id}",
                                new AdmissionRegistration.V1Alpha1.ValidatingAdmissionPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicyBinding":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1alpha1/ValidatingAdmissionPolicyBinding::{id}",
                                new AdmissionRegistration.V1Alpha1.ValidatingAdmissionPolicyBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1beta1/MutatingWebhookConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1beta1/MutatingWebhookConfiguration::{id}",
                                new AdmissionRegistration.V1Beta1.MutatingWebhookConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicy::{id}",
                                new AdmissionRegistration.V1Beta1.ValidatingAdmissionPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicyBinding":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1beta1/ValidatingAdmissionPolicyBinding::{id}",
                                new AdmissionRegistration.V1Beta1.ValidatingAdmissionPolicyBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"admissionregistration.k8s.io/v1beta1/ValidatingWebhookConfiguration::{id}",
                                new AdmissionRegistration.V1Beta1.ValidatingWebhookConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "apiextensions.k8s.io/v1/CustomResourceDefinition":
                        return new[]
                        {
                            id.Apply(id => ($"apiextensions.k8s.io/v1/CustomResourceDefinition::{id}",
                                new ApiExtensions.V1.CustomResourceDefinition(id, obj!, opts) as KubernetesResource))
                        };
                    case "apiextensions.k8s.io/v1beta1/CustomResourceDefinition":
                        return new[]
                        {
                            id.Apply(id => ($"apiextensions.k8s.io/v1beta1/CustomResourceDefinition::{id}",
                                new ApiExtensions.V1Beta1.CustomResourceDefinition(id, obj!, opts) as KubernetesResource))
                        };
                    case "apiregistration.k8s.io/v1/APIService":
                        return new[]
                        {
                            id.Apply(id => ($"apiregistration.k8s.io/v1/APIService::{id}",
                                new ApiRegistration.V1.APIService(id, obj!, opts) as KubernetesResource))
                        };
                    case "apiregistration.k8s.io/v1beta1/APIService":
                        return new[]
                        {
                            id.Apply(id => ($"apiregistration.k8s.io/v1beta1/APIService::{id}",
                                new ApiRegistration.V1Beta1.APIService(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/ControllerRevision":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/ControllerRevision::{id}",
                                new Apps.V1.ControllerRevision(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/DaemonSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/DaemonSet::{id}",
                                new Apps.V1.DaemonSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/Deployment":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/Deployment::{id}",
                                new Apps.V1.Deployment(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/ReplicaSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/ReplicaSet::{id}",
                                new Apps.V1.ReplicaSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1/StatefulSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1/StatefulSet::{id}",
                                new Apps.V1.StatefulSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta1/ControllerRevision":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta1/ControllerRevision::{id}",
                                new Apps.V1Beta1.ControllerRevision(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta1/Deployment":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta1/Deployment::{id}",
                                new Apps.V1Beta1.Deployment(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta1/StatefulSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta1/StatefulSet::{id}",
                                new Apps.V1Beta1.StatefulSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/ControllerRevision":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/ControllerRevision::{id}",
                                new Apps.V1Beta2.ControllerRevision(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/DaemonSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/DaemonSet::{id}",
                                new Apps.V1Beta2.DaemonSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/Deployment":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/Deployment::{id}",
                                new Apps.V1Beta2.Deployment(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/ReplicaSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/ReplicaSet::{id}",
                                new Apps.V1Beta2.ReplicaSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "apps/v1beta2/StatefulSet":
                        return new[]
                        {
                            id.Apply(id => ($"apps/v1beta2/StatefulSet::{id}",
                                new Apps.V1Beta2.StatefulSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "auditregistration.k8s.io/v1alpha1/AuditSink":
                        return new[]
                        {
                            id.Apply(id => ($"auditregistration.k8s.io/v1alpha1/AuditSink::{id}",
                                new AuditRegistraion.V1Alpha1.AuditSink(id, obj!, opts) as KubernetesResource))
                        };
                    case "autoscaling/v1/HorizontalPodAutoscaler":
                        return new[]
                        {
                            id.Apply(id => ($"autoscaling/v1/HorizontalPodAutoscaler::{id}",
                                new Autoscaling.V1.HorizontalPodAutoscaler(id, obj!, opts) as KubernetesResource))
                        };
                    case "autoscaling/v2/HorizontalPodAutoscaler":
                        return new[]
                        {
                            id.Apply(id => ($"autoscaling/v2/HorizontalPodAutoscaler::{id}",
                                new Autoscaling.V2.HorizontalPodAutoscaler(id, obj!, opts) as KubernetesResource))
                        };
                    case "autoscaling/v2beta1/HorizontalPodAutoscaler":
                        return new[]
                        {
                            id.Apply(id => ($"autoscaling/v2beta1/HorizontalPodAutoscaler::{id}",
                                new Autoscaling.V2Beta1.HorizontalPodAutoscaler(id, obj!, opts) as KubernetesResource))
                        };
                    case "autoscaling/v2beta2/HorizontalPodAutoscaler":
                        return new[]
                        {
                            id.Apply(id => ($"autoscaling/v2beta2/HorizontalPodAutoscaler::{id}",
                                new Autoscaling.V2Beta2.HorizontalPodAutoscaler(id, obj!, opts) as KubernetesResource))
                        };
                    case "batch/v1/CronJob":
                        return new[]
                        {
                            id.Apply(id => ($"batch/v1/CronJob::{id}",
                                new Batch.V1.CronJob(id, obj!, opts) as KubernetesResource))
                        };
                    case "batch/v1/Job":
                        return new[]
                        {
                            id.Apply(id => ($"batch/v1/Job::{id}",
                                new Batch.V1.Job(id, obj!, opts) as KubernetesResource))
                        };
                    case "batch/v1beta1/CronJob":
                        return new[]
                        {
                            id.Apply(id => ($"batch/v1beta1/CronJob::{id}",
                                new Batch.V1Beta1.CronJob(id, obj!, opts) as KubernetesResource))
                        };
                    case "batch/v2alpha1/CronJob":
                        return new[]
                        {
                            id.Apply(id => ($"batch/v2alpha1/CronJob::{id}",
                                new Batch.V2Alpha1.CronJob(id, obj!, opts) as KubernetesResource))
                        };
                    case "certificates.k8s.io/v1/CertificateSigningRequest":
                        return new[]
                        {
                            id.Apply(id => ($"certificates.k8s.io/v1/CertificateSigningRequest::{id}",
                                new Certificates.V1.CertificateSigningRequest(id, obj!, opts) as KubernetesResource))
                        };
                    case "certificates.k8s.io/v1alpha1/ClusterTrustBundle":
                        return new[]
                        {
                            id.Apply(id => ($"certificates.k8s.io/v1alpha1/ClusterTrustBundle::{id}",
                                new Certificates.V1Alpha1.ClusterTrustBundle(id, obj!, opts) as KubernetesResource))
                        };
                    case "certificates.k8s.io/v1beta1/CertificateSigningRequest":
                        return new[]
                        {
                            id.Apply(id => ($"certificates.k8s.io/v1beta1/CertificateSigningRequest::{id}",
                                new Certificates.V1Beta1.CertificateSigningRequest(id, obj!, opts) as KubernetesResource))
                        };
                    case "coordination.k8s.io/v1/Lease":
                        return new[]
                        {
                            id.Apply(id => ($"coordination.k8s.io/v1/Lease::{id}",
                                new Coordination.V1.Lease(id, obj!, opts) as KubernetesResource))
                        };
                    case "coordination.k8s.io/v1beta1/Lease":
                        return new[]
                        {
                            id.Apply(id => ($"coordination.k8s.io/v1beta1/Lease::{id}",
                                new Coordination.V1Beta1.Lease(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Binding":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Binding::{id}",
                                new Core.V1.Binding(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/ConfigMap":
                        return new[]
                        {
                            id.Apply(id => ($"v1/ConfigMap::{id}",
                                new Core.V1.ConfigMap(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Endpoints":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Endpoints::{id}",
                                new Core.V1.Endpoints(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Event":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Event::{id}",
                                new Core.V1.Event(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/LimitRange":
                        return new[]
                        {
                            id.Apply(id => ($"v1/LimitRange::{id}",
                                new Core.V1.LimitRange(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Namespace":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Namespace::{id}",
                                new Core.V1.Namespace(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Node":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Node::{id}",
                                new Core.V1.Node(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/PersistentVolume":
                        return new[]
                        {
                            id.Apply(id => ($"v1/PersistentVolume::{id}",
                                new Core.V1.PersistentVolume(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/PersistentVolumeClaim":
                        return new[]
                        {
                            id.Apply(id => ($"v1/PersistentVolumeClaim::{id}",
                                new Core.V1.PersistentVolumeClaim(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Pod":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Pod::{id}",
                                new Core.V1.Pod(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/PodTemplate":
                        return new[]
                        {
                            id.Apply(id => ($"v1/PodTemplate::{id}",
                                new Core.V1.PodTemplate(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/ReplicationController":
                        return new[]
                        {
                            id.Apply(id => ($"v1/ReplicationController::{id}",
                                new Core.V1.ReplicationController(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/ResourceQuota":
                        return new[]
                        {
                            id.Apply(id => ($"v1/ResourceQuota::{id}",
                                new Core.V1.ResourceQuota(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Secret":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Secret::{id}",
                                new Core.V1.Secret(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/Service":
                        return new[]
                        {
                            id.Apply(id => ($"v1/Service::{id}",
                                new Core.V1.Service(id, obj!, opts) as KubernetesResource))
                        };
                    case "v1/ServiceAccount":
                        return new[]
                        {
                            id.Apply(id => ($"v1/ServiceAccount::{id}",
                                new Core.V1.ServiceAccount(id, obj!, opts) as KubernetesResource))
                        };
                    case "discovery.k8s.io/v1/EndpointSlice":
                        return new[]
                        {
                            id.Apply(id => ($"discovery.k8s.io/v1/EndpointSlice::{id}",
                                new Discovery.V1.EndpointSlice(id, obj!, opts) as KubernetesResource))
                        };
                    case "discovery.k8s.io/v1beta1/EndpointSlice":
                        return new[]
                        {
                            id.Apply(id => ($"discovery.k8s.io/v1beta1/EndpointSlice::{id}",
                                new Discovery.V1Beta1.EndpointSlice(id, obj!, opts) as KubernetesResource))
                        };
                    case "events.k8s.io/v1/Event":
                        return new[]
                        {
                            id.Apply(id => ($"events.k8s.io/v1/Event::{id}",
                                new Events.V1.Event(id, obj!, opts) as KubernetesResource))
                        };
                    case "events.k8s.io/v1beta1/Event":
                        return new[]
                        {
                            id.Apply(id => ($"events.k8s.io/v1beta1/Event::{id}",
                                new Events.V1Beta1.Event(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/DaemonSet":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/DaemonSet::{id}",
                                new Extensions.V1Beta1.DaemonSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/Deployment":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/Deployment::{id}",
                                new Extensions.V1Beta1.Deployment(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/Ingress":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/Ingress::{id}",
                                new Extensions.V1Beta1.Ingress(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/NetworkPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/NetworkPolicy::{id}",
                                new Extensions.V1Beta1.NetworkPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/PodSecurityPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/PodSecurityPolicy::{id}",
                                new Extensions.V1Beta1.PodSecurityPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "extensions/v1beta1/ReplicaSet":
                        return new[]
                        {
                            id.Apply(id => ($"extensions/v1beta1/ReplicaSet::{id}",
                                new Extensions.V1Beta1.ReplicaSet(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1/FlowSchema":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1/FlowSchema::{id}",
                                new FlowControl.V1.FlowSchema(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1/PriorityLevelConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1/PriorityLevelConfiguration::{id}",
                                new FlowControl.V1.PriorityLevelConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchema":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1alpha1/FlowSchema::{id}",
                                new FlowControl.V1Alpha1.FlowSchema(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1alpha1/PriorityLevelConfiguration::{id}",
                                new FlowControl.V1Alpha1.PriorityLevelConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1beta1/FlowSchema":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1beta1/FlowSchema::{id}",
                                new FlowControl.V1Beta1.FlowSchema(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1beta1/PriorityLevelConfiguration::{id}",
                                new FlowControl.V1Beta1.PriorityLevelConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1beta2/FlowSchema":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1beta2/FlowSchema::{id}",
                                new FlowControl.V1Beta2.FlowSchema(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1beta2/PriorityLevelConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1beta2/PriorityLevelConfiguration::{id}",
                                new FlowControl.V1Beta2.PriorityLevelConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1beta3/FlowSchema":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1beta3/FlowSchema::{id}",
                                new FlowControl.V1Beta3.FlowSchema(id, obj!, opts) as KubernetesResource))
                        };
                    case "flowcontrol.apiserver.k8s.io/v1beta3/PriorityLevelConfiguration":
                        return new[]
                        {
                            id.Apply(id => ($"flowcontrol.apiserver.k8s.io/v1beta3/PriorityLevelConfiguration::{id}",
                                new FlowControl.V1Beta3.PriorityLevelConfiguration(id, obj!, opts) as KubernetesResource))
                        };
                    case "meta/v1/Status":
                        return new[]
                        {
                            id.Apply(id => ($"meta/v1/Status::{id}",
                                new Meta.V1.Status(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1/Ingress":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1/Ingress::{id}",
                                new Networking.V1.Ingress(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1/IngressClass":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1/IngressClass::{id}",
                                new Networking.V1.IngressClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1/NetworkPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1/NetworkPolicy::{id}",
                                new Networking.V1.NetworkPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1alpha1/ClusterCIDR":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1alpha1/ClusterCIDR::{id}",
                                new Networking.V1Alpha1.ClusterCIDR(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1alpha1/IPAddress":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1alpha1/IPAddress::{id}",
                                new Networking.V1Alpha1.IPAddress(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1alpha1/ServiceCIDR":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1alpha1/ServiceCIDR::{id}",
                                new Networking.V1Alpha1.ServiceCIDR(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1beta1/Ingress":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1beta1/Ingress::{id}",
                                new Networking.V1Beta1.Ingress(id, obj!, opts) as KubernetesResource))
                        };
                    case "networking.k8s.io/v1beta1/IngressClass":
                        return new[]
                        {
                            id.Apply(id => ($"networking.k8s.io/v1beta1/IngressClass::{id}",
                                new Networking.V1Beta1.IngressClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "node.k8s.io/v1/RuntimeClass":
                        return new[]
                        {
                            id.Apply(id => ($"node.k8s.io/v1/RuntimeClass::{id}",
                                new Node.V1.RuntimeClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "node.k8s.io/v1alpha1/RuntimeClass":
                        return new[]
                        {
                            id.Apply(id => ($"node.k8s.io/v1alpha1/RuntimeClass::{id}",
                                new Node.V1Alpha1.RuntimeClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "node.k8s.io/v1beta1/RuntimeClass":
                        return new[]
                        {
                            id.Apply(id => ($"node.k8s.io/v1beta1/RuntimeClass::{id}",
                                new Node.V1Beta1.RuntimeClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "policy/v1/PodDisruptionBudget":
                        return new[]
                        {
                            id.Apply(id => ($"policy/v1/PodDisruptionBudget::{id}",
                                new Policy.V1.PodDisruptionBudget(id, obj!, opts) as KubernetesResource))
                        };
                    case "policy/v1beta1/PodDisruptionBudget":
                        return new[]
                        {
                            id.Apply(id => ($"policy/v1beta1/PodDisruptionBudget::{id}",
                                new Policy.V1Beta1.PodDisruptionBudget(id, obj!, opts) as KubernetesResource))
                        };
                    case "policy/v1beta1/PodSecurityPolicy":
                        return new[]
                        {
                            id.Apply(id => ($"policy/v1beta1/PodSecurityPolicy::{id}",
                                new Policy.V1Beta1.PodSecurityPolicy(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1/ClusterRole":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1/ClusterRole::{id}",
                                new Rbac.V1.ClusterRole(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1/ClusterRoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1/ClusterRoleBinding::{id}",
                                new Rbac.V1.ClusterRoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1/Role":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1/Role::{id}",
                                new Rbac.V1.Role(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1/RoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1/RoleBinding::{id}",
                                new Rbac.V1.RoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1alpha1/ClusterRole":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1alpha1/ClusterRole::{id}",
                                new Rbac.V1Alpha1.ClusterRole(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1alpha1/ClusterRoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1alpha1/ClusterRoleBinding::{id}",
                                new Rbac.V1Alpha1.ClusterRoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1alpha1/Role":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1alpha1/Role::{id}",
                                new Rbac.V1Alpha1.Role(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1alpha1/RoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1alpha1/RoleBinding::{id}",
                                new Rbac.V1Alpha1.RoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1beta1/ClusterRole":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1beta1/ClusterRole::{id}",
                                new Rbac.V1Beta1.ClusterRole(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1beta1/ClusterRoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1beta1/ClusterRoleBinding::{id}",
                                new Rbac.V1Beta1.ClusterRoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1beta1/Role":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1beta1/Role::{id}",
                                new Rbac.V1Beta1.Role(id, obj!, opts) as KubernetesResource))
                        };
                    case "rbac.authorization.k8s.io/v1beta1/RoleBinding":
                        return new[]
                        {
                            id.Apply(id => ($"rbac.authorization.k8s.io/v1beta1/RoleBinding::{id}",
                                new Rbac.V1Beta1.RoleBinding(id, obj!, opts) as KubernetesResource))
                        };
                    case "resource.k8s.io/v1alpha1/PodScheduling":
                        return new[]
                        {
                            id.Apply(id => ($"resource.k8s.io/v1alpha1/PodScheduling::{id}",
                                new Resource.V1Alpha1.PodScheduling(id, obj!, opts) as KubernetesResource))
                        };
                    case "resource.k8s.io/v1alpha1/ResourceClaim":
                        return new[]
                        {
                            id.Apply(id => ($"resource.k8s.io/v1alpha1/ResourceClaim::{id}",
                                new Resource.V1Alpha1.ResourceClaim(id, obj!, opts) as KubernetesResource))
                        };
                    case "resource.k8s.io/v1alpha1/ResourceClaimTemplate":
                        return new[]
                        {
                            id.Apply(id => ($"resource.k8s.io/v1alpha1/ResourceClaimTemplate::{id}",
                                new Resource.V1Alpha1.ResourceClaimTemplate(id, obj!, opts) as KubernetesResource))
                        };
                    case "resource.k8s.io/v1alpha1/ResourceClass":
                        return new[]
                        {
                            id.Apply(id => ($"resource.k8s.io/v1alpha1/ResourceClass::{id}",
                                new Resource.V1Alpha1.ResourceClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "resource.k8s.io/v1alpha2/PodSchedulingContext":
                        return new[]
                        {
                            id.Apply(id => ($"resource.k8s.io/v1alpha2/PodSchedulingContext::{id}",
                                new Resource.V1Alpha2.PodSchedulingContext(id, obj!, opts) as KubernetesResource))
                        };
                    case "resource.k8s.io/v1alpha2/ResourceClaim":
                        return new[]
                        {
                            id.Apply(id => ($"resource.k8s.io/v1alpha2/ResourceClaim::{id}",
                                new Resource.V1Alpha2.ResourceClaim(id, obj!, opts) as KubernetesResource))
                        };
                    case "resource.k8s.io/v1alpha2/ResourceClaimTemplate":
                        return new[]
                        {
                            id.Apply(id => ($"resource.k8s.io/v1alpha2/ResourceClaimTemplate::{id}",
                                new Resource.V1Alpha2.ResourceClaimTemplate(id, obj!, opts) as KubernetesResource))
                        };
                    case "resource.k8s.io/v1alpha2/ResourceClass":
                        return new[]
                        {
                            id.Apply(id => ($"resource.k8s.io/v1alpha2/ResourceClass::{id}",
                                new Resource.V1Alpha2.ResourceClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "scheduling.k8s.io/v1/PriorityClass":
                        return new[]
                        {
                            id.Apply(id => ($"scheduling.k8s.io/v1/PriorityClass::{id}",
                                new Scheduling.V1.PriorityClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "scheduling.k8s.io/v1alpha1/PriorityClass":
                        return new[]
                        {
                            id.Apply(id => ($"scheduling.k8s.io/v1alpha1/PriorityClass::{id}",
                                new Scheduling.V1Alpha1.PriorityClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "scheduling.k8s.io/v1beta1/PriorityClass":
                        return new[]
                        {
                            id.Apply(id => ($"scheduling.k8s.io/v1beta1/PriorityClass::{id}",
                                new Scheduling.V1Beta1.PriorityClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "settings.k8s.io/v1alpha1/PodPreset":
                        return new[]
                        {
                            id.Apply(id => ($"settings.k8s.io/v1alpha1/PodPreset::{id}",
                                new Settings.V1Alpha1.PodPreset(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1/CSIDriver":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1/CSIDriver::{id}",
                                new Storage.V1.CSIDriver(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1/CSINode":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1/CSINode::{id}",
                                new Storage.V1.CSINode(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1/CSIStorageCapacity":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1/CSIStorageCapacity::{id}",
                                new Storage.V1.CSIStorageCapacity(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1/StorageClass":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1/StorageClass::{id}",
                                new Storage.V1.StorageClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1/VolumeAttachment":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1/VolumeAttachment::{id}",
                                new Storage.V1.VolumeAttachment(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1alpha1/VolumeAttachment":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1alpha1/VolumeAttachment::{id}",
                                new Storage.V1Alpha1.VolumeAttachment(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1alpha1/VolumeAttributesClass":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1alpha1/VolumeAttributesClass::{id}",
                                new Storage.V1Alpha1.VolumeAttributesClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1beta1/CSIDriver":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1beta1/CSIDriver::{id}",
                                new Storage.V1Beta1.CSIDriver(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1beta1/CSINode":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1beta1/CSINode::{id}",
                                new Storage.V1Beta1.CSINode(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1beta1/CSIStorageCapacity":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1beta1/CSIStorageCapacity::{id}",
                                new Storage.V1Beta1.CSIStorageCapacity(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1beta1/StorageClass":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1beta1/StorageClass::{id}",
                                new Storage.V1Beta1.StorageClass(id, obj!, opts) as KubernetesResource))
                        };
                    case "storage.k8s.io/v1beta1/VolumeAttachment":
                        return new[]
                        {
                            id.Apply(id => ($"storage.k8s.io/v1beta1/VolumeAttachment::{id}",
                                new Storage.V1Beta1.VolumeAttachment(id, obj!, opts) as KubernetesResource))
                        };
                default:
                    return new[]
                    {
                        id.Apply(id => ($"{apiVersion}/{kind}::{id}",
                            new ApiExtensions.CustomResource(id, obj!, opts) as KubernetesResource))
                    };
            }
        }
    }

    internal class ParseArgs
    {
        /// <summary>
        /// Objects representing Kubernetes resources.
        /// </summary>
        public InputList<ImmutableDictionary<string, object>> Objs { get; set; } = null!;

        private List<TransformationAction>? _transformations;

        /// <summary>
        /// An optional list of transformations to apply to Kubernetes resource definitions before registering
        /// with engine.
        /// </summary>
        public List<TransformationAction> Transformations
        {
            get => _transformations ??= new List<TransformationAction>();
            set => _transformations = value;
        }

        /// <summary>
        /// An optional prefix for the auto-generated resource names.
        /// Example: A resource created with resourcePrefix="foo" would produce a resource named "foo-resourceName".
        /// </summary>
        public string? ResourcePrefix { get; set; }
    }
}
