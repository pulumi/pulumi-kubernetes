// *** WARNING: this file was generated by the Pulumi Kubernetes client generation tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Types.Inputs.AdmissionRegistration
{
  namespace V1
  {
    /// <summary>
    /// MutatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    public class MutatingWebhookArgs : Pulumi.ResourceArgs
    {
        [Input("admissionReviewVersions", required: true)]
        private InputList<string>? _admissionReviewVersions;

        /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy.
        /// </summary>
        public InputList<string> AdmissionReviewVersions
        {
            get => _admissionReviewVersions ?? (_admissionReviewVersions = new InputList<string>());
            set => _admissionReviewVersions = value;
        }

        /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
        [Input("clientConfig", required: true)]
        public Input<AdmissionRegistration.V1.WebhookClientConfigArgs> ClientConfig { get; set; } = null!;

        /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// SideEffects states whether this webhook has side effects. Acceptable values are: None,
        /// NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks
        /// with side effects MUST implement a reconciliation system, since a request may be
        /// rejected by a future step in the admission change and the side effects therefore need to
        /// be undone. Requests with the dryRun attribute will be auto-rejected if they match a
        /// webhook with sideEffects == Unknown or Some.
        /// </summary>
        [Input("sideEffects", required: true)]
        public Input<string> SideEffects { get; set; } = null!;

        /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Fail.
        /// </summary>
        [Input("failurePolicy")]
        public Input<string>? FailurePolicy { get; set; }

        /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Equivalent"
        /// </summary>
        [Input("matchPolicy")]
        public Input<string>? MatchPolicy { get; set; }

        /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
        [Input("namespaceSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? NamespaceSelector { get; set; }

        /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
        [Input("objectSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? ObjectSelector { get; set; }

        /// <summary>
        /// reinvocationPolicy indicates whether this webhook should be called multiple times as
        /// part of a single admission evaluation. Allowed values are "Never" and "IfNeeded".
        /// 
        /// Never: the webhook will not be called more than once in a single admission evaluation.
        /// 
        /// IfNeeded: the webhook will be called at least one additional time as part of the
        /// admission evaluation if the object being admitted is modified by other admission plugins
        /// after the initial webhook call. Webhooks that specify this option *must* be idempotent,
        /// able to process objects they previously admitted. Note: * the number of additional
        /// invocations is not guaranteed to be exactly one. * if additional invocations result in
        /// further modifications to the object, webhooks are not guaranteed to be invoked again. *
        /// webhooks that use this option may be reordered to minimize the number of additional
        /// invocations. * to validate an object after all mutations are guaranteed complete, use a
        /// validating admission webhook instead.
        /// 
        /// Defaults to "Never".
        /// </summary>
        [Input("reinvocationPolicy")]
        public Input<string>? ReinvocationPolicy { get; set; }

        [Input("rules")]
        private InputList<AdmissionRegistration.V1.RuleWithOperationsArgs>? _rules;

        /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
        public InputList<AdmissionRegistration.V1.RuleWithOperationsArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<AdmissionRegistration.V1.RuleWithOperationsArgs>());
            set => _rules = value;
        }

        /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 10 seconds.
        /// </summary>
        [Input("timeoutSeconds")]
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// MutatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and may change the object.
    /// </summary>
    public class MutatingWebhookConfigurationArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("webhooks")]
        private InputList<AdmissionRegistration.V1.MutatingWebhookArgs>? _webhooks;

        /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
        public InputList<AdmissionRegistration.V1.MutatingWebhookArgs> Webhooks
        {
            get => _webhooks ?? (_webhooks = new InputList<AdmissionRegistration.V1.MutatingWebhookArgs>());
            set => _webhooks = value;
        }

    }

    /// <summary>
    /// MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
    /// </summary>
    public class MutatingWebhookConfigurationListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<AdmissionRegistration.V1.MutatingWebhookConfigurationArgs>? _items;

        /// <summary>
        /// List of MutatingWebhookConfiguration.
        /// </summary>
        public InputList<AdmissionRegistration.V1.MutatingWebhookConfigurationArgs> Items
        {
            get => _items ?? (_items = new InputList<AdmissionRegistration.V1.MutatingWebhookConfigurationArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure
    /// that all the tuple expansions are valid.
    /// </summary>
    public class RuleWithOperationsArgs : Pulumi.ResourceArgs
    {
        [Input("apiGroups")]
        private InputList<string>? _apiGroups;

        /// <summary>
        /// APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
        public InputList<string> ApiGroups
        {
            get => _apiGroups ?? (_apiGroups = new InputList<string>());
            set => _apiGroups = value;
        }

        [Input("apiVersions")]
        private InputList<string>? _apiVersions;

        /// <summary>
        /// APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
        public InputList<string> ApiVersions
        {
            get => _apiVersions ?? (_apiVersions = new InputList<string>());
            set => _apiVersions = value;
        }

        [Input("operations")]
        private InputList<string>? _operations;

        /// <summary>
        /// Operations is the operations the admission hook cares about - CREATE, UPDATE, or * for
        /// all operations. If '*' is present, the length of the slice must be one. Required.
        /// </summary>
        public InputList<string> Operations
        {
            get => _operations ?? (_operations = new InputList<string>());
            set => _operations = value;
        }

        [Input("resources")]
        private InputList<string>? _resources;

        /// <summary>
        /// Resources is a list of resources this rule applies to.
        /// 
        /// For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means
        /// all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale'
        /// means all scale subresources. '*/*' means all resources and their subresources.
        /// 
        /// If wildcard is present, the validation rule will ensure resources do not overlap with
        /// each other.
        /// 
        /// Depending on the enclosing object, subresources might not be allowed. Required.
        /// </summary>
        public InputList<string> Resources
        {
            get => _resources ?? (_resources = new InputList<string>());
            set => _resources = value;
        }

        /// <summary>
        /// scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and
        /// "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace
        /// API objects are cluster-scoped. "Namespaced" means that only namespaced resources will
        /// match this rule. "*" means that there are no scope restrictions. Subresources match the
        /// scope of their parent resource. Default is "*".
        /// </summary>
        [Input("scope")]
        public Input<string>? Scope { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    public class ServiceReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// `name` is the name of the service. Required
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// `namespace` is the namespace of the service. Required
        /// </summary>
        [Input("namespace", required: true)]
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// `path` is an optional URL path which will be sent in any request to this service.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// ValidatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    public class ValidatingWebhookArgs : Pulumi.ResourceArgs
    {
        [Input("admissionReviewVersions", required: true)]
        private InputList<string>? _admissionReviewVersions;

        /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy.
        /// </summary>
        public InputList<string> AdmissionReviewVersions
        {
            get => _admissionReviewVersions ?? (_admissionReviewVersions = new InputList<string>());
            set => _admissionReviewVersions = value;
        }

        /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
        [Input("clientConfig", required: true)]
        public Input<AdmissionRegistration.V1.WebhookClientConfigArgs> ClientConfig { get; set; } = null!;

        /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// SideEffects states whether this webhook has side effects. Acceptable values are: None,
        /// NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks
        /// with side effects MUST implement a reconciliation system, since a request may be
        /// rejected by a future step in the admission change and the side effects therefore need to
        /// be undone. Requests with the dryRun attribute will be auto-rejected if they match a
        /// webhook with sideEffects == Unknown or Some.
        /// </summary>
        [Input("sideEffects", required: true)]
        public Input<string> SideEffects { get; set; } = null!;

        /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Fail.
        /// </summary>
        [Input("failurePolicy")]
        public Input<string>? FailurePolicy { get; set; }

        /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Equivalent"
        /// </summary>
        [Input("matchPolicy")]
        public Input<string>? MatchPolicy { get; set; }

        /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
        [Input("namespaceSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? NamespaceSelector { get; set; }

        /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
        [Input("objectSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? ObjectSelector { get; set; }

        [Input("rules")]
        private InputList<AdmissionRegistration.V1.RuleWithOperationsArgs>? _rules;

        /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
        public InputList<AdmissionRegistration.V1.RuleWithOperationsArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<AdmissionRegistration.V1.RuleWithOperationsArgs>());
            set => _rules = value;
        }

        /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 10 seconds.
        /// </summary>
        [Input("timeoutSeconds")]
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// ValidatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and object without changing it.
    /// </summary>
    public class ValidatingWebhookConfigurationArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("webhooks")]
        private InputList<AdmissionRegistration.V1.ValidatingWebhookArgs>? _webhooks;

        /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
        public InputList<AdmissionRegistration.V1.ValidatingWebhookArgs> Webhooks
        {
            get => _webhooks ?? (_webhooks = new InputList<AdmissionRegistration.V1.ValidatingWebhookArgs>());
            set => _webhooks = value;
        }

    }

    /// <summary>
    /// ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
    /// </summary>
    public class ValidatingWebhookConfigurationListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<AdmissionRegistration.V1.ValidatingWebhookConfigurationArgs>? _items;

        /// <summary>
        /// List of ValidatingWebhookConfiguration.
        /// </summary>
        public InputList<AdmissionRegistration.V1.ValidatingWebhookConfigurationArgs> Items
        {
            get => _items ?? (_items = new InputList<AdmissionRegistration.V1.ValidatingWebhookConfigurationArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook
    /// </summary>
    public class WebhookClientConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's
        /// server certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        [Input("caBundle")]
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// `service` is a reference to the service for this webhook. Either `service` or `url` must
        /// be specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        [Input("service")]
        public Input<AdmissionRegistration.V1.ServiceReferenceArgs>? Service { get; set; }

        /// <summary>
        /// `url` gives the location of the webhook, in standard URL form
        /// (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        [Input("url")]
        public Input<string>? Url { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// MutatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    public class MutatingWebhookArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
        [Input("clientConfig", required: true)]
        public Input<AdmissionRegistration.V1Beta1.WebhookClientConfigArgs> ClientConfig { get; set; } = null!;

        /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("admissionReviewVersions")]
        private InputList<string>? _admissionReviewVersions;

        /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy. Default to `['v1beta1']`.
        /// </summary>
        public InputList<string> AdmissionReviewVersions
        {
            get => _admissionReviewVersions ?? (_admissionReviewVersions = new InputList<string>());
            set => _admissionReviewVersions = value;
        }

        /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Ignore.
        /// </summary>
        [Input("failurePolicy")]
        public Input<string>? FailurePolicy { get; set; }

        /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Exact"
        /// </summary>
        [Input("matchPolicy")]
        public Input<string>? MatchPolicy { get; set; }

        /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
        [Input("namespaceSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? NamespaceSelector { get; set; }

        /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
        [Input("objectSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? ObjectSelector { get; set; }

        /// <summary>
        /// reinvocationPolicy indicates whether this webhook should be called multiple times as
        /// part of a single admission evaluation. Allowed values are "Never" and "IfNeeded".
        /// 
        /// Never: the webhook will not be called more than once in a single admission evaluation.
        /// 
        /// IfNeeded: the webhook will be called at least one additional time as part of the
        /// admission evaluation if the object being admitted is modified by other admission plugins
        /// after the initial webhook call. Webhooks that specify this option *must* be idempotent,
        /// able to process objects they previously admitted. Note: * the number of additional
        /// invocations is not guaranteed to be exactly one. * if additional invocations result in
        /// further modifications to the object, webhooks are not guaranteed to be invoked again. *
        /// webhooks that use this option may be reordered to minimize the number of additional
        /// invocations. * to validate an object after all mutations are guaranteed complete, use a
        /// validating admission webhook instead.
        /// 
        /// Defaults to "Never".
        /// </summary>
        [Input("reinvocationPolicy")]
        public Input<string>? ReinvocationPolicy { get; set; }

        [Input("rules")]
        private InputList<AdmissionRegistration.V1Beta1.RuleWithOperationsArgs>? _rules;

        /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
        public InputList<AdmissionRegistration.V1Beta1.RuleWithOperationsArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<AdmissionRegistration.V1Beta1.RuleWithOperationsArgs>());
            set => _rules = value;
        }

        /// <summary>
        /// SideEffects states whether this webhookk has side effects. Acceptable values are:
        /// Unknown, None, Some, NoneOnDryRun Webhooks with side effects MUST implement a
        /// reconciliation system, since a request may be rejected by a future step in the admission
        /// change and the side effects therefore need to be undone. Requests with the dryRun
        /// attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or
        /// Some. Defaults to Unknown.
        /// </summary>
        [Input("sideEffects")]
        public Input<string>? SideEffects { get; set; }

        /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 30 seconds.
        /// </summary>
        [Input("timeoutSeconds")]
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// MutatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and may change the object. Deprecated in v1.16, planned for removal in
    /// v1.19. Use admissionregistration.k8s.io/v1 MutatingWebhookConfiguration instead.
    /// </summary>
    public class MutatingWebhookConfigurationArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("webhooks")]
        private InputList<AdmissionRegistration.V1Beta1.MutatingWebhookArgs>? _webhooks;

        /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
        public InputList<AdmissionRegistration.V1Beta1.MutatingWebhookArgs> Webhooks
        {
            get => _webhooks ?? (_webhooks = new InputList<AdmissionRegistration.V1Beta1.MutatingWebhookArgs>());
            set => _webhooks = value;
        }

    }

    /// <summary>
    /// MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
    /// </summary>
    public class MutatingWebhookConfigurationListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<AdmissionRegistration.V1Beta1.MutatingWebhookConfigurationArgs>? _items;

        /// <summary>
        /// List of MutatingWebhookConfiguration.
        /// </summary>
        public InputList<AdmissionRegistration.V1Beta1.MutatingWebhookConfigurationArgs> Items
        {
            get => _items ?? (_items = new InputList<AdmissionRegistration.V1Beta1.MutatingWebhookConfigurationArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure
    /// that all the tuple expansions are valid.
    /// </summary>
    public class RuleWithOperationsArgs : Pulumi.ResourceArgs
    {
        [Input("apiGroups")]
        private InputList<string>? _apiGroups;

        /// <summary>
        /// APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
        public InputList<string> ApiGroups
        {
            get => _apiGroups ?? (_apiGroups = new InputList<string>());
            set => _apiGroups = value;
        }

        [Input("apiVersions")]
        private InputList<string>? _apiVersions;

        /// <summary>
        /// APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
        public InputList<string> ApiVersions
        {
            get => _apiVersions ?? (_apiVersions = new InputList<string>());
            set => _apiVersions = value;
        }

        [Input("operations")]
        private InputList<string>? _operations;

        /// <summary>
        /// Operations is the operations the admission hook cares about - CREATE, UPDATE, or * for
        /// all operations. If '*' is present, the length of the slice must be one. Required.
        /// </summary>
        public InputList<string> Operations
        {
            get => _operations ?? (_operations = new InputList<string>());
            set => _operations = value;
        }

        [Input("resources")]
        private InputList<string>? _resources;

        /// <summary>
        /// Resources is a list of resources this rule applies to.
        /// 
        /// For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means
        /// all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale'
        /// means all scale subresources. '*/*' means all resources and their subresources.
        /// 
        /// If wildcard is present, the validation rule will ensure resources do not overlap with
        /// each other.
        /// 
        /// Depending on the enclosing object, subresources might not be allowed. Required.
        /// </summary>
        public InputList<string> Resources
        {
            get => _resources ?? (_resources = new InputList<string>());
            set => _resources = value;
        }

        /// <summary>
        /// scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and
        /// "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace
        /// API objects are cluster-scoped. "Namespaced" means that only namespaced resources will
        /// match this rule. "*" means that there are no scope restrictions. Subresources match the
        /// scope of their parent resource. Default is "*".
        /// </summary>
        [Input("scope")]
        public Input<string>? Scope { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    public class ServiceReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// `name` is the name of the service. Required
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// `namespace` is the namespace of the service. Required
        /// </summary>
        [Input("namespace", required: true)]
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// `path` is an optional URL path which will be sent in any request to this service.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// ValidatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    public class ValidatingWebhookArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
        [Input("clientConfig", required: true)]
        public Input<AdmissionRegistration.V1Beta1.WebhookClientConfigArgs> ClientConfig { get; set; } = null!;

        /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("admissionReviewVersions")]
        private InputList<string>? _admissionReviewVersions;

        /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy. Default to `['v1beta1']`.
        /// </summary>
        public InputList<string> AdmissionReviewVersions
        {
            get => _admissionReviewVersions ?? (_admissionReviewVersions = new InputList<string>());
            set => _admissionReviewVersions = value;
        }

        /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Ignore.
        /// </summary>
        [Input("failurePolicy")]
        public Input<string>? FailurePolicy { get; set; }

        /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Exact"
        /// </summary>
        [Input("matchPolicy")]
        public Input<string>? MatchPolicy { get; set; }

        /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
        [Input("namespaceSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? NamespaceSelector { get; set; }

        /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
        [Input("objectSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? ObjectSelector { get; set; }

        [Input("rules")]
        private InputList<AdmissionRegistration.V1Beta1.RuleWithOperationsArgs>? _rules;

        /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
        public InputList<AdmissionRegistration.V1Beta1.RuleWithOperationsArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<AdmissionRegistration.V1Beta1.RuleWithOperationsArgs>());
            set => _rules = value;
        }

        /// <summary>
        /// SideEffects states whether this webhookk has side effects. Acceptable values are:
        /// Unknown, None, Some, NoneOnDryRun Webhooks with side effects MUST implement a
        /// reconciliation system, since a request may be rejected by a future step in the admission
        /// change and the side effects therefore need to be undone. Requests with the dryRun
        /// attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or
        /// Some. Defaults to Unknown.
        /// </summary>
        [Input("sideEffects")]
        public Input<string>? SideEffects { get; set; }

        /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 30 seconds.
        /// </summary>
        [Input("timeoutSeconds")]
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// ValidatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and object without changing it. Deprecated in v1.16, planned for removal in
    /// v1.19. Use admissionregistration.k8s.io/v1 ValidatingWebhookConfiguration instead.
    /// </summary>
    public class ValidatingWebhookConfigurationArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("webhooks")]
        private InputList<AdmissionRegistration.V1Beta1.ValidatingWebhookArgs>? _webhooks;

        /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
        public InputList<AdmissionRegistration.V1Beta1.ValidatingWebhookArgs> Webhooks
        {
            get => _webhooks ?? (_webhooks = new InputList<AdmissionRegistration.V1Beta1.ValidatingWebhookArgs>());
            set => _webhooks = value;
        }

    }

    /// <summary>
    /// ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
    /// </summary>
    public class ValidatingWebhookConfigurationListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<AdmissionRegistration.V1Beta1.ValidatingWebhookConfigurationArgs>? _items;

        /// <summary>
        /// List of ValidatingWebhookConfiguration.
        /// </summary>
        public InputList<AdmissionRegistration.V1Beta1.ValidatingWebhookConfigurationArgs> Items
        {
            get => _items ?? (_items = new InputList<AdmissionRegistration.V1Beta1.ValidatingWebhookConfigurationArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook
    /// </summary>
    public class WebhookClientConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's
        /// server certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        [Input("caBundle")]
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// `service` is a reference to the service for this webhook. Either `service` or `url` must
        /// be specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        [Input("service")]
        public Input<AdmissionRegistration.V1Beta1.ServiceReferenceArgs>? Service { get; set; }

        /// <summary>
        /// `url` gives the location of the webhook, in standard URL form
        /// (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        [Input("url")]
        public Input<string>? Url { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.ApiExtensions
{
  namespace V1
  {
    /// <summary>
    /// CustomResourceColumnDefinition specifies a column for server side printing.
    /// </summary>
    public class CustomResourceColumnDefinitionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against
        /// each custom resource to produce the value for this column.
        /// </summary>
        [Input("jsonPath", required: true)]
        public Input<string> JsonPath { get; set; } = null!;

        /// <summary>
        /// name is a human readable name for the column.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// type is an OpenAPI type definition for this column. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// description is a human readable description of this column.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// format is an optional OpenAPI type definition for this column. The 'name' format is
        /// applied to the primary identifier column to assist in clients identifying column is the
        /// resource name. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
        [Input("format")]
        public Input<string>? Format { get; set; }

        /// <summary>
        /// priority is an integer defining the relative importance of this column compared to
        /// others. Lower numbers are considered higher priority. Columns that may be omitted in
        /// limited space scenarios should be given a priority greater than 0.
        /// </summary>
        [Input("priority")]
        public Input<int>? Priority { get; set; }

    }

    /// <summary>
    /// CustomResourceConversion describes how to convert different versions of a CR.
    /// </summary>
    public class CustomResourceConversionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// strategy specifies how custom resources are converted between versions. Allowed values
        /// are: - `None`: The converter only change the apiVersion and would not touch any other
        /// field in the custom resource. - `Webhook`: API Server will call to an external webhook
        /// to do the conversion. Additional information
        ///   is needed for this option. This requires spec.preserveUnknownFields to be false, and
        /// spec.conversion.webhook to be set.
        /// </summary>
        [Input("strategy", required: true)]
        public Input<string> Strategy { get; set; } = null!;

        /// <summary>
        /// webhook describes how to call the conversion webhook. Required when `strategy` is set to
        /// `Webhook`.
        /// </summary>
        [Input("webhook")]
        public Input<ApiExtensions.V1.WebhookConversionArgs>? Webhook { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinition represents a resource that should be exposed on the API server.
    /// Its name MUST be in the format &amp;lt;.spec.name&amp;gt;.&amp;lt;.spec.group&amp;gt;.
    /// </summary>
    public class CustomResourceDefinitionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// spec describes how the user wants the resources to appear
        /// </summary>
        [Input("spec", required: true)]
        public Input<ApiExtensions.V1.CustomResourceDefinitionSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionCondition contains details for the current condition of this pod.
    /// </summary>
    public class CustomResourceDefinitionConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// type is the type of the condition. Types include Established, NamesAccepted and
        /// Terminating.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// lastTransitionTime last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// message is a human-readable message indicating details about last transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// reason is a unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
    /// </summary>
    public class CustomResourceDefinitionListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<ApiExtensions.V1.CustomResourceDefinitionArgs>? _items;

        /// <summary>
        /// items list individual CustomResourceDefinition objects
        /// </summary>
        public InputList<ApiExtensions.V1.CustomResourceDefinitionArgs> Items
        {
            get => _items ?? (_items = new InputList<ApiExtensions.V1.CustomResourceDefinitionArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition
    /// </summary>
    public class CustomResourceDefinitionNamesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// kind is the serialized kind of the resource. It is normally CamelCase and singular.
        /// Custom resource instances will use this value as the `kind` attribute in API calls.
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// plural is the plural name of the resource to serve. The custom resources are served
        /// under `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/.../&amp;lt;plural&amp;gt;`.
        /// Must match the name of the CustomResourceDefinition (in the form
        /// `&amp;lt;names.plural&amp;gt;.&amp;lt;group&amp;gt;`). Must be all lowercase.
        /// </summary>
        [Input("plural", required: true)]
        public Input<string> Plural { get; set; } = null!;

        [Input("categories")]
        private InputList<string>? _categories;

        /// <summary>
        /// categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
        /// This is published in API discovery documents, and used by clients to support invocations
        /// like `kubectl get all`.
        /// </summary>
        public InputList<string> Categories
        {
            get => _categories ?? (_categories = new InputList<string>());
            set => _categories = value;
        }

        /// <summary>
        /// listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
        /// </summary>
        [Input("listKind")]
        public Input<string>? ListKind { get; set; }

        [Input("shortNames")]
        private InputList<string>? _shortNames;

        /// <summary>
        /// shortNames are short names for the resource, exposed in API discovery documents, and
        /// used by clients to support invocations like `kubectl get &amp;lt;shortname&amp;gt;`. It
        /// must be all lowercase.
        /// </summary>
        public InputList<string> ShortNames
        {
            get => _shortNames ?? (_shortNames = new InputList<string>());
            set => _shortNames = value;
        }

        /// <summary>
        /// singular is the singular name of the resource. It must be all lowercase. Defaults to
        /// lowercased `kind`.
        /// </summary>
        [Input("singular")]
        public Input<string>? Singular { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionSpec describes how a user wants their resource to appear
    /// </summary>
    public class CustomResourceDefinitionSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// group is the API group of the defined custom resource. The custom resources are served
        /// under `/apis/&amp;lt;group&amp;gt;/...`. Must match the name of the
        /// CustomResourceDefinition (in the form
        /// `&amp;lt;names.plural&amp;gt;.&amp;lt;group&amp;gt;`).
        /// </summary>
        [Input("group", required: true)]
        public Input<string> Group { get; set; } = null!;

        /// <summary>
        /// names specify the resource and kind names for the custom resource.
        /// </summary>
        [Input("names", required: true)]
        public Input<ApiExtensions.V1.CustomResourceDefinitionNamesArgs> Names { get; set; } = null!;

        /// <summary>
        /// scope indicates whether the defined custom resource is cluster- or namespace-scoped.
        /// Allowed values are `Cluster` and `Namespaced`. Default is `Namespaced`.
        /// </summary>
        [Input("scope", required: true)]
        public Input<string> Scope { get; set; } = null!;

        [Input("versions", required: true)]
        private InputList<ApiExtensions.V1.CustomResourceDefinitionVersionArgs>? _versions;

        /// <summary>
        /// versions is the list of all API versions of the defined custom resource. Version names
        /// are used to compute the order in which served versions are listed in API discovery. If
        /// the version string is "kube-like", it will sort above non "kube-like" version strings,
        /// which are ordered lexicographically. "Kube-like" versions start with a "v", then are
        /// followed by a number (the major version), then optionally the string "alpha" or "beta"
        /// and another number (the minor version). These are sorted first by GA &amp;gt; beta
        /// &amp;gt; alpha (where GA is a version with no suffix such as beta or alpha), and then by
        /// comparing major version, then minor version. An example sorted list of versions: v10,
        /// v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
        /// </summary>
        public InputList<ApiExtensions.V1.CustomResourceDefinitionVersionArgs> Versions
        {
            get => _versions ?? (_versions = new InputList<ApiExtensions.V1.CustomResourceDefinitionVersionArgs>());
            set => _versions = value;
        }

        /// <summary>
        /// conversion defines conversion settings for the CRD.
        /// </summary>
        [Input("conversion")]
        public Input<ApiExtensions.V1.CustomResourceConversionArgs>? Conversion { get; set; }

        /// <summary>
        /// preserveUnknownFields indicates that object fields which are not specified in the
        /// OpenAPI schema should be preserved when persisting to storage. apiVersion, kind,
        /// metadata and known fields inside metadata are always preserved. This field is deprecated
        /// in favor of setting `x-preserve-unknown-fields` to true in
        /// `spec.versions[*].schema.openAPIV3Schema`. See
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields
        /// for details.
        /// </summary>
        [Input("preserveUnknownFields")]
        public Input<bool>? PreserveUnknownFields { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition
    /// </summary>
    public class CustomResourceDefinitionStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// acceptedNames are the names that are actually being used to serve discovery. They may be
        /// different than the names in spec.
        /// </summary>
        [Input("acceptedNames", required: true)]
        public Input<ApiExtensions.V1.CustomResourceDefinitionNamesArgs> AcceptedNames { get; set; } = null!;

        [Input("storedVersions", required: true)]
        private InputList<string>? _storedVersions;

        /// <summary>
        /// storedVersions lists all versions of CustomResources that were ever persisted. Tracking
        /// these versions allows a migration path for stored versions in etcd. The field is mutable
        /// so a migration controller can finish a migration to another version (ensuring no old
        /// objects are left in storage), and then remove the rest of the versions from this list.
        /// Versions may not be removed from `spec.versions` while they exist in this list.
        /// </summary>
        public InputList<string> StoredVersions
        {
            get => _storedVersions ?? (_storedVersions = new InputList<string>());
            set => _storedVersions = value;
        }

        [Input("conditions")]
        private InputList<ApiExtensions.V1.CustomResourceDefinitionConditionArgs>? _conditions;

        /// <summary>
        /// conditions indicate state for particular aspects of a CustomResourceDefinition
        /// </summary>
        public InputList<ApiExtensions.V1.CustomResourceDefinitionConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<ApiExtensions.V1.CustomResourceDefinitionConditionArgs>());
            set => _conditions = value;
        }

    }

    /// <summary>
    /// CustomResourceDefinitionVersion describes a version for CRD.
    /// </summary>
    public class CustomResourceDefinitionVersionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// name is the version name, e.g. “v1”, “v2beta1”, etc. The custom resources are
        /// served under this version at `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/...`
        /// if `served` is true.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// served is a flag enabling/disabling this version from being served via REST APIs
        /// </summary>
        [Input("served", required: true)]
        public Input<bool> Served { get; set; } = null!;

        /// <summary>
        /// storage indicates this version should be used when persisting custom resources to
        /// storage. There must be exactly one version with storage=true.
        /// </summary>
        [Input("storage", required: true)]
        public Input<bool> Storage { get; set; } = null!;

        [Input("additionalPrinterColumns")]
        private InputList<ApiExtensions.V1.CustomResourceColumnDefinitionArgs>? _additionalPrinterColumns;

        /// <summary>
        /// additionalPrinterColumns specifies additional columns returned in Table output. See
        /// https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
        /// for details. If no columns are specified, a single column displaying the age of the
        /// custom resource is used.
        /// </summary>
        public InputList<ApiExtensions.V1.CustomResourceColumnDefinitionArgs> AdditionalPrinterColumns
        {
            get => _additionalPrinterColumns ?? (_additionalPrinterColumns = new InputList<ApiExtensions.V1.CustomResourceColumnDefinitionArgs>());
            set => _additionalPrinterColumns = value;
        }

        /// <summary>
        /// schema describes the schema used for validation, pruning, and defaulting of this version
        /// of the custom resource.
        /// </summary>
        [Input("schema")]
        public Input<ApiExtensions.V1.CustomResourceValidationArgs>? Schema { get; set; }

        /// <summary>
        /// subresources specify what subresources this version of the defined custom resource have.
        /// </summary>
        [Input("subresources")]
        public Input<ApiExtensions.V1.CustomResourceSubresourcesArgs>? Subresources { get; set; }

    }

    /// <summary>
    /// CustomResourceSubresourceScale defines how to serve the scale subresource for
    /// CustomResources.
    /// </summary>
    public class CustomResourceSubresourceScaleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// specReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a
        /// JSON Path under `.spec`. If there is no value under the given path in the custom
        /// resource, the `/scale` subresource will return an error on GET.
        /// </summary>
        [Input("specReplicasPath", required: true)]
        public Input<string> SpecReplicasPath { get; set; } = null!;

        /// <summary>
        /// statusReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status`. If there is no value under the given path in the custom
        /// resource, the `status.replicas` value in the `/scale` subresource will default to 0.
        /// </summary>
        [Input("statusReplicasPath", required: true)]
        public Input<string> StatusReplicasPath { get; set; } = null!;

        /// <summary>
        /// labelSelectorPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status` or `.spec`. Must be set to work with
        /// HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not
        /// a complex selector struct) which contains a serialized label selector in string form.
        /// More info:
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource
        /// If there is no value under the given path in the custom resource, the `status.selector`
        /// value in the `/scale` subresource will default to the empty string.
        /// </summary>
        [Input("labelSelectorPath")]
        public Input<string>? LabelSelectorPath { get; set; }

    }

    /// <summary>
    /// CustomResourceSubresources defines the status and scale subresources for CustomResources.
    /// </summary>
    public class CustomResourceSubresourcesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// scale indicates the custom resource should serve a `/scale` subresource that returns an
        /// `autoscaling/v1` Scale object.
        /// </summary>
        [Input("scale")]
        public Input<ApiExtensions.V1.CustomResourceSubresourceScaleArgs>? Scale { get; set; }

    }

    /// <summary>
    /// CustomResourceValidation is a list of validation methods for CustomResources.
    /// </summary>
    public class CustomResourceValidationArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.
        /// </summary>
        [Input("openAPIV3Schema")]
        public Input<ApiExtensions.V1.JSONSchemaPropsArgs>? OpenAPIV3Schema { get; set; }

    }

    /// <summary>
    /// ExternalDocumentation allows referencing an external resource for extended documentation.
    /// </summary>
    public class ExternalDocumentationArgs : Pulumi.ResourceArgs
    {
        
        [Input("description")]
        public Input<string>? Description { get; set; }

        
        [Input("url")]
        public Input<string>? Url { get; set; }

    }

    /// <summary>
    /// JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
    /// </summary>
    public class JSONSchemaPropsArgs : Pulumi.ResourceArgs
    {
        
        [Input("$ref")]
        public Input<string>? Ref { get; set; }

        
        [Input("$schema")]
        public Input<string>? Schema { get; set; }

        
        [Input("additionalItems")]
        public InputUnion<ApiExtensions.V1.JSONSchemaPropsArgs,bool>? AdditionalItems { get; set; }

        
        [Input("additionalProperties")]
        public InputUnion<ApiExtensions.V1.JSONSchemaPropsArgs,bool>? AdditionalProperties { get; set; }

        [Input("allOf")]
        private InputList<ApiExtensions.V1.JSONSchemaPropsArgs>? _allOf;

        
        public InputList<ApiExtensions.V1.JSONSchemaPropsArgs> AllOf
        {
            get => _allOf ?? (_allOf = new InputList<ApiExtensions.V1.JSONSchemaPropsArgs>());
            set => _allOf = value;
        }

        [Input("anyOf")]
        private InputList<ApiExtensions.V1.JSONSchemaPropsArgs>? _anyOf;

        
        public InputList<ApiExtensions.V1.JSONSchemaPropsArgs> AnyOf
        {
            get => _anyOf ?? (_anyOf = new InputList<ApiExtensions.V1.JSONSchemaPropsArgs>());
            set => _anyOf = value;
        }

        /// <summary>
        /// default is a default value for undefined object fields. Defaulting is a beta feature
        /// under the CustomResourceDefaulting feature gate. Defaulting requires
        /// spec.preserveUnknownFields to be false.
        /// </summary>
        [Input("default")]
        public Input<string>? Default { get; set; }

        [Input("definitions")]
        private InputMap<ApiExtensions.V1.JSONSchemaPropsArgs>? _definitions;

        
        public InputMap<ApiExtensions.V1.JSONSchemaPropsArgs> Definitions
        {
            get => _definitions ?? (_definitions = new InputMap<ApiExtensions.V1.JSONSchemaPropsArgs>());
            set => _definitions = value;
        }

        [Input("dependencies")]
        private InputMap<Union<ApiExtensions.V1.JSONSchemaPropsArgs,InputList<string>>>? _dependencies;

        
        public InputMap<Union<ApiExtensions.V1.JSONSchemaPropsArgs,InputList<string>>> Dependencies
        {
            get => _dependencies ?? (_dependencies = new InputMap<Union<ApiExtensions.V1.JSONSchemaPropsArgs,InputList<string>>>());
            set => _dependencies = value;
        }

        
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("enum")]
        private InputList<string>? _enum;

        
        public InputList<string> Enum
        {
            get => _enum ?? (_enum = new InputList<string>());
            set => _enum = value;
        }

        
        [Input("example")]
        public Input<string>? Example { get; set; }

        
        [Input("exclusiveMaximum")]
        public Input<bool>? ExclusiveMaximum { get; set; }

        
        [Input("exclusiveMinimum")]
        public Input<bool>? ExclusiveMinimum { get; set; }

        
        [Input("externalDocs")]
        public Input<ApiExtensions.V1.ExternalDocumentationArgs>? ExternalDocs { get; set; }

        
        [Input("format")]
        public Input<string>? Format { get; set; }

        
        [Input("id")]
        public Input<string>? Id { get; set; }

        
        [Input("items")]
        public InputUnion<ApiExtensions.V1.JSONSchemaPropsArgs,InputList<string>>? Items { get; set; }

        
        [Input("maxItems")]
        public Input<int>? MaxItems { get; set; }

        
        [Input("maxLength")]
        public Input<int>? MaxLength { get; set; }

        
        [Input("maxProperties")]
        public Input<int>? MaxProperties { get; set; }

        
        [Input("maximum")]
        public Input<double>? Maximum { get; set; }

        
        [Input("minItems")]
        public Input<int>? MinItems { get; set; }

        
        [Input("minLength")]
        public Input<int>? MinLength { get; set; }

        
        [Input("minProperties")]
        public Input<int>? MinProperties { get; set; }

        
        [Input("minimum")]
        public Input<double>? Minimum { get; set; }

        
        [Input("multipleOf")]
        public Input<double>? MultipleOf { get; set; }

        
        [Input("not")]
        public Input<ApiExtensions.V1.JSONSchemaPropsArgs>? Not { get; set; }

        
        [Input("nullable")]
        public Input<bool>? Nullable { get; set; }

        [Input("oneOf")]
        private InputList<ApiExtensions.V1.JSONSchemaPropsArgs>? _oneOf;

        
        public InputList<ApiExtensions.V1.JSONSchemaPropsArgs> OneOf
        {
            get => _oneOf ?? (_oneOf = new InputList<ApiExtensions.V1.JSONSchemaPropsArgs>());
            set => _oneOf = value;
        }

        
        [Input("pattern")]
        public Input<string>? Pattern { get; set; }

        [Input("patternProperties")]
        private InputMap<ApiExtensions.V1.JSONSchemaPropsArgs>? _patternProperties;

        
        public InputMap<ApiExtensions.V1.JSONSchemaPropsArgs> PatternProperties
        {
            get => _patternProperties ?? (_patternProperties = new InputMap<ApiExtensions.V1.JSONSchemaPropsArgs>());
            set => _patternProperties = value;
        }

        [Input("properties")]
        private InputMap<ApiExtensions.V1.JSONSchemaPropsArgs>? _properties;

        
        public InputMap<ApiExtensions.V1.JSONSchemaPropsArgs> Properties
        {
            get => _properties ?? (_properties = new InputMap<ApiExtensions.V1.JSONSchemaPropsArgs>());
            set => _properties = value;
        }

        [Input("required")]
        private InputList<string>? _required;

        
        public InputList<string> Required
        {
            get => _required ?? (_required = new InputList<string>());
            set => _required = value;
        }

        
        [Input("title")]
        public Input<string>? Title { get; set; }

        
        [Input("type")]
        public Input<string>? Type { get; set; }

        
        [Input("uniqueItems")]
        public Input<bool>? UniqueItems { get; set; }

        /// <summary>
        /// x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes
        /// runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to
        /// further restrict the embedded object. kind, apiVersion and metadata are validated
        /// automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not
        /// have to be if the object is fully specified (up to kind, apiVersion, metadata).
        /// </summary>
        [Input("x_kubernetes_embedded_resource")]
        public Input<bool>? X_kubernetes_embedded_resource { get; set; }

        /// <summary>
        /// x-kubernetes-int-or-string specifies that this value is either an integer or a string.
        /// If this is true, an empty type is allowed and type as child of anyOf is permitted if
        /// following one of the following patterns:
        /// 
        /// 1) anyOf:
        ///    - type: integer
        ///    - type: string
        /// 2) allOf:
        ///    - anyOf:
        ///      - type: integer
        ///      - type: string
        ///    - ... zero or more
        /// </summary>
        [Input("x_kubernetes_int_or_string")]
        public Input<bool>? X_kubernetes_int_or_string { get; set; }

        [Input("x_kubernetes_list_map_keys")]
        private InputList<string>? _x_kubernetes_list_map_keys;

        /// <summary>
        /// x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by
        /// specifying the keys used as the index of the map.
        /// 
        /// This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set
        /// to "map". Also, the values specified for this attribute must be a scalar typed field of
        /// the child structure (no nesting is supported).
        /// </summary>
        public InputList<string> X_kubernetes_list_map_keys
        {
            get => _x_kubernetes_list_map_keys ?? (_x_kubernetes_list_map_keys = new InputList<string>());
            set => _x_kubernetes_list_map_keys = value;
        }

        /// <summary>
        /// x-kubernetes-list-type annotates an array to further describe its topology. This
        /// extension must only be used on lists and may have 3 possible values:
        /// 
        /// 1) `atomic`: the list is treated as a single entity, like a scalar.
        ///      Atomic lists will be entirely replaced when updated. This extension
        ///      may be used on any type of list (struct, scalar, ...).
        /// 2) `set`:
        ///      Sets are lists that must not have multiple items with the same value. Each
        ///      value must be a scalar (or another atomic type).
        /// 3) `map`:
        ///      These lists are like maps in that their elements have a non-index key
        ///      used to identify them. Order is preserved upon merge. The map tag
        ///      must only be used on a list with elements of type object.
        /// Defaults to atomic for arrays.
        /// </summary>
        [Input("x_kubernetes_list_type")]
        public Input<string>? X_kubernetes_list_type { get; set; }

        /// <summary>
        /// x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning
        /// fields which are not specified in the validation schema. This affects fields
        /// recursively, but switches back to normal pruning behaviour if nested properties or
        /// additionalProperties are specified in the schema. This can either be true or undefined.
        /// False is forbidden.
        /// </summary>
        [Input("x_kubernetes_preserve_unknown_fields")]
        public Input<bool>? X_kubernetes_preserve_unknown_fields { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    public class ServiceReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// name is the name of the service. Required
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// namespace is the namespace of the service. Required
        /// </summary>
        [Input("namespace", required: true)]
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// path is an optional URL path at which the webhook will be contacted.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// port is an optional service port at which the webhook will be contacted. `port` should
        /// be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook.
    /// </summary>
    public class WebhookClientConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server
        /// certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        [Input("caBundle")]
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// service is a reference to the service for this webhook. Either service or url must be
        /// specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        [Input("service")]
        public Input<ApiExtensions.V1.ServiceReferenceArgs>? Service { get; set; }

        /// <summary>
        /// url gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
        /// Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        [Input("url")]
        public Input<string>? Url { get; set; }

    }

    /// <summary>
    /// WebhookConversion describes how to call a conversion webhook
    /// </summary>
    public class WebhookConversionArgs : Pulumi.ResourceArgs
    {
        [Input("conversionReviewVersions", required: true)]
        private InputList<string>? _conversionReviewVersions;

        /// <summary>
        /// conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the
        /// Webhook expects. The API server will use the first version in the list which it
        /// supports. If none of the versions specified in this list are supported by API server,
        /// conversion will fail for the custom resource. If a persisted Webhook configuration
        /// specifies allowed versions and does not include any versions known to the API Server,
        /// calls to the webhook will fail.
        /// </summary>
        public InputList<string> ConversionReviewVersions
        {
            get => _conversionReviewVersions ?? (_conversionReviewVersions = new InputList<string>());
            set => _conversionReviewVersions = value;
        }

        /// <summary>
        /// clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
        /// </summary>
        [Input("clientConfig")]
        public Input<ApiExtensions.V1.WebhookClientConfigArgs>? ClientConfig { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// CustomResourceColumnDefinition specifies a column for server side printing.
    /// </summary>
    public class CustomResourceColumnDefinitionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// JSONPath is a simple JSON path (i.e. with array notation) which is evaluated against
        /// each custom resource to produce the value for this column.
        /// </summary>
        [Input("JSONPath", required: true)]
        public Input<string> JSONPath { get; set; } = null!;

        /// <summary>
        /// name is a human readable name for the column.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// type is an OpenAPI type definition for this column. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// description is a human readable description of this column.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// format is an optional OpenAPI type definition for this column. The 'name' format is
        /// applied to the primary identifier column to assist in clients identifying column is the
        /// resource name. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
        [Input("format")]
        public Input<string>? Format { get; set; }

        /// <summary>
        /// priority is an integer defining the relative importance of this column compared to
        /// others. Lower numbers are considered higher priority. Columns that may be omitted in
        /// limited space scenarios should be given a priority greater than 0.
        /// </summary>
        [Input("priority")]
        public Input<int>? Priority { get; set; }

    }

    /// <summary>
    /// CustomResourceConversion describes how to convert different versions of a CR.
    /// </summary>
    public class CustomResourceConversionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// strategy specifies how custom resources are converted between versions. Allowed values
        /// are: - `None`: The converter only change the apiVersion and would not touch any other
        /// field in the custom resource. - `Webhook`: API Server will call to an external webhook
        /// to do the conversion. Additional information
        ///   is needed for this option. This requires spec.preserveUnknownFields to be false, and
        /// spec.conversion.webhookClientConfig to be set.
        /// </summary>
        [Input("strategy", required: true)]
        public Input<string> Strategy { get; set; } = null!;

        [Input("conversionReviewVersions")]
        private InputList<string>? _conversionReviewVersions;

        /// <summary>
        /// conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the
        /// Webhook expects. The API server will use the first version in the list which it
        /// supports. If none of the versions specified in this list are supported by API server,
        /// conversion will fail for the custom resource. If a persisted Webhook configuration
        /// specifies allowed versions and does not include any versions known to the API Server,
        /// calls to the webhook will fail. Defaults to `["v1beta1"]`.
        /// </summary>
        public InputList<string> ConversionReviewVersions
        {
            get => _conversionReviewVersions ?? (_conversionReviewVersions = new InputList<string>());
            set => _conversionReviewVersions = value;
        }

        /// <summary>
        /// webhookClientConfig is the instructions for how to call the webhook if strategy is
        /// `Webhook`. Required when `strategy` is set to `Webhook`.
        /// </summary>
        [Input("webhookClientConfig")]
        public Input<ApiExtensions.V1Beta1.WebhookClientConfigArgs>? WebhookClientConfig { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinition represents a resource that should be exposed on the API server.
    /// Its name MUST be in the format &amp;lt;.spec.name&amp;gt;.&amp;lt;.spec.group&amp;gt;.
    /// Deprecated in v1.16, planned for removal in v1.19. Use apiextensions.k8s.io/v1
    /// CustomResourceDefinition instead.
    /// </summary>
    public class CustomResourceDefinitionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// spec describes how the user wants the resources to appear
        /// </summary>
        [Input("spec", required: true)]
        public Input<ApiExtensions.V1Beta1.CustomResourceDefinitionSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionCondition contains details for the current condition of this pod.
    /// </summary>
    public class CustomResourceDefinitionConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// type is the type of the condition. Types include Established, NamesAccepted and
        /// Terminating.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// lastTransitionTime last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// message is a human-readable message indicating details about last transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// reason is a unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
    /// </summary>
    public class CustomResourceDefinitionListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<ApiExtensions.V1Beta1.CustomResourceDefinitionArgs>? _items;

        /// <summary>
        /// items list individual CustomResourceDefinition objects
        /// </summary>
        public InputList<ApiExtensions.V1Beta1.CustomResourceDefinitionArgs> Items
        {
            get => _items ?? (_items = new InputList<ApiExtensions.V1Beta1.CustomResourceDefinitionArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition
    /// </summary>
    public class CustomResourceDefinitionNamesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// kind is the serialized kind of the resource. It is normally CamelCase and singular.
        /// Custom resource instances will use this value as the `kind` attribute in API calls.
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// plural is the plural name of the resource to serve. The custom resources are served
        /// under `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/.../&amp;lt;plural&amp;gt;`.
        /// Must match the name of the CustomResourceDefinition (in the form
        /// `&amp;lt;names.plural&amp;gt;.&amp;lt;group&amp;gt;`). Must be all lowercase.
        /// </summary>
        [Input("plural", required: true)]
        public Input<string> Plural { get; set; } = null!;

        [Input("categories")]
        private InputList<string>? _categories;

        /// <summary>
        /// categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
        /// This is published in API discovery documents, and used by clients to support invocations
        /// like `kubectl get all`.
        /// </summary>
        public InputList<string> Categories
        {
            get => _categories ?? (_categories = new InputList<string>());
            set => _categories = value;
        }

        /// <summary>
        /// listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
        /// </summary>
        [Input("listKind")]
        public Input<string>? ListKind { get; set; }

        [Input("shortNames")]
        private InputList<string>? _shortNames;

        /// <summary>
        /// shortNames are short names for the resource, exposed in API discovery documents, and
        /// used by clients to support invocations like `kubectl get &amp;lt;shortname&amp;gt;`. It
        /// must be all lowercase.
        /// </summary>
        public InputList<string> ShortNames
        {
            get => _shortNames ?? (_shortNames = new InputList<string>());
            set => _shortNames = value;
        }

        /// <summary>
        /// singular is the singular name of the resource. It must be all lowercase. Defaults to
        /// lowercased `kind`.
        /// </summary>
        [Input("singular")]
        public Input<string>? Singular { get; set; }

    }

    /// <summary>
    /// CustomResourceDefinitionSpec describes how a user wants their resource to appear
    /// </summary>
    public class CustomResourceDefinitionSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// group is the API group of the defined custom resource. The custom resources are served
        /// under `/apis/&amp;lt;group&amp;gt;/...`. Must match the name of the
        /// CustomResourceDefinition (in the form
        /// `&amp;lt;names.plural&amp;gt;.&amp;lt;group&amp;gt;`).
        /// </summary>
        [Input("group", required: true)]
        public Input<string> Group { get; set; } = null!;

        /// <summary>
        /// names specify the resource and kind names for the custom resource.
        /// </summary>
        [Input("names", required: true)]
        public Input<ApiExtensions.V1Beta1.CustomResourceDefinitionNamesArgs> Names { get; set; } = null!;

        /// <summary>
        /// scope indicates whether the defined custom resource is cluster- or namespace-scoped.
        /// Allowed values are `Cluster` and `Namespaced`. Default is `Namespaced`.
        /// </summary>
        [Input("scope", required: true)]
        public Input<string> Scope { get; set; } = null!;

        [Input("additionalPrinterColumns")]
        private InputList<ApiExtensions.V1Beta1.CustomResourceColumnDefinitionArgs>? _additionalPrinterColumns;

        /// <summary>
        /// additionalPrinterColumns specifies additional columns returned in Table output. See
        /// https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
        /// for details. If present, this field configures columns for all versions. Top-level and
        /// per-version columns are mutually exclusive. If no top-level or per-version columns are
        /// specified, a single column displaying the age of the custom resource is used.
        /// </summary>
        public InputList<ApiExtensions.V1Beta1.CustomResourceColumnDefinitionArgs> AdditionalPrinterColumns
        {
            get => _additionalPrinterColumns ?? (_additionalPrinterColumns = new InputList<ApiExtensions.V1Beta1.CustomResourceColumnDefinitionArgs>());
            set => _additionalPrinterColumns = value;
        }

        /// <summary>
        /// conversion defines conversion settings for the CRD.
        /// </summary>
        [Input("conversion")]
        public Input<ApiExtensions.V1Beta1.CustomResourceConversionArgs>? Conversion { get; set; }

        /// <summary>
        /// preserveUnknownFields indicates that object fields which are not specified in the
        /// OpenAPI schema should be preserved when persisting to storage. apiVersion, kind,
        /// metadata and known fields inside metadata are always preserved. If false, schemas must
        /// be defined for all versions. Defaults to true in v1beta for backwards compatibility.
        /// Deprecated: will be required to be false in v1. Preservation of unknown fields can be
        /// specified in the validation schema using the `x-kubernetes-preserve-unknown-fields:
        /// true` extension. See
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields
        /// for details.
        /// </summary>
        [Input("preserveUnknownFields")]
        public Input<bool>? PreserveUnknownFields { get; set; }

        /// <summary>
        /// subresources specify what subresources the defined custom resource has. If present, this
        /// field configures subresources for all versions. Top-level and per-version subresources
        /// are mutually exclusive.
        /// </summary>
        [Input("subresources")]
        public Input<ApiExtensions.V1Beta1.CustomResourceSubresourcesArgs>? Subresources { get; set; }

        /// <summary>
        /// validation describes the schema used for validation and pruning of the custom resource.
        /// If present, this validation schema is used to validate all versions. Top-level and
        /// per-version schemas are mutually exclusive.
        /// </summary>
        [Input("validation")]
        public Input<ApiExtensions.V1Beta1.CustomResourceValidationArgs>? Validation { get; set; }

        /// <summary>
        /// version is the API version of the defined custom resource. The custom resources are
        /// served under `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/...`. Must match the
        /// name of the first item in the `versions` list if `version` and `versions` are both
        /// specified. Optional if `versions` is specified. Deprecated: use `versions` instead.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        [Input("versions")]
        private InputList<ApiExtensions.V1Beta1.CustomResourceDefinitionVersionArgs>? _versions;

        /// <summary>
        /// versions is the list of all API versions of the defined custom resource. Optional if
        /// `version` is specified. The name of the first item in the `versions` list must match the
        /// `version` field if `version` and `versions` are both specified. Version names are used
        /// to compute the order in which served versions are listed in API discovery. If the
        /// version string is "kube-like", it will sort above non "kube-like" version strings, which
        /// are ordered lexicographically. "Kube-like" versions start with a "v", then are followed
        /// by a number (the major version), then optionally the string "alpha" or "beta" and
        /// another number (the minor version). These are sorted first by GA &amp;gt; beta &amp;gt;
        /// alpha (where GA is a version with no suffix such as beta or alpha), and then by
        /// comparing major version, then minor version. An example sorted list of versions: v10,
        /// v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
        /// </summary>
        public InputList<ApiExtensions.V1Beta1.CustomResourceDefinitionVersionArgs> Versions
        {
            get => _versions ?? (_versions = new InputList<ApiExtensions.V1Beta1.CustomResourceDefinitionVersionArgs>());
            set => _versions = value;
        }

    }

    /// <summary>
    /// CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition
    /// </summary>
    public class CustomResourceDefinitionStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// acceptedNames are the names that are actually being used to serve discovery. They may be
        /// different than the names in spec.
        /// </summary>
        [Input("acceptedNames", required: true)]
        public Input<ApiExtensions.V1Beta1.CustomResourceDefinitionNamesArgs> AcceptedNames { get; set; } = null!;

        [Input("storedVersions", required: true)]
        private InputList<string>? _storedVersions;

        /// <summary>
        /// storedVersions lists all versions of CustomResources that were ever persisted. Tracking
        /// these versions allows a migration path for stored versions in etcd. The field is mutable
        /// so a migration controller can finish a migration to another version (ensuring no old
        /// objects are left in storage), and then remove the rest of the versions from this list.
        /// Versions may not be removed from `spec.versions` while they exist in this list.
        /// </summary>
        public InputList<string> StoredVersions
        {
            get => _storedVersions ?? (_storedVersions = new InputList<string>());
            set => _storedVersions = value;
        }

        [Input("conditions")]
        private InputList<ApiExtensions.V1Beta1.CustomResourceDefinitionConditionArgs>? _conditions;

        /// <summary>
        /// conditions indicate state for particular aspects of a CustomResourceDefinition
        /// </summary>
        public InputList<ApiExtensions.V1Beta1.CustomResourceDefinitionConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<ApiExtensions.V1Beta1.CustomResourceDefinitionConditionArgs>());
            set => _conditions = value;
        }

    }

    /// <summary>
    /// CustomResourceDefinitionVersion describes a version for CRD.
    /// </summary>
    public class CustomResourceDefinitionVersionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// name is the version name, e.g. “v1”, “v2beta1”, etc. The custom resources are
        /// served under this version at `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/...`
        /// if `served` is true.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// served is a flag enabling/disabling this version from being served via REST APIs
        /// </summary>
        [Input("served", required: true)]
        public Input<bool> Served { get; set; } = null!;

        /// <summary>
        /// storage indicates this version should be used when persisting custom resources to
        /// storage. There must be exactly one version with storage=true.
        /// </summary>
        [Input("storage", required: true)]
        public Input<bool> Storage { get; set; } = null!;

        [Input("additionalPrinterColumns")]
        private InputList<ApiExtensions.V1Beta1.CustomResourceColumnDefinitionArgs>? _additionalPrinterColumns;

        /// <summary>
        /// additionalPrinterColumns specifies additional columns returned in Table output. See
        /// https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
        /// for details. Top-level and per-version columns are mutually exclusive. Per-version
        /// columns must not all be set to identical values (top-level columns should be used
        /// instead). If no top-level or per-version columns are specified, a single column
        /// displaying the age of the custom resource is used.
        /// </summary>
        public InputList<ApiExtensions.V1Beta1.CustomResourceColumnDefinitionArgs> AdditionalPrinterColumns
        {
            get => _additionalPrinterColumns ?? (_additionalPrinterColumns = new InputList<ApiExtensions.V1Beta1.CustomResourceColumnDefinitionArgs>());
            set => _additionalPrinterColumns = value;
        }

        /// <summary>
        /// schema describes the schema used for validation and pruning of this version of the
        /// custom resource. Top-level and per-version schemas are mutually exclusive. Per-version
        /// schemas must not all be set to identical values (top-level validation schema should be
        /// used instead).
        /// </summary>
        [Input("schema")]
        public Input<ApiExtensions.V1Beta1.CustomResourceValidationArgs>? Schema { get; set; }

        /// <summary>
        /// subresources specify what subresources this version of the defined custom resource have.
        /// Top-level and per-version subresources are mutually exclusive. Per-version subresources
        /// must not all be set to identical values (top-level subresources should be used instead).
        /// </summary>
        [Input("subresources")]
        public Input<ApiExtensions.V1Beta1.CustomResourceSubresourcesArgs>? Subresources { get; set; }

    }

    /// <summary>
    /// CustomResourceSubresourceScale defines how to serve the scale subresource for
    /// CustomResources.
    /// </summary>
    public class CustomResourceSubresourceScaleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// specReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a
        /// JSON Path under `.spec`. If there is no value under the given path in the custom
        /// resource, the `/scale` subresource will return an error on GET.
        /// </summary>
        [Input("specReplicasPath", required: true)]
        public Input<string> SpecReplicasPath { get; set; } = null!;

        /// <summary>
        /// statusReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status`. If there is no value under the given path in the custom
        /// resource, the `status.replicas` value in the `/scale` subresource will default to 0.
        /// </summary>
        [Input("statusReplicasPath", required: true)]
        public Input<string> StatusReplicasPath { get; set; } = null!;

        /// <summary>
        /// labelSelectorPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status` or `.spec`. Must be set to work with
        /// HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not
        /// a complex selector struct) which contains a serialized label selector in string form.
        /// More info:
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource
        /// If there is no value under the given path in the custom resource, the `status.selector`
        /// value in the `/scale` subresource will default to the empty string.
        /// </summary>
        [Input("labelSelectorPath")]
        public Input<string>? LabelSelectorPath { get; set; }

    }

    /// <summary>
    /// CustomResourceSubresources defines the status and scale subresources for CustomResources.
    /// </summary>
    public class CustomResourceSubresourcesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// scale indicates the custom resource should serve a `/scale` subresource that returns an
        /// `autoscaling/v1` Scale object.
        /// </summary>
        [Input("scale")]
        public Input<ApiExtensions.V1Beta1.CustomResourceSubresourceScaleArgs>? Scale { get; set; }

    }

    /// <summary>
    /// CustomResourceValidation is a list of validation methods for CustomResources.
    /// </summary>
    public class CustomResourceValidationArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.
        /// </summary>
        [Input("openAPIV3Schema")]
        public Input<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>? OpenAPIV3Schema { get; set; }

    }

    /// <summary>
    /// ExternalDocumentation allows referencing an external resource for extended documentation.
    /// </summary>
    public class ExternalDocumentationArgs : Pulumi.ResourceArgs
    {
        
        [Input("description")]
        public Input<string>? Description { get; set; }

        
        [Input("url")]
        public Input<string>? Url { get; set; }

    }

    /// <summary>
    /// JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
    /// </summary>
    public class JSONSchemaPropsArgs : Pulumi.ResourceArgs
    {
        
        [Input("$ref")]
        public Input<string>? Ref { get; set; }

        
        [Input("$schema")]
        public Input<string>? Schema { get; set; }

        
        [Input("additionalItems")]
        public InputUnion<ApiExtensions.V1Beta1.JSONSchemaPropsArgs,bool>? AdditionalItems { get; set; }

        
        [Input("additionalProperties")]
        public InputUnion<ApiExtensions.V1Beta1.JSONSchemaPropsArgs,bool>? AdditionalProperties { get; set; }

        [Input("allOf")]
        private InputList<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>? _allOf;

        
        public InputList<ApiExtensions.V1Beta1.JSONSchemaPropsArgs> AllOf
        {
            get => _allOf ?? (_allOf = new InputList<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>());
            set => _allOf = value;
        }

        [Input("anyOf")]
        private InputList<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>? _anyOf;

        
        public InputList<ApiExtensions.V1Beta1.JSONSchemaPropsArgs> AnyOf
        {
            get => _anyOf ?? (_anyOf = new InputList<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>());
            set => _anyOf = value;
        }

        /// <summary>
        /// default is a default value for undefined object fields. Defaulting is a beta feature
        /// under the CustomResourceDefaulting feature gate. CustomResourceDefinitions with defaults
        /// must be created using the v1 (or newer) CustomResourceDefinition API.
        /// </summary>
        [Input("default")]
        public Input<string>? Default { get; set; }

        [Input("definitions")]
        private InputMap<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>? _definitions;

        
        public InputMap<ApiExtensions.V1Beta1.JSONSchemaPropsArgs> Definitions
        {
            get => _definitions ?? (_definitions = new InputMap<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>());
            set => _definitions = value;
        }

        [Input("dependencies")]
        private InputMap<Union<ApiExtensions.V1Beta1.JSONSchemaPropsArgs,InputList<string>>>? _dependencies;

        
        public InputMap<Union<ApiExtensions.V1Beta1.JSONSchemaPropsArgs,InputList<string>>> Dependencies
        {
            get => _dependencies ?? (_dependencies = new InputMap<Union<ApiExtensions.V1Beta1.JSONSchemaPropsArgs,InputList<string>>>());
            set => _dependencies = value;
        }

        
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("enum")]
        private InputList<string>? _enum;

        
        public InputList<string> Enum
        {
            get => _enum ?? (_enum = new InputList<string>());
            set => _enum = value;
        }

        
        [Input("example")]
        public Input<string>? Example { get; set; }

        
        [Input("exclusiveMaximum")]
        public Input<bool>? ExclusiveMaximum { get; set; }

        
        [Input("exclusiveMinimum")]
        public Input<bool>? ExclusiveMinimum { get; set; }

        
        [Input("externalDocs")]
        public Input<ApiExtensions.V1Beta1.ExternalDocumentationArgs>? ExternalDocs { get; set; }

        
        [Input("format")]
        public Input<string>? Format { get; set; }

        
        [Input("id")]
        public Input<string>? Id { get; set; }

        
        [Input("items")]
        public InputUnion<ApiExtensions.V1Beta1.JSONSchemaPropsArgs,InputList<string>>? Items { get; set; }

        
        [Input("maxItems")]
        public Input<int>? MaxItems { get; set; }

        
        [Input("maxLength")]
        public Input<int>? MaxLength { get; set; }

        
        [Input("maxProperties")]
        public Input<int>? MaxProperties { get; set; }

        
        [Input("maximum")]
        public Input<double>? Maximum { get; set; }

        
        [Input("minItems")]
        public Input<int>? MinItems { get; set; }

        
        [Input("minLength")]
        public Input<int>? MinLength { get; set; }

        
        [Input("minProperties")]
        public Input<int>? MinProperties { get; set; }

        
        [Input("minimum")]
        public Input<double>? Minimum { get; set; }

        
        [Input("multipleOf")]
        public Input<double>? MultipleOf { get; set; }

        
        [Input("not")]
        public Input<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>? Not { get; set; }

        
        [Input("nullable")]
        public Input<bool>? Nullable { get; set; }

        [Input("oneOf")]
        private InputList<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>? _oneOf;

        
        public InputList<ApiExtensions.V1Beta1.JSONSchemaPropsArgs> OneOf
        {
            get => _oneOf ?? (_oneOf = new InputList<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>());
            set => _oneOf = value;
        }

        
        [Input("pattern")]
        public Input<string>? Pattern { get; set; }

        [Input("patternProperties")]
        private InputMap<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>? _patternProperties;

        
        public InputMap<ApiExtensions.V1Beta1.JSONSchemaPropsArgs> PatternProperties
        {
            get => _patternProperties ?? (_patternProperties = new InputMap<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>());
            set => _patternProperties = value;
        }

        [Input("properties")]
        private InputMap<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>? _properties;

        
        public InputMap<ApiExtensions.V1Beta1.JSONSchemaPropsArgs> Properties
        {
            get => _properties ?? (_properties = new InputMap<ApiExtensions.V1Beta1.JSONSchemaPropsArgs>());
            set => _properties = value;
        }

        [Input("required")]
        private InputList<string>? _required;

        
        public InputList<string> Required
        {
            get => _required ?? (_required = new InputList<string>());
            set => _required = value;
        }

        
        [Input("title")]
        public Input<string>? Title { get; set; }

        
        [Input("type")]
        public Input<string>? Type { get; set; }

        
        [Input("uniqueItems")]
        public Input<bool>? UniqueItems { get; set; }

        /// <summary>
        /// x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes
        /// runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to
        /// further restrict the embedded object. kind, apiVersion and metadata are validated
        /// automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not
        /// have to be if the object is fully specified (up to kind, apiVersion, metadata).
        /// </summary>
        [Input("x_kubernetes_embedded_resource")]
        public Input<bool>? X_kubernetes_embedded_resource { get; set; }

        /// <summary>
        /// x-kubernetes-int-or-string specifies that this value is either an integer or a string.
        /// If this is true, an empty type is allowed and type as child of anyOf is permitted if
        /// following one of the following patterns:
        /// 
        /// 1) anyOf:
        ///    - type: integer
        ///    - type: string
        /// 2) allOf:
        ///    - anyOf:
        ///      - type: integer
        ///      - type: string
        ///    - ... zero or more
        /// </summary>
        [Input("x_kubernetes_int_or_string")]
        public Input<bool>? X_kubernetes_int_or_string { get; set; }

        [Input("x_kubernetes_list_map_keys")]
        private InputList<string>? _x_kubernetes_list_map_keys;

        /// <summary>
        /// x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by
        /// specifying the keys used as the index of the map.
        /// 
        /// This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set
        /// to "map". Also, the values specified for this attribute must be a scalar typed field of
        /// the child structure (no nesting is supported).
        /// </summary>
        public InputList<string> X_kubernetes_list_map_keys
        {
            get => _x_kubernetes_list_map_keys ?? (_x_kubernetes_list_map_keys = new InputList<string>());
            set => _x_kubernetes_list_map_keys = value;
        }

        /// <summary>
        /// x-kubernetes-list-type annotates an array to further describe its topology. This
        /// extension must only be used on lists and may have 3 possible values:
        /// 
        /// 1) `atomic`: the list is treated as a single entity, like a scalar.
        ///      Atomic lists will be entirely replaced when updated. This extension
        ///      may be used on any type of list (struct, scalar, ...).
        /// 2) `set`:
        ///      Sets are lists that must not have multiple items with the same value. Each
        ///      value must be a scalar (or another atomic type).
        /// 3) `map`:
        ///      These lists are like maps in that their elements have a non-index key
        ///      used to identify them. Order is preserved upon merge. The map tag
        ///      must only be used on a list with elements of type object.
        /// Defaults to atomic for arrays.
        /// </summary>
        [Input("x_kubernetes_list_type")]
        public Input<string>? X_kubernetes_list_type { get; set; }

        /// <summary>
        /// x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning
        /// fields which are not specified in the validation schema. This affects fields
        /// recursively, but switches back to normal pruning behaviour if nested properties or
        /// additionalProperties are specified in the schema. This can either be true or undefined.
        /// False is forbidden.
        /// </summary>
        [Input("x_kubernetes_preserve_unknown_fields")]
        public Input<bool>? X_kubernetes_preserve_unknown_fields { get; set; }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    public class ServiceReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// name is the name of the service. Required
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// namespace is the namespace of the service. Required
        /// </summary>
        [Input("namespace", required: true)]
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// path is an optional URL path at which the webhook will be contacted.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// port is an optional service port at which the webhook will be contacted. `port` should
        /// be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook.
    /// </summary>
    public class WebhookClientConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server
        /// certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        [Input("caBundle")]
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// service is a reference to the service for this webhook. Either service or url must be
        /// specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        [Input("service")]
        public Input<ApiExtensions.V1Beta1.ServiceReferenceArgs>? Service { get; set; }

        /// <summary>
        /// url gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
        /// Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        [Input("url")]
        public Input<string>? Url { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.ApiRegistration
{
  namespace V1
  {
    /// <summary>
    /// APIService represents a server for a particular GroupVersion. Name must be "version.group".
    /// </summary>
    public class APIServiceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec contains information for locating and communicating with a server
        /// </summary>
        [Input("spec")]
        public Input<ApiRegistration.V1.APIServiceSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// APIServiceCondition describes the state of an APIService at a particular point
    /// </summary>
    public class APIServiceConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type is the type of the condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// APIServiceList is a list of APIService objects.
    /// </summary>
    public class APIServiceListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<ApiRegistration.V1.APIServiceArgs>? _items;

        
        public InputList<ApiRegistration.V1.APIServiceArgs> Items
        {
            get => _items ?? (_items = new InputList<ApiRegistration.V1.APIServiceArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// APIServiceSpec contains information for locating and communicating with a server. Only https
    /// is supported, though you are able to disable certificate verification.
    /// </summary>
    public class APIServiceSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// GroupPriorityMininum is the priority this group should have at least. Higher priority
        /// means that the group is preferred by clients over lower priority ones. Note that other
        /// versions of this group might specify even higher GroupPriorityMininum values such that
        /// the whole group gets a higher priority. The primary sort is based on
        /// GroupPriorityMinimum, ordered highest number to lowest (20 before 10). The secondary
        /// sort is based on the alphabetical comparison of the name of the object.  (v1.bar before
        /// v1.foo) We'd recommend something like: *.k8s.io (except extensions) at 18000 and PaaSes
        /// (OpenShift, Deis) are recommended to be in the 2000s
        /// </summary>
        [Input("groupPriorityMinimum", required: true)]
        public Input<int> GroupPriorityMinimum { get; set; } = null!;

        /// <summary>
        /// Service is a reference to the service for this API server.  It must communicate on port
        /// 443 If the Service is nil, that means the handling for the API groupversion is handled
        /// locally on this server. The call will simply delegate to the normal handler chain to be
        /// fulfilled.
        /// </summary>
        [Input("service", required: true)]
        public Input<ApiRegistration.V1.ServiceReferenceArgs> Service { get; set; } = null!;

        /// <summary>
        /// VersionPriority controls the ordering of this API version inside of its group.  Must be
        /// greater than zero. The primary sort is based on VersionPriority, ordered highest to
        /// lowest (20 before 10). Since it's inside of a group, the number can be small, probably
        /// in the 10s. In case of equal version priorities, the version string will be used to
        /// compute the order inside a group. If the version string is "kube-like", it will sort
        /// above non "kube-like" version strings, which are ordered lexicographically. "Kube-like"
        /// versions start with a "v", then are followed by a number (the major version), then
        /// optionally the string "alpha" or "beta" and another number (the minor version). These
        /// are sorted first by GA &amp;gt; beta &amp;gt; alpha (where GA is a version with no
        /// suffix such as beta or alpha), and then by comparing major version, then minor version.
        /// An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1,
        /// v11alpha2, foo1, foo10.
        /// </summary>
        [Input("versionPriority", required: true)]
        public Input<int> VersionPriority { get; set; } = null!;

        /// <summary>
        /// CABundle is a PEM encoded CA bundle which will be used to validate an API server's
        /// serving certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        [Input("caBundle")]
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// Group is the API group name this server hosts
        /// </summary>
        [Input("group")]
        public Input<string>? Group { get; set; }

        /// <summary>
        /// InsecureSkipTLSVerify disables TLS certificate verification when communicating with this
        /// server. This is strongly discouraged.  You should use the CABundle instead.
        /// </summary>
        [Input("insecureSkipTLSVerify")]
        public Input<bool>? InsecureSkipTLSVerify { get; set; }

        /// <summary>
        /// Version is the API version this server hosts.  For example, "v1"
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// APIServiceStatus contains derived information about an API server
    /// </summary>
    public class APIServiceStatusArgs : Pulumi.ResourceArgs
    {
        [Input("conditions")]
        private InputList<ApiRegistration.V1.APIServiceConditionArgs>? _conditions;

        /// <summary>
        /// Current service state of apiService.
        /// </summary>
        public InputList<ApiRegistration.V1.APIServiceConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<ApiRegistration.V1.APIServiceConditionArgs>());
            set => _conditions = value;
        }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    public class ServiceReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name is the name of the service
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace is the namespace of the service
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// APIService represents a server for a particular GroupVersion. Name must be "version.group".
    /// </summary>
    public class APIServiceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec contains information for locating and communicating with a server
        /// </summary>
        [Input("spec")]
        public Input<ApiRegistration.V1Beta1.APIServiceSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// APIServiceCondition describes the state of an APIService at a particular point
    /// </summary>
    public class APIServiceConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type is the type of the condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// APIServiceList is a list of APIService objects.
    /// </summary>
    public class APIServiceListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<ApiRegistration.V1Beta1.APIServiceArgs>? _items;

        
        public InputList<ApiRegistration.V1Beta1.APIServiceArgs> Items
        {
            get => _items ?? (_items = new InputList<ApiRegistration.V1Beta1.APIServiceArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// APIServiceSpec contains information for locating and communicating with a server. Only https
    /// is supported, though you are able to disable certificate verification.
    /// </summary>
    public class APIServiceSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// GroupPriorityMininum is the priority this group should have at least. Higher priority
        /// means that the group is preferred by clients over lower priority ones. Note that other
        /// versions of this group might specify even higher GroupPriorityMininum values such that
        /// the whole group gets a higher priority. The primary sort is based on
        /// GroupPriorityMinimum, ordered highest number to lowest (20 before 10). The secondary
        /// sort is based on the alphabetical comparison of the name of the object.  (v1.bar before
        /// v1.foo) We'd recommend something like: *.k8s.io (except extensions) at 18000 and PaaSes
        /// (OpenShift, Deis) are recommended to be in the 2000s
        /// </summary>
        [Input("groupPriorityMinimum", required: true)]
        public Input<int> GroupPriorityMinimum { get; set; } = null!;

        /// <summary>
        /// Service is a reference to the service for this API server.  It must communicate on port
        /// 443 If the Service is nil, that means the handling for the API groupversion is handled
        /// locally on this server. The call will simply delegate to the normal handler chain to be
        /// fulfilled.
        /// </summary>
        [Input("service", required: true)]
        public Input<ApiRegistration.V1Beta1.ServiceReferenceArgs> Service { get; set; } = null!;

        /// <summary>
        /// VersionPriority controls the ordering of this API version inside of its group.  Must be
        /// greater than zero. The primary sort is based on VersionPriority, ordered highest to
        /// lowest (20 before 10). Since it's inside of a group, the number can be small, probably
        /// in the 10s. In case of equal version priorities, the version string will be used to
        /// compute the order inside a group. If the version string is "kube-like", it will sort
        /// above non "kube-like" version strings, which are ordered lexicographically. "Kube-like"
        /// versions start with a "v", then are followed by a number (the major version), then
        /// optionally the string "alpha" or "beta" and another number (the minor version). These
        /// are sorted first by GA &amp;gt; beta &amp;gt; alpha (where GA is a version with no
        /// suffix such as beta or alpha), and then by comparing major version, then minor version.
        /// An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1,
        /// v11alpha2, foo1, foo10.
        /// </summary>
        [Input("versionPriority", required: true)]
        public Input<int> VersionPriority { get; set; } = null!;

        /// <summary>
        /// CABundle is a PEM encoded CA bundle which will be used to validate an API server's
        /// serving certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        [Input("caBundle")]
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// Group is the API group name this server hosts
        /// </summary>
        [Input("group")]
        public Input<string>? Group { get; set; }

        /// <summary>
        /// InsecureSkipTLSVerify disables TLS certificate verification when communicating with this
        /// server. This is strongly discouraged.  You should use the CABundle instead.
        /// </summary>
        [Input("insecureSkipTLSVerify")]
        public Input<bool>? InsecureSkipTLSVerify { get; set; }

        /// <summary>
        /// Version is the API version this server hosts.  For example, "v1"
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// APIServiceStatus contains derived information about an API server
    /// </summary>
    public class APIServiceStatusArgs : Pulumi.ResourceArgs
    {
        [Input("conditions")]
        private InputList<ApiRegistration.V1Beta1.APIServiceConditionArgs>? _conditions;

        /// <summary>
        /// Current service state of apiService.
        /// </summary>
        public InputList<ApiRegistration.V1Beta1.APIServiceConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<ApiRegistration.V1Beta1.APIServiceConditionArgs>());
            set => _conditions = value;
        }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    public class ServiceReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name is the name of the service
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace is the namespace of the service
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Apps
{
  namespace V1
  {
    /// <summary>
    /// ControllerRevision implements an immutable snapshot of state data. Clients are responsible
    /// for serializing and deserializing the objects that contain their internal state. Once a
    /// ControllerRevision has been successfully created, it can not be updated. The API Server will
    /// fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
    /// may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
    /// controllers for update and rollback, this object is beta. However, it may be subject to name
    /// and representation changes in future releases, and clients should not depend on its
    /// stability. It is primarily for internal use by controllers.
    /// </summary>
    public class ControllerRevisionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Revision indicates the revision of the state represented by Data.
        /// </summary>
        [Input("revision", required: true)]
        public Input<int> Revision { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Data is the serialized representation of the state.
        /// </summary>
        [Input("data")]
        public Input<string>? Data { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
    /// </summary>
    public class ControllerRevisionListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1.ControllerRevisionArgs>? _items;

        /// <summary>
        /// Items is the list of ControllerRevisions
        /// </summary>
        public InputList<Apps.V1.ControllerRevisionArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1.ControllerRevisionArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DaemonSet represents the configuration of a daemon set.
    /// </summary>
    public class DaemonSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// The desired behavior of this daemon set. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1.DaemonSetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// DaemonSetCondition describes the state of a DaemonSet at a certain point.
    /// </summary>
    public class DaemonSetConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of DaemonSet condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DaemonSetList is a collection of daemon sets.
    /// </summary>
    public class DaemonSetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1.DaemonSetArgs>? _items;

        /// <summary>
        /// A list of daemon sets.
        /// </summary>
        public InputList<Apps.V1.DaemonSetArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1.DaemonSetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DaemonSetSpec is the specification of a daemon set.
    /// </summary>
    public class DaemonSetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A label query over pods that are managed by the daemon set. Must match in order to be
        /// controlled. It must match the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> Selector { get; set; } = null!;

        /// <summary>
        /// An object that describes the pod that will be created. The DaemonSet will create exactly
        /// one copy of this pod on every node that matches the template's node selector (or on
        /// every node if no node selector is specified). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// The minimum number of seconds for which a newly created DaemonSet pod should be ready
        /// without any of its container crashing, for it to be considered available. Defaults to 0
        /// (pod will be considered available as soon as it is ready).
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// The number of old history to retain to allow rollback. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 10.
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// An update strategy to replace existing DaemonSet pods with new pods.
        /// </summary>
        [Input("updateStrategy")]
        public Input<Apps.V1.DaemonSetUpdateStrategyArgs>? UpdateStrategy { get; set; }

    }

    /// <summary>
    /// DaemonSetStatus represents the current status of a daemon set.
    /// </summary>
    public class DaemonSetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The number of nodes that are running at least 1 daemon pod and are supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        [Input("currentNumberScheduled", required: true)]
        public Input<int> CurrentNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The total number of nodes that should be running the daemon pod (including nodes
        /// correctly running the daemon pod). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        [Input("desiredNumberScheduled", required: true)]
        public Input<int> DesiredNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that are running the daemon pod, but are not supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        [Input("numberMisscheduled", required: true)]
        public Input<int> NumberMisscheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and ready.
        /// </summary>
        [Input("numberReady", required: true)]
        public Input<int> NumberReady { get; set; } = null!;

        /// <summary>
        /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as
        /// a collision avoidance mechanism when it needs to create the name for the newest
        /// ControllerRevision.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1.DaemonSetConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a DaemonSet's current state.
        /// </summary>
        public InputList<Apps.V1.DaemonSetConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1.DaemonSetConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        [Input("numberAvailable")]
        public Input<int>? NumberAvailable { get; set; }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have none of the daemon
        /// pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        [Input("numberUnavailable")]
        public Input<int>? NumberUnavailable { get; set; }

        /// <summary>
        /// The most recent generation observed by the daemon set controller.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The total number of nodes that are running updated daemon pod
        /// </summary>
        [Input("updatedNumberScheduled")]
        public Input<int>? UpdatedNumberScheduled { get; set; }

    }

    /// <summary>
    /// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
    /// </summary>
    public class DaemonSetUpdateStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Rolling update config params. Present only if type = "RollingUpdate".
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Apps.V1.RollingUpdateDaemonSetArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is
        /// RollingUpdate.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    public class DeploymentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1.DeploymentSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    public class DeploymentConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of deployment condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// The last time this condition was updated.
        /// </summary>
        [Input("lastUpdateTime")]
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    public class DeploymentListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1.DeploymentArgs>? _items;

        /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
        public InputList<Apps.V1.DeploymentArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1.DeploymentArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    public class DeploymentSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment. It must match the pod template's labels.
        /// </summary>
        [Input("selector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> Selector { get; set; } = null!;

        /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Indicates that the deployment is paused.
        /// </summary>
        [Input("paused")]
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// Defaults to 600s.
        /// </summary>
        [Input("progressDeadlineSeconds")]
        public Input<int>? ProgressDeadlineSeconds { get; set; }

        /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. Defaults to 10.
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
        [Input("strategy")]
        public Input<Apps.V1.DeploymentStrategyArgs>? Strategy { get; set; }

    }

    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    public class DeploymentStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
        [Input("availableReplicas")]
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1.DeploymentConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
        public InputList<Apps.V1.DeploymentConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1.DeploymentConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
        [Input("unavailableReplicas")]
        public Input<int>? UnavailableReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
        [Input("updatedReplicas")]
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    public class DeploymentStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Apps.V1.RollingUpdateDeploymentArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
    /// </summary>
    public class ReplicaSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
        /// that the ReplicaSet manages. Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the specification of the desired behavior of the ReplicaSet. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1.ReplicaSetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// ReplicaSetCondition describes the state of a replica set at a certain point.
    /// </summary>
    public class ReplicaSetConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of replica set condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ReplicaSetList is a collection of ReplicaSets.
    /// </summary>
    public class ReplicaSetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1.ReplicaSetArgs>? _items;

        /// <summary>
        /// List of ReplicaSets. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
        public InputList<Apps.V1.ReplicaSetArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1.ReplicaSetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ReplicaSetSpec is the specification of a ReplicaSet.
    /// </summary>
    public class ReplicaSetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Selector is a label query over pods that should match the replica count. Label keys and
        /// values that must match in order to be controlled by this replica set. It must match the
        /// pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> Selector { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        [Input("template")]
        public Input<Core.V1.PodTemplateSpecArgs>? Template { get; set; }

    }

    /// <summary>
    /// ReplicaSetStatus represents the current status of a ReplicaSet.
    /// </summary>
    public class ReplicaSetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this replica
        /// set.
        /// </summary>
        [Input("availableReplicas")]
        public Input<int>? AvailableReplicas { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1.ReplicaSetConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a replica set's current state.
        /// </summary>
        public InputList<Apps.V1.ReplicaSetConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1.ReplicaSetConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replicaset.
        /// </summary>
        [Input("fullyLabeledReplicas")]
        public Input<int>? FullyLabeledReplicas { get; set; }

        /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The number of ready replicas for this replica set.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of daemon set rolling update.
    /// </summary>
    public class RollingUpdateDaemonSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The maximum number of DaemonSet pods that can be unavailable during the update. Value
        /// can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at
        /// the start of the update (ex: 10%). Absolute number is calculated from percentage by
        /// rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at
        /// most 30% of the total number of nodes that should be running the daemon pod (i.e.
        /// status.desiredNumberScheduled) can have their pods stopped for an update at any given
        /// time. The update starts by stopping at most 30% of those DaemonSet pods and then brings
        /// up new DaemonSet pods in their place. Once the new pods are available, it then proceeds
        /// onto other DaemonSet pods, thus ensuring that at least 70% of original number of
        /// DaemonSet pods are available at all times during the update.
        /// </summary>
        [Input("maxUnavailable")]
        public InputUnion<int,string>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    public class RollingUpdateDeploymentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can
        /// be scaled up immediately when the rolling update starts, such that the total number of
        /// old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new
        /// ReplicaSet can be scaled up further, ensuring that total number of pods running at any
        /// time during the update is at most 130% of desired pods.
        /// </summary>
        [Input("maxSurge")]
        public InputUnion<int,string>? MaxSurge { get; set; }

        /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0.
        /// Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down
        /// to 70% of desired pods immediately when the rolling update starts. Once new pods are
        /// ready, old ReplicaSet can be scaled down further, followed by scaling up the new
        /// ReplicaSet, ensuring that the total number of pods available at all times during the
        /// update is at least 70% of desired pods.
        /// </summary>
        [Input("maxUnavailable")]
        public InputUnion<int,string>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// RollingUpdateStatefulSetStrategy is used to communicate parameter for
    /// RollingUpdateStatefulSetStrategyType.
    /// </summary>
    public class RollingUpdateStatefulSetStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default
        /// value is 0.
        /// </summary>
        [Input("partition")]
        public Input<int>? Partition { get; set; }

    }

    /// <summary>
    /// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
    ///  - Network: A single stable DNS and hostname.
    ///  - Storage: As many VolumeClaims as requested.
    /// The StatefulSet guarantees that a given network identity will always map to the same storage
    /// identity.
    /// </summary>
    public class StatefulSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired identities of pods in this set.
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1.StatefulSetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// StatefulSetCondition describes the state of a statefulset at a certain point.
    /// </summary>
    public class StatefulSetConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of statefulset condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatefulSetList is a collection of StatefulSets.
    /// </summary>
    public class StatefulSetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1.StatefulSetArgs>? _items;

        
        public InputList<Apps.V1.StatefulSetArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1.StatefulSetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// A StatefulSetSpec is the specification of a StatefulSet.
    /// </summary>
    public class StatefulSetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// selector is a label query over pods that should match the replica count. It must match
        /// the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> Selector { get; set; } = null!;

        /// <summary>
        /// serviceName is the name of the service that governs this StatefulSet. This service must
        /// exist before the StatefulSet, and is responsible for the network identity of the set.
        /// Pods get DNS/hostnames that follow the pattern:
        /// pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
        /// managed by the StatefulSet controller.
        /// </summary>
        [Input("serviceName", required: true)]
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. Each pod stamped out by the StatefulSet will fulfill this
        /// Template, but have a unique identity from the rest of the StatefulSet.
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// podManagementPolicy controls how pods are created during initial scale up, when
        /// replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`,
        /// where pods are created in increasing order (pod-0, then pod-1, etc) and the controller
        /// will wait until each pod is ready before continuing. When scaling down, the pods are
        /// removed in the opposite order. The alternative policy is `Parallel` which will create
        /// pods in parallel to match the desired scale without waiting, and on scale down will
        /// delete all pods at once.
        /// </summary>
        [Input("podManagementPolicy")]
        public Input<string>? PodManagementPolicy { get; set; }

        /// <summary>
        /// replicas is the desired number of replicas of the given Template. These are replicas in
        /// the sense that they are instantiations of the same Template, but individual replicas
        /// also have a consistent identity. If unspecified, defaults to 1.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the
        /// StatefulSet's revision history. The revision history consists of all revisions not
        /// represented by a currently applied StatefulSetSpec version. The default value is 10.
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update
        /// Pods in the StatefulSet when a revision is made to Template.
        /// </summary>
        [Input("updateStrategy")]
        public Input<Apps.V1.StatefulSetUpdateStrategyArgs>? UpdateStrategy { get; set; }

        [Input("volumeClaimTemplates")]
        private InputList<Core.V1.PersistentVolumeClaimArgs>? _volumeClaimTemplates;

        /// <summary>
        /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The
        /// StatefulSet controller is responsible for mapping network identities to claims in a way
        /// that maintains the identity of a pod. Every claim in this list must have at least one
        /// matching (by name) volumeMount in one container in the template. A claim in this list
        /// takes precedence over any volumes in the template, with the same name.
        /// </summary>
        public InputList<Core.V1.PersistentVolumeClaimArgs> VolumeClaimTemplates
        {
            get => _volumeClaimTemplates ?? (_volumeClaimTemplates = new InputList<Core.V1.PersistentVolumeClaimArgs>());
            set => _volumeClaimTemplates = value;
        }

    }

    /// <summary>
    /// StatefulSetStatus represents the current state of a StatefulSet.
    /// </summary>
    public class StatefulSetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// replicas is the number of Pods created by the StatefulSet controller.
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet
        /// controller uses this field as a collision avoidance mechanism when it needs to create
        /// the name for the newest ControllerRevision.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1.StatefulSetConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a statefulset's current state.
        /// </summary>
        public InputList<Apps.V1.StatefulSetConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1.StatefulSetConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// currentReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by currentRevision.
        /// </summary>
        [Input("currentReplicas")]
        public Input<int>? CurrentReplicas { get; set; }

        /// <summary>
        /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [0,currentReplicas).
        /// </summary>
        [Input("currentRevision")]
        public Input<string>? CurrentRevision { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed for this StatefulSet. It
        /// corresponds to the StatefulSet's generation, which is updated on mutation by the API
        /// Server.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// readyReplicas is the number of Pods created by the StatefulSet controller that have a
        /// Ready Condition.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [replicas-updatedReplicas,replicas)
        /// </summary>
        [Input("updateRevision")]
        public Input<string>? UpdateRevision { get; set; }

        /// <summary>
        /// updatedReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by updateRevision.
        /// </summary>
        [Input("updatedReplicas")]
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
    /// perform updates. It includes any additional parameters necessary to perform the update for
    /// the indicated strategy.
    /// </summary>
    public class StatefulSetUpdateStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RollingUpdate is used to communicate parameters when Type is
        /// RollingUpdateStatefulSetStrategyType.
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Apps.V1.RollingUpdateStatefulSetStrategyArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// DEPRECATED - apps/v1beta1/ControllerRevision is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/ControllerRevision instead.
    /// 
    /// ControllerRevision implements an immutable snapshot of state data. Clients are responsible
    /// for serializing and deserializing the objects that contain their internal state. Once a
    /// ControllerRevision has been successfully created, it can not be updated. The API Server will
    /// fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
    /// may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
    /// controllers for update and rollback, this object is beta. However, it may be subject to name
    /// and representation changes in future releases, and clients should not depend on its
    /// stability. It is primarily for internal use by controllers.
    /// </summary>
    public class ControllerRevisionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Revision indicates the revision of the state represented by Data.
        /// </summary>
        [Input("revision", required: true)]
        public Input<int> Revision { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Data is the serialized representation of the state.
        /// </summary>
        [Input("data")]
        public Input<string>? Data { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
    /// </summary>
    public class ControllerRevisionListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1Beta1.ControllerRevisionArgs>? _items;

        /// <summary>
        /// Items is the list of ControllerRevisions
        /// </summary>
        public InputList<Apps.V1Beta1.ControllerRevisionArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1Beta1.ControllerRevisionArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta1/Deployment is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/Deployment instead.
    /// 
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    public class DeploymentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1Beta1.DeploymentSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    public class DeploymentConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of deployment condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// The last time this condition was updated.
        /// </summary>
        [Input("lastUpdateTime")]
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    public class DeploymentListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1Beta1.DeploymentArgs>? _items;

        /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
        public InputList<Apps.V1Beta1.DeploymentArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1Beta1.DeploymentArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
    /// </summary>
    public class DeploymentRollbackArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required: This must match the Name of a deployment.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// The config of this deployment rollback.
        /// </summary>
        [Input("rollbackTo", required: true)]
        public Input<Apps.V1Beta1.RollbackConfigArgs> RollbackTo { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        [Input("updatedAnnotations")]
        private InputMap<string>? _updatedAnnotations;

        /// <summary>
        /// The annotations to be updated to a deployment
        /// </summary>
        public InputMap<string> UpdatedAnnotations
        {
            get => _updatedAnnotations ?? (_updatedAnnotations = new InputMap<string>());
            set => _updatedAnnotations = value;
        }

    }

    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    public class DeploymentSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Indicates that the deployment is paused.
        /// </summary>
        [Input("paused")]
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// Defaults to 600s.
        /// </summary>
        [Input("progressDeadlineSeconds")]
        public Input<int>? ProgressDeadlineSeconds { get; set; }

        /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. Defaults to 2.
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// DEPRECATED. The config this deployment is rolling back to. Will be cleared after
        /// rollback is done.
        /// </summary>
        [Input("rollbackTo")]
        public Input<Apps.V1Beta1.RollbackConfigArgs>? RollbackTo { get; set; }

        /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

        /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
        [Input("strategy")]
        public Input<Apps.V1Beta1.DeploymentStrategyArgs>? Strategy { get; set; }

    }

    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    public class DeploymentStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
        [Input("availableReplicas")]
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1Beta1.DeploymentConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
        public InputList<Apps.V1Beta1.DeploymentConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1Beta1.DeploymentConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
        [Input("unavailableReplicas")]
        public Input<int>? UnavailableReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
        [Input("updatedReplicas")]
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    public class DeploymentStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Apps.V1Beta1.RollingUpdateDeploymentArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// DEPRECATED.
    /// </summary>
    public class RollbackConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The revision to rollback to. If set to 0, rollback to the last revision.
        /// </summary>
        [Input("revision")]
        public Input<int>? Revision { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    public class RollingUpdateDeploymentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can
        /// be scaled up immediately when the rolling update starts, such that the total number of
        /// old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new
        /// ReplicaSet can be scaled up further, ensuring that total number of pods running at any
        /// time during the update is at most 130% of desired pods.
        /// </summary>
        [Input("maxSurge")]
        public InputUnion<int,string>? MaxSurge { get; set; }

        /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0.
        /// Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down
        /// to 70% of desired pods immediately when the rolling update starts. Once new pods are
        /// ready, old ReplicaSet can be scaled down further, followed by scaling up the new
        /// ReplicaSet, ensuring that the total number of pods available at all times during the
        /// update is at least 70% of desired pods.
        /// </summary>
        [Input("maxUnavailable")]
        public InputUnion<int,string>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// RollingUpdateStatefulSetStrategy is used to communicate parameter for
    /// RollingUpdateStatefulSetStrategyType.
    /// </summary>
    public class RollingUpdateStatefulSetStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Partition indicates the ordinal at which the StatefulSet should be partitioned.
        /// </summary>
        [Input("partition")]
        public Input<int>? Partition { get; set; }

    }

    /// <summary>
    /// Scale represents a scaling request for a resource.
    /// </summary>
    public class ScaleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1Beta1.ScaleSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// ScaleSpec describes the attributes of a scale subresource
    /// </summary>
    public class ScaleSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

    }

    /// <summary>
    /// ScaleStatus represents the current status of a scale subresource.
    /// </summary>
    public class ScaleStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        [Input("selector")]
        private InputMap<string>? _selector;

        /// <summary>
        /// label query over pods that should match the replicas count. More info:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
        public InputMap<string> Selector
        {
            get => _selector ?? (_selector = new InputMap<string>());
            set => _selector = value;
        }

        /// <summary>
        /// label selector for pods that should match the replicas count. This is a serializated
        /// version of both map-based and more expressive set-based selectors. This is done to avoid
        /// introspection in the clients. The string will be in the same format as the query-param
        /// syntax. If the target type only supports map-based selectors, both this field and
        /// map-based selector field are populated. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("targetSelector")]
        public Input<string>? TargetSelector { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta1/StatefulSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/StatefulSet instead.
    /// 
    /// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
    ///  - Network: A single stable DNS and hostname.
    ///  - Storage: As many VolumeClaims as requested.
    /// The StatefulSet guarantees that a given network identity will always map to the same storage
    /// identity.
    /// </summary>
    public class StatefulSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired identities of pods in this set.
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1Beta1.StatefulSetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// StatefulSetCondition describes the state of a statefulset at a certain point.
    /// </summary>
    public class StatefulSetConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of statefulset condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatefulSetList is a collection of StatefulSets.
    /// </summary>
    public class StatefulSetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1Beta1.StatefulSetArgs>? _items;

        
        public InputList<Apps.V1Beta1.StatefulSetArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1Beta1.StatefulSetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// A StatefulSetSpec is the specification of a StatefulSet.
    /// </summary>
    public class StatefulSetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// serviceName is the name of the service that governs this StatefulSet. This service must
        /// exist before the StatefulSet, and is responsible for the network identity of the set.
        /// Pods get DNS/hostnames that follow the pattern:
        /// pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
        /// managed by the StatefulSet controller.
        /// </summary>
        [Input("serviceName", required: true)]
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. Each pod stamped out by the StatefulSet will fulfill this
        /// Template, but have a unique identity from the rest of the StatefulSet.
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// podManagementPolicy controls how pods are created during initial scale up, when
        /// replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`,
        /// where pods are created in increasing order (pod-0, then pod-1, etc) and the controller
        /// will wait until each pod is ready before continuing. When scaling down, the pods are
        /// removed in the opposite order. The alternative policy is `Parallel` which will create
        /// pods in parallel to match the desired scale without waiting, and on scale down will
        /// delete all pods at once.
        /// </summary>
        [Input("podManagementPolicy")]
        public Input<string>? PodManagementPolicy { get; set; }

        /// <summary>
        /// replicas is the desired number of replicas of the given Template. These are replicas in
        /// the sense that they are instantiations of the same Template, but individual replicas
        /// also have a consistent identity. If unspecified, defaults to 1.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the
        /// StatefulSet's revision history. The revision history consists of all revisions not
        /// represented by a currently applied StatefulSetSpec version. The default value is 10.
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// selector is a label query over pods that should match the replica count. If empty,
        /// defaulted to labels on the pod template. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

        /// <summary>
        /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update
        /// Pods in the StatefulSet when a revision is made to Template.
        /// </summary>
        [Input("updateStrategy")]
        public Input<Apps.V1Beta1.StatefulSetUpdateStrategyArgs>? UpdateStrategy { get; set; }

        [Input("volumeClaimTemplates")]
        private InputList<Core.V1.PersistentVolumeClaimArgs>? _volumeClaimTemplates;

        /// <summary>
        /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The
        /// StatefulSet controller is responsible for mapping network identities to claims in a way
        /// that maintains the identity of a pod. Every claim in this list must have at least one
        /// matching (by name) volumeMount in one container in the template. A claim in this list
        /// takes precedence over any volumes in the template, with the same name.
        /// </summary>
        public InputList<Core.V1.PersistentVolumeClaimArgs> VolumeClaimTemplates
        {
            get => _volumeClaimTemplates ?? (_volumeClaimTemplates = new InputList<Core.V1.PersistentVolumeClaimArgs>());
            set => _volumeClaimTemplates = value;
        }

    }

    /// <summary>
    /// StatefulSetStatus represents the current state of a StatefulSet.
    /// </summary>
    public class StatefulSetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// replicas is the number of Pods created by the StatefulSet controller.
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet
        /// controller uses this field as a collision avoidance mechanism when it needs to create
        /// the name for the newest ControllerRevision.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1Beta1.StatefulSetConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a statefulset's current state.
        /// </summary>
        public InputList<Apps.V1Beta1.StatefulSetConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1Beta1.StatefulSetConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// currentReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by currentRevision.
        /// </summary>
        [Input("currentReplicas")]
        public Input<int>? CurrentReplicas { get; set; }

        /// <summary>
        /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [0,currentReplicas).
        /// </summary>
        [Input("currentRevision")]
        public Input<string>? CurrentRevision { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed for this StatefulSet. It
        /// corresponds to the StatefulSet's generation, which is updated on mutation by the API
        /// Server.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// readyReplicas is the number of Pods created by the StatefulSet controller that have a
        /// Ready Condition.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [replicas-updatedReplicas,replicas)
        /// </summary>
        [Input("updateRevision")]
        public Input<string>? UpdateRevision { get; set; }

        /// <summary>
        /// updatedReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by updateRevision.
        /// </summary>
        [Input("updatedReplicas")]
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
    /// perform updates. It includes any additional parameters necessary to perform the update for
    /// the indicated strategy.
    /// </summary>
    public class StatefulSetUpdateStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RollingUpdate is used to communicate parameters when Type is
        /// RollingUpdateStatefulSetStrategyType.
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Apps.V1Beta1.RollingUpdateStatefulSetStrategyArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type indicates the type of the StatefulSetUpdateStrategy.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

  }

  namespace V1Beta2
  {
    /// <summary>
    /// DEPRECATED - apps/v1beta2/ControllerRevision is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/ControllerRevision instead.
    /// 
    /// ControllerRevision implements an immutable snapshot of state data. Clients are responsible
    /// for serializing and deserializing the objects that contain their internal state. Once a
    /// ControllerRevision has been successfully created, it can not be updated. The API Server will
    /// fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
    /// may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
    /// controllers for update and rollback, this object is beta. However, it may be subject to name
    /// and representation changes in future releases, and clients should not depend on its
    /// stability. It is primarily for internal use by controllers.
    /// </summary>
    public class ControllerRevisionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Revision indicates the revision of the state represented by Data.
        /// </summary>
        [Input("revision", required: true)]
        public Input<int> Revision { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Data is the serialized representation of the state.
        /// </summary>
        [Input("data")]
        public Input<string>? Data { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
    /// </summary>
    public class ControllerRevisionListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1Beta2.ControllerRevisionArgs>? _items;

        /// <summary>
        /// Items is the list of ControllerRevisions
        /// </summary>
        public InputList<Apps.V1Beta2.ControllerRevisionArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1Beta2.ControllerRevisionArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta2/DaemonSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/DaemonSet instead.
    /// 
    /// DaemonSet represents the configuration of a daemon set.
    /// </summary>
    public class DaemonSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// The desired behavior of this daemon set. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1Beta2.DaemonSetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// DaemonSetCondition describes the state of a DaemonSet at a certain point.
    /// </summary>
    public class DaemonSetConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of DaemonSet condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DaemonSetList is a collection of daemon sets.
    /// </summary>
    public class DaemonSetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1Beta2.DaemonSetArgs>? _items;

        /// <summary>
        /// A list of daemon sets.
        /// </summary>
        public InputList<Apps.V1Beta2.DaemonSetArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1Beta2.DaemonSetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DaemonSetSpec is the specification of a daemon set.
    /// </summary>
    public class DaemonSetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A label query over pods that are managed by the daemon set. Must match in order to be
        /// controlled. It must match the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> Selector { get; set; } = null!;

        /// <summary>
        /// An object that describes the pod that will be created. The DaemonSet will create exactly
        /// one copy of this pod on every node that matches the template's node selector (or on
        /// every node if no node selector is specified). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// The minimum number of seconds for which a newly created DaemonSet pod should be ready
        /// without any of its container crashing, for it to be considered available. Defaults to 0
        /// (pod will be considered available as soon as it is ready).
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// The number of old history to retain to allow rollback. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 10.
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// An update strategy to replace existing DaemonSet pods with new pods.
        /// </summary>
        [Input("updateStrategy")]
        public Input<Apps.V1Beta2.DaemonSetUpdateStrategyArgs>? UpdateStrategy { get; set; }

    }

    /// <summary>
    /// DaemonSetStatus represents the current status of a daemon set.
    /// </summary>
    public class DaemonSetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The number of nodes that are running at least 1 daemon pod and are supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        [Input("currentNumberScheduled", required: true)]
        public Input<int> CurrentNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The total number of nodes that should be running the daemon pod (including nodes
        /// correctly running the daemon pod). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        [Input("desiredNumberScheduled", required: true)]
        public Input<int> DesiredNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that are running the daemon pod, but are not supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        [Input("numberMisscheduled", required: true)]
        public Input<int> NumberMisscheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and ready.
        /// </summary>
        [Input("numberReady", required: true)]
        public Input<int> NumberReady { get; set; } = null!;

        /// <summary>
        /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as
        /// a collision avoidance mechanism when it needs to create the name for the newest
        /// ControllerRevision.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1Beta2.DaemonSetConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a DaemonSet's current state.
        /// </summary>
        public InputList<Apps.V1Beta2.DaemonSetConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1Beta2.DaemonSetConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        [Input("numberAvailable")]
        public Input<int>? NumberAvailable { get; set; }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have none of the daemon
        /// pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        [Input("numberUnavailable")]
        public Input<int>? NumberUnavailable { get; set; }

        /// <summary>
        /// The most recent generation observed by the daemon set controller.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The total number of nodes that are running updated daemon pod
        /// </summary>
        [Input("updatedNumberScheduled")]
        public Input<int>? UpdatedNumberScheduled { get; set; }

    }

    /// <summary>
    /// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
    /// </summary>
    public class DaemonSetUpdateStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Rolling update config params. Present only if type = "RollingUpdate".
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Apps.V1Beta2.RollingUpdateDaemonSetArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is
        /// RollingUpdate.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta2/Deployment is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/Deployment instead.
    /// 
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    public class DeploymentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1Beta2.DeploymentSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    public class DeploymentConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of deployment condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// The last time this condition was updated.
        /// </summary>
        [Input("lastUpdateTime")]
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    public class DeploymentListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1Beta2.DeploymentArgs>? _items;

        /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
        public InputList<Apps.V1Beta2.DeploymentArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1Beta2.DeploymentArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    public class DeploymentSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment. It must match the pod template's labels.
        /// </summary>
        [Input("selector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> Selector { get; set; } = null!;

        /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Indicates that the deployment is paused.
        /// </summary>
        [Input("paused")]
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// Defaults to 600s.
        /// </summary>
        [Input("progressDeadlineSeconds")]
        public Input<int>? ProgressDeadlineSeconds { get; set; }

        /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. Defaults to 10.
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
        [Input("strategy")]
        public Input<Apps.V1Beta2.DeploymentStrategyArgs>? Strategy { get; set; }

    }

    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    public class DeploymentStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
        [Input("availableReplicas")]
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1Beta2.DeploymentConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
        public InputList<Apps.V1Beta2.DeploymentConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1Beta2.DeploymentConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
        [Input("unavailableReplicas")]
        public Input<int>? UnavailableReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
        [Input("updatedReplicas")]
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    public class DeploymentStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Apps.V1Beta2.RollingUpdateDeploymentArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta2/ReplicaSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/ReplicaSet instead.
    /// 
    /// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
    /// </summary>
    public class ReplicaSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
        /// that the ReplicaSet manages. Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the specification of the desired behavior of the ReplicaSet. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1Beta2.ReplicaSetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// ReplicaSetCondition describes the state of a replica set at a certain point.
    /// </summary>
    public class ReplicaSetConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of replica set condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ReplicaSetList is a collection of ReplicaSets.
    /// </summary>
    public class ReplicaSetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1Beta2.ReplicaSetArgs>? _items;

        /// <summary>
        /// List of ReplicaSets. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
        public InputList<Apps.V1Beta2.ReplicaSetArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1Beta2.ReplicaSetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ReplicaSetSpec is the specification of a ReplicaSet.
    /// </summary>
    public class ReplicaSetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Selector is a label query over pods that should match the replica count. Label keys and
        /// values that must match in order to be controlled by this replica set. It must match the
        /// pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> Selector { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        [Input("template")]
        public Input<Core.V1.PodTemplateSpecArgs>? Template { get; set; }

    }

    /// <summary>
    /// ReplicaSetStatus represents the current status of a ReplicaSet.
    /// </summary>
    public class ReplicaSetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this replica
        /// set.
        /// </summary>
        [Input("availableReplicas")]
        public Input<int>? AvailableReplicas { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1Beta2.ReplicaSetConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a replica set's current state.
        /// </summary>
        public InputList<Apps.V1Beta2.ReplicaSetConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1Beta2.ReplicaSetConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replicaset.
        /// </summary>
        [Input("fullyLabeledReplicas")]
        public Input<int>? FullyLabeledReplicas { get; set; }

        /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The number of ready replicas for this replica set.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of daemon set rolling update.
    /// </summary>
    public class RollingUpdateDaemonSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The maximum number of DaemonSet pods that can be unavailable during the update. Value
        /// can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at
        /// the start of the update (ex: 10%). Absolute number is calculated from percentage by
        /// rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at
        /// most 30% of the total number of nodes that should be running the daemon pod (i.e.
        /// status.desiredNumberScheduled) can have their pods stopped for an update at any given
        /// time. The update starts by stopping at most 30% of those DaemonSet pods and then brings
        /// up new DaemonSet pods in their place. Once the new pods are available, it then proceeds
        /// onto other DaemonSet pods, thus ensuring that at least 70% of original number of
        /// DaemonSet pods are available at all times during the update.
        /// </summary>
        [Input("maxUnavailable")]
        public InputUnion<int,string>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    public class RollingUpdateDeploymentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can
        /// be scaled up immediately when the rolling update starts, such that the total number of
        /// old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new
        /// ReplicaSet can be scaled up further, ensuring that total number of pods running at any
        /// time during the update is at most 130% of desired pods.
        /// </summary>
        [Input("maxSurge")]
        public InputUnion<int,string>? MaxSurge { get; set; }

        /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0.
        /// Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down
        /// to 70% of desired pods immediately when the rolling update starts. Once new pods are
        /// ready, old ReplicaSet can be scaled down further, followed by scaling up the new
        /// ReplicaSet, ensuring that the total number of pods available at all times during the
        /// update is at least 70% of desired pods.
        /// </summary>
        [Input("maxUnavailable")]
        public InputUnion<int,string>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// RollingUpdateStatefulSetStrategy is used to communicate parameter for
    /// RollingUpdateStatefulSetStrategyType.
    /// </summary>
    public class RollingUpdateStatefulSetStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default
        /// value is 0.
        /// </summary>
        [Input("partition")]
        public Input<int>? Partition { get; set; }

    }

    /// <summary>
    /// Scale represents a scaling request for a resource.
    /// </summary>
    public class ScaleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1Beta2.ScaleSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// ScaleSpec describes the attributes of a scale subresource
    /// </summary>
    public class ScaleSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

    }

    /// <summary>
    /// ScaleStatus represents the current status of a scale subresource.
    /// </summary>
    public class ScaleStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        [Input("selector")]
        private InputMap<string>? _selector;

        /// <summary>
        /// label query over pods that should match the replicas count. More info:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
        public InputMap<string> Selector
        {
            get => _selector ?? (_selector = new InputMap<string>());
            set => _selector = value;
        }

        /// <summary>
        /// label selector for pods that should match the replicas count. This is a serializated
        /// version of both map-based and more expressive set-based selectors. This is done to avoid
        /// introspection in the clients. The string will be in the same format as the query-param
        /// syntax. If the target type only supports map-based selectors, both this field and
        /// map-based selector field are populated. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("targetSelector")]
        public Input<string>? TargetSelector { get; set; }

    }

    /// <summary>
    /// DEPRECATED - apps/v1beta2/StatefulSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/StatefulSet instead.
    /// 
    /// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
    ///  - Network: A single stable DNS and hostname.
    ///  - Storage: As many VolumeClaims as requested.
    /// The StatefulSet guarantees that a given network identity will always map to the same storage
    /// identity.
    /// </summary>
    public class StatefulSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired identities of pods in this set.
        /// </summary>
        [Input("spec")]
        public Input<Apps.V1Beta2.StatefulSetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// StatefulSetCondition describes the state of a statefulset at a certain point.
    /// </summary>
    public class StatefulSetConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of statefulset condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatefulSetList is a collection of StatefulSets.
    /// </summary>
    public class StatefulSetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Apps.V1Beta2.StatefulSetArgs>? _items;

        
        public InputList<Apps.V1Beta2.StatefulSetArgs> Items
        {
            get => _items ?? (_items = new InputList<Apps.V1Beta2.StatefulSetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// A StatefulSetSpec is the specification of a StatefulSet.
    /// </summary>
    public class StatefulSetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// selector is a label query over pods that should match the replica count. It must match
        /// the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> Selector { get; set; } = null!;

        /// <summary>
        /// serviceName is the name of the service that governs this StatefulSet. This service must
        /// exist before the StatefulSet, and is responsible for the network identity of the set.
        /// Pods get DNS/hostnames that follow the pattern:
        /// pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
        /// managed by the StatefulSet controller.
        /// </summary>
        [Input("serviceName", required: true)]
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. Each pod stamped out by the StatefulSet will fulfill this
        /// Template, but have a unique identity from the rest of the StatefulSet.
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// podManagementPolicy controls how pods are created during initial scale up, when
        /// replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`,
        /// where pods are created in increasing order (pod-0, then pod-1, etc) and the controller
        /// will wait until each pod is ready before continuing. When scaling down, the pods are
        /// removed in the opposite order. The alternative policy is `Parallel` which will create
        /// pods in parallel to match the desired scale without waiting, and on scale down will
        /// delete all pods at once.
        /// </summary>
        [Input("podManagementPolicy")]
        public Input<string>? PodManagementPolicy { get; set; }

        /// <summary>
        /// replicas is the desired number of replicas of the given Template. These are replicas in
        /// the sense that they are instantiations of the same Template, but individual replicas
        /// also have a consistent identity. If unspecified, defaults to 1.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the
        /// StatefulSet's revision history. The revision history consists of all revisions not
        /// represented by a currently applied StatefulSetSpec version. The default value is 10.
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update
        /// Pods in the StatefulSet when a revision is made to Template.
        /// </summary>
        [Input("updateStrategy")]
        public Input<Apps.V1Beta2.StatefulSetUpdateStrategyArgs>? UpdateStrategy { get; set; }

        [Input("volumeClaimTemplates")]
        private InputList<Core.V1.PersistentVolumeClaimArgs>? _volumeClaimTemplates;

        /// <summary>
        /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The
        /// StatefulSet controller is responsible for mapping network identities to claims in a way
        /// that maintains the identity of a pod. Every claim in this list must have at least one
        /// matching (by name) volumeMount in one container in the template. A claim in this list
        /// takes precedence over any volumes in the template, with the same name.
        /// </summary>
        public InputList<Core.V1.PersistentVolumeClaimArgs> VolumeClaimTemplates
        {
            get => _volumeClaimTemplates ?? (_volumeClaimTemplates = new InputList<Core.V1.PersistentVolumeClaimArgs>());
            set => _volumeClaimTemplates = value;
        }

    }

    /// <summary>
    /// StatefulSetStatus represents the current state of a StatefulSet.
    /// </summary>
    public class StatefulSetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// replicas is the number of Pods created by the StatefulSet controller.
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet
        /// controller uses this field as a collision avoidance mechanism when it needs to create
        /// the name for the newest ControllerRevision.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Apps.V1Beta2.StatefulSetConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a statefulset's current state.
        /// </summary>
        public InputList<Apps.V1Beta2.StatefulSetConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Apps.V1Beta2.StatefulSetConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// currentReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by currentRevision.
        /// </summary>
        [Input("currentReplicas")]
        public Input<int>? CurrentReplicas { get; set; }

        /// <summary>
        /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [0,currentReplicas).
        /// </summary>
        [Input("currentRevision")]
        public Input<string>? CurrentRevision { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed for this StatefulSet. It
        /// corresponds to the StatefulSet's generation, which is updated on mutation by the API
        /// Server.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// readyReplicas is the number of Pods created by the StatefulSet controller that have a
        /// Ready Condition.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [replicas-updatedReplicas,replicas)
        /// </summary>
        [Input("updateRevision")]
        public Input<string>? UpdateRevision { get; set; }

        /// <summary>
        /// updatedReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by updateRevision.
        /// </summary>
        [Input("updatedReplicas")]
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
    /// perform updates. It includes any additional parameters necessary to perform the update for
    /// the indicated strategy.
    /// </summary>
    public class StatefulSetUpdateStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RollingUpdate is used to communicate parameters when Type is
        /// RollingUpdateStatefulSetStrategyType.
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Apps.V1Beta2.RollingUpdateStatefulSetStrategyArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.AuditRegistraion
{
  namespace V1Alpha1
  {
    /// <summary>
    /// AuditSink represents a cluster level audit sink
    /// </summary>
    public class AuditSinkArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the audit configuration spec
        /// </summary>
        [Input("spec")]
        public Input<AuditRegistraion.V1Alpha1.AuditSinkSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// AuditSinkList is a list of AuditSink items.
    /// </summary>
    public class AuditSinkListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<AuditRegistraion.V1Alpha1.AuditSinkArgs>? _items;

        /// <summary>
        /// List of audit configurations.
        /// </summary>
        public InputList<AuditRegistraion.V1Alpha1.AuditSinkArgs> Items
        {
            get => _items ?? (_items = new InputList<AuditRegistraion.V1Alpha1.AuditSinkArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// AuditSinkSpec holds the spec for the audit sink
    /// </summary>
    public class AuditSinkSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Policy defines the policy for selecting which events should be sent to the webhook
        /// required
        /// </summary>
        [Input("policy", required: true)]
        public Input<AuditRegistraion.V1Alpha1.PolicyArgs> Policy { get; set; } = null!;

        /// <summary>
        /// Webhook to send events required
        /// </summary>
        [Input("webhook", required: true)]
        public Input<AuditRegistraion.V1Alpha1.WebhookArgs> Webhook { get; set; } = null!;

    }

    /// <summary>
    /// Policy defines the configuration of how audit events are logged
    /// </summary>
    public class PolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Level that all requests are recorded at. available options: None, Metadata, Request,
        /// RequestResponse required
        /// </summary>
        [Input("level", required: true)]
        public Input<string> Level { get; set; } = null!;

        [Input("stages")]
        private InputList<string>? _stages;

        /// <summary>
        /// Stages is a list of stages for which events are created.
        /// </summary>
        public InputList<string> Stages
        {
            get => _stages ?? (_stages = new InputList<string>());
            set => _stages = value;
        }

    }

    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    public class ServiceReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// `name` is the name of the service. Required
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// `namespace` is the namespace of the service. Required
        /// </summary>
        [Input("namespace", required: true)]
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// `path` is an optional URL path which will be sent in any request to this service.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

    }

    /// <summary>
    /// Webhook holds the configuration of the webhook
    /// </summary>
    public class WebhookArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ClientConfig holds the connection parameters for the webhook required
        /// </summary>
        [Input("clientConfig", required: true)]
        public Input<AuditRegistraion.V1Alpha1.WebhookClientConfigArgs> ClientConfig { get; set; } = null!;

        /// <summary>
        /// Throttle holds the options for throttling the webhook
        /// </summary>
        [Input("throttle")]
        public Input<AuditRegistraion.V1Alpha1.WebhookThrottleConfigArgs>? Throttle { get; set; }

    }

    /// <summary>
    /// WebhookClientConfig contains the information to make a connection with the webhook
    /// </summary>
    public class WebhookClientConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's
        /// server certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
        [Input("caBundle")]
        public Input<string>? CaBundle { get; set; }

        /// <summary>
        /// `service` is a reference to the service for this webhook. Either `service` or `url` must
        /// be specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
        [Input("service")]
        public Input<AuditRegistraion.V1Alpha1.ServiceReferenceArgs>? Service { get; set; }

        /// <summary>
        /// `url` gives the location of the webhook, in standard URL form
        /// (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
        [Input("url")]
        public Input<string>? Url { get; set; }

    }

    /// <summary>
    /// WebhookThrottleConfig holds the configuration for throttling events
    /// </summary>
    public class WebhookThrottleConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ThrottleBurst is the maximum number of events sent at the same moment default 15 QPS
        /// </summary>
        [Input("burst")]
        public Input<int>? Burst { get; set; }

        /// <summary>
        /// ThrottleQPS maximum number of batches per second default 10 QPS
        /// </summary>
        [Input("qps")]
        public Input<int>? Qps { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Authentication
{
  namespace V1
  {
    /// <summary>
    /// BoundObjectReference is a reference to an object that a token is bound to.
    /// </summary>
    public class BoundObjectReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// API version of the referent.
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind of the referent. Valid kinds are 'Pod' and 'Secret'.
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Name of the referent.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// UID of the referent.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// TokenRequest requests a token for a given service account.
    /// </summary>
    public class TokenRequestArgs : Pulumi.ResourceArgs
    {
        
        [Input("spec", required: true)]
        public Input<Authentication.V1.TokenRequestSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// TokenRequestSpec contains client provided parameters of a token request.
    /// </summary>
    public class TokenRequestSpecArgs : Pulumi.ResourceArgs
    {
        [Input("audiences", required: true)]
        private InputList<string>? _audiences;

        /// <summary>
        /// Audiences are the intendend audiences of the token. A recipient of a token must
        /// identitfy themself with an identifier in the list of audiences of the token, and
        /// otherwise should reject the token. A token issued for multiple audiences may be used to
        /// authenticate against any of the audiences listed but implies a high degree of trust
        /// between the target audiences.
        /// </summary>
        public InputList<string> Audiences
        {
            get => _audiences ?? (_audiences = new InputList<string>());
            set => _audiences = value;
        }

        /// <summary>
        /// BoundObjectRef is a reference to an object that the token will be bound to. The token
        /// will only be valid for as long as the bound object exists. NOTE: The API server's
        /// TokenReview endpoint will validate the BoundObjectRef, but other audiences may not. Keep
        /// ExpirationSeconds small if you want prompt revocation.
        /// </summary>
        [Input("boundObjectRef")]
        public Input<Authentication.V1.BoundObjectReferenceArgs>? BoundObjectRef { get; set; }

        /// <summary>
        /// ExpirationSeconds is the requested duration of validity of the request. The token issuer
        /// may return a token with a different validity duration so a client needs to check the
        /// 'expiration' field in a response.
        /// </summary>
        [Input("expirationSeconds")]
        public Input<int>? ExpirationSeconds { get; set; }

    }

    /// <summary>
    /// TokenRequestStatus is the result of a token request.
    /// </summary>
    public class TokenRequestStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ExpirationTimestamp is the time of expiration of the returned token.
        /// </summary>
        [Input("expirationTimestamp", required: true)]
        public Input<string> ExpirationTimestamp { get; set; } = null!;

        /// <summary>
        /// Token is the opaque bearer token.
        /// </summary>
        [Input("token", required: true)]
        public Input<string> Token { get; set; } = null!;

    }

    /// <summary>
    /// TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may
    /// be cached by the webhook token authenticator plugin in the kube-apiserver.
    /// </summary>
    public class TokenReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authentication.V1.TokenReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// TokenReviewSpec is a description of the token authentication request.
    /// </summary>
    public class TokenReviewSpecArgs : Pulumi.ResourceArgs
    {
        [Input("audiences")]
        private InputList<string>? _audiences;

        /// <summary>
        /// Audiences is a list of the identifiers that the resource server presented with the token
        /// identifies as. Audience-aware token authenticators will verify that the token was
        /// intended for at least one of the audiences in this list. If no audiences are provided,
        /// the audience will default to the audience of the Kubernetes apiserver.
        /// </summary>
        public InputList<string> Audiences
        {
            get => _audiences ?? (_audiences = new InputList<string>());
            set => _audiences = value;
        }

        /// <summary>
        /// Token is the opaque bearer token.
        /// </summary>
        [Input("token")]
        public Input<string>? Token { get; set; }

    }

    /// <summary>
    /// TokenReviewStatus is the result of the token authentication request.
    /// </summary>
    public class TokenReviewStatusArgs : Pulumi.ResourceArgs
    {
        [Input("audiences")]
        private InputList<string>? _audiences;

        /// <summary>
        /// Audiences are audience identifiers chosen by the authenticator that are compatible with
        /// both the TokenReview and token. An identifier is any identifier in the intersection of
        /// the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API
        /// that sets the spec.audiences field should validate that a compatible audience identifier
        /// is returned in the status.audiences field to ensure that the TokenReview server is
        /// audience aware. If a TokenReview returns an empty status.audience field where
        /// status.authenticated is "true", the token is valid against the audience of the
        /// Kubernetes API server.
        /// </summary>
        public InputList<string> Audiences
        {
            get => _audiences ?? (_audiences = new InputList<string>());
            set => _audiences = value;
        }

        /// <summary>
        /// Authenticated indicates that the token was associated with a known user.
        /// </summary>
        [Input("authenticated")]
        public Input<bool>? Authenticated { get; set; }

        /// <summary>
        /// Error indicates that the token couldn't be checked
        /// </summary>
        [Input("error")]
        public Input<string>? Error { get; set; }

        /// <summary>
        /// User is the UserInfo associated with the provided token.
        /// </summary>
        [Input("user")]
        public Input<Authentication.V1.UserInfoArgs>? User { get; set; }

    }

    /// <summary>
    /// UserInfo holds the information about the user needed to implement the user.Info interface.
    /// </summary>
    public class UserInfoArgs : Pulumi.ResourceArgs
    {
        [Input("extra")]
        private InputMap<InputList<string>>? _extra;

        /// <summary>
        /// Any additional information provided by the authenticator.
        /// </summary>
        public InputMap<InputList<string>> Extra
        {
            get => _extra ?? (_extra = new InputMap<InputList<string>>());
            set => _extra = value;
        }

        [Input("groups")]
        private InputList<string>? _groups;

        /// <summary>
        /// The names of groups this user is a part of.
        /// </summary>
        public InputList<string> Groups
        {
            get => _groups ?? (_groups = new InputList<string>());
            set => _groups = value;
        }

        /// <summary>
        /// A unique value that identifies this user across time. If this user is deleted and
        /// another user by the same name is added, they will have different UIDs.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// The name that uniquely identifies this user among all active users.
        /// </summary>
        [Input("username")]
        public Input<string>? Username { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may
    /// be cached by the webhook token authenticator plugin in the kube-apiserver.
    /// </summary>
    public class TokenReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authentication.V1Beta1.TokenReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// TokenReviewSpec is a description of the token authentication request.
    /// </summary>
    public class TokenReviewSpecArgs : Pulumi.ResourceArgs
    {
        [Input("audiences")]
        private InputList<string>? _audiences;

        /// <summary>
        /// Audiences is a list of the identifiers that the resource server presented with the token
        /// identifies as. Audience-aware token authenticators will verify that the token was
        /// intended for at least one of the audiences in this list. If no audiences are provided,
        /// the audience will default to the audience of the Kubernetes apiserver.
        /// </summary>
        public InputList<string> Audiences
        {
            get => _audiences ?? (_audiences = new InputList<string>());
            set => _audiences = value;
        }

        /// <summary>
        /// Token is the opaque bearer token.
        /// </summary>
        [Input("token")]
        public Input<string>? Token { get; set; }

    }

    /// <summary>
    /// TokenReviewStatus is the result of the token authentication request.
    /// </summary>
    public class TokenReviewStatusArgs : Pulumi.ResourceArgs
    {
        [Input("audiences")]
        private InputList<string>? _audiences;

        /// <summary>
        /// Audiences are audience identifiers chosen by the authenticator that are compatible with
        /// both the TokenReview and token. An identifier is any identifier in the intersection of
        /// the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API
        /// that sets the spec.audiences field should validate that a compatible audience identifier
        /// is returned in the status.audiences field to ensure that the TokenReview server is
        /// audience aware. If a TokenReview returns an empty status.audience field where
        /// status.authenticated is "true", the token is valid against the audience of the
        /// Kubernetes API server.
        /// </summary>
        public InputList<string> Audiences
        {
            get => _audiences ?? (_audiences = new InputList<string>());
            set => _audiences = value;
        }

        /// <summary>
        /// Authenticated indicates that the token was associated with a known user.
        /// </summary>
        [Input("authenticated")]
        public Input<bool>? Authenticated { get; set; }

        /// <summary>
        /// Error indicates that the token couldn't be checked
        /// </summary>
        [Input("error")]
        public Input<string>? Error { get; set; }

        /// <summary>
        /// User is the UserInfo associated with the provided token.
        /// </summary>
        [Input("user")]
        public Input<Authentication.V1Beta1.UserInfoArgs>? User { get; set; }

    }

    /// <summary>
    /// UserInfo holds the information about the user needed to implement the user.Info interface.
    /// </summary>
    public class UserInfoArgs : Pulumi.ResourceArgs
    {
        [Input("extra")]
        private InputMap<InputList<string>>? _extra;

        /// <summary>
        /// Any additional information provided by the authenticator.
        /// </summary>
        public InputMap<InputList<string>> Extra
        {
            get => _extra ?? (_extra = new InputMap<InputList<string>>());
            set => _extra = value;
        }

        [Input("groups")]
        private InputList<string>? _groups;

        /// <summary>
        /// The names of groups this user is a part of.
        /// </summary>
        public InputList<string> Groups
        {
            get => _groups ?? (_groups = new InputList<string>());
            set => _groups = value;
        }

        /// <summary>
        /// A unique value that identifies this user across time. If this user is deleted and
        /// another user by the same name is added, they will have different UIDs.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// The name that uniquely identifies this user among all active users.
        /// </summary>
        [Input("username")]
        public Input<string>? Username { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Authorization
{
  namespace V1
  {
    /// <summary>
    /// LocalSubjectAccessReview checks whether or not a user or group can perform an action in a
    /// given namespace. Having a namespace scoped resource makes it much easier to grant namespace
    /// scoped policy that includes permissions checking.
    /// </summary>
    public class LocalSubjectAccessReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated.  spec.namespace must be equal
        /// to the namespace you made the request against.  If empty, it is defaulted.
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authorization.V1.SubjectAccessReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// NonResourceAttributes includes the authorization attributes available for non-resource
    /// requests to the Authorizer interface
    /// </summary>
    public class NonResourceAttributesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Path is the URL path of the request
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Verb is the standard HTTP verb
        /// </summary>
        [Input("verb")]
        public Input<string>? Verb { get; set; }

    }

    /// <summary>
    /// NonResourceRule holds information that describes a rule for the non-resource
    /// </summary>
    public class NonResourceRuleArgs : Pulumi.ResourceArgs
    {
        [Input("verbs", required: true)]
        private InputList<string>? _verbs;

        /// <summary>
        /// Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete,
        /// patch, head, options.  "*" means all.
        /// </summary>
        public InputList<string> Verbs
        {
            get => _verbs ?? (_verbs = new InputList<string>());
            set => _verbs = value;
        }

        [Input("nonResourceURLs")]
        private InputList<string>? _nonResourceURLs;

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path.  "*" means all.
        /// </summary>
        public InputList<string> NonResourceURLs
        {
            get => _nonResourceURLs ?? (_nonResourceURLs = new InputList<string>());
            set => _nonResourceURLs = value;
        }

    }

    /// <summary>
    /// ResourceAttributes includes the authorization attributes available for resource requests to
    /// the Authorizer interface
    /// </summary>
    public class ResourceAttributesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Group is the API Group of the Resource.  "*" means all.
        /// </summary>
        [Input("group")]
        public Input<string>? Group { get; set; }

        /// <summary>
        /// Name is the name of the resource being requested for a "get" or deleted for a "delete".
        /// "" (empty) means all.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace is the namespace of the action being requested.  Currently, there is no
        /// distinction between no namespace and all namespaces "" (empty) is defaulted for
        /// LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty)
        /// means "all" for namespace scoped resources from a SubjectAccessReview or
        /// SelfSubjectAccessReview
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Resource is one of the existing resource types.  "*" means all.
        /// </summary>
        [Input("resource")]
        public Input<string>? Resource { get; set; }

        /// <summary>
        /// Subresource is one of the existing resource types.  "" means none.
        /// </summary>
        [Input("subresource")]
        public Input<string>? Subresource { get; set; }

        /// <summary>
        /// Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete,
        /// proxy.  "*" means all.
        /// </summary>
        [Input("verb")]
        public Input<string>? Verb { get; set; }

        /// <summary>
        /// Version is the API Version of the Resource.  "*" means all.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// ResourceRule is the list of actions the subject is allowed to perform on resources. The list
    /// ordering isn't significant, may contain duplicates, and possibly be incomplete.
    /// </summary>
    public class ResourceRuleArgs : Pulumi.ResourceArgs
    {
        [Input("verbs", required: true)]
        private InputList<string>? _verbs;

        /// <summary>
        /// Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update,
        /// delete, proxy.  "*" means all.
        /// </summary>
        public InputList<string> Verbs
        {
            get => _verbs ?? (_verbs = new InputList<string>());
            set => _verbs = value;
        }

        [Input("apiGroups")]
        private InputList<string>? _apiGroups;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.  "*" means all.
        /// </summary>
        public InputList<string> ApiGroups
        {
            get => _apiGroups ?? (_apiGroups = new InputList<string>());
            set => _apiGroups = value;
        }

        [Input("resourceNames")]
        private InputList<string>? _resourceNames;

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.  "*" means all.
        /// </summary>
        public InputList<string> ResourceNames
        {
            get => _resourceNames ?? (_resourceNames = new InputList<string>());
            set => _resourceNames = value;
        }

        [Input("resources")]
        private InputList<string>? _resources;

        /// <summary>
        /// Resources is a list of resources this rule applies to.  "*" means all in the specified
        /// apiGroups.
        ///  "*/foo" represents the subresource 'foo' for all resources in the specified apiGroups.
        /// </summary>
        public InputList<string> Resources
        {
            get => _resources ?? (_resources = new InputList<string>());
            set => _resources = value;
        }

    }

    /// <summary>
    /// SelfSubjectAccessReview checks whether or the current user can perform an action.  Not
    /// filling in a spec.namespace means "in all namespaces".  Self is a special case, because
    /// users should always be able to check whether they can perform an action
    /// </summary>
    public class SelfSubjectAccessReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated.  user and groups must be empty
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authorization.V1.SelfSubjectAccessReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    public class SelfSubjectAccessReviewSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
        [Input("nonResourceAttributes")]
        public Input<Authorization.V1.NonResourceAttributesArgs>? NonResourceAttributes { get; set; }

        /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
        [Input("resourceAttributes")]
        public Input<Authorization.V1.ResourceAttributesArgs>? ResourceAttributes { get; set; }

    }

    /// <summary>
    /// SelfSubjectRulesReview enumerates the set of actions the current user can perform within a
    /// namespace. The returned list of actions may be incomplete depending on the server's
    /// authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview
    /// should be used by UIs to show/hide actions, or to quickly let an end user reason about their
    /// permissions. It should NOT Be used by external systems to drive authorization decisions as
    /// this raises confused deputy, cache lifetime/revocation, and correctness concerns.
    /// SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization
    /// decisions to the API server.
    /// </summary>
    public class SelfSubjectRulesReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated.
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authorization.V1.SelfSubjectRulesReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    public class SelfSubjectRulesReviewSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Namespace to evaluate rules for. Required.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

    }

    /// <summary>
    /// SubjectAccessReview checks whether or not a user or group can perform an action.
    /// </summary>
    public class SubjectAccessReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authorization.V1.SubjectAccessReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// SubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    public class SubjectAccessReviewSpecArgs : Pulumi.ResourceArgs
    {
        [Input("extra")]
        private InputMap<InputList<string>>? _extra;

        /// <summary>
        /// Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that
        /// is input to the authorizer it needs a reflection here.
        /// </summary>
        public InputMap<InputList<string>> Extra
        {
            get => _extra ?? (_extra = new InputMap<InputList<string>>());
            set => _extra = value;
        }

        [Input("groups")]
        private InputList<string>? _groups;

        /// <summary>
        /// Groups is the groups you're testing for.
        /// </summary>
        public InputList<string> Groups
        {
            get => _groups ?? (_groups = new InputList<string>());
            set => _groups = value;
        }

        /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
        [Input("nonResourceAttributes")]
        public Input<Authorization.V1.NonResourceAttributesArgs>? NonResourceAttributes { get; set; }

        /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
        [Input("resourceAttributes")]
        public Input<Authorization.V1.ResourceAttributesArgs>? ResourceAttributes { get; set; }

        /// <summary>
        /// UID information about the requesting user.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// User is the user you're testing for. If you specify "User" but not "Groups", then is it
        /// interpreted as "What if User were not a member of any groups
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// SubjectAccessReviewStatus
    /// </summary>
    public class SubjectAccessReviewStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Allowed is required. True if the action would be allowed, false otherwise.
        /// </summary>
        [Input("allowed", required: true)]
        public Input<bool> Allowed { get; set; } = null!;

        /// <summary>
        /// Denied is optional. True if the action would be denied, otherwise false. If both allowed
        /// is false and denied is false, then the authorizer has no opinion on whether to authorize
        /// the action. Denied may not be true if Allowed is true.
        /// </summary>
        [Input("denied")]
        public Input<bool>? Denied { get; set; }

        /// <summary>
        /// EvaluationError is an indication that some error occurred during the authorization
        /// check. It is entirely possible to get an error and be able to continue determine
        /// authorization status in spite of it. For instance, RBAC can be missing a role, but
        /// enough roles are still present and bound to reason about the request.
        /// </summary>
        [Input("evaluationError")]
        public Input<string>? EvaluationError { get; set; }

        /// <summary>
        /// Reason is optional.  It indicates why a request was allowed or denied.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete
    /// depending on the set of authorizers the server is configured with and any errors experienced
    /// during evaluation. Because authorization rules are additive, if a rule appears in a list
    /// it's safe to assume the subject has that permission, even if that list is incomplete.
    /// </summary>
    public class SubjectRulesReviewStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Incomplete is true when the rules returned by this call are incomplete. This is most
        /// commonly encountered when an authorizer, such as an external authorizer, doesn't support
        /// rules evaluation.
        /// </summary>
        [Input("incomplete", required: true)]
        public Input<bool> Incomplete { get; set; } = null!;

        [Input("nonResourceRules", required: true)]
        private InputList<Authorization.V1.NonResourceRuleArgs>? _nonResourceRules;

        /// <summary>
        /// NonResourceRules is the list of actions the subject is allowed to perform on
        /// non-resources. The list ordering isn't significant, may contain duplicates, and possibly
        /// be incomplete.
        /// </summary>
        public InputList<Authorization.V1.NonResourceRuleArgs> NonResourceRules
        {
            get => _nonResourceRules ?? (_nonResourceRules = new InputList<Authorization.V1.NonResourceRuleArgs>());
            set => _nonResourceRules = value;
        }

        [Input("resourceRules", required: true)]
        private InputList<Authorization.V1.ResourceRuleArgs>? _resourceRules;

        /// <summary>
        /// ResourceRules is the list of actions the subject is allowed to perform on resources. The
        /// list ordering isn't significant, may contain duplicates, and possibly be incomplete.
        /// </summary>
        public InputList<Authorization.V1.ResourceRuleArgs> ResourceRules
        {
            get => _resourceRules ?? (_resourceRules = new InputList<Authorization.V1.ResourceRuleArgs>());
            set => _resourceRules = value;
        }

        /// <summary>
        /// EvaluationError can appear in combination with Rules. It indicates an error occurred
        /// during rule evaluation, such as an authorizer that doesn't support rule evaluation, and
        /// that ResourceRules and/or NonResourceRules may be incomplete.
        /// </summary>
        [Input("evaluationError")]
        public Input<string>? EvaluationError { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// LocalSubjectAccessReview checks whether or not a user or group can perform an action in a
    /// given namespace. Having a namespace scoped resource makes it much easier to grant namespace
    /// scoped policy that includes permissions checking.
    /// </summary>
    public class LocalSubjectAccessReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated.  spec.namespace must be equal
        /// to the namespace you made the request against.  If empty, it is defaulted.
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authorization.V1Beta1.SubjectAccessReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// NonResourceAttributes includes the authorization attributes available for non-resource
    /// requests to the Authorizer interface
    /// </summary>
    public class NonResourceAttributesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Path is the URL path of the request
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Verb is the standard HTTP verb
        /// </summary>
        [Input("verb")]
        public Input<string>? Verb { get; set; }

    }

    /// <summary>
    /// NonResourceRule holds information that describes a rule for the non-resource
    /// </summary>
    public class NonResourceRuleArgs : Pulumi.ResourceArgs
    {
        [Input("verbs", required: true)]
        private InputList<string>? _verbs;

        /// <summary>
        /// Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete,
        /// patch, head, options.  "*" means all.
        /// </summary>
        public InputList<string> Verbs
        {
            get => _verbs ?? (_verbs = new InputList<string>());
            set => _verbs = value;
        }

        [Input("nonResourceURLs")]
        private InputList<string>? _nonResourceURLs;

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path.  "*" means all.
        /// </summary>
        public InputList<string> NonResourceURLs
        {
            get => _nonResourceURLs ?? (_nonResourceURLs = new InputList<string>());
            set => _nonResourceURLs = value;
        }

    }

    /// <summary>
    /// ResourceAttributes includes the authorization attributes available for resource requests to
    /// the Authorizer interface
    /// </summary>
    public class ResourceAttributesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Group is the API Group of the Resource.  "*" means all.
        /// </summary>
        [Input("group")]
        public Input<string>? Group { get; set; }

        /// <summary>
        /// Name is the name of the resource being requested for a "get" or deleted for a "delete".
        /// "" (empty) means all.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace is the namespace of the action being requested.  Currently, there is no
        /// distinction between no namespace and all namespaces "" (empty) is defaulted for
        /// LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty)
        /// means "all" for namespace scoped resources from a SubjectAccessReview or
        /// SelfSubjectAccessReview
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Resource is one of the existing resource types.  "*" means all.
        /// </summary>
        [Input("resource")]
        public Input<string>? Resource { get; set; }

        /// <summary>
        /// Subresource is one of the existing resource types.  "" means none.
        /// </summary>
        [Input("subresource")]
        public Input<string>? Subresource { get; set; }

        /// <summary>
        /// Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete,
        /// proxy.  "*" means all.
        /// </summary>
        [Input("verb")]
        public Input<string>? Verb { get; set; }

        /// <summary>
        /// Version is the API Version of the Resource.  "*" means all.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// ResourceRule is the list of actions the subject is allowed to perform on resources. The list
    /// ordering isn't significant, may contain duplicates, and possibly be incomplete.
    /// </summary>
    public class ResourceRuleArgs : Pulumi.ResourceArgs
    {
        [Input("verbs", required: true)]
        private InputList<string>? _verbs;

        /// <summary>
        /// Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update,
        /// delete, proxy.  "*" means all.
        /// </summary>
        public InputList<string> Verbs
        {
            get => _verbs ?? (_verbs = new InputList<string>());
            set => _verbs = value;
        }

        [Input("apiGroups")]
        private InputList<string>? _apiGroups;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.  "*" means all.
        /// </summary>
        public InputList<string> ApiGroups
        {
            get => _apiGroups ?? (_apiGroups = new InputList<string>());
            set => _apiGroups = value;
        }

        [Input("resourceNames")]
        private InputList<string>? _resourceNames;

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.  "*" means all.
        /// </summary>
        public InputList<string> ResourceNames
        {
            get => _resourceNames ?? (_resourceNames = new InputList<string>());
            set => _resourceNames = value;
        }

        [Input("resources")]
        private InputList<string>? _resources;

        /// <summary>
        /// Resources is a list of resources this rule applies to.  "*" means all in the specified
        /// apiGroups.
        ///  "*/foo" represents the subresource 'foo' for all resources in the specified apiGroups.
        /// </summary>
        public InputList<string> Resources
        {
            get => _resources ?? (_resources = new InputList<string>());
            set => _resources = value;
        }

    }

    /// <summary>
    /// SelfSubjectAccessReview checks whether or the current user can perform an action.  Not
    /// filling in a spec.namespace means "in all namespaces".  Self is a special case, because
    /// users should always be able to check whether they can perform an action
    /// </summary>
    public class SelfSubjectAccessReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated.  user and groups must be empty
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authorization.V1Beta1.SelfSubjectAccessReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    public class SelfSubjectAccessReviewSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
        [Input("nonResourceAttributes")]
        public Input<Authorization.V1Beta1.NonResourceAttributesArgs>? NonResourceAttributes { get; set; }

        /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
        [Input("resourceAttributes")]
        public Input<Authorization.V1Beta1.ResourceAttributesArgs>? ResourceAttributes { get; set; }

    }

    /// <summary>
    /// SelfSubjectRulesReview enumerates the set of actions the current user can perform within a
    /// namespace. The returned list of actions may be incomplete depending on the server's
    /// authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview
    /// should be used by UIs to show/hide actions, or to quickly let an end user reason about their
    /// permissions. It should NOT Be used by external systems to drive authorization decisions as
    /// this raises confused deputy, cache lifetime/revocation, and correctness concerns.
    /// SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization
    /// decisions to the API server.
    /// </summary>
    public class SelfSubjectRulesReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated.
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authorization.V1Beta1.SelfSubjectRulesReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    public class SelfSubjectRulesReviewSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Namespace to evaluate rules for. Required.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

    }

    /// <summary>
    /// SubjectAccessReview checks whether or not a user or group can perform an action.
    /// </summary>
    public class SubjectAccessReviewArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
        [Input("spec", required: true)]
        public Input<Authorization.V1Beta1.SubjectAccessReviewSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// SubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    public class SubjectAccessReviewSpecArgs : Pulumi.ResourceArgs
    {
        [Input("extra")]
        private InputMap<InputList<string>>? _extra;

        /// <summary>
        /// Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that
        /// is input to the authorizer it needs a reflection here.
        /// </summary>
        public InputMap<InputList<string>> Extra
        {
            get => _extra ?? (_extra = new InputMap<InputList<string>>());
            set => _extra = value;
        }

        [Input("group")]
        private InputList<string>? _group;

        /// <summary>
        /// Groups is the groups you're testing for.
        /// </summary>
        public InputList<string> Group
        {
            get => _group ?? (_group = new InputList<string>());
            set => _group = value;
        }

        /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
        [Input("nonResourceAttributes")]
        public Input<Authorization.V1Beta1.NonResourceAttributesArgs>? NonResourceAttributes { get; set; }

        /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
        [Input("resourceAttributes")]
        public Input<Authorization.V1Beta1.ResourceAttributesArgs>? ResourceAttributes { get; set; }

        /// <summary>
        /// UID information about the requesting user.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// User is the user you're testing for. If you specify "User" but not "Group", then is it
        /// interpreted as "What if User were not a member of any groups
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// SubjectAccessReviewStatus
    /// </summary>
    public class SubjectAccessReviewStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Allowed is required. True if the action would be allowed, false otherwise.
        /// </summary>
        [Input("allowed", required: true)]
        public Input<bool> Allowed { get; set; } = null!;

        /// <summary>
        /// Denied is optional. True if the action would be denied, otherwise false. If both allowed
        /// is false and denied is false, then the authorizer has no opinion on whether to authorize
        /// the action. Denied may not be true if Allowed is true.
        /// </summary>
        [Input("denied")]
        public Input<bool>? Denied { get; set; }

        /// <summary>
        /// EvaluationError is an indication that some error occurred during the authorization
        /// check. It is entirely possible to get an error and be able to continue determine
        /// authorization status in spite of it. For instance, RBAC can be missing a role, but
        /// enough roles are still present and bound to reason about the request.
        /// </summary>
        [Input("evaluationError")]
        public Input<string>? EvaluationError { get; set; }

        /// <summary>
        /// Reason is optional.  It indicates why a request was allowed or denied.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete
    /// depending on the set of authorizers the server is configured with and any errors experienced
    /// during evaluation. Because authorization rules are additive, if a rule appears in a list
    /// it's safe to assume the subject has that permission, even if that list is incomplete.
    /// </summary>
    public class SubjectRulesReviewStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Incomplete is true when the rules returned by this call are incomplete. This is most
        /// commonly encountered when an authorizer, such as an external authorizer, doesn't support
        /// rules evaluation.
        /// </summary>
        [Input("incomplete", required: true)]
        public Input<bool> Incomplete { get; set; } = null!;

        [Input("nonResourceRules", required: true)]
        private InputList<Authorization.V1Beta1.NonResourceRuleArgs>? _nonResourceRules;

        /// <summary>
        /// NonResourceRules is the list of actions the subject is allowed to perform on
        /// non-resources. The list ordering isn't significant, may contain duplicates, and possibly
        /// be incomplete.
        /// </summary>
        public InputList<Authorization.V1Beta1.NonResourceRuleArgs> NonResourceRules
        {
            get => _nonResourceRules ?? (_nonResourceRules = new InputList<Authorization.V1Beta1.NonResourceRuleArgs>());
            set => _nonResourceRules = value;
        }

        [Input("resourceRules", required: true)]
        private InputList<Authorization.V1Beta1.ResourceRuleArgs>? _resourceRules;

        /// <summary>
        /// ResourceRules is the list of actions the subject is allowed to perform on resources. The
        /// list ordering isn't significant, may contain duplicates, and possibly be incomplete.
        /// </summary>
        public InputList<Authorization.V1Beta1.ResourceRuleArgs> ResourceRules
        {
            get => _resourceRules ?? (_resourceRules = new InputList<Authorization.V1Beta1.ResourceRuleArgs>());
            set => _resourceRules = value;
        }

        /// <summary>
        /// EvaluationError can appear in combination with Rules. It indicates an error occurred
        /// during rule evaluation, such as an authorizer that doesn't support rule evaluation, and
        /// that ResourceRules and/or NonResourceRules may be incomplete.
        /// </summary>
        [Input("evaluationError")]
        public Input<string>? EvaluationError { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Autoscaling
{
  namespace V1
  {
    /// <summary>
    /// CrossVersionObjectReference contains enough information to let you identify the referred
    /// resource.
    /// </summary>
    public class CrossVersionObjectReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Kind of the referent; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// API version of the referent
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

    }

    /// <summary>
    /// configuration of a horizontal pod autoscaler.
    /// </summary>
    public class HorizontalPodAutoscalerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// behaviour of autoscaler. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        [Input("spec")]
        public Input<Autoscaling.V1.HorizontalPodAutoscalerSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// list of horizontal pod autoscaler objects.
    /// </summary>
    public class HorizontalPodAutoscalerListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Autoscaling.V1.HorizontalPodAutoscalerArgs>? _items;

        /// <summary>
        /// list of horizontal pod autoscaler objects.
        /// </summary>
        public InputList<Autoscaling.V1.HorizontalPodAutoscalerArgs> Items
        {
            get => _items ?? (_items = new InputList<Autoscaling.V1.HorizontalPodAutoscalerArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// specification of a horizontal pod autoscaler.
    /// </summary>
    public class HorizontalPodAutoscalerSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// upper limit for the number of pods that can be set by the autoscaler; cannot be smaller
        /// than MinReplicas.
        /// </summary>
        [Input("maxReplicas", required: true)]
        public Input<int> MaxReplicas { get; set; } = null!;

        /// <summary>
        /// reference to scaled resource; horizontal pod autoscaler will learn the current resource
        /// consumption and will set the desired number of pods by using its Scale subresource.
        /// </summary>
        [Input("scaleTargetRef", required: true)]
        public Input<Autoscaling.V1.CrossVersionObjectReferenceArgs> ScaleTargetRef { get; set; } = null!;

        /// <summary>
        /// minReplicas is the lower limit for the number of replicas to which the autoscaler can
        /// scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature
        /// gate HPAScaleToZero is enabled and at least one Object or External metric is configured.
        /// Scaling is active as long as at least one metric value is available.
        /// </summary>
        [Input("minReplicas")]
        public Input<int>? MinReplicas { get; set; }

        /// <summary>
        /// target average CPU utilization (represented as a percentage of requested CPU) over all
        /// the pods; if not specified the default autoscaling policy will be used.
        /// </summary>
        [Input("targetCPUUtilizationPercentage")]
        public Input<int>? TargetCPUUtilizationPercentage { get; set; }

    }

    /// <summary>
    /// current status of a horizontal pod autoscaler
    /// </summary>
    public class HorizontalPodAutoscalerStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// current number of replicas of pods managed by this autoscaler.
        /// </summary>
        [Input("currentReplicas", required: true)]
        public Input<int> CurrentReplicas { get; set; } = null!;

        /// <summary>
        /// desired number of replicas of pods managed by this autoscaler.
        /// </summary>
        [Input("desiredReplicas", required: true)]
        public Input<int> DesiredReplicas { get; set; } = null!;

        /// <summary>
        /// current average CPU utilization over all pods, represented as a percentage of requested
        /// CPU, e.g. 70 means that an average pod is using now 70% of its requested CPU.
        /// </summary>
        [Input("currentCPUUtilizationPercentage")]
        public Input<int>? CurrentCPUUtilizationPercentage { get; set; }

        /// <summary>
        /// last time the HorizontalPodAutoscaler scaled the number of pods; used by the autoscaler
        /// to control how often the number of pods is changed.
        /// </summary>
        [Input("lastScaleTime")]
        public Input<string>? LastScaleTime { get; set; }

        /// <summary>
        /// most recent generation observed by this autoscaler.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

    }

    /// <summary>
    /// Scale represents a scaling request for a resource.
    /// </summary>
    public class ScaleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        [Input("spec")]
        public Input<Autoscaling.V1.ScaleSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// ScaleSpec describes the attributes of a scale subresource.
    /// </summary>
    public class ScaleSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

    }

    /// <summary>
    /// ScaleStatus represents the current status of a scale subresource.
    /// </summary>
    public class ScaleStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// label query over pods that should match the replicas count. This is same as the label
        /// selector but in the string format to avoid introspection by clients. The string will be
        /// in the same format as the query-param syntax. More info about label selectors:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
        [Input("selector")]
        public Input<string>? Selector { get; set; }

    }

  }

  namespace V2Beta1
  {
    /// <summary>
    /// CrossVersionObjectReference contains enough information to let you identify the referred
    /// resource.
    /// </summary>
    public class CrossVersionObjectReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Kind of the referent; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// API version of the referent
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

    }

    /// <summary>
    /// ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes
    /// object (for example length of queue in cloud messaging service, or QPS from loadbalancer
    /// running outside of cluster). Exactly one "target" type should be set.
    /// </summary>
    public class ExternalMetricSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// metricName is the name of the metric in question.
        /// </summary>
        [Input("metricName", required: true)]
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// metricSelector is used to identify a specific time series within a given metric.
        /// </summary>
        [Input("metricSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? MetricSelector { get; set; }

        /// <summary>
        /// targetAverageValue is the target per-pod value of global metric (as a quantity).
        /// Mutually exclusive with TargetValue.
        /// </summary>
        [Input("targetAverageValue")]
        public Input<string>? TargetAverageValue { get; set; }

        /// <summary>
        /// targetValue is the target value of the metric (as a quantity). Mutually exclusive with
        /// TargetAverageValue.
        /// </summary>
        [Input("targetValue")]
        public Input<string>? TargetValue { get; set; }

    }

    /// <summary>
    /// ExternalMetricStatus indicates the current value of a global metric not associated with any
    /// Kubernetes object.
    /// </summary>
    public class ExternalMetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// currentValue is the current value of the metric (as a quantity)
        /// </summary>
        [Input("currentValue", required: true)]
        public Input<string> CurrentValue { get; set; } = null!;

        /// <summary>
        /// metricName is the name of a metric used for autoscaling in metric system.
        /// </summary>
        [Input("metricName", required: true)]
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// currentAverageValue is the current value of metric averaged over autoscaled pods.
        /// </summary>
        [Input("currentAverageValue")]
        public Input<string>? CurrentAverageValue { get; set; }

        /// <summary>
        /// metricSelector is used to identify a specific time series within a given metric.
        /// </summary>
        [Input("metricSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? MetricSelector { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which
    /// automatically manages the replica count of any resource implementing the scale subresource
    /// based on the metrics specified.
    /// </summary>
    public class HorizontalPodAutoscalerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// metadata is the standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// spec is the specification for the behaviour of the autoscaler. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        [Input("spec")]
        public Input<Autoscaling.V2Beta1.HorizontalPodAutoscalerSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a
    /// certain point.
    /// </summary>
    public class HorizontalPodAutoscalerConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// status is the status of the condition (True, False, Unknown)
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// type describes the current condition
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// lastTransitionTime is the last time the condition transitioned from one status to
        /// another
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// message is a human-readable explanation containing details about the transition
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// reason is the reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects.
    /// </summary>
    public class HorizontalPodAutoscalerListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Autoscaling.V2Beta1.HorizontalPodAutoscalerArgs>? _items;

        /// <summary>
        /// items is the list of horizontal pod autoscaler objects.
        /// </summary>
        public InputList<Autoscaling.V2Beta1.HorizontalPodAutoscalerArgs> Items
        {
            get => _items ?? (_items = new InputList<Autoscaling.V2Beta1.HorizontalPodAutoscalerArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// metadata is the standard list metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerSpec describes the desired functionality of the
    /// HorizontalPodAutoscaler.
    /// </summary>
    public class HorizontalPodAutoscalerSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// maxReplicas is the upper limit for the number of replicas to which the autoscaler can
        /// scale up. It cannot be less that minReplicas.
        /// </summary>
        [Input("maxReplicas", required: true)]
        public Input<int> MaxReplicas { get; set; } = null!;

        /// <summary>
        /// scaleTargetRef points to the target resource to scale, and is used to the pods for which
        /// metrics should be collected, as well as to actually change the replica count.
        /// </summary>
        [Input("scaleTargetRef", required: true)]
        public Input<Autoscaling.V2Beta1.CrossVersionObjectReferenceArgs> ScaleTargetRef { get; set; } = null!;

        [Input("metrics")]
        private InputList<Autoscaling.V2Beta1.MetricSpecArgs>? _metrics;

        /// <summary>
        /// metrics contains the specifications for which to use to calculate the desired replica
        /// count (the maximum replica count across all metrics will be used).  The desired replica
        /// count is calculated multiplying the ratio between the target value and the current value
        /// by the current number of pods.  Ergo, metrics used must decrease as the pod count is
        /// increased, and vice-versa.  See the individual metric source types for more information
        /// about how each type of metric must respond.
        /// </summary>
        public InputList<Autoscaling.V2Beta1.MetricSpecArgs> Metrics
        {
            get => _metrics ?? (_metrics = new InputList<Autoscaling.V2Beta1.MetricSpecArgs>());
            set => _metrics = value;
        }

        /// <summary>
        /// minReplicas is the lower limit for the number of replicas to which the autoscaler can
        /// scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature
        /// gate HPAScaleToZero is enabled and at least one Object or External metric is configured.
        /// Scaling is active as long as at least one metric value is available.
        /// </summary>
        [Input("minReplicas")]
        public Input<int>? MinReplicas { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.
    /// </summary>
    public class HorizontalPodAutoscalerStatusArgs : Pulumi.ResourceArgs
    {
        [Input("conditions", required: true)]
        private InputList<Autoscaling.V2Beta1.HorizontalPodAutoscalerConditionArgs>? _conditions;

        /// <summary>
        /// conditions is the set of conditions required for this autoscaler to scale its target,
        /// and indicates whether or not those conditions are met.
        /// </summary>
        public InputList<Autoscaling.V2Beta1.HorizontalPodAutoscalerConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Autoscaling.V2Beta1.HorizontalPodAutoscalerConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// currentReplicas is current number of replicas of pods managed by this autoscaler, as
        /// last seen by the autoscaler.
        /// </summary>
        [Input("currentReplicas", required: true)]
        public Input<int> CurrentReplicas { get; set; } = null!;

        /// <summary>
        /// desiredReplicas is the desired number of replicas of pods managed by this autoscaler, as
        /// last calculated by the autoscaler.
        /// </summary>
        [Input("desiredReplicas", required: true)]
        public Input<int> DesiredReplicas { get; set; } = null!;

        [Input("currentMetrics")]
        private InputList<Autoscaling.V2Beta1.MetricStatusArgs>? _currentMetrics;

        /// <summary>
        /// currentMetrics is the last read state of the metrics used by this autoscaler.
        /// </summary>
        public InputList<Autoscaling.V2Beta1.MetricStatusArgs> CurrentMetrics
        {
            get => _currentMetrics ?? (_currentMetrics = new InputList<Autoscaling.V2Beta1.MetricStatusArgs>());
            set => _currentMetrics = value;
        }

        /// <summary>
        /// lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods,
        /// used by the autoscaler to control how often the number of pods is changed.
        /// </summary>
        [Input("lastScaleTime")]
        public Input<string>? LastScaleTime { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed by this autoscaler.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

    }

    /// <summary>
    /// MetricSpec specifies how to scale based on a single metric (only `type` and one other
    /// matching field should be set at once).
    /// </summary>
    public class MetricSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// type is the type of metric source.  It should be one of "Object", "Pods" or "Resource",
        /// each mapping to a matching field in the object.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
        [Input("external")]
        public Input<Autoscaling.V2Beta1.ExternalMetricSourceArgs>? External { get; set; }

        /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
        [Input("object")]
        public Input<Autoscaling.V2Beta1.ObjectMetricSourceArgs>? Object { get; set; }

        /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
        [Input("pods")]
        public Input<Autoscaling.V2Beta1.PodsMetricSourceArgs>? Pods { get; set; }

        /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
        [Input("resource")]
        public Input<Autoscaling.V2Beta1.ResourceMetricSourceArgs>? Resource { get; set; }

    }

    /// <summary>
    /// MetricStatus describes the last-read state of a single metric.
    /// </summary>
    public class MetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// type is the type of metric source.  It will be one of "Object", "Pods" or "Resource",
        /// each corresponds to a matching field in the object.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
        [Input("external")]
        public Input<Autoscaling.V2Beta1.ExternalMetricStatusArgs>? External { get; set; }

        /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
        [Input("object")]
        public Input<Autoscaling.V2Beta1.ObjectMetricStatusArgs>? Object { get; set; }

        /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
        [Input("pods")]
        public Input<Autoscaling.V2Beta1.PodsMetricStatusArgs>? Pods { get; set; }

        /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
        [Input("resource")]
        public Input<Autoscaling.V2Beta1.ResourceMetricStatusArgs>? Resource { get; set; }

    }

    /// <summary>
    /// ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for
    /// example, hits-per-second on an Ingress object).
    /// </summary>
    public class ObjectMetricSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// metricName is the name of the metric in question.
        /// </summary>
        [Input("metricName", required: true)]
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// target is the described Kubernetes object.
        /// </summary>
        [Input("target", required: true)]
        public Input<Autoscaling.V2Beta1.CrossVersionObjectReferenceArgs> Target { get; set; } = null!;

        /// <summary>
        /// targetValue is the target value of the metric (as a quantity).
        /// </summary>
        [Input("targetValue", required: true)]
        public Input<string> TargetValue { get; set; } = null!;

        /// <summary>
        /// averageValue is the target value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
        [Input("averageValue")]
        public Input<string>? AverageValue { get; set; }

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set, it is passed as an additional parameter to the metrics server for
        /// more specific metrics scoping When unset, just the metricName will be used to gather
        /// metrics.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

    }

    /// <summary>
    /// ObjectMetricStatus indicates the current value of a metric describing a kubernetes object
    /// (for example, hits-per-second on an Ingress object).
    /// </summary>
    public class ObjectMetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// currentValue is the current value of the metric (as a quantity).
        /// </summary>
        [Input("currentValue", required: true)]
        public Input<string> CurrentValue { get; set; } = null!;

        /// <summary>
        /// metricName is the name of the metric in question.
        /// </summary>
        [Input("metricName", required: true)]
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// target is the described Kubernetes object.
        /// </summary>
        [Input("target", required: true)]
        public Input<Autoscaling.V2Beta1.CrossVersionObjectReferenceArgs> Target { get; set; } = null!;

        /// <summary>
        /// averageValue is the current value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
        [Input("averageValue")]
        public Input<string>? AverageValue { get; set; }

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set in the ObjectMetricSource, it is passed as an additional parameter
        /// to the metrics server for more specific metrics scoping. When unset, just the metricName
        /// will be used to gather metrics.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

    }

    /// <summary>
    /// PodsMetricSource indicates how to scale on a metric describing each pod in the current scale
    /// target (for example, transactions-processed-per-second). The values will be averaged
    /// together before being compared to the target value.
    /// </summary>
    public class PodsMetricSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// metricName is the name of the metric in question
        /// </summary>
        [Input("metricName", required: true)]
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// targetAverageValue is the target value of the average of the metric across all relevant
        /// pods (as a quantity)
        /// </summary>
        [Input("targetAverageValue", required: true)]
        public Input<string> TargetAverageValue { get; set; } = null!;

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set, it is passed as an additional parameter to the metrics server for
        /// more specific metrics scoping When unset, just the metricName will be used to gather
        /// metrics.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

    }

    /// <summary>
    /// PodsMetricStatus indicates the current value of a metric describing each pod in the current
    /// scale target (for example, transactions-processed-per-second).
    /// </summary>
    public class PodsMetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// currentAverageValue is the current value of the average of the metric across all
        /// relevant pods (as a quantity)
        /// </summary>
        [Input("currentAverageValue", required: true)]
        public Input<string> CurrentAverageValue { get; set; } = null!;

        /// <summary>
        /// metricName is the name of the metric in question
        /// </summary>
        [Input("metricName", required: true)]
        public Input<string> MetricName { get; set; } = null!;

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set in the PodsMetricSource, it is passed as an additional parameter
        /// to the metrics server for more specific metrics scoping. When unset, just the metricName
        /// will be used to gather metrics.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

    }

    /// <summary>
    /// ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as
    /// specified in requests and limits, describing each pod in the current scale target (e.g. CPU
    /// or memory).  The values will be averaged together before being compared to the target.  Such
    /// metrics are built in to Kubernetes, and have special scaling options on top of those
    /// available to normal per-pod metrics using the "pods" source.  Only one "target" type should
    /// be set.
    /// </summary>
    public class ResourceMetricSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// name is the name of the resource in question.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// targetAverageUtilization is the target value of the average of the resource metric
        /// across all relevant pods, represented as a percentage of the requested value of the
        /// resource for the pods.
        /// </summary>
        [Input("targetAverageUtilization")]
        public Input<int>? TargetAverageUtilization { get; set; }

        /// <summary>
        /// targetAverageValue is the target value of the average of the resource metric across all
        /// relevant pods, as a raw value (instead of as a percentage of the request), similar to
        /// the "pods" metric source type.
        /// </summary>
        [Input("targetAverageValue")]
        public Input<string>? TargetAverageValue { get; set; }

    }

    /// <summary>
    /// ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes,
    /// as specified in requests and limits, describing each pod in the current scale target (e.g.
    /// CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options
    /// on top of those available to normal per-pod metrics using the "pods" source.
    /// </summary>
    public class ResourceMetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// currentAverageValue is the current value of the average of the resource metric across
        /// all relevant pods, as a raw value (instead of as a percentage of the request), similar
        /// to the "pods" metric source type. It will always be set, regardless of the corresponding
        /// metric specification.
        /// </summary>
        [Input("currentAverageValue", required: true)]
        public Input<string> CurrentAverageValue { get; set; } = null!;

        /// <summary>
        /// name is the name of the resource in question.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// currentAverageUtilization is the current value of the average of the resource metric
        /// across all relevant pods, represented as a percentage of the requested value of the
        /// resource for the pods.  It will only be present if `targetAverageValue` was set in the
        /// corresponding metric specification.
        /// </summary>
        [Input("currentAverageUtilization")]
        public Input<int>? CurrentAverageUtilization { get; set; }

    }

  }

  namespace V2Beta2
  {
    /// <summary>
    /// CrossVersionObjectReference contains enough information to let you identify the referred
    /// resource.
    /// </summary>
    public class CrossVersionObjectReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Kind of the referent; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// API version of the referent
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

    }

    /// <summary>
    /// ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes
    /// object (for example length of queue in cloud messaging service, or QPS from loadbalancer
    /// running outside of cluster).
    /// </summary>
    public class ExternalMetricSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        [Input("metric", required: true)]
        public Input<Autoscaling.V2Beta2.MetricIdentifierArgs> Metric { get; set; } = null!;

        /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
        [Input("target", required: true)]
        public Input<Autoscaling.V2Beta2.MetricTargetArgs> Target { get; set; } = null!;

    }

    /// <summary>
    /// ExternalMetricStatus indicates the current value of a global metric not associated with any
    /// Kubernetes object.
    /// </summary>
    public class ExternalMetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
        [Input("current", required: true)]
        public Input<Autoscaling.V2Beta2.MetricValueStatusArgs> Current { get; set; } = null!;

        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        [Input("metric", required: true)]
        public Input<Autoscaling.V2Beta2.MetricIdentifierArgs> Metric { get; set; } = null!;

    }

    /// <summary>
    /// HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which
    /// automatically manages the replica count of any resource implementing the scale subresource
    /// based on the metrics specified.
    /// </summary>
    public class HorizontalPodAutoscalerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// metadata is the standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// spec is the specification for the behaviour of the autoscaler. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        [Input("spec")]
        public Input<Autoscaling.V2Beta2.HorizontalPodAutoscalerSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a
    /// certain point.
    /// </summary>
    public class HorizontalPodAutoscalerConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// status is the status of the condition (True, False, Unknown)
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// type describes the current condition
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// lastTransitionTime is the last time the condition transitioned from one status to
        /// another
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// message is a human-readable explanation containing details about the transition
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// reason is the reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects.
    /// </summary>
    public class HorizontalPodAutoscalerListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Autoscaling.V2Beta2.HorizontalPodAutoscalerArgs>? _items;

        /// <summary>
        /// items is the list of horizontal pod autoscaler objects.
        /// </summary>
        public InputList<Autoscaling.V2Beta2.HorizontalPodAutoscalerArgs> Items
        {
            get => _items ?? (_items = new InputList<Autoscaling.V2Beta2.HorizontalPodAutoscalerArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// metadata is the standard list metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerSpec describes the desired functionality of the
    /// HorizontalPodAutoscaler.
    /// </summary>
    public class HorizontalPodAutoscalerSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// maxReplicas is the upper limit for the number of replicas to which the autoscaler can
        /// scale up. It cannot be less that minReplicas.
        /// </summary>
        [Input("maxReplicas", required: true)]
        public Input<int> MaxReplicas { get; set; } = null!;

        /// <summary>
        /// scaleTargetRef points to the target resource to scale, and is used to the pods for which
        /// metrics should be collected, as well as to actually change the replica count.
        /// </summary>
        [Input("scaleTargetRef", required: true)]
        public Input<Autoscaling.V2Beta2.CrossVersionObjectReferenceArgs> ScaleTargetRef { get; set; } = null!;

        [Input("metrics")]
        private InputList<Autoscaling.V2Beta2.MetricSpecArgs>? _metrics;

        /// <summary>
        /// metrics contains the specifications for which to use to calculate the desired replica
        /// count (the maximum replica count across all metrics will be used).  The desired replica
        /// count is calculated multiplying the ratio between the target value and the current value
        /// by the current number of pods.  Ergo, metrics used must decrease as the pod count is
        /// increased, and vice-versa.  See the individual metric source types for more information
        /// about how each type of metric must respond. If not set, the default metric will be set
        /// to 80% average CPU utilization.
        /// </summary>
        public InputList<Autoscaling.V2Beta2.MetricSpecArgs> Metrics
        {
            get => _metrics ?? (_metrics = new InputList<Autoscaling.V2Beta2.MetricSpecArgs>());
            set => _metrics = value;
        }

        /// <summary>
        /// minReplicas is the lower limit for the number of replicas to which the autoscaler can
        /// scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature
        /// gate HPAScaleToZero is enabled and at least one Object or External metric is configured.
        /// Scaling is active as long as at least one metric value is available.
        /// </summary>
        [Input("minReplicas")]
        public Input<int>? MinReplicas { get; set; }

    }

    /// <summary>
    /// HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.
    /// </summary>
    public class HorizontalPodAutoscalerStatusArgs : Pulumi.ResourceArgs
    {
        [Input("conditions", required: true)]
        private InputList<Autoscaling.V2Beta2.HorizontalPodAutoscalerConditionArgs>? _conditions;

        /// <summary>
        /// conditions is the set of conditions required for this autoscaler to scale its target,
        /// and indicates whether or not those conditions are met.
        /// </summary>
        public InputList<Autoscaling.V2Beta2.HorizontalPodAutoscalerConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Autoscaling.V2Beta2.HorizontalPodAutoscalerConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// currentReplicas is current number of replicas of pods managed by this autoscaler, as
        /// last seen by the autoscaler.
        /// </summary>
        [Input("currentReplicas", required: true)]
        public Input<int> CurrentReplicas { get; set; } = null!;

        /// <summary>
        /// desiredReplicas is the desired number of replicas of pods managed by this autoscaler, as
        /// last calculated by the autoscaler.
        /// </summary>
        [Input("desiredReplicas", required: true)]
        public Input<int> DesiredReplicas { get; set; } = null!;

        [Input("currentMetrics")]
        private InputList<Autoscaling.V2Beta2.MetricStatusArgs>? _currentMetrics;

        /// <summary>
        /// currentMetrics is the last read state of the metrics used by this autoscaler.
        /// </summary>
        public InputList<Autoscaling.V2Beta2.MetricStatusArgs> CurrentMetrics
        {
            get => _currentMetrics ?? (_currentMetrics = new InputList<Autoscaling.V2Beta2.MetricStatusArgs>());
            set => _currentMetrics = value;
        }

        /// <summary>
        /// lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods,
        /// used by the autoscaler to control how often the number of pods is changed.
        /// </summary>
        [Input("lastScaleTime")]
        public Input<string>? LastScaleTime { get; set; }

        /// <summary>
        /// observedGeneration is the most recent generation observed by this autoscaler.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

    }

    /// <summary>
    /// MetricIdentifier defines the name and optionally selector for a metric
    /// </summary>
    public class MetricIdentifierArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// name is the name of the given metric
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set, it is passed as an additional parameter to the metrics server for
        /// more specific metrics scoping. When unset, just the metricName will be used to gather
        /// metrics.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

    }

    /// <summary>
    /// MetricSpec specifies how to scale based on a single metric (only `type` and one other
    /// matching field should be set at once).
    /// </summary>
    public class MetricSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// type is the type of metric source.  It should be one of "Object", "Pods" or "Resource",
        /// each mapping to a matching field in the object.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
        [Input("external")]
        public Input<Autoscaling.V2Beta2.ExternalMetricSourceArgs>? External { get; set; }

        /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
        [Input("object")]
        public Input<Autoscaling.V2Beta2.ObjectMetricSourceArgs>? Object { get; set; }

        /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
        [Input("pods")]
        public Input<Autoscaling.V2Beta2.PodsMetricSourceArgs>? Pods { get; set; }

        /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
        [Input("resource")]
        public Input<Autoscaling.V2Beta2.ResourceMetricSourceArgs>? Resource { get; set; }

    }

    /// <summary>
    /// MetricStatus describes the last-read state of a single metric.
    /// </summary>
    public class MetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// type is the type of metric source.  It will be one of "Object", "Pods" or "Resource",
        /// each corresponds to a matching field in the object.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
        [Input("external")]
        public Input<Autoscaling.V2Beta2.ExternalMetricStatusArgs>? External { get; set; }

        /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
        [Input("object")]
        public Input<Autoscaling.V2Beta2.ObjectMetricStatusArgs>? Object { get; set; }

        /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
        [Input("pods")]
        public Input<Autoscaling.V2Beta2.PodsMetricStatusArgs>? Pods { get; set; }

        /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
        [Input("resource")]
        public Input<Autoscaling.V2Beta2.ResourceMetricStatusArgs>? Resource { get; set; }

    }

    /// <summary>
    /// MetricTarget defines the target value, average value, or average utilization of a specific
    /// metric
    /// </summary>
    public class MetricTargetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// type represents whether the metric type is Utilization, Value, or AverageValue
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// averageUtilization is the target value of the average of the resource metric across all
        /// relevant pods, represented as a percentage of the requested value of the resource for
        /// the pods. Currently only valid for Resource metric source type
        /// </summary>
        [Input("averageUtilization")]
        public Input<int>? AverageUtilization { get; set; }

        /// <summary>
        /// averageValue is the target value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
        [Input("averageValue")]
        public Input<string>? AverageValue { get; set; }

        /// <summary>
        /// value is the target value of the metric (as a quantity).
        /// </summary>
        [Input("value")]
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// MetricValueStatus holds the current value for a metric
    /// </summary>
    public class MetricValueStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// currentAverageUtilization is the current value of the average of the resource metric
        /// across all relevant pods, represented as a percentage of the requested value of the
        /// resource for the pods.
        /// </summary>
        [Input("averageUtilization")]
        public Input<int>? AverageUtilization { get; set; }

        /// <summary>
        /// averageValue is the current value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
        [Input("averageValue")]
        public Input<string>? AverageValue { get; set; }

        /// <summary>
        /// value is the current value of the metric (as a quantity).
        /// </summary>
        [Input("value")]
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for
    /// example, hits-per-second on an Ingress object).
    /// </summary>
    public class ObjectMetricSourceArgs : Pulumi.ResourceArgs
    {
        
        [Input("describedObject", required: true)]
        public Input<Autoscaling.V2Beta2.CrossVersionObjectReferenceArgs> DescribedObject { get; set; } = null!;

        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        [Input("metric", required: true)]
        public Input<Autoscaling.V2Beta2.MetricIdentifierArgs> Metric { get; set; } = null!;

        /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
        [Input("target", required: true)]
        public Input<Autoscaling.V2Beta2.MetricTargetArgs> Target { get; set; } = null!;

    }

    /// <summary>
    /// ObjectMetricStatus indicates the current value of a metric describing a kubernetes object
    /// (for example, hits-per-second on an Ingress object).
    /// </summary>
    public class ObjectMetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
        [Input("current", required: true)]
        public Input<Autoscaling.V2Beta2.MetricValueStatusArgs> Current { get; set; } = null!;

        
        [Input("describedObject", required: true)]
        public Input<Autoscaling.V2Beta2.CrossVersionObjectReferenceArgs> DescribedObject { get; set; } = null!;

        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        [Input("metric", required: true)]
        public Input<Autoscaling.V2Beta2.MetricIdentifierArgs> Metric { get; set; } = null!;

    }

    /// <summary>
    /// PodsMetricSource indicates how to scale on a metric describing each pod in the current scale
    /// target (for example, transactions-processed-per-second). The values will be averaged
    /// together before being compared to the target value.
    /// </summary>
    public class PodsMetricSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        [Input("metric", required: true)]
        public Input<Autoscaling.V2Beta2.MetricIdentifierArgs> Metric { get; set; } = null!;

        /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
        [Input("target", required: true)]
        public Input<Autoscaling.V2Beta2.MetricTargetArgs> Target { get; set; } = null!;

    }

    /// <summary>
    /// PodsMetricStatus indicates the current value of a metric describing each pod in the current
    /// scale target (for example, transactions-processed-per-second).
    /// </summary>
    public class PodsMetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
        [Input("current", required: true)]
        public Input<Autoscaling.V2Beta2.MetricValueStatusArgs> Current { get; set; } = null!;

        /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
        [Input("metric", required: true)]
        public Input<Autoscaling.V2Beta2.MetricIdentifierArgs> Metric { get; set; } = null!;

    }

    /// <summary>
    /// ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as
    /// specified in requests and limits, describing each pod in the current scale target (e.g. CPU
    /// or memory).  The values will be averaged together before being compared to the target.  Such
    /// metrics are built in to Kubernetes, and have special scaling options on top of those
    /// available to normal per-pod metrics using the "pods" source.  Only one "target" type should
    /// be set.
    /// </summary>
    public class ResourceMetricSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// name is the name of the resource in question.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
        [Input("target", required: true)]
        public Input<Autoscaling.V2Beta2.MetricTargetArgs> Target { get; set; } = null!;

    }

    /// <summary>
    /// ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes,
    /// as specified in requests and limits, describing each pod in the current scale target (e.g.
    /// CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options
    /// on top of those available to normal per-pod metrics using the "pods" source.
    /// </summary>
    public class ResourceMetricStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
        [Input("current", required: true)]
        public Input<Autoscaling.V2Beta2.MetricValueStatusArgs> Current { get; set; } = null!;

        /// <summary>
        /// Name is the name of the resource in question.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Batch
{
  namespace V1
  {
    /// <summary>
    /// Job represents the configuration of a single job.
    /// </summary>
    public class JobArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of a job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Batch.V1.JobSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// JobCondition describes current state of a job.
    /// </summary>
    public class JobConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of job condition, Complete or Failed.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition was checked.
        /// </summary>
        [Input("lastProbeTime")]
        public Input<string>? LastProbeTime { get; set; }

        /// <summary>
        /// Last time the condition transit from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human readable message indicating details about last transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// (brief) reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// JobList is a collection of jobs.
    /// </summary>
    public class JobListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Batch.V1.JobArgs>? _items;

        /// <summary>
        /// items is the list of Jobs.
        /// </summary>
        public InputList<Batch.V1.JobArgs> Items
        {
            get => _items ?? (_items = new InputList<Batch.V1.JobArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// JobSpec describes how the job execution will look like.
    /// </summary>
    public class JobSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Describes the pod that will be created when executing a job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// Specifies the duration in seconds relative to the startTime that the job may be active
        /// before the system tries to terminate it; value must be positive integer
        /// </summary>
        [Input("activeDeadlineSeconds")]
        public Input<int>? ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// Specifies the number of retries before marking this job failed. Defaults to 6
        /// </summary>
        [Input("backoffLimit")]
        public Input<int>? BackoffLimit { get; set; }

        /// <summary>
        /// Specifies the desired number of successfully finished pods the job should be run with.
        /// Setting to nil means that the success of any pod signals the success of all pods, and
        /// allows parallelism to have any positive value.  Setting to 1 means that parallelism is
        /// limited to 1 and the success of that pod signals the success of the job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        [Input("completions")]
        public Input<int>? Completions { get; set; }

        /// <summary>
        /// manualSelector controls generation of pod labels and pod selectors. Leave
        /// `manualSelector` unset unless you are certain what you are doing. When false or unset,
        /// the system pick labels unique to this job and appends those labels to the pod template.
        /// When true, the user is responsible for picking unique labels and specifying the
        /// selector.  Failure to pick a unique label may cause this and other jobs to not function
        /// correctly.  However, You may see `manualSelector=true` in jobs that were created with
        /// the old `extensions/v1beta1` API. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
        /// </summary>
        [Input("manualSelector")]
        public Input<bool>? ManualSelector { get; set; }

        /// <summary>
        /// Specifies the maximum desired number of pods the job should run at any given time. The
        /// actual number of pods running in steady state will be less than this number when
        /// ((.spec.completions - .status.successful) &amp;lt; .spec.parallelism), i.e. when the
        /// work left to do is less than max parallelism. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        [Input("parallelism")]
        public Input<int>? Parallelism { get; set; }

        /// <summary>
        /// A label query over pods that should match the pod count. Normally, the system sets this
        /// field for you. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

        /// <summary>
        /// ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either
        /// Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job
        /// finishes, it is eligible to be automatically deleted. When the Job is being deleted, its
        /// lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job
        /// won't be automatically deleted. If this field is set to zero, the Job becomes eligible
        /// to be deleted immediately after it finishes. This field is alpha-level and is only
        /// honored by servers that enable the TTLAfterFinished feature.
        /// </summary>
        [Input("ttlSecondsAfterFinished")]
        public Input<int>? TtlSecondsAfterFinished { get; set; }

    }

    /// <summary>
    /// JobStatus represents the current state of a Job.
    /// </summary>
    public class JobStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The number of actively running pods.
        /// </summary>
        [Input("active")]
        public Input<int>? Active { get; set; }

        /// <summary>
        /// Represents time when the job was completed. It is not guaranteed to be set in
        /// happens-before order across separate operations. It is represented in RFC3339 form and
        /// is in UTC.
        /// </summary>
        [Input("completionTime")]
        public Input<string>? CompletionTime { get; set; }

        [Input("conditions")]
        private InputList<Batch.V1.JobConditionArgs>? _conditions;

        /// <summary>
        /// The latest available observations of an object's current state. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
        public InputList<Batch.V1.JobConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Batch.V1.JobConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The number of pods which reached phase Failed.
        /// </summary>
        [Input("failed")]
        public Input<int>? Failed { get; set; }

        /// <summary>
        /// Represents time when the job was acknowledged by the job controller. It is not
        /// guaranteed to be set in happens-before order across separate operations. It is
        /// represented in RFC3339 form and is in UTC.
        /// </summary>
        [Input("startTime")]
        public Input<string>? StartTime { get; set; }

        /// <summary>
        /// The number of pods which reached phase Succeeded.
        /// </summary>
        [Input("succeeded")]
        public Input<int>? Succeeded { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// CronJob represents the configuration of a single cron job.
    /// </summary>
    public class CronJobArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of a cron job, including the schedule. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Batch.V1Beta1.CronJobSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// CronJobList is a collection of cron jobs.
    /// </summary>
    public class CronJobListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Batch.V1Beta1.CronJobArgs>? _items;

        /// <summary>
        /// items is the list of CronJobs.
        /// </summary>
        public InputList<Batch.V1Beta1.CronJobArgs> Items
        {
            get => _items ?? (_items = new InputList<Batch.V1Beta1.CronJobArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CronJobSpec describes how the job execution will look like and when it will actually run.
    /// </summary>
    public class CronJobSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specifies the job that will be created when executing a CronJob.
        /// </summary>
        [Input("jobTemplate", required: true)]
        public Input<Batch.V1Beta1.JobTemplateSpecArgs> JobTemplate { get; set; } = null!;

        /// <summary>
        /// The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
        /// </summary>
        [Input("schedule", required: true)]
        public Input<string> Schedule { get; set; } = null!;

        /// <summary>
        /// Specifies how to treat concurrent executions of a Job. Valid values are: - "Allow"
        /// (default): allows CronJobs to run concurrently; - "Forbid": forbids concurrent runs,
        /// skipping next run if previous run hasn't finished yet; - "Replace": cancels currently
        /// running job and replaces it with a new one
        /// </summary>
        [Input("concurrencyPolicy")]
        public Input<string>? ConcurrencyPolicy { get; set; }

        /// <summary>
        /// The number of failed finished jobs to retain. This is a pointer to distinguish between
        /// explicit zero and not specified. Defaults to 1.
        /// </summary>
        [Input("failedJobsHistoryLimit")]
        public Input<int>? FailedJobsHistoryLimit { get; set; }

        /// <summary>
        /// Optional deadline in seconds for starting the job if it misses scheduled time for any
        /// reason.  Missed jobs executions will be counted as failed ones.
        /// </summary>
        [Input("startingDeadlineSeconds")]
        public Input<int>? StartingDeadlineSeconds { get; set; }

        /// <summary>
        /// The number of successful finished jobs to retain. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 3.
        /// </summary>
        [Input("successfulJobsHistoryLimit")]
        public Input<int>? SuccessfulJobsHistoryLimit { get; set; }

        /// <summary>
        /// This flag tells the controller to suspend subsequent executions, it does not apply to
        /// already started executions.  Defaults to false.
        /// </summary>
        [Input("suspend")]
        public Input<bool>? Suspend { get; set; }

    }

    /// <summary>
    /// CronJobStatus represents the current state of a cron job.
    /// </summary>
    public class CronJobStatusArgs : Pulumi.ResourceArgs
    {
        [Input("active")]
        private InputList<Core.V1.ObjectReferenceArgs>? _active;

        /// <summary>
        /// A list of pointers to currently running jobs.
        /// </summary>
        public InputList<Core.V1.ObjectReferenceArgs> Active
        {
            get => _active ?? (_active = new InputList<Core.V1.ObjectReferenceArgs>());
            set => _active = value;
        }

        /// <summary>
        /// Information when was the last time the job was successfully scheduled.
        /// </summary>
        [Input("lastScheduleTime")]
        public Input<string>? LastScheduleTime { get; set; }

    }

    /// <summary>
    /// JobTemplateSpec describes the data a Job should have when created from a template
    /// </summary>
    public class JobTemplateSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Standard object's metadata of the jobs created from this template. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Batch.V1.JobSpecArgs>? Spec { get; set; }

    }

  }

  namespace V2Alpha1
  {
    /// <summary>
    /// CronJob represents the configuration of a single cron job.
    /// </summary>
    public class CronJobArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of a cron job, including the schedule. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Batch.V2Alpha1.CronJobSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// CronJobList is a collection of cron jobs.
    /// </summary>
    public class CronJobListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Batch.V2Alpha1.CronJobArgs>? _items;

        /// <summary>
        /// items is the list of CronJobs.
        /// </summary>
        public InputList<Batch.V2Alpha1.CronJobArgs> Items
        {
            get => _items ?? (_items = new InputList<Batch.V2Alpha1.CronJobArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CronJobSpec describes how the job execution will look like and when it will actually run.
    /// </summary>
    public class CronJobSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specifies the job that will be created when executing a CronJob.
        /// </summary>
        [Input("jobTemplate", required: true)]
        public Input<Batch.V2Alpha1.JobTemplateSpecArgs> JobTemplate { get; set; } = null!;

        /// <summary>
        /// The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
        /// </summary>
        [Input("schedule", required: true)]
        public Input<string> Schedule { get; set; } = null!;

        /// <summary>
        /// Specifies how to treat concurrent executions of a Job. Valid values are: - "Allow"
        /// (default): allows CronJobs to run concurrently; - "Forbid": forbids concurrent runs,
        /// skipping next run if previous run hasn't finished yet; - "Replace": cancels currently
        /// running job and replaces it with a new one
        /// </summary>
        [Input("concurrencyPolicy")]
        public Input<string>? ConcurrencyPolicy { get; set; }

        /// <summary>
        /// The number of failed finished jobs to retain. This is a pointer to distinguish between
        /// explicit zero and not specified.
        /// </summary>
        [Input("failedJobsHistoryLimit")]
        public Input<int>? FailedJobsHistoryLimit { get; set; }

        /// <summary>
        /// Optional deadline in seconds for starting the job if it misses scheduled time for any
        /// reason.  Missed jobs executions will be counted as failed ones.
        /// </summary>
        [Input("startingDeadlineSeconds")]
        public Input<int>? StartingDeadlineSeconds { get; set; }

        /// <summary>
        /// The number of successful finished jobs to retain. This is a pointer to distinguish
        /// between explicit zero and not specified.
        /// </summary>
        [Input("successfulJobsHistoryLimit")]
        public Input<int>? SuccessfulJobsHistoryLimit { get; set; }

        /// <summary>
        /// This flag tells the controller to suspend subsequent executions, it does not apply to
        /// already started executions.  Defaults to false.
        /// </summary>
        [Input("suspend")]
        public Input<bool>? Suspend { get; set; }

    }

    /// <summary>
    /// CronJobStatus represents the current state of a cron job.
    /// </summary>
    public class CronJobStatusArgs : Pulumi.ResourceArgs
    {
        [Input("active")]
        private InputList<Core.V1.ObjectReferenceArgs>? _active;

        /// <summary>
        /// A list of pointers to currently running jobs.
        /// </summary>
        public InputList<Core.V1.ObjectReferenceArgs> Active
        {
            get => _active ?? (_active = new InputList<Core.V1.ObjectReferenceArgs>());
            set => _active = value;
        }

        /// <summary>
        /// Information when was the last time the job was successfully scheduled.
        /// </summary>
        [Input("lastScheduleTime")]
        public Input<string>? LastScheduleTime { get; set; }

    }

    /// <summary>
    /// JobTemplateSpec describes the data a Job should have when created from a template
    /// </summary>
    public class JobTemplateSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Standard object's metadata of the jobs created from this template. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Batch.V1.JobSpecArgs>? Spec { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Certificates
{
  namespace V1Beta1
  {
    /// <summary>
    /// Describes a certificate signing request
    /// </summary>
    public class CertificateSigningRequestArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// The certificate request itself and any additional information.
        /// </summary>
        [Input("spec")]
        public Input<Certificates.V1Beta1.CertificateSigningRequestSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    public class CertificateSigningRequestConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// request approval state, currently Approved or Denied.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// timestamp for the last update to this condition
        /// </summary>
        [Input("lastUpdateTime")]
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// human readable message with details about the request state
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// brief reason for the request state
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    public class CertificateSigningRequestListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Certificates.V1Beta1.CertificateSigningRequestArgs>? _items;

        
        public InputList<Certificates.V1Beta1.CertificateSigningRequestArgs> Items
        {
            get => _items ?? (_items = new InputList<Certificates.V1Beta1.CertificateSigningRequestArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// This information is immutable after the request is created. Only the Request and Usages
    /// fields can be set on creation, other fields are derived by Kubernetes and cannot be modified
    /// by users.
    /// </summary>
    public class CertificateSigningRequestSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Base64-encoded PKCS#10 CSR data
        /// </summary>
        [Input("request", required: true)]
        public Input<string> Request { get; set; } = null!;

        [Input("extra")]
        private InputMap<InputList<string>>? _extra;

        /// <summary>
        /// Extra information about the requesting user. See user.Info interface for details.
        /// </summary>
        public InputMap<InputList<string>> Extra
        {
            get => _extra ?? (_extra = new InputMap<InputList<string>>());
            set => _extra = value;
        }

        [Input("groups")]
        private InputList<string>? _groups;

        /// <summary>
        /// Group information about the requesting user. See user.Info interface for details.
        /// </summary>
        public InputList<string> Groups
        {
            get => _groups ?? (_groups = new InputList<string>());
            set => _groups = value;
        }

        /// <summary>
        /// UID information about the requesting user. See user.Info interface for details.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

        [Input("usages")]
        private InputList<string>? _usages;

        /// <summary>
        /// allowedUsages specifies a set of usage contexts the key will be valid for. See:
        /// https://tools.ietf.org/html/rfc5280#section-4.2.1.3
        ///      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
        /// </summary>
        public InputList<string> Usages
        {
            get => _usages ?? (_usages = new InputList<string>());
            set => _usages = value;
        }

        /// <summary>
        /// Information about the requesting user. See user.Info interface for details.
        /// </summary>
        [Input("username")]
        public Input<string>? Username { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    public class CertificateSigningRequestStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// If request was approved, the controller will place the issued certificate here.
        /// </summary>
        [Input("certificate")]
        public Input<string>? Certificate { get; set; }

        [Input("conditions")]
        private InputList<Certificates.V1Beta1.CertificateSigningRequestConditionArgs>? _conditions;

        /// <summary>
        /// Conditions applied to the request, such as approval or denial.
        /// </summary>
        public InputList<Certificates.V1Beta1.CertificateSigningRequestConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Certificates.V1Beta1.CertificateSigningRequestConditionArgs>());
            set => _conditions = value;
        }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Coordination
{
  namespace V1
  {
    /// <summary>
    /// Lease defines a lease concept.
    /// </summary>
    public class LeaseArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the Lease. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Coordination.V1.LeaseSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// LeaseList is a list of Lease objects.
    /// </summary>
    public class LeaseListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Coordination.V1.LeaseArgs>? _items;

        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public InputList<Coordination.V1.LeaseArgs> Items
        {
            get => _items ?? (_items = new InputList<Coordination.V1.LeaseArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// LeaseSpec is a specification of a Lease.
    /// </summary>
    public class LeaseSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// acquireTime is a time when the current lease was acquired.
        /// </summary>
        [Input("acquireTime")]
        public Input<string>? AcquireTime { get; set; }

        /// <summary>
        /// holderIdentity contains the identity of the holder of a current lease.
        /// </summary>
        [Input("holderIdentity")]
        public Input<string>? HolderIdentity { get; set; }

        /// <summary>
        /// leaseDurationSeconds is a duration that candidates for a lease need to wait to force
        /// acquire it. This is measure against time of last observed RenewTime.
        /// </summary>
        [Input("leaseDurationSeconds")]
        public Input<int>? LeaseDurationSeconds { get; set; }

        /// <summary>
        /// leaseTransitions is the number of transitions of a lease between holders.
        /// </summary>
        [Input("leaseTransitions")]
        public Input<int>? LeaseTransitions { get; set; }

        /// <summary>
        /// renewTime is a time when the current holder of a lease has last updated the lease.
        /// </summary>
        [Input("renewTime")]
        public Input<string>? RenewTime { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// Lease defines a lease concept.
    /// </summary>
    public class LeaseArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the Lease. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Coordination.V1Beta1.LeaseSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// LeaseList is a list of Lease objects.
    /// </summary>
    public class LeaseListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Coordination.V1Beta1.LeaseArgs>? _items;

        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public InputList<Coordination.V1Beta1.LeaseArgs> Items
        {
            get => _items ?? (_items = new InputList<Coordination.V1Beta1.LeaseArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// LeaseSpec is a specification of a Lease.
    /// </summary>
    public class LeaseSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// acquireTime is a time when the current lease was acquired.
        /// </summary>
        [Input("acquireTime")]
        public Input<string>? AcquireTime { get; set; }

        /// <summary>
        /// holderIdentity contains the identity of the holder of a current lease.
        /// </summary>
        [Input("holderIdentity")]
        public Input<string>? HolderIdentity { get; set; }

        /// <summary>
        /// leaseDurationSeconds is a duration that candidates for a lease need to wait to force
        /// acquire it. This is measure against time of last observed RenewTime.
        /// </summary>
        [Input("leaseDurationSeconds")]
        public Input<int>? LeaseDurationSeconds { get; set; }

        /// <summary>
        /// leaseTransitions is the number of transitions of a lease between holders.
        /// </summary>
        [Input("leaseTransitions")]
        public Input<int>? LeaseTransitions { get; set; }

        /// <summary>
        /// renewTime is a time when the current holder of a lease has last updated the lease.
        /// </summary>
        [Input("renewTime")]
        public Input<string>? RenewTime { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Core
{
  namespace V1
  {
    /// <summary>
    /// Represents a Persistent Disk resource in AWS.
    /// 
    /// An AWS EBS disk must exist before mounting to a container. The disk must also be in the same
    /// AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS
    /// volumes support ownership management and SELinux relabeling.
    /// </summary>
    public class AWSElasticBlockStoreVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [Input("volumeID", required: true)]
        public Input<string> VolumeID { get; set; } = null!;

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// The partition in the volume that you want to mount. If omitted, the default is to mount
        /// by volume name. Examples: For volume /dev/sda1, you specify the partition as "1".
        /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property
        /// empty).
        /// </summary>
        [Input("partition")]
        public Input<int>? Partition { get; set; }

        /// <summary>
        /// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If
        /// omitted, the default is "false". More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Affinity is a group of affinity scheduling rules.
    /// </summary>
    public class AffinityArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Describes node affinity scheduling rules for the pod.
        /// </summary>
        [Input("nodeAffinity")]
        public Input<Core.V1.NodeAffinityArgs>? NodeAffinity { get; set; }

        /// <summary>
        /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
        /// etc. as some other pod(s)).
        /// </summary>
        [Input("podAffinity")]
        public Input<Core.V1.PodAffinityArgs>? PodAffinity { get; set; }

        /// <summary>
        /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same
        /// node, zone, etc. as some other pod(s)).
        /// </summary>
        [Input("podAntiAffinity")]
        public Input<Core.V1.PodAntiAffinityArgs>? PodAntiAffinity { get; set; }

    }

    /// <summary>
    /// AttachedVolume describes a volume attached to a node
    /// </summary>
    public class AttachedVolumeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// DevicePath represents the device path where the volume should be available
        /// </summary>
        [Input("devicePath", required: true)]
        public Input<string> DevicePath { get; set; } = null!;

        /// <summary>
        /// Name of the attached volume
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// </summary>
    public class AzureDiskVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Name of the data disk in the blob storage
        /// </summary>
        [Input("diskName", required: true)]
        public Input<string> DiskName { get; set; } = null!;

        /// <summary>
        /// The URI the data disk in the blob storage
        /// </summary>
        [Input("diskURI", required: true)]
        public Input<string> DiskURI { get; set; } = null!;

        /// <summary>
        /// Host Caching mode: None, Read Only, Read Write.
        /// </summary>
        [Input("cachingMode")]
        public Input<string>? CachingMode { get; set; }

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob
        /// disk per storage account  Managed: azure managed data disk (only in managed availability
        /// set). defaults to shared
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// </summary>
    public class AzureFilePersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// the name of secret that contains Azure Storage Account Name and Key
        /// </summary>
        [Input("secretName", required: true)]
        public Input<string> SecretName { get; set; } = null!;

        /// <summary>
        /// Share Name
        /// </summary>
        [Input("shareName", required: true)]
        public Input<string> ShareName { get; set; } = null!;

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// the namespace of the secret that contains Azure Storage Account Name and Key default is
        /// the same as the Pod
        /// </summary>
        [Input("secretNamespace")]
        public Input<string>? SecretNamespace { get; set; }

    }

    /// <summary>
    /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// </summary>
    public class AzureFileVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// the name of secret that contains Azure Storage Account Name and Key
        /// </summary>
        [Input("secretName", required: true)]
        public Input<string> SecretName { get; set; } = null!;

        /// <summary>
        /// Share Name
        /// </summary>
        [Input("shareName", required: true)]
        public Input<string> ShareName { get; set; } = null!;

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
    /// Deprecated in 1.7, please use the bindings subresource of pods instead.
    /// </summary>
    public class BindingArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The target object that you want to bind to the standard object.
        /// </summary>
        [Input("target", required: true)]
        public Input<Core.V1.ObjectReferenceArgs> Target { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// Represents storage that is managed by an external CSI volume driver (Beta feature)
    /// </summary>
    public class CSIPersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Driver is the name of the driver to use for this volume. Required.
        /// </summary>
        [Input("driver", required: true)]
        public Input<string> Driver { get; set; } = null!;

        /// <summary>
        /// VolumeHandle is the unique volume name returned by the CSI volume plugin’s
        /// CreateVolume to refer to the volume on all subsequent calls. Required.
        /// </summary>
        [Input("volumeHandle", required: true)]
        public Input<string> VolumeHandle { get; set; } = null!;

        /// <summary>
        /// ControllerExpandSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI ControllerExpandVolume call.
        /// This is an alpha field and requires enabling ExpandCSIVolumes feature gate. This field
        /// is optional, and may be empty if no secret is required. If the secret object contains
        /// more than one secret, all secrets are passed.
        /// </summary>
        [Input("controllerExpandSecretRef")]
        public Input<Core.V1.SecretReferenceArgs>? ControllerExpandSecretRef { get; set; }

        /// <summary>
        /// ControllerPublishSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI ControllerPublishVolume and
        /// ControllerUnpublishVolume calls. This field is optional, and may be empty if no secret
        /// is required. If the secret object contains more than one secret, all secrets are passed.
        /// </summary>
        [Input("controllerPublishSecretRef")]
        public Input<Core.V1.SecretReferenceArgs>? ControllerPublishSecretRef { get; set; }

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs".
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// NodePublishSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI NodePublishVolume and
        /// NodeUnpublishVolume calls. This field is optional, and may be empty if no secret is
        /// required. If the secret object contains more than one secret, all secrets are passed.
        /// </summary>
        [Input("nodePublishSecretRef")]
        public Input<Core.V1.SecretReferenceArgs>? NodePublishSecretRef { get; set; }

        /// <summary>
        /// NodeStageSecretRef is a reference to the secret object containing sensitive information
        /// to pass to the CSI driver to complete the CSI NodeStageVolume and NodeStageVolume and
        /// NodeUnstageVolume calls. This field is optional, and may be empty if no secret is
        /// required. If the secret object contains more than one secret, all secrets are passed.
        /// </summary>
        [Input("nodeStageSecretRef")]
        public Input<Core.V1.SecretReferenceArgs>? NodeStageSecretRef { get; set; }

        /// <summary>
        /// Optional: The value to pass to ControllerPublishVolumeRequest. Defaults to false
        /// (read/write).
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        [Input("volumeAttributes")]
        private InputMap<string>? _volumeAttributes;

        /// <summary>
        /// Attributes of the volume to publish.
        /// </summary>
        public InputMap<string> VolumeAttributes
        {
            get => _volumeAttributes ?? (_volumeAttributes = new InputMap<string>());
            set => _volumeAttributes = value;
        }

    }

    /// <summary>
    /// Represents a source location of a volume to mount, managed by an external CSI driver
    /// </summary>
    public class CSIVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Driver is the name of the CSI driver that handles this volume. Consult with your admin
        /// for the correct name as registered in the cluster.
        /// </summary>
        [Input("driver", required: true)]
        public Input<string> Driver { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is
        /// passed to the associated CSI driver which will determine the default filesystem to
        /// apply.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// NodePublishSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI NodePublishVolume and
        /// NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is
        /// required. If the secret object contains more than one secret, all secret references are
        /// passed.
        /// </summary>
        [Input("nodePublishSecretRef")]
        public Input<Core.V1.LocalObjectReferenceArgs>? NodePublishSecretRef { get; set; }

        /// <summary>
        /// Specifies a read-only configuration for the volume. Defaults to false (read/write).
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        [Input("volumeAttributes")]
        private InputMap<string>? _volumeAttributes;

        /// <summary>
        /// VolumeAttributes stores driver-specific properties that are passed to the CSI driver.
        /// Consult your driver's documentation for supported values.
        /// </summary>
        public InputMap<string> VolumeAttributes
        {
            get => _volumeAttributes ?? (_volumeAttributes = new InputMap<string>());
            set => _volumeAttributes = value;
        }

    }

    /// <summary>
    /// Adds and removes POSIX capabilities from running containers.
    /// </summary>
    public class CapabilitiesArgs : Pulumi.ResourceArgs
    {
        [Input("add")]
        private InputList<string>? _add;

        /// <summary>
        /// Added capabilities
        /// </summary>
        public InputList<string> Add
        {
            get => _add ?? (_add = new InputList<string>());
            set => _add = value;
        }

        [Input("drop")]
        private InputList<string>? _drop;

        /// <summary>
        /// Removed capabilities
        /// </summary>
        public InputList<string> Drop
        {
            get => _drop ?? (_drop = new InputList<string>());
            set => _drop = value;
        }

    }

    /// <summary>
    /// Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    public class CephFSPersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        [Input("monitors", required: true)]
        private InputList<string>? _monitors;

        /// <summary>
        /// Required: Monitors is a collection of Ceph monitors More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public InputList<string> Monitors
        {
            get => _monitors ?? (_monitors = new InputList<string>());
            set => _monitors = value;
        }

        /// <summary>
        /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Input("secretFile")]
        public Input<string>? SecretFile { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the authentication secret for User, default is
        /// empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.SecretReferenceArgs>? SecretRef { get; set; }

        /// <summary>
        /// Optional: User is the rados user name, default is admin More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    public class CephFSVolumeSourceArgs : Pulumi.ResourceArgs
    {
        [Input("monitors", required: true)]
        private InputList<string>? _monitors;

        /// <summary>
        /// Required: Monitors is a collection of Ceph monitors More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        public InputList<string> Monitors
        {
            get => _monitors ?? (_monitors = new InputList<string>());
            set => _monitors = value;
        }

        /// <summary>
        /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Input("secretFile")]
        public Input<string>? SecretFile { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the authentication secret for User, default is
        /// empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.LocalObjectReferenceArgs>? SecretRef { get; set; }

        /// <summary>
        /// Optional: User is the rados user name, default is admin More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting
    /// to a container. The volume must also be in the same region as the kubelet. Cinder volumes
    /// support ownership management and SELinux relabeling.
    /// </summary>
    public class CinderPersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// volume id used to identify the volume in cinder. More info:
        /// https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Input("volumeID", required: true)]
        public Input<string> VolumeID { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
        /// unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: points to a secret object containing parameters used to connect to OpenStack.
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.SecretReferenceArgs>? SecretRef { get; set; }

    }

    /// <summary>
    /// Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting
    /// to a container. The volume must also be in the same region as the kubelet. Cinder volumes
    /// support ownership management and SELinux relabeling.
    /// </summary>
    public class CinderVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// volume id used to identify the volume in cinder. More info:
        /// https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Input("volumeID", required: true)]
        public Input<string> VolumeID { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
        /// unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: points to a secret object containing parameters used to connect to OpenStack.
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.LocalObjectReferenceArgs>? SecretRef { get; set; }

    }

    /// <summary>
    /// ClientIPConfig represents the configurations of Client IP based session affinity.
    /// </summary>
    public class ClientIPConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value
        /// must be &amp;gt;0 &amp;&amp; &amp;lt;=86400(for 1 day) if ServiceAffinity == "ClientIP".
        /// Default value is 10800(for 3 hours).
        /// </summary>
        [Input("timeoutSeconds")]
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// Information about the condition of a component.
    /// </summary>
    public class ComponentConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition for a component. Valid values for "Healthy": "True", "False", or
        /// "Unknown".
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of condition for a component. Valid value: "Healthy"
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Condition error code for a component. For example, a health check error code.
        /// </summary>
        [Input("error")]
        public Input<string>? Error { get; set; }

        /// <summary>
        /// Message about the condition for a component. For example, information about a health
        /// check.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

    }

    /// <summary>
    /// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
    /// </summary>
    public class ComponentStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        [Input("conditions")]
        private InputList<Core.V1.ComponentConditionArgs>? _conditions;

        /// <summary>
        /// List of component conditions observed
        /// </summary>
        public InputList<Core.V1.ComponentConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Core.V1.ComponentConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// Status of all the conditions for the component as a list of ComponentStatus objects.
    /// </summary>
    public class ComponentStatusListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.ComponentStatusArgs>? _items;

        /// <summary>
        /// List of ComponentStatus objects.
        /// </summary>
        public InputList<Core.V1.ComponentStatusArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.ComponentStatusArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ConfigMap holds configuration data for pods to consume.
    /// </summary>
    public class ConfigMapArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        [Input("binaryData")]
        private InputMap<string>? _binaryData;

        /// <summary>
        /// BinaryData contains the binary data. Each key must consist of alphanumeric characters,
        /// '-', '_' or '.'. BinaryData can contain byte sequences that are not in the UTF-8 range.
        /// The keys stored in BinaryData must not overlap with the ones in the Data field, this is
        /// enforced during validation process. Using this field will require 1.10+ apiserver and
        /// kubelet.
        /// </summary>
        public InputMap<string> BinaryData
        {
            get => _binaryData ?? (_binaryData = new InputMap<string>());
            set => _binaryData = value;
        }

        [Input("data")]
        private InputMap<string>? _data;

        /// <summary>
        /// Data contains the configuration data. Each key must consist of alphanumeric characters,
        /// '-', '_' or '.'. Values with non-UTF-8 byte sequences must use the BinaryData field. The
        /// keys stored in Data must not overlap with the keys in the BinaryData field, this is
        /// enforced during validation process.
        /// </summary>
        public InputMap<string> Data
        {
            get => _data ?? (_data = new InputMap<string>());
            set => _data = value;
        }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.
    /// 
    /// The contents of the target ConfigMap's Data field will represent the key-value pairs as
    /// environment variables.
    /// </summary>
    public class ConfigMapEnvSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap must be defined
        /// </summary>
        [Input("optional")]
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// Selects a key from a ConfigMap.
    /// </summary>
    public class ConfigMapKeySelectorArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The key to select.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap or its key must be defined
        /// </summary>
        [Input("optional")]
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// ConfigMapList is a resource containing a list of ConfigMap objects.
    /// </summary>
    public class ConfigMapListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.ConfigMapArgs>? _items;

        /// <summary>
        /// Items is the list of ConfigMaps.
        /// </summary>
        public InputList<Core.V1.ConfigMapArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.ConfigMapArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config
    /// source for the Node.
    /// </summary>
    public class ConfigMapNodeConfigSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the
        /// KubeletConfiguration structure This field is required in all cases.
        /// </summary>
        [Input("kubeletConfigKey", required: true)]
        public Input<string> KubeletConfigKey { get; set; } = null!;

        /// <summary>
        /// Name is the metadata.name of the referenced ConfigMap. This field is required in all
        /// cases.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Namespace is the metadata.namespace of the referenced ConfigMap. This field is required
        /// in all cases.
        /// </summary>
        [Input("namespace", required: true)]
        public Input<string> Namespace { get; set; } = null!;

        /// <summary>
        /// ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap. This field
        /// is forbidden in Node.Spec, and required in Node.Status.
        /// </summary>
        [Input("resourceVersion")]
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// UID is the metadata.UID of the referenced ConfigMap. This field is forbidden in
        /// Node.Spec, and required in Node.Status.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// Adapts a ConfigMap into a projected volume.
    /// 
    /// The contents of the target ConfigMap's Data field will be presented in a projected volume as
    /// files using the keys in the Data field as the file names, unless the items element is
    /// populated with specific mappings of keys to paths. Note that this is identical to a
    /// configmap volume source without the default mode.
    /// </summary>
    public class ConfigMapProjectionArgs : Pulumi.ResourceArgs
    {
        [Input("items")]
        private InputList<Core.V1.KeyToPathArgs>? _items;

        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will
        /// be projected into the volume as a file whose name is the key and content is the value.
        /// If specified, the listed keys will be projected into the specified paths, and unlisted
        /// keys will not be present. If a key is specified which is not present in the ConfigMap,
        /// the volume setup will error unless it is marked optional. Paths must be relative and may
        /// not contain the '..' path or start with '..'.
        /// </summary>
        public InputList<Core.V1.KeyToPathArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.KeyToPathArgs>());
            set => _items = value;
        }

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap or its keys must be defined
        /// </summary>
        [Input("optional")]
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// Adapts a ConfigMap into a volume.
    /// 
    /// The contents of the target ConfigMap's Data field will be presented in a volume as files
    /// using the keys in the Data field as the file names, unless the items element is populated
    /// with specific mappings of keys to paths. ConfigMap volumes support ownership management and
    /// SELinux relabeling.
    /// </summary>
    public class ConfigMapVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a value between 0 and
        /// 0777. Defaults to 0644. Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file mode, like fsGroup,
        /// and the result can be other mode bits set.
        /// </summary>
        [Input("defaultMode")]
        public Input<int>? DefaultMode { get; set; }

        [Input("items")]
        private InputList<Core.V1.KeyToPathArgs>? _items;

        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will
        /// be projected into the volume as a file whose name is the key and content is the value.
        /// If specified, the listed keys will be projected into the specified paths, and unlisted
        /// keys will not be present. If a key is specified which is not present in the ConfigMap,
        /// the volume setup will error unless it is marked optional. Paths must be relative and may
        /// not contain the '..' path or start with '..'.
        /// </summary>
        public InputList<Core.V1.KeyToPathArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.KeyToPathArgs>());
            set => _items = value;
        }

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap or its keys must be defined
        /// </summary>
        [Input("optional")]
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// A single application container that you want to run within a pod.
    /// </summary>
    public class ContainerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of the container specified as a DNS_LABEL. Each container in a pod must have a
        /// unique name (DNS_LABEL). Cannot be updated.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("args")]
        private InputList<string>? _args;

        /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a
        /// variable cannot be resolved, the reference in the input string will be unchanged. The
        /// $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references
        /// will never be expanded, regardless of whether the variable exists or not. Cannot be
        /// updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        public InputList<string> Args
        {
            get => _args ?? (_args = new InputList<string>());
            set => _args = value;
        }

        [Input("command")]
        private InputList<string>? _command;

        /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if
        /// this is not provided. Variable references $(VAR_NAME) are expanded using the container's
        /// environment. If a variable cannot be resolved, the reference in the input string will be
        /// unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
        /// Escaped references will never be expanded, regardless of whether the variable exists or
        /// not. Cannot be updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        public InputList<string> Command
        {
            get => _command ?? (_command = new InputList<string>());
            set => _command = value;
        }

        [Input("env")]
        private InputList<Core.V1.EnvVarArgs>? _env;

        /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
        public InputList<Core.V1.EnvVarArgs> Env
        {
            get => _env ?? (_env = new InputList<Core.V1.EnvVarArgs>());
            set => _env = value;
        }

        [Input("envFrom")]
        private InputList<Core.V1.EnvFromSourceArgs>? _envFrom;

        /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined
        /// within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event
        /// when the container is starting. When a key exists in multiple sources, the value
        /// associated with the last source will take precedence. Values defined by an Env with a
        /// duplicate key will take precedence. Cannot be updated.
        /// </summary>
        public InputList<Core.V1.EnvFromSourceArgs> EnvFrom
        {
            get => _envFrom ?? (_envFrom = new InputList<Core.V1.EnvFromSourceArgs>());
            set => _envFrom = value;
        }

        /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This
        /// field is optional to allow higher level config management to default or override
        /// container images in workload controllers like Deployments and StatefulSets.
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag
        /// is specified, or IfNotPresent otherwise. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
        [Input("imagePullPolicy")]
        public Input<string>? ImagePullPolicy { get; set; }

        /// <summary>
        /// Actions that the management system should take in response to container lifecycle
        /// events. Cannot be updated.
        /// </summary>
        [Input("lifecycle")]
        public Input<Core.V1.LifecycleArgs>? Lifecycle { get; set; }

        /// <summary>
        /// Periodic probe of container liveness. Container will be restarted if the probe fails.
        /// Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Input("livenessProbe")]
        public Input<Core.V1.ProbeArgs>? LivenessProbe { get; set; }

        [Input("ports")]
        private InputList<Core.V1.ContainerPortArgs>? _ports;

        /// <summary>
        /// List of ports to expose from the container. Exposing a port here gives the system
        /// additional information about the network connections a container uses, but is primarily
        /// informational. Not specifying a port here DOES NOT prevent that port from being exposed.
        /// Any port which is listening on the default "0.0.0.0" address inside a container will be
        /// accessible from the network. Cannot be updated.
        /// </summary>
        public InputList<Core.V1.ContainerPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Core.V1.ContainerPortArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// Periodic probe of container service readiness. Container will be removed from service
        /// endpoints if the probe fails. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Input("readinessProbe")]
        public Input<Core.V1.ProbeArgs>? ReadinessProbe { get; set; }

        /// <summary>
        /// Compute Resources required by this container. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
        [Input("resources")]
        public Input<Core.V1.ResourceRequirementsArgs>? Resources { get; set; }

        /// <summary>
        /// Security options the pod should run with. More info:
        /// https://kubernetes.io/docs/concepts/policy/security-context/ More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        [Input("securityContext")]
        public Input<Core.V1.SecurityContextArgs>? SecurityContext { get; set; }

        /// <summary>
        /// StartupProbe indicates that the Pod has successfully initialized. If specified, no other
        /// probes are executed until this completes successfully. If this probe fails, the Pod will
        /// be restarted, just as if the livenessProbe failed. This can be used to provide different
        /// probe parameters at the beginning of a Pod's lifecycle, when it might take a long time
        /// to load data or warm a cache, than during steady-state operation. This cannot be
        /// updated. This is an alpha feature enabled by the StartupProbe feature flag. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Input("startupProbe")]
        public Input<Core.V1.ProbeArgs>? StartupProbe { get; set; }

        /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If
        /// this is not set, reads from stdin in the container will always result in EOF. Default is
        /// false.
        /// </summary>
        [Input("stdin")]
        public Input<bool>? Stdin { get; set; }

        /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by
        /// a single attach. When stdin is true the stdin stream will remain open across multiple
        /// attach sessions. If stdinOnce is set to true, stdin is opened on container start, is
        /// empty until the first client attaches to stdin, and then remains open and accepts data
        /// until the client disconnects, at which time stdin is closed and remains closed until the
        /// container is restarted. If this flag is false, a container processes that reads from
        /// stdin will never receive an EOF. Default is false
        /// </summary>
        [Input("stdinOnce")]
        public Input<bool>? StdinOnce { get; set; }

        /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be
        /// written is mounted into the container's filesystem. Message written is intended to be
        /// brief final status, such as an assertion failure message. Will be truncated by the node
        /// if greater than 4096 bytes. The total message length across all containers will be
        /// limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
        [Input("terminationMessagePath")]
        public Input<string>? TerminationMessagePath { get; set; }

        /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of
        /// terminationMessagePath to populate the container status message on both success and
        /// failure. FallbackToLogsOnError will use the last chunk of container log output if the
        /// termination message file is empty and the container exited with an error. The log output
        /// is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be
        /// updated.
        /// </summary>
        [Input("terminationMessagePolicy")]
        public Input<string>? TerminationMessagePolicy { get; set; }

        /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be
        /// true. Default is false.
        /// </summary>
        [Input("tty")]
        public Input<bool>? Tty { get; set; }

        [Input("volumeDevices")]
        private InputList<Core.V1.VolumeDeviceArgs>? _volumeDevices;

        /// <summary>
        /// volumeDevices is the list of block devices to be used by the container. This is a beta
        /// feature.
        /// </summary>
        public InputList<Core.V1.VolumeDeviceArgs> VolumeDevices
        {
            get => _volumeDevices ?? (_volumeDevices = new InputList<Core.V1.VolumeDeviceArgs>());
            set => _volumeDevices = value;
        }

        [Input("volumeMounts")]
        private InputList<Core.V1.VolumeMountArgs>? _volumeMounts;

        /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
        public InputList<Core.V1.VolumeMountArgs> VolumeMounts
        {
            get => _volumeMounts ?? (_volumeMounts = new InputList<Core.V1.VolumeMountArgs>());
            set => _volumeMounts = value;
        }

        /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be
        /// used, which might be configured in the container image. Cannot be updated.
        /// </summary>
        [Input("workingDir")]
        public Input<string>? WorkingDir { get; set; }

    }

    /// <summary>
    /// Describe a container image
    /// </summary>
    public class ContainerImageArgs : Pulumi.ResourceArgs
    {
        [Input("names", required: true)]
        private InputList<string>? _names;

        /// <summary>
        /// Names by which this image is known. e.g. ["k8s.gcr.io/hyperkube:v1.0.7",
        /// "dockerhub.io/google_containers/hyperkube:v1.0.7"]
        /// </summary>
        public InputList<string> Names
        {
            get => _names ?? (_names = new InputList<string>());
            set => _names = value;
        }

        /// <summary>
        /// The size of the image in bytes.
        /// </summary>
        [Input("sizeBytes")]
        public Input<int>? SizeBytes { get; set; }

    }

    /// <summary>
    /// ContainerPort represents a network port in a single container.
    /// </summary>
    public class ContainerPortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Number of port to expose on the pod's IP address. This must be a valid port number, 0
        /// &amp;lt; x &amp;lt; 65536.
        /// </summary>
        [Input("containerPort", required: true)]
        public Input<int> ContainerPortValue { get; set; } = null!;

        /// <summary>
        /// What host IP to bind the external port to.
        /// </summary>
        [Input("hostIP")]
        public Input<string>? HostIP { get; set; }

        /// <summary>
        /// Number of port to expose on the host. If specified, this must be a valid port number, 0
        /// &amp;lt; x &amp;lt; 65536. If HostNetwork is specified, this must match ContainerPort.
        /// Most containers do not need this.
        /// </summary>
        [Input("hostPort")]
        public Input<int>? HostPort { get; set; }

        /// <summary>
        /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port
        /// in a pod must have a unique name. Name for the port that can be referred to by services.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// ContainerState holds a possible state of container. Only one of its members may be
    /// specified. If none of them is specified, the default one is ContainerStateWaiting.
    /// </summary>
    public class ContainerStateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Details about a running container
        /// </summary>
        [Input("running")]
        public Input<Core.V1.ContainerStateRunningArgs>? Running { get; set; }

        /// <summary>
        /// Details about a terminated container
        /// </summary>
        [Input("terminated")]
        public Input<Core.V1.ContainerStateTerminatedArgs>? Terminated { get; set; }

        /// <summary>
        /// Details about a waiting container
        /// </summary>
        [Input("waiting")]
        public Input<Core.V1.ContainerStateWaitingArgs>? Waiting { get; set; }

    }

    /// <summary>
    /// ContainerStateRunning is a running state of a container.
    /// </summary>
    public class ContainerStateRunningArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Time at which the container was last (re-)started
        /// </summary>
        [Input("startedAt")]
        public Input<string>? StartedAt { get; set; }

    }

    /// <summary>
    /// ContainerStateTerminated is a terminated state of a container.
    /// </summary>
    public class ContainerStateTerminatedArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Exit status from the last termination of the container
        /// </summary>
        [Input("exitCode", required: true)]
        public Input<int> ExitCode { get; set; } = null!;

        /// <summary>
        /// Container's ID in the format 'docker://&amp;lt;container_id&amp;gt;'
        /// </summary>
        [Input("containerID")]
        public Input<string>? ContainerID { get; set; }

        /// <summary>
        /// Time at which the container last terminated
        /// </summary>
        [Input("finishedAt")]
        public Input<string>? FinishedAt { get; set; }

        /// <summary>
        /// Message regarding the last termination of the container
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// (brief) reason from the last termination of the container
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

        /// <summary>
        /// Signal from the last termination of the container
        /// </summary>
        [Input("signal")]
        public Input<int>? Signal { get; set; }

        /// <summary>
        /// Time at which previous execution of the container started
        /// </summary>
        [Input("startedAt")]
        public Input<string>? StartedAt { get; set; }

    }

    /// <summary>
    /// ContainerStateWaiting is a waiting state of a container.
    /// </summary>
    public class ContainerStateWaitingArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Message regarding why the container is not yet running.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// (brief) reason the container is not yet running.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ContainerStatus contains details for the current status of this container.
    /// </summary>
    public class ContainerStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The image the container is running. More info:
        /// https://kubernetes.io/docs/concepts/containers/images
        /// </summary>
        [Input("image", required: true)]
        public Input<string> Image { get; set; } = null!;

        /// <summary>
        /// ImageID of the container's image.
        /// </summary>
        [Input("imageID", required: true)]
        public Input<string> ImageID { get; set; } = null!;

        /// <summary>
        /// This must be a DNS_LABEL. Each container in a pod must have a unique name. Cannot be
        /// updated.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Specifies whether the container has passed its readiness probe.
        /// </summary>
        [Input("ready", required: true)]
        public Input<bool> Ready { get; set; } = null!;

        /// <summary>
        /// The number of times the container has been restarted, currently based on the number of
        /// dead containers that have not yet been removed. Note that this is calculated from dead
        /// containers. But those containers are subject to garbage collection. This value will get
        /// capped at 5 by GC.
        /// </summary>
        [Input("restartCount", required: true)]
        public Input<int> RestartCount { get; set; } = null!;

        /// <summary>
        /// Container's ID in the format 'docker://&amp;lt;container_id&amp;gt;'.
        /// </summary>
        [Input("containerID")]
        public Input<string>? ContainerID { get; set; }

        /// <summary>
        /// Details about the container's last termination condition.
        /// </summary>
        [Input("lastState")]
        public Input<Core.V1.ContainerStateArgs>? LastState { get; set; }

        /// <summary>
        /// Specifies whether the container has passed its startup probe. Initialized as false,
        /// becomes true after startupProbe is considered successful. Resets to false when the
        /// container is restarted, or if kubelet loses state temporarily. Is always true when no
        /// startupProbe is defined.
        /// </summary>
        [Input("started")]
        public Input<bool>? Started { get; set; }

        /// <summary>
        /// Details about the container's current condition.
        /// </summary>
        [Input("state")]
        public Input<Core.V1.ContainerStateArgs>? State { get; set; }

    }

    /// <summary>
    /// DaemonEndpoint contains information about a single Daemon endpoint.
    /// </summary>
    public class DaemonEndpointArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Port number of the given endpoint.
        /// </summary>
        [Input("Port", required: true)]
        public Input<int> Port { get; set; } = null!;

    }

    /// <summary>
    /// Represents downward API info for projecting into a projected volume. Note that this is
    /// identical to a downwardAPI volume source without the default mode.
    /// </summary>
    public class DownwardAPIProjectionArgs : Pulumi.ResourceArgs
    {
        [Input("items")]
        private InputList<Core.V1.DownwardAPIVolumeFileArgs>? _items;

        /// <summary>
        /// Items is a list of DownwardAPIVolume file
        /// </summary>
        public InputList<Core.V1.DownwardAPIVolumeFileArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.DownwardAPIVolumeFileArgs>());
            set => _items = value;
        }

    }

    /// <summary>
    /// DownwardAPIVolumeFile represents information to create the file containing the pod field
    /// </summary>
    public class DownwardAPIVolumeFileArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required: Path is  the relative path name of the file to be created. Must not be
        /// absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative
        /// path must not start with '..'
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Required: Selects a field of the pod: only annotations, labels, name and namespace are
        /// supported.
        /// </summary>
        [Input("fieldRef")]
        public Input<Core.V1.ObjectFieldSelectorArgs>? FieldRef { get; set; }

        /// <summary>
        /// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not
        /// specified, the volume defaultMode will be used. This might be in conflict with other
        /// options that affect the file mode, like fsGroup, and the result can be other mode bits
        /// set.
        /// </summary>
        [Input("mode")]
        public Input<int>? Mode { get; set; }

        /// <summary>
        /// Selects a resource of the container: only resources limits and requests (limits.cpu,
        /// limits.memory, requests.cpu and requests.memory) are currently supported.
        /// </summary>
        [Input("resourceFieldRef")]
        public Input<Core.V1.ResourceFieldSelectorArgs>? ResourceFieldRef { get; set; }

    }

    /// <summary>
    /// DownwardAPIVolumeSource represents a volume containing downward API info. Downward API
    /// volumes support ownership management and SELinux relabeling.
    /// </summary>
    public class DownwardAPIVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a value between 0 and
        /// 0777. Defaults to 0644. Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file mode, like fsGroup,
        /// and the result can be other mode bits set.
        /// </summary>
        [Input("defaultMode")]
        public Input<int>? DefaultMode { get; set; }

        [Input("items")]
        private InputList<Core.V1.DownwardAPIVolumeFileArgs>? _items;

        /// <summary>
        /// Items is a list of downward API volume file
        /// </summary>
        public InputList<Core.V1.DownwardAPIVolumeFileArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.DownwardAPIVolumeFileArgs>());
            set => _items = value;
        }

    }

    /// <summary>
    /// Represents an empty directory for a pod. Empty directory volumes support ownership
    /// management and SELinux relabeling.
    /// </summary>
    public class EmptyDirVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// What type of storage medium should back this directory. The default is "" which means to
        /// use the node's default medium. Must be an empty string (default) or Memory. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        /// </summary>
        [Input("medium")]
        public Input<string>? Medium { get; set; }

        /// <summary>
        /// Total amount of local storage required for this EmptyDir volume. The size limit is also
        /// applicable for memory medium. The maximum usage on memory medium EmptyDir would be the
        /// minimum value between the SizeLimit specified here and the sum of memory limits of all
        /// containers in a pod. The default is nil which means that the limit is undefined. More
        /// info: http://kubernetes.io/docs/user-guide/volumes#emptydir
        /// </summary>
        [Input("sizeLimit")]
        public Input<string>? SizeLimit { get; set; }

    }

    /// <summary>
    /// EndpointAddress is a tuple that describes single IP address.
    /// </summary>
    public class EndpointAddressArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The IP of this endpoint. May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
        /// or link-local multicast ((224.0.0.0/24). IPv6 is also accepted but not fully supported
        /// on all platforms. Also, certain kubernetes components, like kube-proxy, are not IPv6
        /// ready.
        /// </summary>
        [Input("ip", required: true)]
        public Input<string> Ip { get; set; } = null!;

        /// <summary>
        /// The Hostname of this endpoint
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a
        /// node.
        /// </summary>
        [Input("nodeName")]
        public Input<string>? NodeName { get; set; }

        /// <summary>
        /// Reference to object providing the endpoint.
        /// </summary>
        [Input("targetRef")]
        public Input<Core.V1.ObjectReferenceArgs>? TargetRef { get; set; }

    }

    /// <summary>
    /// EndpointPort is a tuple that describes a single port.
    /// </summary>
    public class EndpointPortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The port number of the endpoint.
        /// </summary>
        [Input("port", required: true)]
        public Input<int> Port { get; set; } = null!;

        /// <summary>
        /// The name of this port.  This must match the 'name' field in the corresponding
        /// ServicePort. Must be a DNS_LABEL. Optional only if one port is defined.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// EndpointSubset is a group of addresses with a common set of ports. The expanded set of
    /// endpoints is the Cartesian product of Addresses x Ports. For example, given:
    ///   {
    ///     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
    ///     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
    ///   }
    /// The resulting set of endpoints can be viewed as:
    ///     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
    ///     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
    /// </summary>
    public class EndpointSubsetArgs : Pulumi.ResourceArgs
    {
        [Input("addresses")]
        private InputList<Core.V1.EndpointAddressArgs>? _addresses;

        /// <summary>
        /// IP addresses which offer the related ports that are marked as ready. These endpoints
        /// should be considered safe for load balancers and clients to utilize.
        /// </summary>
        public InputList<Core.V1.EndpointAddressArgs> Addresses
        {
            get => _addresses ?? (_addresses = new InputList<Core.V1.EndpointAddressArgs>());
            set => _addresses = value;
        }

        [Input("notReadyAddresses")]
        private InputList<Core.V1.EndpointAddressArgs>? _notReadyAddresses;

        /// <summary>
        /// IP addresses which offer the related ports but are not currently marked as ready because
        /// they have not yet finished starting, have recently failed a readiness check, or have
        /// recently failed a liveness check.
        /// </summary>
        public InputList<Core.V1.EndpointAddressArgs> NotReadyAddresses
        {
            get => _notReadyAddresses ?? (_notReadyAddresses = new InputList<Core.V1.EndpointAddressArgs>());
            set => _notReadyAddresses = value;
        }

        [Input("ports")]
        private InputList<Core.V1.EndpointPortArgs>? _ports;

        /// <summary>
        /// Port numbers available on the related IP addresses.
        /// </summary>
        public InputList<Core.V1.EndpointPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Core.V1.EndpointPortArgs>());
            set => _ports = value;
        }

    }

    /// <summary>
    /// Endpoints is a collection of endpoints that implement the actual service. Example:
    ///   Name: "mysvc",
    ///   Subsets: [
    ///     {
    ///       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
    ///       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
    ///     },
    ///     {
    ///       Addresses: [{"ip": "10.10.3.3"}],
    ///       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
    ///     },
    ///  ]
    /// </summary>
    public class EndpointsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("subsets")]
        private InputList<Core.V1.EndpointSubsetArgs>? _subsets;

        /// <summary>
        /// The set of all endpoints is the union of all subsets. Addresses are placed into subsets
        /// according to the IPs they share. A single address with multiple ports, some of which are
        /// ready and some of which are not (because they come from different containers) will
        /// result in the address being displayed in different subsets for the different ports. No
        /// address will appear in both Addresses and NotReadyAddresses in the same subset. Sets of
        /// addresses and ports that comprise a service.
        /// </summary>
        public InputList<Core.V1.EndpointSubsetArgs> Subsets
        {
            get => _subsets ?? (_subsets = new InputList<Core.V1.EndpointSubsetArgs>());
            set => _subsets = value;
        }

    }

    /// <summary>
    /// EndpointsList is a list of endpoints.
    /// </summary>
    public class EndpointsListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.EndpointsArgs>? _items;

        /// <summary>
        /// List of endpoints.
        /// </summary>
        public InputList<Core.V1.EndpointsArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.EndpointsArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// EnvFromSource represents the source of a set of ConfigMaps
    /// </summary>
    public class EnvFromSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The ConfigMap to select from
        /// </summary>
        [Input("configMapRef")]
        public Input<Core.V1.ConfigMapEnvSourceArgs>? ConfigMapRef { get; set; }

        /// <summary>
        /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        /// </summary>
        [Input("prefix")]
        public Input<string>? Prefix { get; set; }

        /// <summary>
        /// The Secret to select from
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.SecretEnvSourceArgs>? SecretRef { get; set; }

    }

    /// <summary>
    /// EnvVar represents an environment variable present in a Container.
    /// </summary>
    public class EnvVarArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of the environment variable. Must be a C_IDENTIFIER.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Variable references $(VAR_NAME) are expanded using the previous defined environment
        /// variables in the container and any service environment variables. If a variable cannot
        /// be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
        /// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be
        /// expanded, regardless of whether the variable exists or not. Defaults to "".
        /// </summary>
        [Input("value")]
        public Input<string>? Value { get; set; }

        /// <summary>
        /// Source for the environment variable's value. Cannot be used if value is not empty.
        /// </summary>
        [Input("valueFrom")]
        public Input<Core.V1.EnvVarSourceArgs>? ValueFrom { get; set; }

    }

    /// <summary>
    /// EnvVarSource represents a source for the value of an EnvVar.
    /// </summary>
    public class EnvVarSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Selects a key of a ConfigMap.
        /// </summary>
        [Input("configMapKeyRef")]
        public Input<Core.V1.ConfigMapKeySelectorArgs>? ConfigMapKeyRef { get; set; }

        /// <summary>
        /// Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels,
        /// metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP,
        /// status.podIP.
        /// </summary>
        [Input("fieldRef")]
        public Input<Core.V1.ObjectFieldSelectorArgs>? FieldRef { get; set; }

        /// <summary>
        /// Selects a resource of the container: only resources limits and requests (limits.cpu,
        /// limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and
        /// requests.ephemeral-storage) are currently supported.
        /// </summary>
        [Input("resourceFieldRef")]
        public Input<Core.V1.ResourceFieldSelectorArgs>? ResourceFieldRef { get; set; }

        /// <summary>
        /// Selects a key of a secret in the pod's namespace
        /// </summary>
        [Input("secretKeyRef")]
        public Input<Core.V1.SecretKeySelectorArgs>? SecretKeyRef { get; set; }

    }

    /// <summary>
    /// An EphemeralContainer is a container that may be added temporarily to an existing pod for
    /// user-initiated activities such as debugging. Ephemeral containers have no resource or
    /// scheduling guarantees, and they will not be restarted when they exit or when a pod is
    /// removed or restarted. If an ephemeral container causes a pod to exceed its resource
    /// allocation, the pod may be evicted. Ephemeral containers may not be added by directly
    /// updating the pod spec. They must be added via the pod's ephemeralcontainers subresource, and
    /// they will appear in the pod spec once added. This is an alpha feature enabled by the
    /// EphemeralContainers feature flag.
    /// </summary>
    public class EphemeralContainerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among
        /// all containers, init containers and ephemeral containers.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("args")]
        private InputList<string>? _args;

        /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a
        /// variable cannot be resolved, the reference in the input string will be unchanged. The
        /// $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references
        /// will never be expanded, regardless of whether the variable exists or not. Cannot be
        /// updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        public InputList<string> Args
        {
            get => _args ?? (_args = new InputList<string>());
            set => _args = value;
        }

        [Input("command")]
        private InputList<string>? _command;

        /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if
        /// this is not provided. Variable references $(VAR_NAME) are expanded using the container's
        /// environment. If a variable cannot be resolved, the reference in the input string will be
        /// unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
        /// Escaped references will never be expanded, regardless of whether the variable exists or
        /// not. Cannot be updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        public InputList<string> Command
        {
            get => _command ?? (_command = new InputList<string>());
            set => _command = value;
        }

        [Input("env")]
        private InputList<Core.V1.EnvVarArgs>? _env;

        /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
        public InputList<Core.V1.EnvVarArgs> Env
        {
            get => _env ?? (_env = new InputList<Core.V1.EnvVarArgs>());
            set => _env = value;
        }

        [Input("envFrom")]
        private InputList<Core.V1.EnvFromSourceArgs>? _envFrom;

        /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined
        /// within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event
        /// when the container is starting. When a key exists in multiple sources, the value
        /// associated with the last source will take precedence. Values defined by an Env with a
        /// duplicate key will take precedence. Cannot be updated.
        /// </summary>
        public InputList<Core.V1.EnvFromSourceArgs> EnvFrom
        {
            get => _envFrom ?? (_envFrom = new InputList<Core.V1.EnvFromSourceArgs>());
            set => _envFrom = value;
        }

        /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag
        /// is specified, or IfNotPresent otherwise. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
        [Input("imagePullPolicy")]
        public Input<string>? ImagePullPolicy { get; set; }

        /// <summary>
        /// Lifecycle is not allowed for ephemeral containers.
        /// </summary>
        [Input("lifecycle")]
        public Input<Core.V1.LifecycleArgs>? Lifecycle { get; set; }

        /// <summary>
        /// Probes are not allowed for ephemeral containers.
        /// </summary>
        [Input("livenessProbe")]
        public Input<Core.V1.ProbeArgs>? LivenessProbe { get; set; }

        [Input("ports")]
        private InputList<Core.V1.ContainerPortArgs>? _ports;

        /// <summary>
        /// Ports are not allowed for ephemeral containers.
        /// </summary>
        public InputList<Core.V1.ContainerPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Core.V1.ContainerPortArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// Probes are not allowed for ephemeral containers.
        /// </summary>
        [Input("readinessProbe")]
        public Input<Core.V1.ProbeArgs>? ReadinessProbe { get; set; }

        /// <summary>
        /// Resources are not allowed for ephemeral containers. Ephemeral containers use spare
        /// resources already allocated to the pod.
        /// </summary>
        [Input("resources")]
        public Input<Core.V1.ResourceRequirementsArgs>? Resources { get; set; }

        /// <summary>
        /// SecurityContext is not allowed for ephemeral containers.
        /// </summary>
        [Input("securityContext")]
        public Input<Core.V1.SecurityContextArgs>? SecurityContext { get; set; }

        /// <summary>
        /// Probes are not allowed for ephemeral containers.
        /// </summary>
        [Input("startupProbe")]
        public Input<Core.V1.ProbeArgs>? StartupProbe { get; set; }

        /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If
        /// this is not set, reads from stdin in the container will always result in EOF. Default is
        /// false.
        /// </summary>
        [Input("stdin")]
        public Input<bool>? Stdin { get; set; }

        /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by
        /// a single attach. When stdin is true the stdin stream will remain open across multiple
        /// attach sessions. If stdinOnce is set to true, stdin is opened on container start, is
        /// empty until the first client attaches to stdin, and then remains open and accepts data
        /// until the client disconnects, at which time stdin is closed and remains closed until the
        /// container is restarted. If this flag is false, a container processes that reads from
        /// stdin will never receive an EOF. Default is false
        /// </summary>
        [Input("stdinOnce")]
        public Input<bool>? StdinOnce { get; set; }

        /// <summary>
        /// If set, the name of the container from PodSpec that this ephemeral container targets.
        /// The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
        /// If not set then the ephemeral container is run in whatever namespaces are shared for the
        /// pod. Note that the container runtime must support this feature.
        /// </summary>
        [Input("targetContainerName")]
        public Input<string>? TargetContainerName { get; set; }

        /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be
        /// written is mounted into the container's filesystem. Message written is intended to be
        /// brief final status, such as an assertion failure message. Will be truncated by the node
        /// if greater than 4096 bytes. The total message length across all containers will be
        /// limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
        [Input("terminationMessagePath")]
        public Input<string>? TerminationMessagePath { get; set; }

        /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of
        /// terminationMessagePath to populate the container status message on both success and
        /// failure. FallbackToLogsOnError will use the last chunk of container log output if the
        /// termination message file is empty and the container exited with an error. The log output
        /// is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be
        /// updated.
        /// </summary>
        [Input("terminationMessagePolicy")]
        public Input<string>? TerminationMessagePolicy { get; set; }

        /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be
        /// true. Default is false.
        /// </summary>
        [Input("tty")]
        public Input<bool>? Tty { get; set; }

        [Input("volumeDevices")]
        private InputList<Core.V1.VolumeDeviceArgs>? _volumeDevices;

        /// <summary>
        /// volumeDevices is the list of block devices to be used by the container. This is a beta
        /// feature.
        /// </summary>
        public InputList<Core.V1.VolumeDeviceArgs> VolumeDevices
        {
            get => _volumeDevices ?? (_volumeDevices = new InputList<Core.V1.VolumeDeviceArgs>());
            set => _volumeDevices = value;
        }

        [Input("volumeMounts")]
        private InputList<Core.V1.VolumeMountArgs>? _volumeMounts;

        /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
        public InputList<Core.V1.VolumeMountArgs> VolumeMounts
        {
            get => _volumeMounts ?? (_volumeMounts = new InputList<Core.V1.VolumeMountArgs>());
            set => _volumeMounts = value;
        }

        /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be
        /// used, which might be configured in the container image. Cannot be updated.
        /// </summary>
        [Input("workingDir")]
        public Input<string>? WorkingDir { get; set; }

    }

    /// <summary>
    /// Event is a report of an event somewhere in the cluster.
    /// </summary>
    public class EventArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The object that this event is about.
        /// </summary>
        [Input("involvedObject", required: true)]
        public Input<Core.V1.ObjectReferenceArgs> InvolvedObject { get; set; } = null!;

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata", required: true)]
        public Input<Meta.V1.ObjectMetaArgs> Metadata { get; set; } = null!;

        /// <summary>
        /// What action was taken/failed regarding to the Regarding object.
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// The number of times this event has occurred.
        /// </summary>
        [Input("count")]
        public Input<int>? Count { get; set; }

        /// <summary>
        /// Time when this Event was first observed.
        /// </summary>
        [Input("eventTime")]
        public Input<string>? EventTime { get; set; }

        /// <summary>
        /// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
        /// </summary>
        [Input("firstTimestamp")]
        public Input<string>? FirstTimestamp { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// The time at which the most recent occurrence of this event was recorded.
        /// </summary>
        [Input("lastTimestamp")]
        public Input<string>? LastTimestamp { get; set; }

        /// <summary>
        /// A human-readable description of the status of this operation.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// This should be a short, machine understandable string that gives the reason for the
        /// transition into the object's current status.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

        /// <summary>
        /// Optional secondary object for more complex actions.
        /// </summary>
        [Input("related")]
        public Input<Core.V1.ObjectReferenceArgs>? Related { get; set; }

        /// <summary>
        /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
        /// </summary>
        [Input("reportingComponent")]
        public Input<string>? ReportingComponent { get; set; }

        /// <summary>
        /// ID of the controller instance, e.g. `kubelet-xyzf`.
        /// </summary>
        [Input("reportingInstance")]
        public Input<string>? ReportingInstance { get; set; }

        /// <summary>
        /// Data about the Event series this event represents or nil if it's a singleton Event.
        /// </summary>
        [Input("series")]
        public Input<Core.V1.EventSeriesArgs>? Series { get; set; }

        /// <summary>
        /// The component reporting this event. Should be a short machine understandable string.
        /// </summary>
        [Input("source")]
        public Input<Core.V1.EventSourceArgs>? Source { get; set; }

        /// <summary>
        /// Type of this event (Normal, Warning), new types could be added in the future
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// EventList is a list of events.
    /// </summary>
    public class EventListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.EventArgs>? _items;

        /// <summary>
        /// List of events
        /// </summary>
        public InputList<Core.V1.EventArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.EventArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// EventSeries contain information on series of events, i.e. thing that was/is happening
    /// continuously for some time.
    /// </summary>
    public class EventSeriesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Number of occurrences in this series up to the last heartbeat time
        /// </summary>
        [Input("count")]
        public Input<int>? Count { get; set; }

        /// <summary>
        /// Time of the last occurrence observed
        /// </summary>
        [Input("lastObservedTime")]
        public Input<string>? LastObservedTime { get; set; }

        /// <summary>
        /// State of this Series: Ongoing or Finished Deprecated. Planned removal for 1.18
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

    }

    /// <summary>
    /// EventSource contains information for an event.
    /// </summary>
    public class EventSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Component from which the event is generated.
        /// </summary>
        [Input("component")]
        public Input<string>? Component { get; set; }

        /// <summary>
        /// Node name on which the event is generated.
        /// </summary>
        [Input("host")]
        public Input<string>? Host { get; set; }

    }

    /// <summary>
    /// ExecAction describes a "run in container" action.
    /// </summary>
    public class ExecActionArgs : Pulumi.ResourceArgs
    {
        [Input("command")]
        private InputList<string>? _command;

        /// <summary>
        /// Command is the command line to execute inside the container, the working directory for
        /// the command  is root ('/') in the container's filesystem. The command is simply exec'd,
        /// it is not run inside a shell, so traditional shell instructions ('|', etc) won't work.
        /// To use a shell, you need to explicitly call out to that shell. Exit status of 0 is
        /// treated as live/healthy and non-zero is unhealthy.
        /// </summary>
        public InputList<string> Command
        {
            get => _command ?? (_command = new InputList<string>());
            set => _command = value;
        }

    }

    /// <summary>
    /// Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write
    /// once. Fibre Channel volumes support ownership management and SELinux relabeling.
    /// </summary>
    public class FCVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Optional: FC target lun number
        /// </summary>
        [Input("lun")]
        public Input<int>? Lun { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        [Input("targetWWNs")]
        private InputList<string>? _targetWWNs;

        /// <summary>
        /// Optional: FC target worldwide names (WWNs)
        /// </summary>
        public InputList<string> TargetWWNs
        {
            get => _targetWWNs ?? (_targetWWNs = new InputList<string>());
            set => _targetWWNs = value;
        }

        [Input("wwids")]
        private InputList<string>? _wwids;

        /// <summary>
        /// Optional: FC volume world wide identifiers (wwids) Either wwids or combination of
        /// targetWWNs and lun must be set, but not both simultaneously.
        /// </summary>
        public InputList<string> Wwids
        {
            get => _wwids ?? (_wwids = new InputList<string>());
            set => _wwids = value;
        }

    }

    /// <summary>
    /// FlexPersistentVolumeSource represents a generic persistent volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// </summary>
    public class FlexPersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Driver is the name of the driver to use for this volume.
        /// </summary>
        [Input("driver", required: true)]
        public Input<string> Driver { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        [Input("options")]
        private InputMap<string>? _options;

        /// <summary>
        /// Optional: Extra command options if any.
        /// </summary>
        public InputMap<string> Options
        {
            get => _options ?? (_options = new InputMap<string>());
            set => _options = value;
        }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the secret object containing sensitive information
        /// to pass to the plugin scripts. This may be empty if no secret object is specified. If
        /// the secret object contains more than one secret, all secrets are passed to the plugin
        /// scripts.
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.SecretReferenceArgs>? SecretRef { get; set; }

    }

    /// <summary>
    /// FlexVolume represents a generic volume resource that is provisioned/attached using an exec
    /// based plugin.
    /// </summary>
    public class FlexVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Driver is the name of the driver to use for this volume.
        /// </summary>
        [Input("driver", required: true)]
        public Input<string> Driver { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        [Input("options")]
        private InputMap<string>? _options;

        /// <summary>
        /// Optional: Extra command options if any.
        /// </summary>
        public InputMap<string> Options
        {
            get => _options ?? (_options = new InputMap<string>());
            set => _options = value;
        }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the secret object containing sensitive information
        /// to pass to the plugin scripts. This may be empty if no secret object is specified. If
        /// the secret object contains more than one secret, all secrets are passed to the plugin
        /// scripts.
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.LocalObjectReferenceArgs>? SecretRef { get; set; }

    }

    /// <summary>
    /// Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName
    /// and datasetUUID should be set. Flocker volumes do not support ownership management or
    /// SELinux relabeling.
    /// </summary>
    public class FlockerVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of the dataset stored as metadata -&amp;gt; name on the dataset for Flocker should
        /// be considered as deprecated
        /// </summary>
        [Input("datasetName")]
        public Input<string>? DatasetName { get; set; }

        /// <summary>
        /// UUID of the dataset. This is unique identifier of a Flocker dataset
        /// </summary>
        [Input("datasetUUID")]
        public Input<string>? DatasetUUID { get; set; }

    }

    /// <summary>
    /// Represents a Persistent Disk resource in Google Compute Engine.
    /// 
    /// A GCE PD must exist before mounting to a container. The disk must also be in the same GCE
    /// project and zone as the kubelet. A GCE PD can only be mounted as read/write once or
    /// read-only many times. GCE PDs support ownership management and SELinux relabeling.
    /// </summary>
    public class GCEPersistentDiskVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Input("pdName", required: true)]
        public Input<string> PdName { get; set; } = null!;

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// The partition in the volume that you want to mount. If omitted, the default is to mount
        /// by volume name. Examples: For volume /dev/sda1, you specify the partition as "1".
        /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property
        /// empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Input("partition")]
        public Input<int>? Partition { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
        /// info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Represents a volume that is populated with the contents of a git repository. Git repo
    /// volumes do not support ownership management. Git repo volumes support SELinux relabeling.
    /// 
    /// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into
    /// the Pod's container.
    /// </summary>
    public class GitRepoVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Repository URL
        /// </summary>
        [Input("repository", required: true)]
        public Input<string> Repository { get; set; } = null!;

        /// <summary>
        /// Target directory name. Must not contain or start with '..'.  If '.' is supplied, the
        /// volume directory will be the git repository.  Otherwise, if specified, the volume will
        /// contain the git repository in the subdirectory with the given name.
        /// </summary>
        [Input("directory")]
        public Input<string>? Directory { get; set; }

        /// <summary>
        /// Commit hash for the specified revision.
        /// </summary>
        [Input("revision")]
        public Input<string>? Revision { get; set; }

    }

    /// <summary>
    /// Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    public class GlusterfsPersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// EndpointsName is the endpoint name that details Glusterfs topology. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Input("endpoints", required: true)]
        public Input<string> Endpoints { get; set; } = null!;

        /// <summary>
        /// Path is the Glusterfs volume path. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// EndpointsNamespace is the namespace that contains Glusterfs endpoint. If this field is
        /// empty, the EndpointNamespace defaults to the same namespace as the bound PVC. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Input("endpointsNamespace")]
        public Input<string>? EndpointsNamespace { get; set; }

        /// <summary>
        /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
        /// Defaults to false. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    public class GlusterfsVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// EndpointsName is the endpoint name that details Glusterfs topology. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Input("endpoints", required: true)]
        public Input<string> Endpoints { get; set; } = null!;

        /// <summary>
        /// Path is the Glusterfs volume path. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
        /// Defaults to false. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// HTTPGetAction describes an action based on HTTP Get requests.
    /// </summary>
    public class HTTPGetActionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name or number of the port to access on the container. Number must be in the range 1 to
        /// 65535. Name must be an IANA_SVC_NAME.
        /// </summary>
        [Input("port", required: true)]
        public InputUnion<int,string> Port { get; set; } = null!;

        /// <summary>
        /// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in
        /// httpHeaders instead.
        /// </summary>
        [Input("host")]
        public Input<string>? Host { get; set; }

        [Input("httpHeaders")]
        private InputList<Core.V1.HTTPHeaderArgs>? _httpHeaders;

        /// <summary>
        /// Custom headers to set in the request. HTTP allows repeated headers.
        /// </summary>
        public InputList<Core.V1.HTTPHeaderArgs> HttpHeaders
        {
            get => _httpHeaders ?? (_httpHeaders = new InputList<Core.V1.HTTPHeaderArgs>());
            set => _httpHeaders = value;
        }

        /// <summary>
        /// Path to access on the HTTP server.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// Scheme to use for connecting to the host. Defaults to HTTP.
        /// </summary>
        [Input("scheme")]
        public Input<string>? Scheme { get; set; }

    }

    /// <summary>
    /// HTTPHeader describes a custom header to be used in HTTP probes
    /// </summary>
    public class HTTPHeaderArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The header field name
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// The header field value
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

    }

    /// <summary>
    /// Handler defines a specific action that should be taken
    /// </summary>
    public class HandlerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// One and only one of the following should be specified. Exec specifies the action to
        /// take.
        /// </summary>
        [Input("exec")]
        public Input<Core.V1.ExecActionArgs>? Exec { get; set; }

        /// <summary>
        /// HTTPGet specifies the http request to perform.
        /// </summary>
        [Input("httpGet")]
        public Input<Core.V1.HTTPGetActionArgs>? HttpGet { get; set; }

        /// <summary>
        /// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        /// </summary>
        [Input("tcpSocket")]
        public Input<Core.V1.TCPSocketActionArgs>? TcpSocket { get; set; }

    }

    /// <summary>
    /// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in
    /// the pod's hosts file.
    /// </summary>
    public class HostAliasArgs : Pulumi.ResourceArgs
    {
        [Input("hostnames")]
        private InputList<string>? _hostnames;

        /// <summary>
        /// Hostnames for the above IP address.
        /// </summary>
        public InputList<string> Hostnames
        {
            get => _hostnames ?? (_hostnames = new InputList<string>());
            set => _hostnames = value;
        }

        /// <summary>
        /// IP address of the host file entry.
        /// </summary>
        [Input("ip")]
        public Input<string>? Ip { get; set; }

    }

    /// <summary>
    /// Represents a host path mapped into a pod. Host path volumes do not support ownership
    /// management or SELinux relabeling.
    /// </summary>
    public class HostPathVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Path of the directory on the host. If the path is a symlink, it will follow the link to
        /// the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Type for HostPath Volume Defaults to "" More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// ISCSIPersistentVolumeSource represents an ISCSI disk. ISCSI volumes can only be mounted as
    /// read/write once. ISCSI volumes support ownership management and SELinux relabeling.
    /// </summary>
    public class ISCSIPersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Target iSCSI Qualified Name.
        /// </summary>
        [Input("iqn", required: true)]
        public Input<string> Iqn { get; set; } = null!;

        /// <summary>
        /// iSCSI Target Lun number.
        /// </summary>
        [Input("lun", required: true)]
        public Input<int> Lun { get; set; } = null!;

        /// <summary>
        /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other
        /// than default (typically TCP ports 860 and 3260).
        /// </summary>
        [Input("targetPortal", required: true)]
        public Input<string> TargetPortal { get; set; } = null!;

        /// <summary>
        /// whether support iSCSI Discovery CHAP authentication
        /// </summary>
        [Input("chapAuthDiscovery")]
        public Input<bool>? ChapAuthDiscovery { get; set; }

        /// <summary>
        /// whether support iSCSI Session CHAP authentication
        /// </summary>
        [Input("chapAuthSession")]
        public Input<bool>? ChapAuthSession { get; set; }

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
        /// simultaneously, new iSCSI interface &amp;lt;target portal&amp;gt;:&amp;lt;volume
        /// name&amp;gt; will be created for the connection.
        /// </summary>
        [Input("initiatorName")]
        public Input<string>? InitiatorName { get; set; }

        /// <summary>
        /// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
        /// </summary>
        [Input("iscsiInterface")]
        public Input<string>? IscsiInterface { get; set; }

        [Input("portals")]
        private InputList<string>? _portals;

        /// <summary>
        /// iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port is
        /// other than default (typically TCP ports 860 and 3260).
        /// </summary>
        public InputList<string> Portals
        {
            get => _portals ?? (_portals = new InputList<string>());
            set => _portals = value;
        }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// CHAP Secret for iSCSI target and initiator authentication
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.SecretReferenceArgs>? SecretRef { get; set; }

    }

    /// <summary>
    /// Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI
    /// volumes support ownership management and SELinux relabeling.
    /// </summary>
    public class ISCSIVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Target iSCSI Qualified Name.
        /// </summary>
        [Input("iqn", required: true)]
        public Input<string> Iqn { get; set; } = null!;

        /// <summary>
        /// iSCSI Target Lun number.
        /// </summary>
        [Input("lun", required: true)]
        public Input<int> Lun { get; set; } = null!;

        /// <summary>
        /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other
        /// than default (typically TCP ports 860 and 3260).
        /// </summary>
        [Input("targetPortal", required: true)]
        public Input<string> TargetPortal { get; set; } = null!;

        /// <summary>
        /// whether support iSCSI Discovery CHAP authentication
        /// </summary>
        [Input("chapAuthDiscovery")]
        public Input<bool>? ChapAuthDiscovery { get; set; }

        /// <summary>
        /// whether support iSCSI Session CHAP authentication
        /// </summary>
        [Input("chapAuthSession")]
        public Input<bool>? ChapAuthSession { get; set; }

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
        /// simultaneously, new iSCSI interface &amp;lt;target portal&amp;gt;:&amp;lt;volume
        /// name&amp;gt; will be created for the connection.
        /// </summary>
        [Input("initiatorName")]
        public Input<string>? InitiatorName { get; set; }

        /// <summary>
        /// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
        /// </summary>
        [Input("iscsiInterface")]
        public Input<string>? IscsiInterface { get; set; }

        [Input("portals")]
        private InputList<string>? _portals;

        /// <summary>
        /// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is
        /// other than default (typically TCP ports 860 and 3260).
        /// </summary>
        public InputList<string> Portals
        {
            get => _portals ?? (_portals = new InputList<string>());
            set => _portals = value;
        }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// CHAP Secret for iSCSI target and initiator authentication
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.LocalObjectReferenceArgs>? SecretRef { get; set; }

    }

    /// <summary>
    /// Maps a string key to a path within a volume.
    /// </summary>
    public class KeyToPathArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The key to project.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// The relative path of the file to map the key to. May not be an absolute path. May not
        /// contain the path element '..'. May not start with the string '..'.
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not
        /// specified, the volume defaultMode will be used. This might be in conflict with other
        /// options that affect the file mode, like fsGroup, and the result can be other mode bits
        /// set.
        /// </summary>
        [Input("mode")]
        public Input<int>? Mode { get; set; }

    }

    /// <summary>
    /// Lifecycle describes actions that the management system should take in response to container
    /// lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the
    /// container blocks until the action is complete, unless the container process fails, in which
    /// case the handler is aborted.
    /// </summary>
    public class LifecycleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// PostStart is called immediately after a container is created. If the handler fails, the
        /// container is terminated and restarted according to its restart policy. Other management
        /// of the container blocks until the hook completes. More info:
        /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        /// </summary>
        [Input("postStart")]
        public Input<Core.V1.HandlerArgs>? PostStart { get; set; }

        /// <summary>
        /// PreStop is called immediately before a container is terminated due to an API request or
        /// management event such as liveness/startup probe failure, preemption, resource
        /// contention, etc. The handler is not called if the container crashes or exits. The reason
        /// for termination is passed to the handler. The Pod's termination grace period countdown
        /// begins before the PreStop hooked is executed. Regardless of the outcome of the handler,
        /// the container will eventually terminate within the Pod's termination grace period. Other
        /// management of the container blocks until the hook completes or until the termination
        /// grace period is reached. More info:
        /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        /// </summary>
        [Input("preStop")]
        public Input<Core.V1.HandlerArgs>? PreStop { get; set; }

    }

    /// <summary>
    /// LimitRange sets resource usage limits for each kind of resource in a Namespace.
    /// </summary>
    public class LimitRangeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the limits enforced. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.LimitRangeSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
    /// </summary>
    public class LimitRangeItemArgs : Pulumi.ResourceArgs
    {
        [Input("default")]
        private InputMap<string>? _default;

        /// <summary>
        /// Default resource requirement limit value by resource name if resource limit is omitted.
        /// </summary>
        public InputMap<string> Default
        {
            get => _default ?? (_default = new InputMap<string>());
            set => _default = value;
        }

        [Input("defaultRequest")]
        private InputMap<string>? _defaultRequest;

        /// <summary>
        /// DefaultRequest is the default resource requirement request value by resource name if
        /// resource request is omitted.
        /// </summary>
        public InputMap<string> DefaultRequest
        {
            get => _defaultRequest ?? (_defaultRequest = new InputMap<string>());
            set => _defaultRequest = value;
        }

        [Input("max")]
        private InputMap<string>? _max;

        /// <summary>
        /// Max usage constraints on this kind by resource name.
        /// </summary>
        public InputMap<string> Max
        {
            get => _max ?? (_max = new InputMap<string>());
            set => _max = value;
        }

        [Input("maxLimitRequestRatio")]
        private InputMap<string>? _maxLimitRequestRatio;

        /// <summary>
        /// MaxLimitRequestRatio if specified, the named resource must have a request and limit that
        /// are both non-zero where limit divided by request is less than or equal to the enumerated
        /// value; this represents the max burst for the named resource.
        /// </summary>
        public InputMap<string> MaxLimitRequestRatio
        {
            get => _maxLimitRequestRatio ?? (_maxLimitRequestRatio = new InputMap<string>());
            set => _maxLimitRequestRatio = value;
        }

        [Input("min")]
        private InputMap<string>? _min;

        /// <summary>
        /// Min usage constraints on this kind by resource name.
        /// </summary>
        public InputMap<string> Min
        {
            get => _min ?? (_min = new InputMap<string>());
            set => _min = value;
        }

        /// <summary>
        /// Type of resource that this limit applies to.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// LimitRangeList is a list of LimitRange items.
    /// </summary>
    public class LimitRangeListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.LimitRangeArgs>? _items;

        /// <summary>
        /// Items is a list of LimitRange objects. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
        public InputList<Core.V1.LimitRangeArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.LimitRangeArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// LimitRangeSpec defines a min/max usage limit for resources that match on kind.
    /// </summary>
    public class LimitRangeSpecArgs : Pulumi.ResourceArgs
    {
        [Input("limits", required: true)]
        private InputList<Core.V1.LimitRangeItemArgs>? _limits;

        /// <summary>
        /// Limits is the list of LimitRangeItem objects that are enforced.
        /// </summary>
        public InputList<Core.V1.LimitRangeItemArgs> Limits
        {
            get => _limits ?? (_limits = new InputList<Core.V1.LimitRangeItemArgs>());
            set => _limits = value;
        }

    }

    /// <summary>
    /// LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended
    /// for the service should be sent to an ingress point.
    /// </summary>
    public class LoadBalancerIngressArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Hostname is set for load-balancer ingress points that are DNS based (typically AWS
        /// load-balancers)
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack
        /// load-balancers)
        /// </summary>
        [Input("ip")]
        public Input<string>? Ip { get; set; }

    }

    /// <summary>
    /// LoadBalancerStatus represents the status of a load-balancer.
    /// </summary>
    public class LoadBalancerStatusArgs : Pulumi.ResourceArgs
    {
        [Input("ingress")]
        private InputList<Core.V1.LoadBalancerIngressArgs>? _ingress;

        /// <summary>
        /// Ingress is a list containing ingress points for the load-balancer. Traffic intended for
        /// the service should be sent to these ingress points.
        /// </summary>
        public InputList<Core.V1.LoadBalancerIngressArgs> Ingress
        {
            get => _ingress ?? (_ingress = new InputList<Core.V1.LoadBalancerIngressArgs>());
            set => _ingress = value;
        }

    }

    /// <summary>
    /// LocalObjectReference contains enough information to let you locate the referenced object
    /// inside the same namespace.
    /// </summary>
    public class LocalObjectReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

    }

    /// <summary>
    /// Local represents directly-attached storage with node affinity (Beta feature)
    /// </summary>
    public class LocalVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The full path to the volume on the node. It can be either a directory or block device
        /// (disk, partition, ...).
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. It applies only when the Path is a block device. Must be a
        /// filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The
        /// default value is to auto-select a fileystem if unspecified.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

    }

    /// <summary>
    /// Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support
    /// ownership management or SELinux relabeling.
    /// </summary>
    public class NFSVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Path that is exported by the NFS server. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Server is the hostname or IP address of the NFS server. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [Input("server", required: true)]
        public Input<string> Server { get; set; } = null!;

        /// <summary>
        /// ReadOnly here will force the NFS export to be mounted with read-only permissions.
        /// Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Namespace provides a scope for Names. Use of multiple namespaces is optional.
    /// </summary>
    public class NamespaceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the behavior of the Namespace. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.NamespaceSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// NamespaceCondition contains details about state of namespace.
    /// </summary>
    public class NamespaceConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of namespace controller condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        
        [Input("message")]
        public Input<string>? Message { get; set; }

        
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// NamespaceList is a list of Namespaces.
    /// </summary>
    public class NamespaceListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.NamespaceArgs>? _items;

        /// <summary>
        /// Items is the list of Namespace objects in the list. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        /// </summary>
        public InputList<Core.V1.NamespaceArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.NamespaceArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// NamespaceSpec describes the attributes on a Namespace.
    /// </summary>
    public class NamespaceSpecArgs : Pulumi.ResourceArgs
    {
        [Input("finalizers")]
        private InputList<string>? _finalizers;

        /// <summary>
        /// Finalizers is an opaque list of values that must be empty to permanently remove object
        /// from storage. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
        /// </summary>
        public InputList<string> Finalizers
        {
            get => _finalizers ?? (_finalizers = new InputList<string>());
            set => _finalizers = value;
        }

    }

    /// <summary>
    /// NamespaceStatus is information about the current status of a Namespace.
    /// </summary>
    public class NamespaceStatusArgs : Pulumi.ResourceArgs
    {
        [Input("conditions")]
        private InputList<Core.V1.NamespaceConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a namespace's current state.
        /// </summary>
        public InputList<Core.V1.NamespaceConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Core.V1.NamespaceConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// Phase is the current lifecycle phase of the namespace. More info:
        /// https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
        /// </summary>
        [Input("phase")]
        public Input<string>? Phase { get; set; }

    }

    /// <summary>
    /// Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache
    /// (i.e. in etcd).
    /// </summary>
    public class NodeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the behavior of a node.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.NodeSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// NodeAddress contains information for the node's address.
    /// </summary>
    public class NodeAddressArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The node address.
        /// </summary>
        [Input("address", required: true)]
        public Input<string> Address { get; set; } = null!;

        /// <summary>
        /// Node address type, one of Hostname, ExternalIP or InternalIP.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

    }

    /// <summary>
    /// Node affinity is a group of node affinity scheduling rules.
    /// </summary>
    public class NodeAffinityArgs : Pulumi.ResourceArgs
    {
        [Input("preferredDuringSchedulingIgnoredDuringExecution")]
        private InputList<Core.V1.PreferredSchedulingTermArgs>? _preferredDuringSchedulingIgnoredDuringExecution;

        /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity
        /// expressions specified by this field, but it may choose a node that violates one or more
        /// of the expressions. The node that is most preferred is the one with the greatest sum of
        /// weights, i.e. for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling affinity expressions, etc.), compute a sum by
        /// iterating through the elements of this field and adding "weight" to the sum if the node
        /// matches the corresponding matchExpressions; the node(s) with the highest sum are the
        /// most preferred.
        /// </summary>
        public InputList<Core.V1.PreferredSchedulingTermArgs> PreferredDuringSchedulingIgnoredDuringExecution
        {
            get => _preferredDuringSchedulingIgnoredDuringExecution ?? (_preferredDuringSchedulingIgnoredDuringExecution = new InputList<Core.V1.PreferredSchedulingTermArgs>());
            set => _preferredDuringSchedulingIgnoredDuringExecution = value;
        }

        /// <summary>
        /// If the affinity requirements specified by this field are not met at scheduling time, the
        /// pod will not be scheduled onto the node. If the affinity requirements specified by this
        /// field cease to be met at some point during pod execution (e.g. due to an update), the
        /// system may or may not try to eventually evict the pod from its node.
        /// </summary>
        [Input("requiredDuringSchedulingIgnoredDuringExecution")]
        public Input<Core.V1.NodeSelectorArgs>? RequiredDuringSchedulingIgnoredDuringExecution { get; set; }

    }

    /// <summary>
    /// NodeCondition contains condition information for a node.
    /// </summary>
    public class NodeConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of node condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time we got an update on a given condition.
        /// </summary>
        [Input("lastHeartbeatTime")]
        public Input<string>? LastHeartbeatTime { get; set; }

        /// <summary>
        /// Last time the condition transit from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human readable message indicating details about last transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// (brief) reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding
    /// metadata) must be non-nil.
    /// </summary>
    public class NodeConfigSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ConfigMap is a reference to a Node's ConfigMap
        /// </summary>
        [Input("configMap")]
        public Input<Core.V1.ConfigMapNodeConfigSourceArgs>? ConfigMap { get; set; }

    }

    /// <summary>
    /// NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
    /// </summary>
    public class NodeConfigStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Active reports the checkpointed config the node is actively using. Active will represent
        /// either the current version of the Assigned config, or the current LastKnownGood config,
        /// depending on whether attempting to use the Assigned config results in an error.
        /// </summary>
        [Input("active")]
        public Input<Core.V1.NodeConfigSourceArgs>? Active { get; set; }

        /// <summary>
        /// Assigned reports the checkpointed config the node will try to use. When
        /// Node.Spec.ConfigSource is updated, the node checkpoints the associated config payload to
        /// local disk, along with a record indicating intended config. The node refers to this
        /// record to choose its config checkpoint, and reports this record in Assigned. Assigned
        /// only updates in the status after the record has been checkpointed to disk. When the
        /// Kubelet is restarted, it tries to make the Assigned config the Active config by loading
        /// and validating the checkpointed payload identified by Assigned.
        /// </summary>
        [Input("assigned")]
        public Input<Core.V1.NodeConfigSourceArgs>? Assigned { get; set; }

        /// <summary>
        /// Error describes any problems reconciling the Spec.ConfigSource to the Active config.
        /// Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local
        /// Assigned record, attempting to checkpoint the payload associated with Spec.ConfigSource,
        /// attempting to load or validate the Assigned config, etc. Errors may occur at different
        /// points while syncing config. Earlier errors (e.g. download or checkpointing errors) will
        /// not result in a rollback to LastKnownGood, and may resolve across Kubelet retries. Later
        /// errors (e.g. loading or validating a checkpointed config) will result in a rollback to
        /// LastKnownGood. In the latter case, it is usually possible to resolve the error by fixing
        /// the config assigned in Spec.ConfigSource. You can find additional information for
        /// debugging by searching the error message in the Kubelet log. Error is a human-readable
        /// description of the error state; machines can check whether or not Error is empty, but
        /// should not rely on the stability of the Error text across Kubelet versions.
        /// </summary>
        [Input("error")]
        public Input<string>? Error { get; set; }

        /// <summary>
        /// LastKnownGood reports the checkpointed config the node will fall back to when it
        /// encounters an error attempting to use the Assigned config. The Assigned config becomes
        /// the LastKnownGood config when the node determines that the Assigned config is stable and
        /// correct. This is currently implemented as a 10-minute soak period starting when the
        /// local record of Assigned config is updated. If the Assigned config is Active at the end
        /// of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is reset to
        /// nil (use local defaults), the LastKnownGood is also immediately reset to nil, because
        /// the local default config is always assumed good. You should not make assumptions about
        /// the node's method of determining config stability and correctness, as this may change or
        /// become configurable in the future.
        /// </summary>
        [Input("lastKnownGood")]
        public Input<Core.V1.NodeConfigSourceArgs>? LastKnownGood { get; set; }

    }

    /// <summary>
    /// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
    /// </summary>
    public class NodeDaemonEndpointsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Endpoint on which Kubelet is listening.
        /// </summary>
        [Input("kubeletEndpoint")]
        public Input<Core.V1.DaemonEndpointArgs>? KubeletEndpoint { get; set; }

    }

    /// <summary>
    /// NodeList is the whole list of all Nodes which have been registered with master.
    /// </summary>
    public class NodeListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.NodeArgs>? _items;

        /// <summary>
        /// List of nodes
        /// </summary>
        public InputList<Core.V1.NodeArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.NodeArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// A node selector represents the union of the results of one or more label queries over a set
    /// of nodes; that is, it represents the OR of the selectors represented by the node selector
    /// terms.
    /// </summary>
    public class NodeSelectorArgs : Pulumi.ResourceArgs
    {
        [Input("nodeSelectorTerms", required: true)]
        private InputList<Core.V1.NodeSelectorTermArgs>? _nodeSelectorTerms;

        /// <summary>
        /// Required. A list of node selector terms. The terms are ORed.
        /// </summary>
        public InputList<Core.V1.NodeSelectorTermArgs> NodeSelectorTerms
        {
            get => _nodeSelectorTerms ?? (_nodeSelectorTerms = new InputList<Core.V1.NodeSelectorTermArgs>());
            set => _nodeSelectorTerms = value;
        }

    }

    /// <summary>
    /// A node selector requirement is a selector that contains values, a key, and an operator that
    /// relates the key and values.
    /// </summary>
    public class NodeSelectorRequirementArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The label key that the selector applies to.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// Represents a key's relationship to a set of values. Valid operators are In, NotIn,
        /// Exists, DoesNotExist. Gt, and Lt.
        /// </summary>
        [Input("operator", required: true)]
        public Input<string> Operator { get; set; } = null!;

        [Input("values")]
        private InputList<string>? _values;

        /// <summary>
        /// An array of string values. If the operator is In or NotIn, the values array must be
        /// non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If
        /// the operator is Gt or Lt, the values array must have a single element, which will be
        /// interpreted as an integer. This array is replaced during a strategic merge patch.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

    }

    /// <summary>
    /// A null or empty node selector term matches no objects. The requirements of them are ANDed.
    /// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
    /// </summary>
    public class NodeSelectorTermArgs : Pulumi.ResourceArgs
    {
        [Input("matchExpressions")]
        private InputList<Core.V1.NodeSelectorRequirementArgs>? _matchExpressions;

        /// <summary>
        /// A list of node selector requirements by node's labels.
        /// </summary>
        public InputList<Core.V1.NodeSelectorRequirementArgs> MatchExpressions
        {
            get => _matchExpressions ?? (_matchExpressions = new InputList<Core.V1.NodeSelectorRequirementArgs>());
            set => _matchExpressions = value;
        }

        [Input("matchFields")]
        private InputList<Core.V1.NodeSelectorRequirementArgs>? _matchFields;

        /// <summary>
        /// A list of node selector requirements by node's fields.
        /// </summary>
        public InputList<Core.V1.NodeSelectorRequirementArgs> MatchFields
        {
            get => _matchFields ?? (_matchFields = new InputList<Core.V1.NodeSelectorRequirementArgs>());
            set => _matchFields = value;
        }

    }

    /// <summary>
    /// NodeSpec describes the attributes that a node is created with.
    /// </summary>
    public class NodeSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// If specified, the source to get node configuration from The DynamicKubeletConfig feature
        /// gate must be enabled for the Kubelet to use this field
        /// </summary>
        [Input("configSource")]
        public Input<Core.V1.NodeConfigSourceArgs>? ConfigSource { get; set; }

        /// <summary>
        /// Deprecated. Not all kubelets will set this field. Remove field after 1.13. see:
        /// https://issues.k8s.io/61966
        /// </summary>
        [Input("externalID")]
        public Input<string>? ExternalID { get; set; }

        /// <summary>
        /// PodCIDR represents the pod IP range assigned to the node.
        /// </summary>
        [Input("podCIDR")]
        public Input<string>? PodCIDR { get; set; }

        [Input("podCIDRs")]
        private InputList<string>? _podCIDRs;

        /// <summary>
        /// podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node.
        /// If this field is specified, the 0th entry must match the podCIDR field. It may contain
        /// at most 1 value for each of IPv4 and IPv6.
        /// </summary>
        public InputList<string> PodCIDRs
        {
            get => _podCIDRs ?? (_podCIDRs = new InputList<string>());
            set => _podCIDRs = value;
        }

        /// <summary>
        /// ID of the node assigned by the cloud provider in the format:
        /// &amp;lt;ProviderName&amp;gt;://&amp;lt;ProviderSpecificNodeID&amp;gt;
        /// </summary>
        [Input("providerID")]
        public Input<string>? ProviderID { get; set; }

        [Input("taints")]
        private InputList<Core.V1.TaintArgs>? _taints;

        /// <summary>
        /// If specified, the node's taints.
        /// </summary>
        public InputList<Core.V1.TaintArgs> Taints
        {
            get => _taints ?? (_taints = new InputList<Core.V1.TaintArgs>());
            set => _taints = value;
        }

        /// <summary>
        /// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
        /// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
        /// </summary>
        [Input("unschedulable")]
        public Input<bool>? Unschedulable { get; set; }

    }

    /// <summary>
    /// NodeStatus is information about the current status of a node.
    /// </summary>
    public class NodeStatusArgs : Pulumi.ResourceArgs
    {
        [Input("addresses")]
        private InputList<Core.V1.NodeAddressArgs>? _addresses;

        /// <summary>
        /// List of addresses reachable to the node. Queried from cloud provider, if available. More
        /// info: https://kubernetes.io/docs/concepts/nodes/node/#addresses Note: This field is
        /// declared as mergeable, but the merge key is not sufficiently unique, which can cause
        /// data corruption when it is merged. Callers should instead use a full-replacement patch.
        /// See http://pr.k8s.io/79391 for an example.
        /// </summary>
        public InputList<Core.V1.NodeAddressArgs> Addresses
        {
            get => _addresses ?? (_addresses = new InputList<Core.V1.NodeAddressArgs>());
            set => _addresses = value;
        }

        [Input("allocatable")]
        private InputMap<string>? _allocatable;

        /// <summary>
        /// Allocatable represents the resources of a node that are available for scheduling.
        /// Defaults to Capacity.
        /// </summary>
        public InputMap<string> Allocatable
        {
            get => _allocatable ?? (_allocatable = new InputMap<string>());
            set => _allocatable = value;
        }

        [Input("capacity")]
        private InputMap<string>? _capacity;

        /// <summary>
        /// Capacity represents the total resources of a node. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </summary>
        public InputMap<string> Capacity
        {
            get => _capacity ?? (_capacity = new InputMap<string>());
            set => _capacity = value;
        }

        [Input("conditions")]
        private InputList<Core.V1.NodeConditionArgs>? _conditions;

        /// <summary>
        /// Conditions is an array of current observed node conditions. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#condition
        /// </summary>
        public InputList<Core.V1.NodeConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Core.V1.NodeConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// Status of the config assigned to the node via the dynamic Kubelet config feature.
        /// </summary>
        [Input("config")]
        public Input<Core.V1.NodeConfigStatusArgs>? Config { get; set; }

        /// <summary>
        /// Endpoints of daemons running on the Node.
        /// </summary>
        [Input("daemonEndpoints")]
        public Input<Core.V1.NodeDaemonEndpointsArgs>? DaemonEndpoints { get; set; }

        [Input("images")]
        private InputList<Core.V1.ContainerImageArgs>? _images;

        /// <summary>
        /// List of container images on this node
        /// </summary>
        public InputList<Core.V1.ContainerImageArgs> Images
        {
            get => _images ?? (_images = new InputList<Core.V1.ContainerImageArgs>());
            set => _images = value;
        }

        /// <summary>
        /// Set of ids/uuids to uniquely identify the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#info
        /// </summary>
        [Input("nodeInfo")]
        public Input<Core.V1.NodeSystemInfoArgs>? NodeInfo { get; set; }

        /// <summary>
        /// NodePhase is the recently observed lifecycle phase of the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and
        /// now is deprecated.
        /// </summary>
        [Input("phase")]
        public Input<string>? Phase { get; set; }

        [Input("volumesAttached")]
        private InputList<Core.V1.AttachedVolumeArgs>? _volumesAttached;

        /// <summary>
        /// List of volumes that are attached to the node.
        /// </summary>
        public InputList<Core.V1.AttachedVolumeArgs> VolumesAttached
        {
            get => _volumesAttached ?? (_volumesAttached = new InputList<Core.V1.AttachedVolumeArgs>());
            set => _volumesAttached = value;
        }

        [Input("volumesInUse")]
        private InputList<string>? _volumesInUse;

        /// <summary>
        /// List of attachable volumes in use (mounted) by the node.
        /// </summary>
        public InputList<string> VolumesInUse
        {
            get => _volumesInUse ?? (_volumesInUse = new InputList<string>());
            set => _volumesInUse = value;
        }

    }

    /// <summary>
    /// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
    /// </summary>
    public class NodeSystemInfoArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Architecture reported by the node
        /// </summary>
        [Input("architecture", required: true)]
        public Input<string> Architecture { get; set; } = null!;

        /// <summary>
        /// Boot ID reported by the node.
        /// </summary>
        [Input("bootID", required: true)]
        public Input<string> BootID { get; set; } = null!;

        /// <summary>
        /// ContainerRuntime Version reported by the node through runtime remote API (e.g.
        /// docker://1.5.0).
        /// </summary>
        [Input("containerRuntimeVersion", required: true)]
        public Input<string> ContainerRuntimeVersion { get; set; } = null!;

        /// <summary>
        /// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
        /// </summary>
        [Input("kernelVersion", required: true)]
        public Input<string> KernelVersion { get; set; } = null!;

        /// <summary>
        /// KubeProxy Version reported by the node.
        /// </summary>
        [Input("kubeProxyVersion", required: true)]
        public Input<string> KubeProxyVersion { get; set; } = null!;

        /// <summary>
        /// Kubelet Version reported by the node.
        /// </summary>
        [Input("kubeletVersion", required: true)]
        public Input<string> KubeletVersion { get; set; } = null!;

        /// <summary>
        /// MachineID reported by the node. For unique machine identification in the cluster this
        /// field is preferred. Learn more from man(5) machine-id:
        /// http://man7.org/linux/man-pages/man5/machine-id.5.html
        /// </summary>
        [Input("machineID", required: true)]
        public Input<string> MachineID { get; set; } = null!;

        /// <summary>
        /// The Operating System reported by the node
        /// </summary>
        [Input("operatingSystem", required: true)]
        public Input<string> OperatingSystem { get; set; } = null!;

        /// <summary>
        /// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
        /// </summary>
        [Input("osImage", required: true)]
        public Input<string> OsImage { get; set; } = null!;

        /// <summary>
        /// SystemUUID reported by the node. For unique machine identification MachineID is
        /// preferred. This field is specific to Red Hat hosts
        /// https://access.redhat.com/documentation/en-US/Red_Hat_Subscription_Management/1/html/RHSM/getting-system-uuid.html
        /// </summary>
        [Input("systemUUID", required: true)]
        public Input<string> SystemUUID { get; set; } = null!;

    }

    /// <summary>
    /// ObjectFieldSelector selects an APIVersioned field of an object.
    /// </summary>
    public class ObjectFieldSelectorArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Path of the field to select in the specified API version.
        /// </summary>
        [Input("fieldPath", required: true)]
        public Input<string> FieldPath { get; set; } = null!;

        /// <summary>
        /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

    }

    /// <summary>
    /// ObjectReference contains enough information to let you inspect or modify the referred
    /// object.
    /// </summary>
    public class ObjectReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// API version of the referent.
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// If referring to a piece of an object instead of an entire object, this string should
        /// contain a valid JSON/Go field access statement, such as
        /// desiredState.manifest.containers[2]. For example, if the object reference is to a
        /// container within a pod, this would take on a value like: "spec.containers{name}" (where
        /// "name" refers to the name of the container that triggered the event) or if no container
        /// name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax
        /// is chosen only to have some well-defined way of referencing a part of an object.
        /// </summary>
        [Input("fieldPath")]
        public Input<string>? FieldPath { get; set; }

        /// <summary>
        /// Kind of the referent. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        /// <summary>
        /// Specific resourceVersion to which this reference is made, if any. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
        [Input("resourceVersion")]
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// UID of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous
    /// to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
    /// </summary>
    public class PersistentVolumeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines a specification of a persistent volume owned by the cluster. Provisioned by
        /// an administrator. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.PersistentVolumeSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaim is a user's request for and claim to a persistent volume
    /// </summary>
    public class PersistentVolumeClaimArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired characteristics of a volume requested by a pod author. More
        /// info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.PersistentVolumeClaimSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimCondition contails details about state of pvc
    /// </summary>
    public class PersistentVolumeClaimConditionArgs : Pulumi.ResourceArgs
    {
        
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time we probed the condition.
        /// </summary>
        [Input("lastProbeTime")]
        public Input<string>? LastProbeTime { get; set; }

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Unique, this should be a short, machine understandable string that gives the reason for
        /// condition's last transition. If it reports "ResizeStarted" that means the underlying
        /// persistent volume is being resized.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
    /// </summary>
    public class PersistentVolumeClaimListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.PersistentVolumeClaimArgs>? _items;

        /// <summary>
        /// A list of persistent volume claims. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        public InputList<Core.V1.PersistentVolumeClaimArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.PersistentVolumeClaimArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a
    /// Source for provider-specific attributes
    /// </summary>
    public class PersistentVolumeClaimSpecArgs : Pulumi.ResourceArgs
    {
        [Input("accessModes")]
        private InputList<string>? _accessModes;

        /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        public InputList<string> AccessModes
        {
            get => _accessModes ?? (_accessModes = new InputList<string>());
            set => _accessModes = value;
        }

        /// <summary>
        /// This field requires the VolumeSnapshotDataSource alpha feature gate to be enabled and
        /// currently VolumeSnapshot is the only supported data source. If the provisioner can
        /// support VolumeSnapshot data source, it will create a new volume and data will be
        /// restored to the volume at the same time. If the provisioner does not support
        /// VolumeSnapshot data source, volume will not be created and the failure will be reported
        /// as an event. In the future, we plan to support more data source types and the behavior
        /// of the provisioner may change.
        /// </summary>
        [Input("dataSource")]
        public Input<Core.V1.TypedLocalObjectReferenceArgs>? DataSource { get; set; }

        /// <summary>
        /// Resources represents the minimum resources the volume should have. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        /// </summary>
        [Input("resources")]
        public Input<Core.V1.ResourceRequirementsArgs>? Resources { get; set; }

        /// <summary>
        /// A label query over volumes to consider for binding.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

        /// <summary>
        /// Name of the StorageClass required by the claim. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
        [Input("storageClassName")]
        public Input<string>? StorageClassName { get; set; }

        /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is
        /// implied when not included in claim spec. This is a beta feature.
        /// </summary>
        [Input("volumeMode")]
        public Input<string>? VolumeMode { get; set; }

        /// <summary>
        /// VolumeName is the binding reference to the PersistentVolume backing this claim.
        /// </summary>
        [Input("volumeName")]
        public Input<string>? VolumeName { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
    /// </summary>
    public class PersistentVolumeClaimStatusArgs : Pulumi.ResourceArgs
    {
        [Input("accessModes")]
        private InputList<string>? _accessModes;

        /// <summary>
        /// AccessModes contains the actual access modes the volume backing the PVC has. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        public InputList<string> AccessModes
        {
            get => _accessModes ?? (_accessModes = new InputList<string>());
            set => _accessModes = value;
        }

        [Input("capacity")]
        private InputMap<string>? _capacity;

        /// <summary>
        /// Represents the actual resources of the underlying volume.
        /// </summary>
        public InputMap<string> Capacity
        {
            get => _capacity ?? (_capacity = new InputMap<string>());
            set => _capacity = value;
        }

        [Input("conditions")]
        private InputList<Core.V1.PersistentVolumeClaimConditionArgs>? _conditions;

        /// <summary>
        /// Current Condition of persistent volume claim. If underlying persistent volume is being
        /// resized then the Condition will be set to 'ResizeStarted'.
        /// </summary>
        public InputList<Core.V1.PersistentVolumeClaimConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Core.V1.PersistentVolumeClaimConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// Phase represents the current phase of PersistentVolumeClaim.
        /// </summary>
        [Input("phase")]
        public Input<string>? Phase { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This
    /// volume finds the bound PV and mounts that volume for the pod. A
    /// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume
    /// that is owned by someone else (the system).
    /// </summary>
    public class PersistentVolumeClaimVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using
        /// this volume. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        [Input("claimName", required: true)]
        public Input<string> ClaimName { get; set; } = null!;

        /// <summary>
        /// Will force the ReadOnly setting in VolumeMounts. Default false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// PersistentVolumeList is a list of PersistentVolume items.
    /// </summary>
    public class PersistentVolumeListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.PersistentVolumeArgs>? _items;

        /// <summary>
        /// List of persistent volumes. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes
        /// </summary>
        public InputList<Core.V1.PersistentVolumeArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.PersistentVolumeArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PersistentVolumeSpec is the specification of a persistent volume.
    /// </summary>
    public class PersistentVolumeSpecArgs : Pulumi.ResourceArgs
    {
        [Input("accessModes")]
        private InputList<string>? _accessModes;

        /// <summary>
        /// AccessModes contains all ways the volume can be mounted. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
        /// </summary>
        public InputList<string> AccessModes
        {
            get => _accessModes ?? (_accessModes = new InputList<string>());
            set => _accessModes = value;
        }

        /// <summary>
        /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's
        /// host machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [Input("awsElasticBlockStore")]
        public Input<Core.V1.AWSElasticBlockStoreVolumeSourceArgs>? AwsElasticBlockStore { get; set; }

        /// <summary>
        /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
        /// </summary>
        [Input("azureDisk")]
        public Input<Core.V1.AzureDiskVolumeSourceArgs>? AzureDisk { get; set; }

        /// <summary>
        /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
        /// </summary>
        [Input("azureFile")]
        public Input<Core.V1.AzureFilePersistentVolumeSourceArgs>? AzureFile { get; set; }

        [Input("capacity")]
        private InputMap<string>? _capacity;

        /// <summary>
        /// A description of the persistent volume's resources and capacity. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </summary>
        public InputMap<string> Capacity
        {
            get => _capacity ?? (_capacity = new InputMap<string>());
            set => _capacity = value;
        }

        /// <summary>
        /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
        /// </summary>
        [Input("cephfs")]
        public Input<Core.V1.CephFSPersistentVolumeSourceArgs>? Cephfs { get; set; }

        /// <summary>
        /// Cinder represents a cinder volume attached and mounted on kubelets host machine. More
        /// info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Input("cinder")]
        public Input<Core.V1.CinderPersistentVolumeSourceArgs>? Cinder { get; set; }

        /// <summary>
        /// ClaimRef is part of a bi-directional binding between PersistentVolume and
        /// PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the
        /// authoritative bind between PV and PVC. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
        /// </summary>
        [Input("claimRef")]
        public Input<Core.V1.ObjectReferenceArgs>? ClaimRef { get; set; }

        /// <summary>
        /// CSI represents storage that is handled by an external CSI driver (Beta feature).
        /// </summary>
        [Input("csi")]
        public Input<Core.V1.CSIPersistentVolumeSourceArgs>? Csi { get; set; }

        /// <summary>
        /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and
        /// then exposed to the pod.
        /// </summary>
        [Input("fc")]
        public Input<Core.V1.FCVolumeSourceArgs>? Fc { get; set; }

        /// <summary>
        /// FlexVolume represents a generic volume resource that is provisioned/attached using an
        /// exec based plugin.
        /// </summary>
        [Input("flexVolume")]
        public Input<Core.V1.FlexPersistentVolumeSourceArgs>? FlexVolume { get; set; }

        /// <summary>
        /// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to
        /// the pod for its usage. This depends on the Flocker control service being running
        /// </summary>
        [Input("flocker")]
        public Input<Core.V1.FlockerVolumeSourceArgs>? Flocker { get; set; }

        /// <summary>
        /// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host
        /// machine and then exposed to the pod. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Input("gcePersistentDisk")]
        public Input<Core.V1.GCEPersistentDiskVolumeSourceArgs>? GcePersistentDisk { get; set; }

        /// <summary>
        /// Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the
        /// pod. Provisioned by an admin. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md
        /// </summary>
        [Input("glusterfs")]
        public Input<Core.V1.GlusterfsPersistentVolumeSourceArgs>? Glusterfs { get; set; }

        /// <summary>
        /// HostPath represents a directory on the host. Provisioned by a developer or tester. This
        /// is useful for single-node development and testing only! On-host storage is not supported
        /// in any way and WILL NOT WORK in a multi-node cluster. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        [Input("hostPath")]
        public Input<Core.V1.HostPathVolumeSourceArgs>? HostPath { get; set; }

        /// <summary>
        /// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and
        /// then exposed to the pod. Provisioned by an admin.
        /// </summary>
        [Input("iscsi")]
        public Input<Core.V1.ISCSIPersistentVolumeSourceArgs>? Iscsi { get; set; }

        /// <summary>
        /// Local represents directly-attached storage with node affinity
        /// </summary>
        [Input("local")]
        public Input<Core.V1.LocalVolumeSourceArgs>? Local { get; set; }

        [Input("mountOptions")]
        private InputList<string>? _mountOptions;

        /// <summary>
        /// A list of mount options, e.g. ["ro", "soft"]. Not validated - mount will simply fail if
        /// one is invalid. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
        /// </summary>
        public InputList<string> MountOptions
        {
            get => _mountOptions ?? (_mountOptions = new InputList<string>());
            set => _mountOptions = value;
        }

        /// <summary>
        /// NFS represents an NFS mount on the host. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [Input("nfs")]
        public Input<Core.V1.NFSVolumeSourceArgs>? Nfs { get; set; }

        /// <summary>
        /// NodeAffinity defines constraints that limit what nodes this volume can be accessed from.
        /// This field influences the scheduling of pods that use this volume.
        /// </summary>
        [Input("nodeAffinity")]
        public Input<Core.V1.VolumeNodeAffinityArgs>? NodeAffinity { get; set; }

        /// <summary>
        /// What happens to a persistent volume when released from its claim. Valid options are
        /// Retain (default for manually created PersistentVolumes), Delete (default for dynamically
        /// provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by
        /// the volume plugin underlying this PersistentVolume. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
        /// </summary>
        [Input("persistentVolumeReclaimPolicy")]
        public Input<string>? PersistentVolumeReclaimPolicy { get; set; }

        /// <summary>
        /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted
        /// on kubelets host machine
        /// </summary>
        [Input("photonPersistentDisk")]
        public Input<Core.V1.PhotonPersistentDiskVolumeSourceArgs>? PhotonPersistentDisk { get; set; }

        /// <summary>
        /// PortworxVolume represents a portworx volume attached and mounted on kubelets host
        /// machine
        /// </summary>
        [Input("portworxVolume")]
        public Input<Core.V1.PortworxVolumeSourceArgs>? PortworxVolume { get; set; }

        /// <summary>
        /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        /// </summary>
        [Input("quobyte")]
        public Input<Core.V1.QuobyteVolumeSourceArgs>? Quobyte { get; set; }

        /// <summary>
        /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md
        /// </summary>
        [Input("rbd")]
        public Input<Core.V1.RBDPersistentVolumeSourceArgs>? Rbd { get; set; }

        /// <summary>
        /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
        /// </summary>
        [Input("scaleIO")]
        public Input<Core.V1.ScaleIOPersistentVolumeSourceArgs>? ScaleIO { get; set; }

        /// <summary>
        /// Name of StorageClass to which this persistent volume belongs. Empty value means that
        /// this volume does not belong to any StorageClass.
        /// </summary>
        [Input("storageClassName")]
        public Input<string>? StorageClassName { get; set; }

        /// <summary>
        /// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine
        /// and mounted into the pod More info: https://examples.k8s.io/volumes/storageos/README.md
        /// </summary>
        [Input("storageos")]
        public Input<Core.V1.StorageOSPersistentVolumeSourceArgs>? Storageos { get; set; }

        /// <summary>
        /// volumeMode defines if a volume is intended to be used with a formatted filesystem or to
        /// remain in raw block state. Value of Filesystem is implied when not included in spec.
        /// This is a beta feature.
        /// </summary>
        [Input("volumeMode")]
        public Input<string>? VolumeMode { get; set; }

        /// <summary>
        /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
        /// </summary>
        [Input("vsphereVolume")]
        public Input<Core.V1.VsphereVirtualDiskVolumeSourceArgs>? VsphereVolume { get; set; }

    }

    /// <summary>
    /// PersistentVolumeStatus is the current status of a persistent volume.
    /// </summary>
    public class PersistentVolumeStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A human-readable message indicating details about why the volume is in this state.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Phase indicates if a volume is available, bound to a claim, or released by a claim. More
        /// info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
        /// </summary>
        [Input("phase")]
        public Input<string>? Phase { get; set; }

        /// <summary>
        /// Reason is a brief CamelCase string that describes any failure and is meant for machine
        /// parsing and tidy display in the CLI.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// Represents a Photon Controller persistent disk resource.
    /// </summary>
    public class PhotonPersistentDiskVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ID that identifies Photon Controller persistent disk
        /// </summary>
        [Input("pdID", required: true)]
        public Input<string> PdID { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

    }

    /// <summary>
    /// Pod is a collection of containers that can run on a host. This resource is created by
    /// clients and scheduled onto hosts.
    /// </summary>
    public class PodArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the pod. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.PodSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// Pod affinity is a group of inter pod affinity scheduling rules.
    /// </summary>
    public class PodAffinityArgs : Pulumi.ResourceArgs
    {
        [Input("preferredDuringSchedulingIgnoredDuringExecution")]
        private InputList<Core.V1.WeightedPodAffinityTermArgs>? _preferredDuringSchedulingIgnoredDuringExecution;

        /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity
        /// expressions specified by this field, but it may choose a node that violates one or more
        /// of the expressions. The node that is most preferred is the one with the greatest sum of
        /// weights, i.e. for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling affinity expressions, etc.), compute a sum by
        /// iterating through the elements of this field and adding "weight" to the sum if the node
        /// has pods which matches the corresponding podAffinityTerm; the node(s) with the highest
        /// sum are the most preferred.
        /// </summary>
        public InputList<Core.V1.WeightedPodAffinityTermArgs> PreferredDuringSchedulingIgnoredDuringExecution
        {
            get => _preferredDuringSchedulingIgnoredDuringExecution ?? (_preferredDuringSchedulingIgnoredDuringExecution = new InputList<Core.V1.WeightedPodAffinityTermArgs>());
            set => _preferredDuringSchedulingIgnoredDuringExecution = value;
        }

        [Input("requiredDuringSchedulingIgnoredDuringExecution")]
        private InputList<Core.V1.PodAffinityTermArgs>? _requiredDuringSchedulingIgnoredDuringExecution;

        /// <summary>
        /// If the affinity requirements specified by this field are not met at scheduling time, the
        /// pod will not be scheduled onto the node. If the affinity requirements specified by this
        /// field cease to be met at some point during pod execution (e.g. due to a pod label
        /// update), the system may or may not try to eventually evict the pod from its node. When
        /// there are multiple elements, the lists of nodes corresponding to each podAffinityTerm
        /// are intersected, i.e. all terms must be satisfied.
        /// </summary>
        public InputList<Core.V1.PodAffinityTermArgs> RequiredDuringSchedulingIgnoredDuringExecution
        {
            get => _requiredDuringSchedulingIgnoredDuringExecution ?? (_requiredDuringSchedulingIgnoredDuringExecution = new InputList<Core.V1.PodAffinityTermArgs>());
            set => _requiredDuringSchedulingIgnoredDuringExecution = value;
        }

    }

    /// <summary>
    /// Defines a set of pods (namely those matching the labelSelector relative to the given
    /// namespace(s)) that this pod should be co-located (affinity) or not co-located
    /// (anti-affinity) with, where co-located is defined as running on a node whose value of the
    /// label with key &amp;lt;topologyKey&amp;gt; matches that of any node on which a pod of the
    /// set of pods is running
    /// </summary>
    public class PodAffinityTermArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods
        /// matching the labelSelector in the specified namespaces, where co-located is defined as
        /// running on a node whose value of the label with key topologyKey matches that of any node
        /// on which any of the selected pods is running. Empty topologyKey is not allowed.
        /// </summary>
        [Input("topologyKey", required: true)]
        public Input<string> TopologyKey { get; set; } = null!;

        /// <summary>
        /// A label query over a set of resources, in this case pods.
        /// </summary>
        [Input("labelSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? LabelSelector { get; set; }

        [Input("namespaces")]
        private InputList<string>? _namespaces;

        /// <summary>
        /// namespaces specifies which namespaces the labelSelector applies to (matches against);
        /// null or empty list means "this pod's namespace"
        /// </summary>
        public InputList<string> Namespaces
        {
            get => _namespaces ?? (_namespaces = new InputList<string>());
            set => _namespaces = value;
        }

    }

    /// <summary>
    /// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
    /// </summary>
    public class PodAntiAffinityArgs : Pulumi.ResourceArgs
    {
        [Input("preferredDuringSchedulingIgnoredDuringExecution")]
        private InputList<Core.V1.WeightedPodAffinityTermArgs>? _preferredDuringSchedulingIgnoredDuringExecution;

        /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity
        /// expressions specified by this field, but it may choose a node that violates one or more
        /// of the expressions. The node that is most preferred is the one with the greatest sum of
        /// weights, i.e. for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by
        /// iterating through the elements of this field and adding "weight" to the sum if the node
        /// has pods which matches the corresponding podAffinityTerm; the node(s) with the highest
        /// sum are the most preferred.
        /// </summary>
        public InputList<Core.V1.WeightedPodAffinityTermArgs> PreferredDuringSchedulingIgnoredDuringExecution
        {
            get => _preferredDuringSchedulingIgnoredDuringExecution ?? (_preferredDuringSchedulingIgnoredDuringExecution = new InputList<Core.V1.WeightedPodAffinityTermArgs>());
            set => _preferredDuringSchedulingIgnoredDuringExecution = value;
        }

        [Input("requiredDuringSchedulingIgnoredDuringExecution")]
        private InputList<Core.V1.PodAffinityTermArgs>? _requiredDuringSchedulingIgnoredDuringExecution;

        /// <summary>
        /// If the anti-affinity requirements specified by this field are not met at scheduling
        /// time, the pod will not be scheduled onto the node. If the anti-affinity requirements
        /// specified by this field cease to be met at some point during pod execution (e.g. due to
        /// a pod label update), the system may or may not try to eventually evict the pod from its
        /// node. When there are multiple elements, the lists of nodes corresponding to each
        /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
        /// </summary>
        public InputList<Core.V1.PodAffinityTermArgs> RequiredDuringSchedulingIgnoredDuringExecution
        {
            get => _requiredDuringSchedulingIgnoredDuringExecution ?? (_requiredDuringSchedulingIgnoredDuringExecution = new InputList<Core.V1.PodAffinityTermArgs>());
            set => _requiredDuringSchedulingIgnoredDuringExecution = value;
        }

    }

    /// <summary>
    /// PodCondition contains details for the current condition of this pod.
    /// </summary>
    public class PodConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status is the status of the condition. Can be True, False, Unknown. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type is the type of the condition. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time we probed the condition.
        /// </summary>
        [Input("lastProbeTime")]
        public Input<string>? LastProbeTime { get; set; }

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// PodDNSConfig defines the DNS parameters of a pod in addition to those generated from
    /// DNSPolicy.
    /// </summary>
    public class PodDNSConfigArgs : Pulumi.ResourceArgs
    {
        [Input("nameservers")]
        private InputList<string>? _nameservers;

        /// <summary>
        /// A list of DNS name server IP addresses. This will be appended to the base nameservers
        /// generated from DNSPolicy. Duplicated nameservers will be removed.
        /// </summary>
        public InputList<string> Nameservers
        {
            get => _nameservers ?? (_nameservers = new InputList<string>());
            set => _nameservers = value;
        }

        [Input("options")]
        private InputList<Core.V1.PodDNSConfigOptionArgs>? _options;

        /// <summary>
        /// A list of DNS resolver options. This will be merged with the base options generated from
        /// DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will
        /// override those that appear in the base DNSPolicy.
        /// </summary>
        public InputList<Core.V1.PodDNSConfigOptionArgs> Options
        {
            get => _options ?? (_options = new InputList<Core.V1.PodDNSConfigOptionArgs>());
            set => _options = value;
        }

        [Input("searches")]
        private InputList<string>? _searches;

        /// <summary>
        /// A list of DNS search domains for host-name lookup. This will be appended to the base
        /// search paths generated from DNSPolicy. Duplicated search paths will be removed.
        /// </summary>
        public InputList<string> Searches
        {
            get => _searches ?? (_searches = new InputList<string>());
            set => _searches = value;
        }

    }

    /// <summary>
    /// PodDNSConfigOption defines DNS resolver options of a pod.
    /// </summary>
    public class PodDNSConfigOptionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        
        [Input("value")]
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// IP address information for entries in the (plural) PodIPs field. Each entry includes:
    ///    IP: An IP address allocated to the pod. Routable at least within the cluster.
    /// </summary>
    public class PodIPArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ip is an IP address (IPv4 or IPv6) assigned to the pod
        /// </summary>
        [Input("ip")]
        public Input<string>? Ip { get; set; }

    }

    /// <summary>
    /// PodList is a list of Pods.
    /// </summary>
    public class PodListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.PodArgs>? _items;

        /// <summary>
        /// List of pods. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
        /// </summary>
        public InputList<Core.V1.PodArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.PodArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PodReadinessGate contains the reference to a pod condition
    /// </summary>
    public class PodReadinessGateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ConditionType refers to a condition in the pod's condition list with matching type.
        /// </summary>
        [Input("conditionType", required: true)]
        public Input<string> ConditionType { get; set; } = null!;

    }

    /// <summary>
    /// PodSecurityContext holds pod-level security attributes and common container settings. Some
    /// fields are also present in container.securityContext.  Field values of
    /// container.securityContext take precedence over field values of PodSecurityContext.
    /// </summary>
    public class PodSecurityContextArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A special supplemental group that applies to all containers in a pod. Some volume types
        /// allow the Kubelet to change the ownership of that volume to be owned by the pod:
        /// 
        /// 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the
        /// volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
        /// 
        /// If unset, the Kubelet will not modify the ownership and permissions of any volume.
        /// </summary>
        [Input("fsGroup")]
        public Input<int>? FsGroup { get; set; }

        /// <summary>
        /// The GID to run the entrypoint of the container process. Uses runtime default if unset.
        /// May also be set in SecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence for that
        /// container.
        /// </summary>
        [Input("runAsGroup")]
        public Input<int>? RunAsGroup { get; set; }

        /// <summary>
        /// Indicates that the container must run as a non-root user. If true, the Kubelet will
        /// validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to
        /// start the container if it does. If unset or false, no such validation will be performed.
        /// May also be set in SecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        [Input("runAsNonRoot")]
        public Input<bool>? RunAsNonRoot { get; set; }

        /// <summary>
        /// The UID to run the entrypoint of the container process. Defaults to user specified in
        /// image metadata if unspecified. May also be set in SecurityContext.  If set in both
        /// SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
        /// precedence for that container.
        /// </summary>
        [Input("runAsUser")]
        public Input<int>? RunAsUser { get; set; }

        /// <summary>
        /// The SELinux context to be applied to all containers. If unspecified, the container
        /// runtime will allocate a random SELinux context for each container.  May also be set in
        /// SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value
        /// specified in SecurityContext takes precedence for that container.
        /// </summary>
        [Input("seLinuxOptions")]
        public Input<Core.V1.SELinuxOptionsArgs>? SeLinuxOptions { get; set; }

        [Input("supplementalGroups")]
        private InputList<int>? _supplementalGroups;

        /// <summary>
        /// A list of groups applied to the first process run in each container, in addition to the
        /// container's primary GID.  If unspecified, no groups will be added to any container.
        /// </summary>
        public InputList<int> SupplementalGroups
        {
            get => _supplementalGroups ?? (_supplementalGroups = new InputList<int>());
            set => _supplementalGroups = value;
        }

        [Input("sysctls")]
        private InputList<Core.V1.SysctlArgs>? _sysctls;

        /// <summary>
        /// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
        /// sysctls (by the container runtime) might fail to launch.
        /// </summary>
        public InputList<Core.V1.SysctlArgs> Sysctls
        {
            get => _sysctls ?? (_sysctls = new InputList<Core.V1.SysctlArgs>());
            set => _sysctls = value;
        }

        /// <summary>
        /// The Windows specific settings applied to all containers. If unspecified, the options
        /// within a container's SecurityContext will be used. If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        [Input("windowsOptions")]
        public Input<Core.V1.WindowsSecurityContextOptionsArgs>? WindowsOptions { get; set; }

    }

    /// <summary>
    /// PodSpec is a description of a pod.
    /// </summary>
    public class PodSpecArgs : Pulumi.ResourceArgs
    {
        [Input("containers", required: true)]
        private InputList<Core.V1.ContainerArgs>? _containers;

        /// <summary>
        /// List of containers belonging to the pod. Containers cannot currently be added or
        /// removed. There must be at least one container in a Pod. Cannot be updated.
        /// </summary>
        public InputList<Core.V1.ContainerArgs> Containers
        {
            get => _containers ?? (_containers = new InputList<Core.V1.ContainerArgs>());
            set => _containers = value;
        }

        /// <summary>
        /// Optional duration in seconds the pod may be active on the node relative to StartTime
        /// before the system will actively try to mark it failed and kill associated containers.
        /// Value must be a positive integer.
        /// </summary>
        [Input("activeDeadlineSeconds")]
        public Input<int>? ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// If specified, the pod's scheduling constraints
        /// </summary>
        [Input("affinity")]
        public Input<Core.V1.AffinityArgs>? Affinity { get; set; }

        /// <summary>
        /// AutomountServiceAccountToken indicates whether a service account token should be
        /// automatically mounted.
        /// </summary>
        [Input("automountServiceAccountToken")]
        public Input<bool>? AutomountServiceAccountToken { get; set; }

        /// <summary>
        /// Specifies the DNS parameters of a pod. Parameters specified here will be merged to the
        /// generated DNS configuration based on DNSPolicy.
        /// </summary>
        [Input("dnsConfig")]
        public Input<Core.V1.PodDNSConfigArgs>? DnsConfig { get; set; }

        /// <summary>
        /// Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are
        /// 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in
        /// DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options
        /// set along with hostNetwork, you have to specify DNS policy explicitly to
        /// 'ClusterFirstWithHostNet'.
        /// </summary>
        [Input("dnsPolicy")]
        public Input<string>? DnsPolicy { get; set; }

        /// <summary>
        /// EnableServiceLinks indicates whether information about services should be injected into
        /// pod's environment variables, matching the syntax of Docker links. Optional: Defaults to
        /// true.
        /// </summary>
        [Input("enableServiceLinks")]
        public Input<bool>? EnableServiceLinks { get; set; }

        [Input("ephemeralContainers")]
        private InputList<Core.V1.EphemeralContainerArgs>? _ephemeralContainers;

        /// <summary>
        /// List of ephemeral containers run in this pod. Ephemeral containers may be run in an
        /// existing pod to perform user-initiated actions such as debugging. This list cannot be
        /// specified when creating a pod, and it cannot be modified by updating the pod spec. In
        /// order to add an ephemeral container to an existing pod, use the pod's
        /// ephemeralcontainers subresource. This field is alpha-level and is only honored by
        /// servers that enable the EphemeralContainers feature.
        /// </summary>
        public InputList<Core.V1.EphemeralContainerArgs> EphemeralContainers
        {
            get => _ephemeralContainers ?? (_ephemeralContainers = new InputList<Core.V1.EphemeralContainerArgs>());
            set => _ephemeralContainers = value;
        }

        [Input("hostAliases")]
        private InputList<Core.V1.HostAliasArgs>? _hostAliases;

        /// <summary>
        /// HostAliases is an optional list of hosts and IPs that will be injected into the pod's
        /// hosts file if specified. This is only valid for non-hostNetwork pods.
        /// </summary>
        public InputList<Core.V1.HostAliasArgs> HostAliases
        {
            get => _hostAliases ?? (_hostAliases = new InputList<Core.V1.HostAliasArgs>());
            set => _hostAliases = value;
        }

        /// <summary>
        /// Use the host's ipc namespace. Optional: Default to false.
        /// </summary>
        [Input("hostIPC")]
        public Input<bool>? HostIPC { get; set; }

        /// <summary>
        /// Host networking requested for this pod. Use the host's network namespace. If this option
        /// is set, the ports that will be used must be specified. Default to false.
        /// </summary>
        [Input("hostNetwork")]
        public Input<bool>? HostNetwork { get; set; }

        /// <summary>
        /// Use the host's pid namespace. Optional: Default to false.
        /// </summary>
        [Input("hostPID")]
        public Input<bool>? HostPID { get; set; }

        /// <summary>
        /// Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a
        /// system-defined value.
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        [Input("imagePullSecrets")]
        private InputList<Core.V1.LocalObjectReferenceArgs>? _imagePullSecrets;

        /// <summary>
        /// ImagePullSecrets is an optional list of references to secrets in the same namespace to
        /// use for pulling any of the images used by this PodSpec. If specified, these secrets will
        /// be passed to individual puller implementations for them to use. For example, in the case
        /// of docker, only DockerConfig type secrets are honored. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
        /// </summary>
        public InputList<Core.V1.LocalObjectReferenceArgs> ImagePullSecrets
        {
            get => _imagePullSecrets ?? (_imagePullSecrets = new InputList<Core.V1.LocalObjectReferenceArgs>());
            set => _imagePullSecrets = value;
        }

        [Input("initContainers")]
        private InputList<Core.V1.ContainerArgs>? _initContainers;

        /// <summary>
        /// List of initialization containers belonging to the pod. Init containers are executed in
        /// order prior to containers being started. If any init container fails, the pod is
        /// considered to have failed and is handled according to its restartPolicy. The name for an
        /// init container or normal container must be unique among all containers. Init containers
        /// may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
        /// The resourceRequirements of an init container are taken into account during scheduling
        /// by finding the highest request/limit for each resource type, and then using the max of
        /// of that value or the sum of the normal containers. Limits are applied to init containers
        /// in a similar fashion. Init containers cannot currently be added or removed. Cannot be
        /// updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        /// </summary>
        public InputList<Core.V1.ContainerArgs> InitContainers
        {
            get => _initContainers ?? (_initContainers = new InputList<Core.V1.ContainerArgs>());
            set => _initContainers = value;
        }

        /// <summary>
        /// NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the
        /// scheduler simply schedules this pod onto that node, assuming that it fits resource
        /// requirements.
        /// </summary>
        [Input("nodeName")]
        public Input<string>? NodeName { get; set; }

        [Input("nodeSelector")]
        private InputMap<string>? _nodeSelector;

        /// <summary>
        /// NodeSelector is a selector which must be true for the pod to fit on a node. Selector
        /// which must match a node's labels for the pod to be scheduled on that node. More info:
        /// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        /// </summary>
        public InputMap<string> NodeSelector
        {
            get => _nodeSelector ?? (_nodeSelector = new InputMap<string>());
            set => _nodeSelector = value;
        }

        [Input("overhead")]
        private InputMap<string>? _overhead;

        /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a given
        /// RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass
        /// admission controller. If the RuntimeClass admission controller is enabled, overhead must
        /// not be set in Pod create requests. The RuntimeClass admission controller will reject Pod
        /// create requests which have the overhead already set. If RuntimeClass is configured and
        /// selected in the PodSpec, Overhead will be set to the value defined in the corresponding
        /// RuntimeClass, otherwise it will remain unset and treated as zero. More info:
        /// https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
        /// alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the
        /// PodOverhead feature.
        /// </summary>
        public InputMap<string> Overhead
        {
            get => _overhead ?? (_overhead = new InputMap<string>());
            set => _overhead = value;
        }

        /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
        [Input("preemptionPolicy")]
        public Input<string>? PreemptionPolicy { get; set; }

        /// <summary>
        /// The priority value. Various system components use this field to find the priority of the
        /// pod. When Priority Admission Controller is enabled, it prevents users from setting this
        /// field. The admission controller populates this field from PriorityClassName. The higher
        /// the value, the higher the priority.
        /// </summary>
        [Input("priority")]
        public Input<int>? Priority { get; set; }

        /// <summary>
        /// If specified, indicates the pod's priority. "system-node-critical" and
        /// "system-cluster-critical" are two special keywords which indicate the highest priorities
        /// with the former being the highest priority. Any other name must be defined by creating a
        /// PriorityClass object with that name. If not specified, the pod priority will be default
        /// or zero if there is no default.
        /// </summary>
        [Input("priorityClassName")]
        public Input<string>? PriorityClassName { get; set; }

        [Input("readinessGates")]
        private InputList<Core.V1.PodReadinessGateArgs>? _readinessGates;

        /// <summary>
        /// If specified, all readiness gates will be evaluated for pod readiness. A pod is ready
        /// when all its containers are ready AND all conditions specified in the readiness gates
        /// have status equal to "True" More info:
        /// https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        /// </summary>
        public InputList<Core.V1.PodReadinessGateArgs> ReadinessGates
        {
            get => _readinessGates ?? (_readinessGates = new InputList<Core.V1.PodReadinessGateArgs>());
            set => _readinessGates = value;
        }

        /// <summary>
        /// Restart policy for all containers within the pod. One of Always, OnFailure, Never.
        /// Default to Always. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
        /// </summary>
        [Input("restartPolicy")]
        public Input<string>? RestartPolicy { get; set; }

        /// <summary>
        /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should
        /// be used to run this pod.  If no RuntimeClass resource matches the named class, the pod
        /// will not be run. If unset or empty, the "legacy" RuntimeClass will be used, which is an
        /// implicit class with an empty definition that uses the default runtime handler. More
        /// info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md This is a beta
        /// feature as of Kubernetes v1.14.
        /// </summary>
        [Input("runtimeClassName")]
        public Input<string>? RuntimeClassName { get; set; }

        /// <summary>
        /// If specified, the pod will be dispatched by specified scheduler. If not specified, the
        /// pod will be dispatched by default scheduler.
        /// </summary>
        [Input("schedulerName")]
        public Input<string>? SchedulerName { get; set; }

        /// <summary>
        /// SecurityContext holds pod-level security attributes and common container settings.
        /// Optional: Defaults to empty.  See type description for default values of each field.
        /// </summary>
        [Input("securityContext")]
        public Input<Core.V1.PodSecurityContextArgs>? SecurityContext { get; set; }

        /// <summary>
        /// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use
        /// serviceAccountName instead.
        /// </summary>
        [Input("serviceAccount")]
        public Input<string>? ServiceAccount { get; set; }

        /// <summary>
        /// ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        /// </summary>
        [Input("serviceAccountName")]
        public Input<string>? ServiceAccountName { get; set; }

        /// <summary>
        /// Share a single process namespace between all of the containers in a pod. When this is
        /// set containers will be able to view and signal processes from other containers in the
        /// same pod, and the first process in each container will not be assigned PID 1. HostPID
        /// and ShareProcessNamespace cannot both be set. Optional: Default to false. This field is
        /// beta-level and may be disabled with the PodShareProcessNamespace feature.
        /// </summary>
        [Input("shareProcessNamespace")]
        public Input<bool>? ShareProcessNamespace { get; set; }

        /// <summary>
        /// If specified, the fully qualified Pod hostname will be
        /// "&amp;lt;hostname&amp;gt;.&amp;lt;subdomain&amp;gt;.&amp;lt;pod
        /// namespace&amp;gt;.svc.&amp;lt;cluster domain&amp;gt;". If not specified, the pod will
        /// not have a domainname at all.
        /// </summary>
        [Input("subdomain")]
        public Input<string>? Subdomain { get; set; }

        /// <summary>
        /// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in
        /// delete request. Value must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period will be used instead. The
        /// grace period is the duration in seconds after the processes running in the pod are sent
        /// a termination signal and the time when the processes are forcibly halted with a kill
        /// signal. Set this value longer than the expected cleanup time for your process. Defaults
        /// to 30 seconds.
        /// </summary>
        [Input("terminationGracePeriodSeconds")]
        public Input<int>? TerminationGracePeriodSeconds { get; set; }

        [Input("tolerations")]
        private InputList<Core.V1.TolerationArgs>? _tolerations;

        /// <summary>
        /// If specified, the pod's tolerations.
        /// </summary>
        public InputList<Core.V1.TolerationArgs> Tolerations
        {
            get => _tolerations ?? (_tolerations = new InputList<Core.V1.TolerationArgs>());
            set => _tolerations = value;
        }

        [Input("topologySpreadConstraints")]
        private InputList<Core.V1.TopologySpreadConstraintArgs>? _topologySpreadConstraints;

        /// <summary>
        /// TopologySpreadConstraints describes how a group of pods ought to spread across topology
        /// domains. Scheduler will schedule pods in a way which abides by the constraints. This
        /// field is alpha-level and is only honored by clusters that enables the EvenPodsSpread
        /// feature. All topologySpreadConstraints are ANDed.
        /// </summary>
        public InputList<Core.V1.TopologySpreadConstraintArgs> TopologySpreadConstraints
        {
            get => _topologySpreadConstraints ?? (_topologySpreadConstraints = new InputList<Core.V1.TopologySpreadConstraintArgs>());
            set => _topologySpreadConstraints = value;
        }

        [Input("volumes")]
        private InputList<Core.V1.VolumeArgs>? _volumes;

        /// <summary>
        /// List of volumes that can be mounted by containers belonging to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes
        /// </summary>
        public InputList<Core.V1.VolumeArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<Core.V1.VolumeArgs>());
            set => _volumes = value;
        }

    }

    /// <summary>
    /// PodStatus represents information about the status of a pod. Status may trail the actual
    /// state of a system, especially if the node that hosts the pod cannot contact the control
    /// plane.
    /// </summary>
    public class PodStatusArgs : Pulumi.ResourceArgs
    {
        [Input("conditions")]
        private InputList<Core.V1.PodConditionArgs>? _conditions;

        /// <summary>
        /// Current service state of pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
        /// </summary>
        public InputList<Core.V1.PodConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Core.V1.PodConditionArgs>());
            set => _conditions = value;
        }

        [Input("containerStatuses")]
        private InputList<Core.V1.ContainerStatusArgs>? _containerStatuses;

        /// <summary>
        /// The list has one entry per container in the manifest. Each entry is currently the output
        /// of `docker inspect`. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
        /// </summary>
        public InputList<Core.V1.ContainerStatusArgs> ContainerStatuses
        {
            get => _containerStatuses ?? (_containerStatuses = new InputList<Core.V1.ContainerStatusArgs>());
            set => _containerStatuses = value;
        }

        [Input("ephemeralContainerStatuses")]
        private InputList<Core.V1.ContainerStatusArgs>? _ephemeralContainerStatuses;

        /// <summary>
        /// Status for any ephemeral containers that have run in this pod. This field is alpha-level
        /// and is only populated by servers that enable the EphemeralContainers feature.
        /// </summary>
        public InputList<Core.V1.ContainerStatusArgs> EphemeralContainerStatuses
        {
            get => _ephemeralContainerStatuses ?? (_ephemeralContainerStatuses = new InputList<Core.V1.ContainerStatusArgs>());
            set => _ephemeralContainerStatuses = value;
        }

        /// <summary>
        /// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
        /// </summary>
        [Input("hostIP")]
        public Input<string>? HostIP { get; set; }

        [Input("initContainerStatuses")]
        private InputList<Core.V1.ContainerStatusArgs>? _initContainerStatuses;

        /// <summary>
        /// The list has one entry per init container in the manifest. The most recent successful
        /// init container will have ready = true, the most recently started container will have
        /// startTime set. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
        /// </summary>
        public InputList<Core.V1.ContainerStatusArgs> InitContainerStatuses
        {
            get => _initContainerStatuses ?? (_initContainerStatuses = new InputList<Core.V1.ContainerStatusArgs>());
            set => _initContainerStatuses = value;
        }

        /// <summary>
        /// A human readable message indicating details about why the pod is in this condition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// nominatedNodeName is set only when this pod preempts other pods on the node, but it
        /// cannot be scheduled right away as preemption victims receive their graceful termination
        /// periods. This field does not guarantee that the pod will be scheduled on this node.
        /// Scheduler may decide to place the pod elsewhere if other nodes become available sooner.
        /// Scheduler may also decide to give the resources on this node to a higher priority pod
        /// that is created after preemption. As a result, this field may be different than
        /// PodSpec.nodeName when the pod is scheduled.
        /// </summary>
        [Input("nominatedNodeName")]
        public Input<string>? NominatedNodeName { get; set; }

        /// <summary>
        /// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
        /// The conditions array, the reason and message fields, and the individual container status
        /// arrays contain more detail about the pod's status. There are five possible phase values:
        /// 
        /// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
        /// container images has not been created. This includes time before being scheduled as well
        /// as time spent downloading images over the network, which could take a while. Running:
        /// The pod has been bound to a node, and all of the containers have been created. At least
        /// one container is still running, or is in the process of starting or restarting.
        /// Succeeded: All containers in the pod have terminated in success, and will not be
        /// restarted. Failed: All containers in the pod have terminated, and at least one container
        /// has terminated in failure. The container either exited with non-zero status or was
        /// terminated by the system. Unknown: For some reason the state of the pod could not be
        /// obtained, typically due to an error in communicating with the host of the pod.
        /// 
        /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
        /// </summary>
        [Input("phase")]
        public Input<string>? Phase { get; set; }

        /// <summary>
        /// IP address allocated to the pod. Routable at least within the cluster. Empty if not yet
        /// allocated.
        /// </summary>
        [Input("podIP")]
        public Input<string>? PodIP { get; set; }

        [Input("podIPs")]
        private InputList<Core.V1.PodIPArgs>? _podIPs;

        /// <summary>
        /// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th
        /// entry must match the podIP field. Pods may be allocated at most 1 value for each of IPv4
        /// and IPv6. This list is empty if no IPs have been allocated yet.
        /// </summary>
        public InputList<Core.V1.PodIPArgs> PodIPs
        {
            get => _podIPs ?? (_podIPs = new InputList<Core.V1.PodIPArgs>());
            set => _podIPs = value;
        }

        /// <summary>
        /// The Quality of Service (QOS) classification assigned to the pod based on resource
        /// requirements See PodQOSClass type for available QOS classes More info:
        /// https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
        /// </summary>
        [Input("qosClass")]
        public Input<string>? QosClass { get; set; }

        /// <summary>
        /// A brief CamelCase message indicating details about why the pod is in this state. e.g.
        /// 'Evicted'
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

        /// <summary>
        /// RFC 3339 date and time at which the object was acknowledged by the Kubelet. This is
        /// before the Kubelet pulled the container image(s) for the pod.
        /// </summary>
        [Input("startTime")]
        public Input<string>? StartTime { get; set; }

    }

    /// <summary>
    /// PodTemplate describes a template for creating copies of a predefined pod.
    /// </summary>
    public class PodTemplateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Template defines the pods that will be created from this pod template.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("template")]
        public Input<Core.V1.PodTemplateSpecArgs>? Template { get; set; }

    }

    /// <summary>
    /// PodTemplateList is a list of PodTemplates.
    /// </summary>
    public class PodTemplateListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.PodTemplateArgs>? _items;

        /// <summary>
        /// List of pod templates
        /// </summary>
        public InputList<Core.V1.PodTemplateArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.PodTemplateArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PodTemplateSpec describes the data a pod should have when created from a template
    /// </summary>
    public class PodTemplateSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the pod. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.PodSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// PortworxVolumeSource represents a Portworx volume resource.
    /// </summary>
    public class PortworxVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// VolumeID uniquely identifies a Portworx volume
        /// </summary>
        [Input("volumeID", required: true)]
        public Input<string> VolumeID { get; set; } = null!;

        /// <summary>
        /// FSType represents the filesystem type to mount Must be a filesystem type supported by
        /// the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if
        /// unspecified.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a
    /// no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
    /// </summary>
    public class PreferredSchedulingTermArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A node selector term, associated with the corresponding weight.
        /// </summary>
        [Input("preference", required: true)]
        public Input<Core.V1.NodeSelectorTermArgs> Preference { get; set; } = null!;

        /// <summary>
        /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

    }

    /// <summary>
    /// Probe describes a health check to be performed against a container to determine whether it
    /// is alive or ready to receive traffic.
    /// </summary>
    public class ProbeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// One and only one of the following should be specified. Exec specifies the action to
        /// take.
        /// </summary>
        [Input("exec")]
        public Input<Core.V1.ExecActionArgs>? Exec { get; set; }

        /// <summary>
        /// Minimum consecutive failures for the probe to be considered failed after having
        /// succeeded. Defaults to 3. Minimum value is 1.
        /// </summary>
        [Input("failureThreshold")]
        public Input<int>? FailureThreshold { get; set; }

        /// <summary>
        /// HTTPGet specifies the http request to perform.
        /// </summary>
        [Input("httpGet")]
        public Input<Core.V1.HTTPGetActionArgs>? HttpGet { get; set; }

        /// <summary>
        /// Number of seconds after the container has started before liveness probes are initiated.
        /// More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Input("initialDelaySeconds")]
        public Input<int>? InitialDelaySeconds { get; set; }

        /// <summary>
        /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        /// </summary>
        [Input("periodSeconds")]
        public Input<int>? PeriodSeconds { get; set; }

        /// <summary>
        /// Minimum consecutive successes for the probe to be considered successful after having
        /// failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
        /// </summary>
        [Input("successThreshold")]
        public Input<int>? SuccessThreshold { get; set; }

        /// <summary>
        /// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        /// </summary>
        [Input("tcpSocket")]
        public Input<Core.V1.TCPSocketActionArgs>? TcpSocket { get; set; }

        /// <summary>
        /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value
        /// is 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Input("timeoutSeconds")]
        public Input<int>? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// Represents a projected volume source
    /// </summary>
    public class ProjectedVolumeSourceArgs : Pulumi.ResourceArgs
    {
        [Input("sources", required: true)]
        private InputList<Core.V1.VolumeProjectionArgs>? _sources;

        /// <summary>
        /// list of volume projections
        /// </summary>
        public InputList<Core.V1.VolumeProjectionArgs> Sources
        {
            get => _sources ?? (_sources = new InputList<Core.V1.VolumeProjectionArgs>());
            set => _sources = value;
        }

        /// <summary>
        /// Mode bits to use on created files by default. Must be a value between 0 and 0777.
        /// Directories within the path are not affected by this setting. This might be in conflict
        /// with other options that affect the file mode, like fsGroup, and the result can be other
        /// mode bits set.
        /// </summary>
        [Input("defaultMode")]
        public Input<int>? DefaultMode { get; set; }

    }

    /// <summary>
    /// Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support
    /// ownership management or SELinux relabeling.
    /// </summary>
    public class QuobyteVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Registry represents a single or multiple Quobyte Registry services specified as a string
        /// as host:port pair (multiple entries are separated with commas) which acts as the central
        /// registry for volumes
        /// </summary>
        [Input("registry", required: true)]
        public Input<string> Registry { get; set; } = null!;

        /// <summary>
        /// Volume is a string that references an already created Quobyte volume by name.
        /// </summary>
        [Input("volume", required: true)]
        public Input<string> Volume { get; set; } = null!;

        /// <summary>
        /// Group to map volume access to Default is no group
        /// </summary>
        [Input("group")]
        public Input<string>? Group { get; set; }

        /// <summary>
        /// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
        /// Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned
        /// Quobyte volumes, value is set by the plugin
        /// </summary>
        [Input("tenant")]
        public Input<string>? Tenant { get; set; }

        /// <summary>
        /// User to map volume access to Defaults to serivceaccount user
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support
    /// ownership management and SELinux relabeling.
    /// </summary>
    public class RBDPersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The rados image name. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("image", required: true)]
        public Input<string> Image { get; set; } = null!;

        [Input("monitors", required: true)]
        private InputList<string>? _monitors;

        /// <summary>
        /// A collection of Ceph monitors. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public InputList<string> Monitors
        {
            get => _monitors ?? (_monitors = new InputList<string>());
            set => _monitors = value;
        }

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#rbd
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("keyring")]
        public Input<string>? Keyring { get; set; }

        /// <summary>
        /// The rados pool name. Default is rbd. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("pool")]
        public Input<string>? Pool { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef is name of the authentication secret for RBDUser. If provided overrides
        /// keyring. Default is nil. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.SecretReferenceArgs>? SecretRef { get; set; }

        /// <summary>
        /// The rados user name. Default is admin. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support
    /// ownership management and SELinux relabeling.
    /// </summary>
    public class RBDVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The rados image name. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("image", required: true)]
        public Input<string> Image { get; set; } = null!;

        [Input("monitors", required: true)]
        private InputList<string>? _monitors;

        /// <summary>
        /// A collection of Ceph monitors. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        public InputList<string> Monitors
        {
            get => _monitors ?? (_monitors = new InputList<string>());
            set => _monitors = value;
        }

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#rbd
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("keyring")]
        public Input<string>? Keyring { get; set; }

        /// <summary>
        /// The rados pool name. Default is rbd. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("pool")]
        public Input<string>? Pool { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef is name of the authentication secret for RBDUser. If provided overrides
        /// keyring. Default is nil. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.LocalObjectReferenceArgs>? SecretRef { get; set; }

        /// <summary>
        /// The rados user name. Default is admin. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// ReplicationController represents the configuration of a replication controller.
    /// </summary>
    public class ReplicationControllerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// If the Labels of a ReplicationController are empty, they are defaulted to be the same as
        /// the Pod(s) that the replication controller manages. Standard object's metadata. More
        /// info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the specification of the desired behavior of the replication controller.
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.ReplicationControllerSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// ReplicationControllerCondition describes the state of a replication controller at a certain
    /// point.
    /// </summary>
    public class ReplicationControllerConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of replication controller condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ReplicationControllerList is a collection of replication controllers.
    /// </summary>
    public class ReplicationControllerListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.ReplicationControllerArgs>? _items;

        /// <summary>
        /// List of replication controllers. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
        public InputList<Core.V1.ReplicationControllerArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.ReplicationControllerArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ReplicationControllerSpec is the specification of a replication controller.
    /// </summary>
    public class ReplicationControllerSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        [Input("selector")]
        private InputMap<string>? _selector;

        /// <summary>
        /// Selector is a label query over pods that should match the Replicas count. If Selector is
        /// empty, it is defaulted to the labels present on the Pod template. Label keys and values
        /// that must match in order to be controlled by this replication controller, if empty
        /// defaulted to labels on Pod template. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        public InputMap<string> Selector
        {
            get => _selector ?? (_selector = new InputMap<string>());
            set => _selector = value;
        }

        /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. This takes precedence over a TemplateRef. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        [Input("template")]
        public Input<Core.V1.PodTemplateSpecArgs>? Template { get; set; }

    }

    /// <summary>
    /// ReplicationControllerStatus represents the current status of a replication controller.
    /// </summary>
    public class ReplicationControllerStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this
        /// replication controller.
        /// </summary>
        [Input("availableReplicas")]
        public Input<int>? AvailableReplicas { get; set; }

        [Input("conditions")]
        private InputList<Core.V1.ReplicationControllerConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a replication controller's current
        /// state.
        /// </summary>
        public InputList<Core.V1.ReplicationControllerConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Core.V1.ReplicationControllerConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replication controller.
        /// </summary>
        [Input("fullyLabeledReplicas")]
        public Input<int>? FullyLabeledReplicas { get; set; }

        /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed replication
        /// controller.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The number of ready replicas for this replication controller.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

    }

    /// <summary>
    /// ResourceFieldSelector represents container resources (cpu, memory) and their output format
    /// </summary>
    public class ResourceFieldSelectorArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required: resource to select
        /// </summary>
        [Input("resource", required: true)]
        public Input<string> Resource { get; set; } = null!;

        /// <summary>
        /// Container name: required for volumes, optional for env vars
        /// </summary>
        [Input("containerName")]
        public Input<string>? ContainerName { get; set; }

        /// <summary>
        /// Specifies the output format of the exposed resources, defaults to "1"
        /// </summary>
        [Input("divisor")]
        public Input<string>? Divisor { get; set; }

    }

    /// <summary>
    /// ResourceQuota sets aggregate quota restrictions enforced per namespace
    /// </summary>
    public class ResourceQuotaArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired quota.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.ResourceQuotaSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// ResourceQuotaList is a list of ResourceQuota items.
    /// </summary>
    public class ResourceQuotaListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.ResourceQuotaArgs>? _items;

        /// <summary>
        /// Items is a list of ResourceQuota objects. More info:
        /// https://kubernetes.io/docs/concepts/policy/resource-quotas/
        /// </summary>
        public InputList<Core.V1.ResourceQuotaArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.ResourceQuotaArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
    /// </summary>
    public class ResourceQuotaSpecArgs : Pulumi.ResourceArgs
    {
        [Input("hard")]
        private InputMap<string>? _hard;

        /// <summary>
        /// hard is the set of desired hard limits for each named resource. More info:
        /// https://kubernetes.io/docs/concepts/policy/resource-quotas/
        /// </summary>
        public InputMap<string> Hard
        {
            get => _hard ?? (_hard = new InputMap<string>());
            set => _hard = value;
        }

        /// <summary>
        /// scopeSelector is also a collection of filters like scopes that must match each object
        /// tracked by a quota but expressed using ScopeSelectorOperator in combination with
        /// possible values. For a resource to match, both scopes AND scopeSelector (if specified in
        /// spec), must be matched.
        /// </summary>
        [Input("scopeSelector")]
        public Input<Core.V1.ScopeSelectorArgs>? ScopeSelector { get; set; }

        [Input("scopes")]
        private InputList<string>? _scopes;

        /// <summary>
        /// A collection of filters that must match each object tracked by a quota. If not
        /// specified, the quota matches all objects.
        /// </summary>
        public InputList<string> Scopes
        {
            get => _scopes ?? (_scopes = new InputList<string>());
            set => _scopes = value;
        }

    }

    /// <summary>
    /// ResourceQuotaStatus defines the enforced hard limits and observed use.
    /// </summary>
    public class ResourceQuotaStatusArgs : Pulumi.ResourceArgs
    {
        [Input("hard")]
        private InputMap<string>? _hard;

        /// <summary>
        /// Hard is the set of enforced hard limits for each named resource. More info:
        /// https://kubernetes.io/docs/concepts/policy/resource-quotas/
        /// </summary>
        public InputMap<string> Hard
        {
            get => _hard ?? (_hard = new InputMap<string>());
            set => _hard = value;
        }

        [Input("used")]
        private InputMap<string>? _used;

        /// <summary>
        /// Used is the current observed total usage of the resource in the namespace.
        /// </summary>
        public InputMap<string> Used
        {
            get => _used ?? (_used = new InputMap<string>());
            set => _used = value;
        }

    }

    /// <summary>
    /// ResourceRequirements describes the compute resource requirements.
    /// </summary>
    public class ResourceRequirementsArgs : Pulumi.ResourceArgs
    {
        [Input("limits")]
        private InputMap<string>? _limits;

        /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
        public InputMap<string> Limits
        {
            get => _limits ?? (_limits = new InputMap<string>());
            set => _limits = value;
        }

        [Input("requests")]
        private InputMap<string>? _requests;

        /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is
        /// omitted for a container, it defaults to Limits if that is explicitly specified,
        /// otherwise to an implementation-defined value. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
        public InputMap<string> Requests
        {
            get => _requests ?? (_requests = new InputMap<string>());
            set => _requests = value;
        }

    }

    /// <summary>
    /// SELinuxOptions are the labels to be applied to the container
    /// </summary>
    public class SELinuxOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Level is SELinux level label that applies to the container.
        /// </summary>
        [Input("level")]
        public Input<string>? Level { get; set; }

        /// <summary>
        /// Role is a SELinux role label that applies to the container.
        /// </summary>
        [Input("role")]
        public Input<string>? Role { get; set; }

        /// <summary>
        /// Type is a SELinux type label that applies to the container.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// User is a SELinux user label that applies to the container.
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

    }

    /// <summary>
    /// ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
    /// </summary>
    public class ScaleIOPersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The host address of the ScaleIO API Gateway.
        /// </summary>
        [Input("gateway", required: true)]
        public Input<string> Gateway { get; set; } = null!;

        /// <summary>
        /// SecretRef references to the secret for ScaleIO user and other sensitive information. If
        /// this is not provided, Login operation will fail.
        /// </summary>
        [Input("secretRef", required: true)]
        public Input<Core.V1.SecretReferenceArgs> SecretRef { get; set; } = null!;

        /// <summary>
        /// The name of the storage system as configured in ScaleIO.
        /// </summary>
        [Input("system", required: true)]
        public Input<string> System { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Default is "xfs"
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// The name of the ScaleIO Protection Domain for the configured storage.
        /// </summary>
        [Input("protectionDomain")]
        public Input<string>? ProtectionDomain { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Flag to enable/disable SSL communication with Gateway, default false
        /// </summary>
        [Input("sslEnabled")]
        public Input<bool>? SslEnabled { get; set; }

        /// <summary>
        /// Indicates whether the storage for a volume should be ThickProvisioned or
        /// ThinProvisioned. Default is ThinProvisioned.
        /// </summary>
        [Input("storageMode")]
        public Input<string>? StorageMode { get; set; }

        /// <summary>
        /// The ScaleIO Storage Pool associated with the protection domain.
        /// </summary>
        [Input("storagePool")]
        public Input<string>? StoragePool { get; set; }

        /// <summary>
        /// The name of a volume already created in the ScaleIO system that is associated with this
        /// volume source.
        /// </summary>
        [Input("volumeName")]
        public Input<string>? VolumeName { get; set; }

    }

    /// <summary>
    /// ScaleIOVolumeSource represents a persistent ScaleIO volume
    /// </summary>
    public class ScaleIOVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The host address of the ScaleIO API Gateway.
        /// </summary>
        [Input("gateway", required: true)]
        public Input<string> Gateway { get; set; } = null!;

        /// <summary>
        /// SecretRef references to the secret for ScaleIO user and other sensitive information. If
        /// this is not provided, Login operation will fail.
        /// </summary>
        [Input("secretRef", required: true)]
        public Input<Core.V1.LocalObjectReferenceArgs> SecretRef { get; set; } = null!;

        /// <summary>
        /// The name of the storage system as configured in ScaleIO.
        /// </summary>
        [Input("system", required: true)]
        public Input<string> System { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// The name of the ScaleIO Protection Domain for the configured storage.
        /// </summary>
        [Input("protectionDomain")]
        public Input<string>? ProtectionDomain { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Flag to enable/disable SSL communication with Gateway, default false
        /// </summary>
        [Input("sslEnabled")]
        public Input<bool>? SslEnabled { get; set; }

        /// <summary>
        /// Indicates whether the storage for a volume should be ThickProvisioned or
        /// ThinProvisioned. Default is ThinProvisioned.
        /// </summary>
        [Input("storageMode")]
        public Input<string>? StorageMode { get; set; }

        /// <summary>
        /// The ScaleIO Storage Pool associated with the protection domain.
        /// </summary>
        [Input("storagePool")]
        public Input<string>? StoragePool { get; set; }

        /// <summary>
        /// The name of a volume already created in the ScaleIO system that is associated with this
        /// volume source.
        /// </summary>
        [Input("volumeName")]
        public Input<string>? VolumeName { get; set; }

    }

    /// <summary>
    /// A scope selector represents the AND of the selectors represented by the scoped-resource
    /// selector requirements.
    /// </summary>
    public class ScopeSelectorArgs : Pulumi.ResourceArgs
    {
        [Input("matchExpressions")]
        private InputList<Core.V1.ScopedResourceSelectorRequirementArgs>? _matchExpressions;

        /// <summary>
        /// A list of scope selector requirements by scope of the resources.
        /// </summary>
        public InputList<Core.V1.ScopedResourceSelectorRequirementArgs> MatchExpressions
        {
            get => _matchExpressions ?? (_matchExpressions = new InputList<Core.V1.ScopedResourceSelectorRequirementArgs>());
            set => _matchExpressions = value;
        }

    }

    /// <summary>
    /// A scoped-resource selector requirement is a selector that contains values, a scope name, and
    /// an operator that relates the scope name and values.
    /// </summary>
    public class ScopedResourceSelectorRequirementArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Represents a scope's relationship to a set of values. Valid operators are In, NotIn,
        /// Exists, DoesNotExist.
        /// </summary>
        [Input("operator", required: true)]
        public Input<string> Operator { get; set; } = null!;

        /// <summary>
        /// The name of the scope that the selector applies to.
        /// </summary>
        [Input("scopeName", required: true)]
        public Input<string> ScopeName { get; set; } = null!;

        [Input("values")]
        private InputList<string>? _values;

        /// <summary>
        /// An array of string values. If the operator is In or NotIn, the values array must be
        /// non-empty. If the operator is Exists or DoesNotExist, the values array must be empty.
        /// This array is replaced during a strategic merge patch.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

    }

    /// <summary>
    /// Secret holds secret data of a certain type. The total bytes of the values in the Data field
    /// must be less than MaxSecretSize bytes.
    /// </summary>
    public class SecretArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        [Input("data")]
        private InputMap<string>? _data;

        /// <summary>
        /// Data contains the secret data. Each key must consist of alphanumeric characters, '-',
        /// '_' or '.'. The serialized form of the secret data is a base64 encoded string,
        /// representing the arbitrary (possibly non-string) data value here. Described in
        /// https://tools.ietf.org/html/rfc4648#section-4
        /// </summary>
        public InputMap<string> Data
        {
            get => _data ?? (_data = new InputMap<string>());
            set => _data = value;
        }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("stringData")]
        private InputMap<string>? _stringData;

        /// <summary>
        /// stringData allows specifying non-binary secret data in string form. It is provided as a
        /// write-only convenience method. All keys and values are merged into the data field on
        /// write, overwriting any existing values. It is never output when reading from the API.
        /// </summary>
        public InputMap<string> StringData
        {
            get => _stringData ?? (_stringData = new InputMap<string>());
            set => _stringData = value;
        }

        /// <summary>
        /// Used to facilitate programmatic handling of secret data.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// SecretEnvSource selects a Secret to populate the environment variables with.
    /// 
    /// The contents of the target Secret's Data field will represent the key-value pairs as
    /// environment variables.
    /// </summary>
    public class SecretEnvSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the Secret must be defined
        /// </summary>
        [Input("optional")]
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// SecretKeySelector selects a key of a Secret.
    /// </summary>
    public class SecretKeySelectorArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The key of the secret to select from.  Must be a valid secret key.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the Secret or its key must be defined
        /// </summary>
        [Input("optional")]
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// SecretList is a list of Secret.
    /// </summary>
    public class SecretListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.SecretArgs>? _items;

        /// <summary>
        /// Items is a list of secret objects. More info:
        /// https://kubernetes.io/docs/concepts/configuration/secret
        /// </summary>
        public InputList<Core.V1.SecretArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.SecretArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// Adapts a secret into a projected volume.
    /// 
    /// The contents of the target Secret's Data field will be presented in a projected volume as
    /// files using the keys in the Data field as the file names. Note that this is identical to a
    /// secret volume source without the default mode.
    /// </summary>
    public class SecretProjectionArgs : Pulumi.ResourceArgs
    {
        [Input("items")]
        private InputList<Core.V1.KeyToPathArgs>? _items;

        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced Secret will be
        /// projected into the volume as a file whose name is the key and content is the value. If
        /// specified, the listed keys will be projected into the specified paths, and unlisted keys
        /// will not be present. If a key is specified which is not present in the Secret, the
        /// volume setup will error unless it is marked optional. Paths must be relative and may not
        /// contain the '..' path or start with '..'.
        /// </summary>
        public InputList<Core.V1.KeyToPathArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.KeyToPathArgs>());
            set => _items = value;
        }

        /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Specify whether the Secret or its key must be defined
        /// </summary>
        [Input("optional")]
        public Input<bool>? Optional { get; set; }

    }

    /// <summary>
    /// SecretReference represents a Secret Reference. It has enough information to retrieve secret
    /// in any namespace
    /// </summary>
    public class SecretReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name is unique within a namespace to reference a secret resource.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace defines the space within which the secret name must be unique.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

    }

    /// <summary>
    /// Adapts a Secret into a volume.
    /// 
    /// The contents of the target Secret's Data field will be presented in a volume as files using
    /// the keys in the Data field as the file names. Secret volumes support ownership management
    /// and SELinux relabeling.
    /// </summary>
    public class SecretVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a value between 0 and
        /// 0777. Defaults to 0644. Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file mode, like fsGroup,
        /// and the result can be other mode bits set.
        /// </summary>
        [Input("defaultMode")]
        public Input<int>? DefaultMode { get; set; }

        [Input("items")]
        private InputList<Core.V1.KeyToPathArgs>? _items;

        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced Secret will be
        /// projected into the volume as a file whose name is the key and content is the value. If
        /// specified, the listed keys will be projected into the specified paths, and unlisted keys
        /// will not be present. If a key is specified which is not present in the Secret, the
        /// volume setup will error unless it is marked optional. Paths must be relative and may not
        /// contain the '..' path or start with '..'.
        /// </summary>
        public InputList<Core.V1.KeyToPathArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.KeyToPathArgs>());
            set => _items = value;
        }

        /// <summary>
        /// Specify whether the Secret or its keys must be defined
        /// </summary>
        [Input("optional")]
        public Input<bool>? Optional { get; set; }

        /// <summary>
        /// Name of the secret in the pod's namespace to use. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#secret
        /// </summary>
        [Input("secretName")]
        public Input<string>? SecretName { get; set; }

    }

    /// <summary>
    /// SecurityContext holds security configuration that will be applied to a container. Some
    /// fields are present in both SecurityContext and PodSecurityContext.  When both are set, the
    /// values in SecurityContext take precedence.
    /// </summary>
    public class SecurityContextArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// AllowPrivilegeEscalation controls whether a process can gain more privileges than its
        /// parent process. This bool directly controls if the no_new_privs flag will be set on the
        /// container process. AllowPrivilegeEscalation is true always when the container is: 1) run
        /// as Privileged 2) has CAP_SYS_ADMIN
        /// </summary>
        [Input("allowPrivilegeEscalation")]
        public Input<bool>? AllowPrivilegeEscalation { get; set; }

        /// <summary>
        /// The capabilities to add/drop when running containers. Defaults to the default set of
        /// capabilities granted by the container runtime.
        /// </summary>
        [Input("capabilities")]
        public Input<Core.V1.CapabilitiesArgs>? Capabilities { get; set; }

        /// <summary>
        /// Run container in privileged mode. Processes in privileged containers are essentially
        /// equivalent to root on the host. Defaults to false.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// procMount denotes the type of proc mount to use for the containers. The default is
        /// DefaultProcMount which uses the container runtime defaults for readonly paths and masked
        /// paths. This requires the ProcMountType feature flag to be enabled.
        /// </summary>
        [Input("procMount")]
        public Input<string>? ProcMount { get; set; }

        /// <summary>
        /// Whether this container has a read-only root filesystem. Default is false.
        /// </summary>
        [Input("readOnlyRootFilesystem")]
        public Input<bool>? ReadOnlyRootFilesystem { get; set; }

        /// <summary>
        /// The GID to run the entrypoint of the container process. Uses runtime default if unset.
        /// May also be set in PodSecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        [Input("runAsGroup")]
        public Input<int>? RunAsGroup { get; set; }

        /// <summary>
        /// Indicates that the container must run as a non-root user. If true, the Kubelet will
        /// validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to
        /// start the container if it does. If unset or false, no such validation will be performed.
        /// May also be set in PodSecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        [Input("runAsNonRoot")]
        public Input<bool>? RunAsNonRoot { get; set; }

        /// <summary>
        /// The UID to run the entrypoint of the container process. Defaults to user specified in
        /// image metadata if unspecified. May also be set in PodSecurityContext.  If set in both
        /// SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
        /// precedence.
        /// </summary>
        [Input("runAsUser")]
        public Input<int>? RunAsUser { get; set; }

        /// <summary>
        /// The SELinux context to be applied to the container. If unspecified, the container
        /// runtime will allocate a random SELinux context for each container.  May also be set in
        /// PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value
        /// specified in SecurityContext takes precedence.
        /// </summary>
        [Input("seLinuxOptions")]
        public Input<Core.V1.SELinuxOptionsArgs>? SeLinuxOptions { get; set; }

        /// <summary>
        /// The Windows specific settings applied to all containers. If unspecified, the options
        /// from the PodSecurityContext will be used. If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        [Input("windowsOptions")]
        public Input<Core.V1.WindowsSecurityContextOptionsArgs>? WindowsOptions { get; set; }

    }

    /// <summary>
    /// Service is a named abstraction of software service (for example, mysql) consisting of local
    /// port (for example 3306) that the proxy listens on, and the selector that determines which
    /// pods will answer requests sent through the proxy.
    /// </summary>
    public class ServiceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the behavior of a service.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Core.V1.ServiceSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral
    /// systems, for an identity * a principal that can be authenticated and authorized * a set of
    /// secrets
    /// </summary>
    public class ServiceAccountArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// AutomountServiceAccountToken indicates whether pods running as this service account
        /// should have an API token automatically mounted. Can be overridden at the pod level.
        /// </summary>
        [Input("automountServiceAccountToken")]
        public Input<bool>? AutomountServiceAccountToken { get; set; }

        [Input("imagePullSecrets")]
        private InputList<Core.V1.LocalObjectReferenceArgs>? _imagePullSecrets;

        /// <summary>
        /// ImagePullSecrets is a list of references to secrets in the same namespace to use for
        /// pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are
        /// distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets
        /// are only accessed by the kubelet. More info:
        /// https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        /// </summary>
        public InputList<Core.V1.LocalObjectReferenceArgs> ImagePullSecrets
        {
            get => _imagePullSecrets ?? (_imagePullSecrets = new InputList<Core.V1.LocalObjectReferenceArgs>());
            set => _imagePullSecrets = value;
        }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("secrets")]
        private InputList<Core.V1.ObjectReferenceArgs>? _secrets;

        /// <summary>
        /// Secrets is the list of secrets allowed to be used by pods running using this
        /// ServiceAccount. More info: https://kubernetes.io/docs/concepts/configuration/secret
        /// </summary>
        public InputList<Core.V1.ObjectReferenceArgs> Secrets
        {
            get => _secrets ?? (_secrets = new InputList<Core.V1.ObjectReferenceArgs>());
            set => _secrets = value;
        }

    }

    /// <summary>
    /// ServiceAccountList is a list of ServiceAccount objects
    /// </summary>
    public class ServiceAccountListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.ServiceAccountArgs>? _items;

        /// <summary>
        /// List of ServiceAccounts. More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        /// </summary>
        public InputList<Core.V1.ServiceAccountArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.ServiceAccountArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ServiceAccountTokenProjection represents a projected service account token volume. This
    /// projection can be used to insert a service account token into the pods runtime filesystem
    /// for use against APIs (Kubernetes API Server or otherwise).
    /// </summary>
    public class ServiceAccountTokenProjectionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Path is the path relative to the mount point of the file to project the token into.
        /// </summary>
        [Input("path", required: true)]
        public Input<string> Path { get; set; } = null!;

        /// <summary>
        /// Audience is the intended audience of the token. A recipient of a token must identify
        /// itself with an identifier specified in the audience of the token, and otherwise should
        /// reject the token. The audience defaults to the identifier of the apiserver.
        /// </summary>
        [Input("audience")]
        public Input<string>? Audience { get; set; }

        /// <summary>
        /// ExpirationSeconds is the requested duration of validity of the service account token. As
        /// the token approaches expiration, the kubelet volume plugin will proactively rotate the
        /// service account token. The kubelet will start trying to rotate the token if the token is
        /// older than 80 percent of its time to live or if the token is older than 24
        /// hours.Defaults to 1 hour and must be at least 10 minutes.
        /// </summary>
        [Input("expirationSeconds")]
        public Input<int>? ExpirationSeconds { get; set; }

    }

    /// <summary>
    /// ServiceList holds a list of services.
    /// </summary>
    public class ServiceListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Core.V1.ServiceArgs>? _items;

        /// <summary>
        /// List of services
        /// </summary>
        public InputList<Core.V1.ServiceArgs> Items
        {
            get => _items ?? (_items = new InputList<Core.V1.ServiceArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ServicePort contains information on service's port.
    /// </summary>
    public class ServicePortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The port that will be exposed by this service.
        /// </summary>
        [Input("port", required: true)]
        public Input<int> Port { get; set; } = null!;

        /// <summary>
        /// The name of this port within the service. This must be a DNS_LABEL. All ports within a
        /// ServiceSpec must have unique names. When considering the endpoints for a Service, this
        /// must match the 'name' field in the EndpointPort. Optional if only one ServicePort is
        /// defined on this service.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The port on each node on which this service is exposed when type=NodePort or
        /// LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the
        /// service if unused or else creation of the service will fail. Default is to auto-allocate
        /// a port if the ServiceType of this Service requires one. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
        /// </summary>
        [Input("nodePort")]
        public Input<int>? NodePort { get; set; }

        /// <summary>
        /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// Number or name of the port to access on the pods targeted by the service. Number must be
        /// in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be
        /// looked up as a named port in the target Pod's container ports. If this is not specified,
        /// the value of the 'port' field is used (an identity map). This field is ignored for
        /// services with clusterIP=None, and should be omitted or set equal to the 'port' field.
        /// More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
        /// </summary>
        [Input("targetPort")]
        public InputUnion<int,string>? TargetPort { get; set; }

    }

    /// <summary>
    /// ServiceSpec describes the attributes that a user creates on a service.
    /// </summary>
    public class ServiceSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// clusterIP is the IP address of the service and is usually assigned randomly by the
        /// master. If an address is specified manually and is not in use by others, it will be
        /// allocated to the service; otherwise, creation of the service will fail. This field can
        /// not be changed through updates. Valid values are "None", empty string (""), or a valid
        /// IP address. "None" can be specified for headless services when proxying is not required.
        /// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is
        /// ExternalName. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        [Input("clusterIP")]
        public Input<string>? ClusterIP { get; set; }

        [Input("externalIPs")]
        private InputList<string>? _externalIPs;

        /// <summary>
        /// externalIPs is a list of IP addresses for which nodes in the cluster will also accept
        /// traffic for this service.  These IPs are not managed by Kubernetes.  The user is
        /// responsible for ensuring that traffic arrives at a node with this IP.  A common example
        /// is external load-balancers that are not part of the Kubernetes system.
        /// </summary>
        public InputList<string> ExternalIPs
        {
            get => _externalIPs ?? (_externalIPs = new InputList<string>());
            set => _externalIPs = value;
        }

        /// <summary>
        /// externalName is the external reference that kubedns or equivalent will return as a CNAME
        /// record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname
        /// (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
        /// </summary>
        [Input("externalName")]
        public Input<string>? ExternalName { get; set; }

        /// <summary>
        /// externalTrafficPolicy denotes if this Service desires to route external traffic to
        /// node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids
        /// a second hop for LoadBalancer and Nodeport type services, but risks potentially
        /// imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a
        /// second hop to another node, but should have good overall load-spreading.
        /// </summary>
        [Input("externalTrafficPolicy")]
        public Input<string>? ExternalTrafficPolicy { get; set; }

        /// <summary>
        /// healthCheckNodePort specifies the healthcheck nodePort for the service. If not
        /// specified, HealthCheckNodePort is created by the service api backend with the allocated
        /// nodePort. Will use user-specified nodePort value if specified by the client. Only
        /// effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
        /// </summary>
        [Input("healthCheckNodePort")]
        public Input<int>? HealthCheckNodePort { get; set; }

        /// <summary>
        /// ipFamily specifies whether this Service has a preference for a particular IP family
        /// (e.g. IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be
        /// allocated from that family, if it is available in the cluster.  If no IP family is
        /// requested, the cluster's primary IP family will be used. Other IP fields
        /// (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which allocate
        /// external load-balancers should use the same IP family.  Endpoints for this Service will
        /// be of this family.  This field is immutable after creation. Assigning a ServiceIPFamily
        /// not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and
        /// will fail during clusterIP assignment.
        /// </summary>
        [Input("ipFamily")]
        public Input<string>? IpFamily { get; set; }

        /// <summary>
        /// Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP
        /// specified in this field. This feature depends on whether the underlying cloud-provider
        /// supports specifying the loadBalancerIP when a load balancer is created. This field will
        /// be ignored if the cloud-provider does not support the feature.
        /// </summary>
        [Input("loadBalancerIP")]
        public Input<string>? LoadBalancerIP { get; set; }

        [Input("loadBalancerSourceRanges")]
        private InputList<string>? _loadBalancerSourceRanges;

        /// <summary>
        /// If specified and supported by the platform, this will restrict traffic through the
        /// cloud-provider load-balancer will be restricted to the specified client IPs. This field
        /// will be ignored if the cloud-provider does not support the feature." More info:
        /// https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
        /// </summary>
        public InputList<string> LoadBalancerSourceRanges
        {
            get => _loadBalancerSourceRanges ?? (_loadBalancerSourceRanges = new InputList<string>());
            set => _loadBalancerSourceRanges = value;
        }

        [Input("ports")]
        private InputList<Core.V1.ServicePortArgs>? _ports;

        /// <summary>
        /// The list of ports that are exposed by this service. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        public InputList<Core.V1.ServicePortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Core.V1.ServicePortArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// publishNotReadyAddresses, when set to true, indicates that DNS implementations must
        /// publish the notReadyAddresses of subsets for the Endpoints associated with the Service.
        /// The default value is false. The primary use case for setting this field is to use a
        /// StatefulSet's Headless Service to propagate SRV records for its Pods without respect to
        /// their readiness for purpose of peer discovery.
        /// </summary>
        [Input("publishNotReadyAddresses")]
        public Input<bool>? PublishNotReadyAddresses { get; set; }

        [Input("selector")]
        private InputMap<string>? _selector;

        /// <summary>
        /// Route service traffic to pods with label keys and values matching this selector. If
        /// empty or not present, the service is assumed to have an external process managing its
        /// endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort,
        /// and LoadBalancer. Ignored if type is ExternalName. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/
        /// </summary>
        public InputMap<string> Selector
        {
            get => _selector ?? (_selector = new InputMap<string>());
            set => _selector = value;
        }

        /// <summary>
        /// Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP
        /// based session affinity. Must be ClientIP or None. Defaults to None. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
        [Input("sessionAffinity")]
        public Input<string>? SessionAffinity { get; set; }

        /// <summary>
        /// sessionAffinityConfig contains the configurations of session affinity.
        /// </summary>
        [Input("sessionAffinityConfig")]
        public Input<Core.V1.SessionAffinityConfigArgs>? SessionAffinityConfig { get; set; }

        /// <summary>
        /// type determines how the Service is exposed. Defaults to ClusterIP. Valid options are
        /// ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the
        /// specified externalName. "ClusterIP" allocates a cluster-internal IP address for
        /// load-balancing to endpoints. Endpoints are determined by the selector or if that is not
        /// specified, by manual construction of an Endpoints object. If clusterIP is "None", no
        /// virtual IP is allocated and the endpoints are published as a set of endpoints rather
        /// than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node
        /// which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external
        /// load-balancer (if supported in the current cloud) which routes to the clusterIP. More
        /// info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// ServiceStatus represents the current status of a service.
    /// </summary>
    public class ServiceStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// LoadBalancer contains the current status of the load-balancer, if one is present.
        /// </summary>
        [Input("loadBalancer")]
        public Input<Core.V1.LoadBalancerStatusArgs>? LoadBalancer { get; set; }

    }

    /// <summary>
    /// SessionAffinityConfig represents the configurations of session affinity.
    /// </summary>
    public class SessionAffinityConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// clientIP contains the configurations of Client IP based session affinity.
        /// </summary>
        [Input("clientIP")]
        public Input<Core.V1.ClientIPConfigArgs>? ClientIP { get; set; }

    }

    /// <summary>
    /// Represents a StorageOS persistent volume resource.
    /// </summary>
    public class StorageOSPersistentVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If
        /// not specified, default values will be attempted.
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.ObjectReferenceArgs>? SecretRef { get; set; }

        /// <summary>
        /// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only
        /// unique within a namespace.
        /// </summary>
        [Input("volumeName")]
        public Input<string>? VolumeName { get; set; }

        /// <summary>
        /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is
        /// specified then the Pod's namespace will be used.  This allows the Kubernetes name
        /// scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any
        /// name to override the default behaviour. Set to "default" if you are not using namespaces
        /// within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
        /// </summary>
        [Input("volumeNamespace")]
        public Input<string>? VolumeNamespace { get; set; }

    }

    /// <summary>
    /// Represents a StorageOS persistent volume resource.
    /// </summary>
    public class StorageOSVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If
        /// not specified, default values will be attempted.
        /// </summary>
        [Input("secretRef")]
        public Input<Core.V1.LocalObjectReferenceArgs>? SecretRef { get; set; }

        /// <summary>
        /// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only
        /// unique within a namespace.
        /// </summary>
        [Input("volumeName")]
        public Input<string>? VolumeName { get; set; }

        /// <summary>
        /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is
        /// specified then the Pod's namespace will be used.  This allows the Kubernetes name
        /// scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any
        /// name to override the default behaviour. Set to "default" if you are not using namespaces
        /// within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
        /// </summary>
        [Input("volumeNamespace")]
        public Input<string>? VolumeNamespace { get; set; }

    }

    /// <summary>
    /// Sysctl defines a kernel parameter to be set
    /// </summary>
    public class SysctlArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of a property to set
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Value of a property to set
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

    }

    /// <summary>
    /// TCPSocketAction describes an action based on opening a socket
    /// </summary>
    public class TCPSocketActionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Number or name of the port to access on the container. Number must be in the range 1 to
        /// 65535. Name must be an IANA_SVC_NAME.
        /// </summary>
        [Input("port", required: true)]
        public InputUnion<int,string> Port { get; set; } = null!;

        /// <summary>
        /// Optional: Host name to connect to, defaults to the pod IP.
        /// </summary>
        [Input("host")]
        public Input<string>? Host { get; set; }

    }

    /// <summary>
    /// The node this Taint is attached to has the "effect" on any pod that does not tolerate the
    /// Taint.
    /// </summary>
    public class TaintArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required. The effect of the taint on pods that do not tolerate the taint. Valid effects
        /// are NoSchedule, PreferNoSchedule and NoExecute.
        /// </summary>
        [Input("effect", required: true)]
        public Input<string> Effect { get; set; } = null!;

        /// <summary>
        /// Required. The taint key to be applied to a node.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// TimeAdded represents the time at which the taint was added. It is only written for
        /// NoExecute taints.
        /// </summary>
        [Input("timeAdded")]
        public Input<string>? TimeAdded { get; set; }

        /// <summary>
        /// Required. The taint value corresponding to the taint key.
        /// </summary>
        [Input("value")]
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// The pod this Toleration is attached to tolerates any taint that matches the triple
    /// &amp;lt;key,value,effect&amp;gt; using the matching operator &amp;lt;operator&amp;gt;.
    /// </summary>
    public class TolerationArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Effect indicates the taint effect to match. Empty means match all taint effects. When
        /// specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        /// </summary>
        [Input("effect")]
        public Input<string>? Effect { get; set; }

        /// <summary>
        /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
        /// If the key is empty, operator must be Exists; this combination means to match all values
        /// and all keys.
        /// </summary>
        [Input("key")]
        public Input<string>? Key { get; set; }

        /// <summary>
        /// Operator represents a key's relationship to the value. Valid operators are Exists and
        /// Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can
        /// tolerate all taints of a particular category.
        /// </summary>
        [Input("operator")]
        public Input<string>? Operator { get; set; }

        /// <summary>
        /// TolerationSeconds represents the period of time the toleration (which must be of effect
        /// NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not
        /// set, which means tolerate the taint forever (do not evict). Zero and negative values
        /// will be treated as 0 (evict immediately) by the system.
        /// </summary>
        [Input("tolerationSeconds")]
        public Input<int>? TolerationSeconds { get; set; }

        /// <summary>
        /// Value is the taint value the toleration matches to. If the operator is Exists, the value
        /// should be empty, otherwise just a regular string.
        /// </summary>
        [Input("value")]
        public Input<string>? Value { get; set; }

    }

    /// <summary>
    /// A topology selector requirement is a selector that matches given label. This is an alpha
    /// feature and may change in the future.
    /// </summary>
    public class TopologySelectorLabelRequirementArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The label key that the selector applies to.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        [Input("values", required: true)]
        private InputList<string>? _values;

        /// <summary>
        /// An array of string values. One value must match the label to be selected. Each entry in
        /// Values is ORed.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

    }

    /// <summary>
    /// A topology selector term represents the result of label queries. A null or empty topology
    /// selector term matches no objects. The requirements of them are ANDed. It provides a subset
    /// of functionality as NodeSelectorTerm. This is an alpha feature and may change in the future.
    /// </summary>
    public class TopologySelectorTermArgs : Pulumi.ResourceArgs
    {
        [Input("matchLabelExpressions")]
        private InputList<Core.V1.TopologySelectorLabelRequirementArgs>? _matchLabelExpressions;

        /// <summary>
        /// A list of topology selector requirements by labels.
        /// </summary>
        public InputList<Core.V1.TopologySelectorLabelRequirementArgs> MatchLabelExpressions
        {
            get => _matchLabelExpressions ?? (_matchLabelExpressions = new InputList<Core.V1.TopologySelectorLabelRequirementArgs>());
            set => _matchLabelExpressions = value;
        }

    }

    /// <summary>
    /// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
    /// </summary>
    public class TopologySpreadConstraintArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// MaxSkew describes the degree to which pods may be unevenly distributed. It's the maximum
        /// permitted difference between the number of matching pods in any two topology domains of
        /// a given topology type. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods
        /// with the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |
        /// | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
        /// scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate
        /// MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. It's a
        /// required field. Default value is 1 and 0 is not allowed.
        /// </summary>
        [Input("maxSkew", required: true)]
        public Input<int> MaxSkew { get; set; } = null!;

        /// <summary>
        /// TopologyKey is the key of node labels. Nodes that have a label with this key and
        /// identical values are considered to be in the same topology. We consider each
        /// &amp;lt;key, value&amp;gt; as a "bucket", and try to put balanced number of pods into
        /// each bucket. It's a required field.
        /// </summary>
        [Input("topologyKey", required: true)]
        public Input<string> TopologyKey { get; set; } = null!;

        /// <summary>
        /// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread
        /// constraint. - DoNotSchedule (default) tells the scheduler not to schedule it -
        /// ScheduleAnyway tells the scheduler to still schedule it It's considered as
        /// "Unsatisfiable" if and only if placing incoming pod on any topology violates "MaxSkew".
        /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
        /// labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If
        /// WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to
        /// zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
        /// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't
        /// make it *more* imbalanced. It's a required field.
        /// </summary>
        [Input("whenUnsatisfiable", required: true)]
        public Input<string> WhenUnsatisfiable { get; set; } = null!;

        /// <summary>
        /// LabelSelector is used to find matching pods. Pods that match this label selector are
        /// counted to determine the number of pods in their corresponding topology domain.
        /// </summary>
        [Input("labelSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? LabelSelector { get; set; }

    }

    /// <summary>
    /// TypedLocalObjectReference contains enough information to let you locate the typed referenced
    /// object inside the same namespace.
    /// </summary>
    public class TypedLocalObjectReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Kind is the type of resource being referenced
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified,
        /// the specified Kind must be in the core API group. For any other third-party types,
        /// APIGroup is required.
        /// </summary>
        [Input("apiGroup")]
        public Input<string>? ApiGroup { get; set; }

    }

    /// <summary>
    /// Volume represents a named volume in a pod that may be accessed by any container in the pod.
    /// </summary>
    public class VolumeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Volume's name. Must be a DNS_LABEL and unique within the pod. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's
        /// host machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [Input("awsElasticBlockStore")]
        public Input<Core.V1.AWSElasticBlockStoreVolumeSourceArgs>? AwsElasticBlockStore { get; set; }

        /// <summary>
        /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
        /// </summary>
        [Input("azureDisk")]
        public Input<Core.V1.AzureDiskVolumeSourceArgs>? AzureDisk { get; set; }

        /// <summary>
        /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
        /// </summary>
        [Input("azureFile")]
        public Input<Core.V1.AzureFileVolumeSourceArgs>? AzureFile { get; set; }

        /// <summary>
        /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
        /// </summary>
        [Input("cephfs")]
        public Input<Core.V1.CephFSVolumeSourceArgs>? Cephfs { get; set; }

        /// <summary>
        /// Cinder represents a cinder volume attached and mounted on kubelets host machine. More
        /// info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Input("cinder")]
        public Input<Core.V1.CinderVolumeSourceArgs>? Cinder { get; set; }

        /// <summary>
        /// ConfigMap represents a configMap that should populate this volume
        /// </summary>
        [Input("configMap")]
        public Input<Core.V1.ConfigMapVolumeSourceArgs>? ConfigMap { get; set; }

        /// <summary>
        /// CSI (Container Storage Interface) represents storage that is handled by an external CSI
        /// driver (Alpha feature).
        /// </summary>
        [Input("csi")]
        public Input<Core.V1.CSIVolumeSourceArgs>? Csi { get; set; }

        /// <summary>
        /// DownwardAPI represents downward API about the pod that should populate this volume
        /// </summary>
        [Input("downwardAPI")]
        public Input<Core.V1.DownwardAPIVolumeSourceArgs>? DownwardAPI { get; set; }

        /// <summary>
        /// EmptyDir represents a temporary directory that shares a pod's lifetime. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        /// </summary>
        [Input("emptyDir")]
        public Input<Core.V1.EmptyDirVolumeSourceArgs>? EmptyDir { get; set; }

        /// <summary>
        /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and
        /// then exposed to the pod.
        /// </summary>
        [Input("fc")]
        public Input<Core.V1.FCVolumeSourceArgs>? Fc { get; set; }

        /// <summary>
        /// FlexVolume represents a generic volume resource that is provisioned/attached using an
        /// exec based plugin.
        /// </summary>
        [Input("flexVolume")]
        public Input<Core.V1.FlexVolumeSourceArgs>? FlexVolume { get; set; }

        /// <summary>
        /// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends
        /// on the Flocker control service being running
        /// </summary>
        [Input("flocker")]
        public Input<Core.V1.FlockerVolumeSourceArgs>? Flocker { get; set; }

        /// <summary>
        /// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host
        /// machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Input("gcePersistentDisk")]
        public Input<Core.V1.GCEPersistentDiskVolumeSourceArgs>? GcePersistentDisk { get; set; }

        /// <summary>
        /// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is
        /// deprecated. To provision a container with a git repo, mount an EmptyDir into an
        /// InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's
        /// container.
        /// </summary>
        [Input("gitRepo")]
        public Input<Core.V1.GitRepoVolumeSourceArgs>? GitRepo { get; set; }

        /// <summary>
        /// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More
        /// info: https://examples.k8s.io/volumes/glusterfs/README.md
        /// </summary>
        [Input("glusterfs")]
        public Input<Core.V1.GlusterfsVolumeSourceArgs>? Glusterfs { get; set; }

        /// <summary>
        /// HostPath represents a pre-existing file or directory on the host machine that is
        /// directly exposed to the container. This is generally used for system agents or other
        /// privileged things that are allowed to see the host machine. Most containers will NOT
        /// need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        [Input("hostPath")]
        public Input<Core.V1.HostPathVolumeSourceArgs>? HostPath { get; set; }

        /// <summary>
        /// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and
        /// then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
        /// </summary>
        [Input("iscsi")]
        public Input<Core.V1.ISCSIVolumeSourceArgs>? Iscsi { get; set; }

        /// <summary>
        /// NFS represents an NFS mount on the host that shares a pod's lifetime More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [Input("nfs")]
        public Input<Core.V1.NFSVolumeSourceArgs>? Nfs { get; set; }

        /// <summary>
        /// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in
        /// the same namespace. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        [Input("persistentVolumeClaim")]
        public Input<Core.V1.PersistentVolumeClaimVolumeSourceArgs>? PersistentVolumeClaim { get; set; }

        /// <summary>
        /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted
        /// on kubelets host machine
        /// </summary>
        [Input("photonPersistentDisk")]
        public Input<Core.V1.PhotonPersistentDiskVolumeSourceArgs>? PhotonPersistentDisk { get; set; }

        /// <summary>
        /// PortworxVolume represents a portworx volume attached and mounted on kubelets host
        /// machine
        /// </summary>
        [Input("portworxVolume")]
        public Input<Core.V1.PortworxVolumeSourceArgs>? PortworxVolume { get; set; }

        /// <summary>
        /// Items for all in one resources secrets, configmaps, and downward API
        /// </summary>
        [Input("projected")]
        public Input<Core.V1.ProjectedVolumeSourceArgs>? Projected { get; set; }

        /// <summary>
        /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        /// </summary>
        [Input("quobyte")]
        public Input<Core.V1.QuobyteVolumeSourceArgs>? Quobyte { get; set; }

        /// <summary>
        /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md
        /// </summary>
        [Input("rbd")]
        public Input<Core.V1.RBDVolumeSourceArgs>? Rbd { get; set; }

        /// <summary>
        /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
        /// </summary>
        [Input("scaleIO")]
        public Input<Core.V1.ScaleIOVolumeSourceArgs>? ScaleIO { get; set; }

        /// <summary>
        /// Secret represents a secret that should populate this volume. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#secret
        /// </summary>
        [Input("secret")]
        public Input<Core.V1.SecretVolumeSourceArgs>? Secret { get; set; }

        /// <summary>
        /// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
        /// </summary>
        [Input("storageos")]
        public Input<Core.V1.StorageOSVolumeSourceArgs>? Storageos { get; set; }

        /// <summary>
        /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
        /// </summary>
        [Input("vsphereVolume")]
        public Input<Core.V1.VsphereVirtualDiskVolumeSourceArgs>? VsphereVolume { get; set; }

    }

    /// <summary>
    /// volumeDevice describes a mapping of a raw block device within a container.
    /// </summary>
    public class VolumeDeviceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// devicePath is the path inside of the container that the device will be mapped to.
        /// </summary>
        [Input("devicePath", required: true)]
        public Input<string> DevicePath { get; set; } = null!;

        /// <summary>
        /// name must match the name of a persistentVolumeClaim in the pod
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// VolumeMount describes a mounting of a Volume within a container.
    /// </summary>
    public class VolumeMountArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Path within the container at which the volume should be mounted.  Must not contain ':'.
        /// </summary>
        [Input("mountPath", required: true)]
        public Input<string> MountPath { get; set; } = null!;

        /// <summary>
        /// This must match the Name of a Volume.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// mountPropagation determines how mounts are propagated from the host to container and the
        /// other way around. When not set, MountPropagationNone is used. This field is beta in
        /// 1.10.
        /// </summary>
        [Input("mountPropagation")]
        public Input<string>? MountPropagation { get; set; }

        /// <summary>
        /// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to
        /// false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Path within the volume from which the container's volume should be mounted. Defaults to
        /// "" (volume's root).
        /// </summary>
        [Input("subPath")]
        public Input<string>? SubPath { get; set; }

        /// <summary>
        /// Expanded path within the volume from which the container's volume should be mounted.
        /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are
        /// expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr
        /// and SubPath are mutually exclusive. This field is beta in 1.15.
        /// </summary>
        [Input("subPathExpr")]
        public Input<string>? SubPathExpr { get; set; }

    }

    /// <summary>
    /// VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed
    /// from.
    /// </summary>
    public class VolumeNodeAffinityArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required specifies hard node constraints that must be met.
        /// </summary>
        [Input("required")]
        public Input<Core.V1.NodeSelectorArgs>? Required { get; set; }

    }

    /// <summary>
    /// Projection that may be projected along with other supported volume types
    /// </summary>
    public class VolumeProjectionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// information about the configMap data to project
        /// </summary>
        [Input("configMap")]
        public Input<Core.V1.ConfigMapProjectionArgs>? ConfigMap { get; set; }

        /// <summary>
        /// information about the downwardAPI data to project
        /// </summary>
        [Input("downwardAPI")]
        public Input<Core.V1.DownwardAPIProjectionArgs>? DownwardAPI { get; set; }

        /// <summary>
        /// information about the secret data to project
        /// </summary>
        [Input("secret")]
        public Input<Core.V1.SecretProjectionArgs>? Secret { get; set; }

        /// <summary>
        /// information about the serviceAccountToken data to project
        /// </summary>
        [Input("serviceAccountToken")]
        public Input<Core.V1.ServiceAccountTokenProjectionArgs>? ServiceAccountToken { get; set; }

    }

    /// <summary>
    /// Represents a vSphere volume resource.
    /// </summary>
    public class VsphereVirtualDiskVolumeSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Path that identifies vSphere volume vmdk
        /// </summary>
        [Input("volumePath", required: true)]
        public Input<string> VolumePath { get; set; } = null!;

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Input("fsType")]
        public Input<string>? FsType { get; set; }

        /// <summary>
        /// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
        /// </summary>
        [Input("storagePolicyID")]
        public Input<string>? StoragePolicyID { get; set; }

        /// <summary>
        /// Storage Policy Based Management (SPBM) profile name.
        /// </summary>
        [Input("storagePolicyName")]
        public Input<string>? StoragePolicyName { get; set; }

    }

    /// <summary>
    /// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find
    /// the most preferred node(s)
    /// </summary>
    public class WeightedPodAffinityTermArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required. A pod affinity term, associated with the corresponding weight.
        /// </summary>
        [Input("podAffinityTerm", required: true)]
        public Input<Core.V1.PodAffinityTermArgs> PodAffinityTerm { get; set; } = null!;

        /// <summary>
        /// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        /// </summary>
        [Input("weight", required: true)]
        public Input<int> Weight { get; set; } = null!;

    }

    /// <summary>
    /// WindowsSecurityContextOptions contain Windows-specific options and credentials.
    /// </summary>
    public class WindowsSecurityContextOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// GMSACredentialSpec is where the GMSA admission webhook
        /// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA
        /// credential spec named by the GMSACredentialSpecName field. This field is alpha-level and
        /// is only honored by servers that enable the WindowsGMSA feature flag.
        /// </summary>
        [Input("gmsaCredentialSpec")]
        public Input<string>? GmsaCredentialSpec { get; set; }

        /// <summary>
        /// GMSACredentialSpecName is the name of the GMSA credential spec to use. This field is
        /// alpha-level and is only honored by servers that enable the WindowsGMSA feature flag.
        /// </summary>
        [Input("gmsaCredentialSpecName")]
        public Input<string>? GmsaCredentialSpecName { get; set; }

        /// <summary>
        /// The UserName in Windows to run the entrypoint of the container process. Defaults to the
        /// user specified in image metadata if unspecified. May also be set in PodSecurityContext.
        /// If set in both SecurityContext and PodSecurityContext, the value specified in
        /// SecurityContext takes precedence. This field is alpha-level and it is only honored by
        /// servers that enable the WindowsRunAsUserName feature flag.
        /// </summary>
        [Input("runAsUserName")]
        public Input<string>? RunAsUserName { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Discovery
{
  namespace V1Alpha1
  {
    /// <summary>
    /// Endpoint represents a single logical "backend" implementing a service.
    /// </summary>
    public class EndpointArgs : Pulumi.ResourceArgs
    {
        [Input("addresses", required: true)]
        private InputList<string>? _addresses;

        /// <summary>
        /// addresses of this endpoint. The contents of this field are interpreted according to the
        /// corresponding EndpointSlice addressType field. This allows for cases like dual-stack
        /// (IPv4 and IPv6) networking. Consumers (e.g. kube-proxy) must handle different types of
        /// addresses in the context of their own capabilities. This must contain at least one
        /// address but no more than 100.
        /// </summary>
        public InputList<string> Addresses
        {
            get => _addresses ?? (_addresses = new InputList<string>());
            set => _addresses = value;
        }

        /// <summary>
        /// conditions contains information about the current status of the endpoint.
        /// </summary>
        [Input("conditions")]
        public Input<Discovery.V1Alpha1.EndpointConditionsArgs>? Conditions { get; set; }

        /// <summary>
        /// hostname of this endpoint. This field may be used by consumers of endpoints to
        /// distinguish endpoints from each other (e.g. in DNS names). Multiple endpoints which use
        /// the same hostname should be considered fungible (e.g. multiple A values in DNS). Must
        /// pass DNS Label (RFC 1123) validation.
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// targetRef is a reference to a Kubernetes object that represents this endpoint.
        /// </summary>
        [Input("targetRef")]
        public Input<Core.V1.ObjectReferenceArgs>? TargetRef { get; set; }

        [Input("topology")]
        private InputMap<string>? _topology;

        /// <summary>
        /// topology contains arbitrary topology information associated with the endpoint. These
        /// key/value pairs must conform with the label format.
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels Topology may
        /// include a maximum of 16 key/value pairs. This includes, but is not limited to the
        /// following well known keys: * kubernetes.io/hostname: the value indicates the hostname of
        /// the node
        ///   where the endpoint is located. This should match the corresponding
        ///   node label.
        /// * topology.kubernetes.io/zone: the value indicates the zone where the
        ///   endpoint is located. This should match the corresponding node label.
        /// * topology.kubernetes.io/region: the value indicates the region where the
        ///   endpoint is located. This should match the corresponding node label.
        /// </summary>
        public InputMap<string> Topology
        {
            get => _topology ?? (_topology = new InputMap<string>());
            set => _topology = value;
        }

    }

    /// <summary>
    /// EndpointConditions represents the current condition of an endpoint.
    /// </summary>
    public class EndpointConditionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// ready indicates that this endpoint is prepared to receive traffic, according to whatever
        /// system is managing the endpoint. A nil value indicates an unknown state. In most cases
        /// consumers should interpret this unknown state as ready.
        /// </summary>
        [Input("ready")]
        public Input<bool>? Ready { get; set; }

    }

    /// <summary>
    /// EndpointPort represents a Port used by an EndpointSlice
    /// </summary>
    public class EndpointPortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The name of this port. All ports in an EndpointSlice must have a unique name. If the
        /// EndpointSlice is dervied from a Kubernetes service, this corresponds to the
        /// Service.ports[].name. Name must either be an empty string or pass IANA_SVC_NAME
        /// validation: * must be no more than 15 characters long * may contain only [-a-z0-9] *
        /// must contain at least one letter [a-z] * it must not start or end with a hyphen, nor
        /// contain adjacent hyphens Default is empty string.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The port number of the endpoint. If this is not specified, ports are not restricted and
        /// must be interpreted in the context of the specific consumer.
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

        /// <summary>
        /// The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// EndpointSlice represents a subset of the endpoints that implement a service. For a given
    /// service there may be multiple EndpointSlice objects, selected by labels, which must be
    /// joined to produce the full set of endpoints.
    /// </summary>
    public class EndpointSliceArgs : Pulumi.ResourceArgs
    {
        [Input("endpoints", required: true)]
        private InputList<Discovery.V1Alpha1.EndpointArgs>? _endpoints;

        /// <summary>
        /// endpoints is a list of unique endpoints in this slice. Each slice may include a maximum
        /// of 1000 endpoints.
        /// </summary>
        public InputList<Discovery.V1Alpha1.EndpointArgs> Endpoints
        {
            get => _endpoints ?? (_endpoints = new InputList<Discovery.V1Alpha1.EndpointArgs>());
            set => _endpoints = value;
        }

        /// <summary>
        /// addressType specifies the type of address carried by this EndpointSlice. All addresses
        /// in this slice must be the same type. Default is IP
        /// </summary>
        [Input("addressType")]
        public Input<string>? AddressType { get; set; }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("ports")]
        private InputList<Discovery.V1Alpha1.EndpointPortArgs>? _ports;

        /// <summary>
        /// ports specifies the list of network ports exposed by each endpoint in this slice. Each
        /// port must have a unique name. When ports is empty, it indicates that there are no
        /// defined ports. When a port is defined with a nil port value, it indicates "all ports".
        /// Each slice may include a maximum of 100 ports.
        /// </summary>
        public InputList<Discovery.V1Alpha1.EndpointPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Discovery.V1Alpha1.EndpointPortArgs>());
            set => _ports = value;
        }

    }

    /// <summary>
    /// EndpointSliceList represents a list of endpoint slices
    /// </summary>
    public class EndpointSliceListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Discovery.V1Alpha1.EndpointSliceArgs>? _items;

        /// <summary>
        /// List of endpoint slices
        /// </summary>
        public InputList<Discovery.V1Alpha1.EndpointSliceArgs> Items
        {
            get => _items ?? (_items = new InputList<Discovery.V1Alpha1.EndpointSliceArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Events
{
  namespace V1Beta1
  {
    /// <summary>
    /// Event is a report of an event somewhere in the cluster. It generally denotes some state
    /// change in the system.
    /// </summary>
    public class EventArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required. Time when this Event was first observed.
        /// </summary>
        [Input("eventTime", required: true)]
        public Input<string> EventTime { get; set; } = null!;

        /// <summary>
        /// What action was taken/failed regarding to the regarding object.
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
        [Input("deprecatedCount")]
        public Input<int>? DeprecatedCount { get; set; }

        /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
        [Input("deprecatedFirstTimestamp")]
        public Input<string>? DeprecatedFirstTimestamp { get; set; }

        /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
        [Input("deprecatedLastTimestamp")]
        public Input<string>? DeprecatedLastTimestamp { get; set; }

        /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
        [Input("deprecatedSource")]
        public Input<Core.V1.EventSourceArgs>? DeprecatedSource { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Optional. A human-readable description of the status of this operation. Maximal length
        /// of the note is 1kB, but libraries should be prepared to handle values up to 64kB.
        /// </summary>
        [Input("note")]
        public Input<string>? Note { get; set; }

        /// <summary>
        /// Why the action was taken.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

        /// <summary>
        /// The object this Event is about. In most cases it's an Object reporting controller
        /// implements. E.g. ReplicaSetController implements ReplicaSets and this event is emitted
        /// because it acts on some changes in a ReplicaSet object.
        /// </summary>
        [Input("regarding")]
        public Input<Core.V1.ObjectReferenceArgs>? Regarding { get; set; }

        /// <summary>
        /// Optional secondary object for more complex actions. E.g. when regarding object triggers
        /// a creation or deletion of related object.
        /// </summary>
        [Input("related")]
        public Input<Core.V1.ObjectReferenceArgs>? Related { get; set; }

        /// <summary>
        /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
        /// </summary>
        [Input("reportingController")]
        public Input<string>? ReportingController { get; set; }

        /// <summary>
        /// ID of the controller instance, e.g. `kubelet-xyzf`.
        /// </summary>
        [Input("reportingInstance")]
        public Input<string>? ReportingInstance { get; set; }

        /// <summary>
        /// Data about the Event series this event represents or nil if it's a singleton Event.
        /// </summary>
        [Input("series")]
        public Input<Events.V1Beta1.EventSeriesArgs>? Series { get; set; }

        /// <summary>
        /// Type of this event (Normal, Warning), new types could be added in the future.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// EventList is a list of Event objects.
    /// </summary>
    public class EventListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Events.V1Beta1.EventArgs>? _items;

        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public InputList<Events.V1Beta1.EventArgs> Items
        {
            get => _items ?? (_items = new InputList<Events.V1Beta1.EventArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// EventSeries contain information on series of events, i.e. thing that was/is happening
    /// continuously for some time.
    /// </summary>
    public class EventSeriesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Number of occurrences in this series up to the last heartbeat time
        /// </summary>
        [Input("count", required: true)]
        public Input<int> Count { get; set; } = null!;

        /// <summary>
        /// Time when last Event from the series was seen before last heartbeat.
        /// </summary>
        [Input("lastObservedTime", required: true)]
        public Input<string> LastObservedTime { get; set; } = null!;

        /// <summary>
        /// Information whether this series is ongoing or finished. Deprecated. Planned removal for
        /// 1.18
        /// </summary>
        [Input("state", required: true)]
        public Input<string> State { get; set; } = null!;

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Extensions
{
  namespace V1Beta1
  {
    /// <summary>
    /// AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
    /// </summary>
    public class AllowedCSIDriverArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name is the registered name of the CSI driver
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// AllowedFlexVolume represents a single Flexvolume that is allowed to be used. Deprecated: use
    /// AllowedFlexVolume from policy API Group instead.
    /// </summary>
    public class AllowedFlexVolumeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// driver is the name of the Flexvolume driver.
        /// </summary>
        [Input("driver", required: true)]
        public Input<string> Driver { get; set; } = null!;

    }

    /// <summary>
    /// AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods
    /// to use. It requires the path prefix to be defined. Deprecated: use AllowedHostPath from
    /// policy API Group instead.
    /// </summary>
    public class AllowedHostPathArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// pathPrefix is the path prefix that the host volume must match. It does not support `*`.
        /// Trailing slashes are trimmed when validating the path prefix with a host path.
        /// 
        /// Examples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo` would not allow
        /// `/food` or `/etc/foo`
        /// </summary>
        [Input("pathPrefix")]
        public Input<string>? PathPrefix { get; set; }

        /// <summary>
        /// when set to true, will allow host volumes matching the pathPrefix only if all volume
        /// mounts are readOnly.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// DEPRECATED - extensions/v1beta1/DaemonSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/DaemonSet instead.
    /// 
    /// DaemonSet represents the configuration of a daemon set.
    /// </summary>
    public class DaemonSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// The desired behavior of this daemon set. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Extensions.V1Beta1.DaemonSetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// DaemonSetCondition describes the state of a DaemonSet at a certain point.
    /// </summary>
    public class DaemonSetConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of DaemonSet condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DaemonSetList is a collection of daemon sets.
    /// </summary>
    public class DaemonSetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Extensions.V1Beta1.DaemonSetArgs>? _items;

        /// <summary>
        /// A list of daemon sets.
        /// </summary>
        public InputList<Extensions.V1Beta1.DaemonSetArgs> Items
        {
            get => _items ?? (_items = new InputList<Extensions.V1Beta1.DaemonSetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DaemonSetSpec is the specification of a daemon set.
    /// </summary>
    public class DaemonSetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// An object that describes the pod that will be created. The DaemonSet will create exactly
        /// one copy of this pod on every node that matches the template's node selector (or on
        /// every node if no node selector is specified). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// The minimum number of seconds for which a newly created DaemonSet pod should be ready
        /// without any of its container crashing, for it to be considered available. Defaults to 0
        /// (pod will be considered available as soon as it is ready).
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// The number of old history to retain to allow rollback. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 10.
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// A label query over pods that are managed by the daemon set. Must match in order to be
        /// controlled. If empty, defaulted to labels on Pod template. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

        /// <summary>
        /// DEPRECATED. A sequence number representing a specific generation of the template.
        /// Populated by the system. It can be set only during the creation.
        /// </summary>
        [Input("templateGeneration")]
        public Input<int>? TemplateGeneration { get; set; }

        /// <summary>
        /// An update strategy to replace existing DaemonSet pods with new pods.
        /// </summary>
        [Input("updateStrategy")]
        public Input<Extensions.V1Beta1.DaemonSetUpdateStrategyArgs>? UpdateStrategy { get; set; }

    }

    /// <summary>
    /// DaemonSetStatus represents the current status of a daemon set.
    /// </summary>
    public class DaemonSetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The number of nodes that are running at least 1 daemon pod and are supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        [Input("currentNumberScheduled", required: true)]
        public Input<int> CurrentNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The total number of nodes that should be running the daemon pod (including nodes
        /// correctly running the daemon pod). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        [Input("desiredNumberScheduled", required: true)]
        public Input<int> DesiredNumberScheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that are running the daemon pod, but are not supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
        [Input("numberMisscheduled", required: true)]
        public Input<int> NumberMisscheduled { get; set; } = null!;

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and ready.
        /// </summary>
        [Input("numberReady", required: true)]
        public Input<int> NumberReady { get; set; } = null!;

        /// <summary>
        /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as
        /// a collision avoidance mechanism when it needs to create the name for the newest
        /// ControllerRevision.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Extensions.V1Beta1.DaemonSetConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a DaemonSet's current state.
        /// </summary>
        public InputList<Extensions.V1Beta1.DaemonSetConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Extensions.V1Beta1.DaemonSetConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        [Input("numberAvailable")]
        public Input<int>? NumberAvailable { get; set; }

        /// <summary>
        /// The number of nodes that should be running the daemon pod and have none of the daemon
        /// pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
        [Input("numberUnavailable")]
        public Input<int>? NumberUnavailable { get; set; }

        /// <summary>
        /// The most recent generation observed by the daemon set controller.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The total number of nodes that are running updated daemon pod
        /// </summary>
        [Input("updatedNumberScheduled")]
        public Input<int>? UpdatedNumberScheduled { get; set; }

    }

    /// <summary>
    /// 
    /// </summary>
    public class DaemonSetUpdateStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Rolling update config params. Present only if type = "RollingUpdate".
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Extensions.V1Beta1.RollingUpdateDaemonSetArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is OnDelete.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// DEPRECATED - extensions/v1beta1/Deployment is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/Deployment instead.
    /// 
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    public class DeploymentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
        [Input("spec")]
        public Input<Extensions.V1Beta1.DeploymentSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    public class DeploymentConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of deployment condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// The last time this condition was updated.
        /// </summary>
        [Input("lastUpdateTime")]
        public Input<string>? LastUpdateTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    public class DeploymentListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Extensions.V1Beta1.DeploymentArgs>? _items;

        /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
        public InputList<Extensions.V1Beta1.DeploymentArgs> Items
        {
            get => _items ?? (_items = new InputList<Extensions.V1Beta1.DeploymentArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
    /// </summary>
    public class DeploymentRollbackArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required: This must match the Name of a deployment.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// The config of this deployment rollback.
        /// </summary>
        [Input("rollbackTo", required: true)]
        public Input<Extensions.V1Beta1.RollbackConfigArgs> RollbackTo { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        [Input("updatedAnnotations")]
        private InputMap<string>? _updatedAnnotations;

        /// <summary>
        /// The annotations to be updated to a deployment
        /// </summary>
        public InputMap<string> UpdatedAnnotations
        {
            get => _updatedAnnotations ?? (_updatedAnnotations = new InputMap<string>());
            set => _updatedAnnotations = value;
        }

    }

    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    public class DeploymentSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
        [Input("template", required: true)]
        public Input<Core.V1.PodTemplateSpecArgs> Template { get; set; } = null!;

        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Indicates that the deployment is paused and will not be processed by the deployment
        /// controller.
        /// </summary>
        [Input("paused")]
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// This is set to the max value of int32 (i.e. 2147483647) by default, which means "no
        /// deadline".
        /// </summary>
        [Input("progressDeadlineSeconds")]
        public Input<int>? ProgressDeadlineSeconds { get; set; }

        /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. This is set to the max value of
        /// int32 (i.e. 2147483647) by default, which means "retaining all old RelicaSets".
        /// </summary>
        [Input("revisionHistoryLimit")]
        public Input<int>? RevisionHistoryLimit { get; set; }

        /// <summary>
        /// DEPRECATED. The config this deployment is rolling back to. Will be cleared after
        /// rollback is done.
        /// </summary>
        [Input("rollbackTo")]
        public Input<Extensions.V1Beta1.RollbackConfigArgs>? RollbackTo { get; set; }

        /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

        /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
        [Input("strategy")]
        public Input<Extensions.V1Beta1.DeploymentStrategyArgs>? Strategy { get; set; }

    }

    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    public class DeploymentStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
        [Input("availableReplicas")]
        public Input<int>? AvailableReplicas { get; set; }

        /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
        [Input("collisionCount")]
        public Input<int>? CollisionCount { get; set; }

        [Input("conditions")]
        private InputList<Extensions.V1Beta1.DeploymentConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
        public InputList<Extensions.V1Beta1.DeploymentConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Extensions.V1Beta1.DeploymentConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
        [Input("unavailableReplicas")]
        public Input<int>? UnavailableReplicas { get; set; }

        /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
        [Input("updatedReplicas")]
        public Input<int>? UpdatedReplicas { get; set; }

    }

    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    public class DeploymentStrategyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
        [Input("rollingUpdate")]
        public Input<Extensions.V1Beta1.RollingUpdateDeploymentArgs>? RollingUpdate { get; set; }

        /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

    }

    /// <summary>
    /// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
    /// Deprecated: use FSGroupStrategyOptions from policy API Group instead.
    /// </summary>
    public class FSGroupStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        [Input("ranges")]
        private InputList<Extensions.V1Beta1.IDRangeArgs>? _ranges;

        /// <summary>
        /// ranges are the allowed ranges of fs groups.  If you would like to force a single fs
        /// group then supply a single range with the same start and end. Required for MustRunAs.
        /// </summary>
        public InputList<Extensions.V1Beta1.IDRangeArgs> Ranges
        {
            get => _ranges ?? (_ranges = new InputList<Extensions.V1Beta1.IDRangeArgs>());
            set => _ranges = value;
        }

        /// <summary>
        /// rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
        /// </summary>
        [Input("rule")]
        public Input<string>? Rule { get; set; }

    }

    /// <summary>
    /// HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are
    /// forwarded to the backend.
    /// </summary>
    public class HTTPIngressPathArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Backend defines the referenced service endpoint to which the traffic will be forwarded
        /// to.
        /// </summary>
        [Input("backend", required: true)]
        public Input<Extensions.V1Beta1.IngressBackendArgs> Backend { get; set; } = null!;

        /// <summary>
        /// Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the
        /// egrep/unix syntax, not the perl syntax) matched against the path of an incoming request.
        /// Currently it can contain characters disallowed from the conventional "path" part of a
        /// URL as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path
        /// defaults to a catch all sending traffic to the backend.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

    }

    /// <summary>
    /// HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example:
    /// http://&amp;lt;host&amp;gt;/&amp;lt;path&amp;gt;?&amp;lt;searchpart&amp;gt; -&amp;gt;
    /// backend where where parts of the url correspond to RFC 3986, this resource will be used to
    /// match against everything after the last '/' and before the first '?' or '#'.
    /// </summary>
    public class HTTPIngressRuleValueArgs : Pulumi.ResourceArgs
    {
        [Input("paths", required: true)]
        private InputList<Extensions.V1Beta1.HTTPIngressPathArgs>? _paths;

        /// <summary>
        /// A collection of paths that map requests to backends.
        /// </summary>
        public InputList<Extensions.V1Beta1.HTTPIngressPathArgs> Paths
        {
            get => _paths ?? (_paths = new InputList<Extensions.V1Beta1.HTTPIngressPathArgs>());
            set => _paths = value;
        }

    }

    /// <summary>
    /// HostPortRange defines a range of host ports that will be enabled by a policy for pods to
    /// use.  It requires both the start and end to be defined. Deprecated: use HostPortRange from
    /// policy API Group instead.
    /// </summary>
    public class HostPortRangeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
        [Input("max", required: true)]
        public Input<int> Max { get; set; } = null!;

        /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
        [Input("min", required: true)]
        public Input<int> Min { get; set; } = null!;

    }

    /// <summary>
    /// IDRange provides a min/max of an allowed range of IDs. Deprecated: use IDRange from policy
    /// API Group instead.
    /// </summary>
    public class IDRangeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
        [Input("max", required: true)]
        public Input<int> Max { get; set; } = null!;

        /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
        [Input("min", required: true)]
        public Input<int> Min { get; set; } = null!;

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of IPBlock is deprecated by networking/v1/IPBlock.
    /// IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
    /// matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
    /// not be included within this rule.
    /// </summary>
    public class IPBlockArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24"
        /// </summary>
        [Input("cidr", required: true)]
        public Input<string> Cidr { get; set; } = null!;

        [Input("except")]
        private InputList<string>? _except;

        /// <summary>
        /// Except is a slice of CIDRs that should not be included within an IP Block Valid examples
        /// are "192.168.1.1/24" Except values will be rejected if they are outside the CIDR range
        /// </summary>
        public InputList<string> Except
        {
            get => _except ?? (_except = new InputList<string>());
            set => _except = value;
        }

    }

    /// <summary>
    /// DEPRECATED - extensions/v1beta1/Ingress is not supported by Kubernetes 1.16+ clusters. Use
    /// networking/v1beta1/Ingress instead.
    /// 
    /// Ingress is a collection of rules that allow inbound connections to reach the endpoints
    /// defined by a backend. An Ingress can be configured to give services externally-reachable
    /// urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. 
    /// </summary>
    public class IngressArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec is the desired state of the Ingress. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Extensions.V1Beta1.IngressSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// IngressBackend describes all endpoints for a given service and port.
    /// </summary>
    public class IngressBackendArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specifies the name of the referenced service.
        /// </summary>
        [Input("serviceName", required: true)]
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// Specifies the port of the referenced service.
        /// </summary>
        [Input("servicePort", required: true)]
        public InputUnion<int,string> ServicePort { get; set; } = null!;

    }

    /// <summary>
    /// IngressList is a collection of Ingress.
    /// </summary>
    public class IngressListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Extensions.V1Beta1.IngressArgs>? _items;

        /// <summary>
        /// Items is the list of Ingress.
        /// </summary>
        public InputList<Extensions.V1Beta1.IngressArgs> Items
        {
            get => _items ?? (_items = new InputList<Extensions.V1Beta1.IngressArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// IngressRule represents the rules mapping the paths under a specified host to the related
    /// backend services. Incoming requests are first evaluated for a host match, then routed to the
    /// backend associated with the matching IngressRuleValue.
    /// </summary>
    public class IngressRuleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note
        /// the following deviations from the "host" part of the URI as defined in the RFC: 1. IPs
        /// are not allowed. Currently an IngressRuleValue can only apply to the
        /// 	  IP in the Spec of the parent Ingress.
        /// 2. The `:` delimiter is not respected because ports are not allowed.
        /// 	  Currently the port of an Ingress is implicitly :80 for http and
        /// 	  :443 for https.
        /// Both these may change in the future. Incoming requests are matched against the host
        /// before the IngressRuleValue. If the host is unspecified, the Ingress routes all traffic
        /// based on the specified IngressRuleValue.
        /// </summary>
        [Input("host")]
        public Input<string>? Host { get; set; }

        
        [Input("http")]
        public Input<Extensions.V1Beta1.HTTPIngressRuleValueArgs>? Http { get; set; }

    }

    /// <summary>
    /// IngressSpec describes the Ingress the user wishes to exist.
    /// </summary>
    public class IngressSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A default backend capable of servicing requests that don't match any rule. At least one
        /// of 'backend' or 'rules' must be specified. This field is optional to allow the
        /// loadbalancer controller or defaulting logic to specify a global default.
        /// </summary>
        [Input("backend")]
        public Input<Extensions.V1Beta1.IngressBackendArgs>? Backend { get; set; }

        [Input("rules")]
        private InputList<Extensions.V1Beta1.IngressRuleArgs>? _rules;

        /// <summary>
        /// A list of host rules used to configure the Ingress. If unspecified, or no rule matches,
        /// all traffic is sent to the default backend.
        /// </summary>
        public InputList<Extensions.V1Beta1.IngressRuleArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<Extensions.V1Beta1.IngressRuleArgs>());
            set => _rules = value;
        }

        [Input("tls")]
        private InputList<Extensions.V1Beta1.IngressTLSArgs>? _tls;

        /// <summary>
        /// TLS configuration. Currently the Ingress only supports a single TLS port, 443. If
        /// multiple members of this list specify different hosts, they will be multiplexed on the
        /// same port according to the hostname specified through the SNI TLS extension, if the
        /// ingress controller fulfilling the ingress supports SNI.
        /// </summary>
        public InputList<Extensions.V1Beta1.IngressTLSArgs> Tls
        {
            get => _tls ?? (_tls = new InputList<Extensions.V1Beta1.IngressTLSArgs>());
            set => _tls = value;
        }

    }

    /// <summary>
    /// IngressStatus describe the current state of the Ingress.
    /// </summary>
    public class IngressStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// LoadBalancer contains the current status of the load-balancer.
        /// </summary>
        [Input("loadBalancer")]
        public Input<Core.V1.LoadBalancerStatusArgs>? LoadBalancer { get; set; }

    }

    /// <summary>
    /// IngressTLS describes the transport layer security associated with an Ingress.
    /// </summary>
    public class IngressTLSArgs : Pulumi.ResourceArgs
    {
        [Input("hosts")]
        private InputList<string>? _hosts;

        /// <summary>
        /// Hosts are a list of hosts included in the TLS certificate. The values in this list must
        /// match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the
        /// loadbalancer controller fulfilling this Ingress, if left unspecified.
        /// </summary>
        public InputList<string> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<string>());
            set => _hosts = value;
        }

        /// <summary>
        /// SecretName is the name of the secret used to terminate SSL traffic on 443. Field is left
        /// optional to allow SSL routing based on SNI hostname alone. If the SNI host in a listener
        /// conflicts with the "Host" header field used by an IngressRule, the SNI host is used for
        /// termination and value of the Host header is used for routing.
        /// </summary>
        [Input("secretName")]
        public Input<string>? SecretName { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by
    /// networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a
    /// set of Pods
    /// </summary>
    public class NetworkPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior for this NetworkPolicy.
        /// </summary>
        [Input("spec")]
        public Input<Extensions.V1Beta1.NetworkPolicySpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyEgressRule is deprecated by
    /// networking/v1/NetworkPolicyEgressRule. NetworkPolicyEgressRule describes a particular set of
    /// traffic that is allowed out of pods matched by a NetworkPolicySpec's podSelector. The
    /// traffic must match both ports and to. This type is beta-level in 1.8
    /// </summary>
    public class NetworkPolicyEgressRuleArgs : Pulumi.ResourceArgs
    {
        [Input("ports")]
        private InputList<Extensions.V1Beta1.NetworkPolicyPortArgs>? _ports;

        /// <summary>
        /// List of destination ports for outgoing traffic. Each item in this list is combined using
        /// a logical OR. If this field is empty or missing, this rule matches all ports (traffic
        /// not restricted by port). If this field is present and contains at least one item, then
        /// this rule allows traffic only if the traffic matches at least one port in the list.
        /// </summary>
        public InputList<Extensions.V1Beta1.NetworkPolicyPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Extensions.V1Beta1.NetworkPolicyPortArgs>());
            set => _ports = value;
        }

        [Input("to")]
        private InputList<Extensions.V1Beta1.NetworkPolicyPeerArgs>? _to;

        /// <summary>
        /// List of destinations for outgoing traffic of pods selected for this rule. Items in this
        /// list are combined using a logical OR operation. If this field is empty or missing, this
        /// rule matches all destinations (traffic not restricted by destination). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the to list.
        /// </summary>
        public InputList<Extensions.V1Beta1.NetworkPolicyPeerArgs> To
        {
            get => _to ?? (_to = new InputList<Extensions.V1Beta1.NetworkPolicyPeerArgs>());
            set => _to = value;
        }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyIngressRule is deprecated by
    /// networking/v1/NetworkPolicyIngressRule. This NetworkPolicyIngressRule matches traffic if and
    /// only if the traffic matches both ports AND from.
    /// </summary>
    public class NetworkPolicyIngressRuleArgs : Pulumi.ResourceArgs
    {
        [Input("from")]
        private InputList<Extensions.V1Beta1.NetworkPolicyPeerArgs>? _from;

        /// <summary>
        /// List of sources which should be able to access the pods selected for this rule. Items in
        /// this list are combined using a logical OR operation. If this field is empty or missing,
        /// this rule matches all sources (traffic not restricted by source). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the from list.
        /// </summary>
        public InputList<Extensions.V1Beta1.NetworkPolicyPeerArgs> From
        {
            get => _from ?? (_from = new InputList<Extensions.V1Beta1.NetworkPolicyPeerArgs>());
            set => _from = value;
        }

        [Input("ports")]
        private InputList<Extensions.V1Beta1.NetworkPolicyPortArgs>? _ports;

        /// <summary>
        /// List of ports which should be made accessible on the pods selected for this rule. Each
        /// item in this list is combined using a logical OR. If this field is empty or missing,
        /// this rule matches all ports (traffic not restricted by port). If this field is present
        /// and contains at least one item, then this rule allows traffic only if the traffic
        /// matches at least one port in the list.
        /// </summary>
        public InputList<Extensions.V1Beta1.NetworkPolicyPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Extensions.V1Beta1.NetworkPolicyPortArgs>());
            set => _ports = value;
        }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyList is deprecated by
    /// networking/v1/NetworkPolicyList. Network Policy List is a list of NetworkPolicy objects.
    /// </summary>
    public class NetworkPolicyListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Extensions.V1Beta1.NetworkPolicyArgs>? _items;

        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public InputList<Extensions.V1Beta1.NetworkPolicyArgs> Items
        {
            get => _items ?? (_items = new InputList<Extensions.V1Beta1.NetworkPolicyArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyPeer is deprecated by
    /// networking/v1/NetworkPolicyPeer.
    /// </summary>
    public class NetworkPolicyPeerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// IPBlock defines policy on a particular IPBlock. If this field is set then neither of the
        /// other fields can be.
        /// </summary>
        [Input("ipBlock")]
        public Input<Extensions.V1Beta1.IPBlockArgs>? IpBlock { get; set; }

        /// <summary>
        /// Selects Namespaces using cluster-scoped labels. This field follows standard label
        /// selector semantics; if present but empty, it selects all namespaces.
        /// 
        /// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects all Pods in the Namespaces selected by NamespaceSelector.
        /// </summary>
        [Input("namespaceSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? NamespaceSelector { get; set; }

        /// <summary>
        /// This is a label selector which selects Pods. This field follows standard label selector
        /// semantics; if present but empty, it selects all pods.
        /// 
        /// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects the Pods matching PodSelector in the policy's own Namespace.
        /// </summary>
        [Input("podSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? PodSelector { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyPort is deprecated by
    /// networking/v1/NetworkPolicyPort.
    /// </summary>
    public class NetworkPolicyPortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// If specified, the port on the given protocol.  This can either be a numerical or named
        /// port on a pod.  If this field is not provided, this matches all port names and numbers.
        /// If present, only traffic on the specified protocol AND port will be matched.
        /// </summary>
        [Input("port")]
        public InputUnion<int,string>? Port { get; set; }

        /// <summary>
        /// Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified,
        /// this field defaults to TCP.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicySpec is deprecated by
    /// networking/v1/NetworkPolicySpec.
    /// </summary>
    public class NetworkPolicySpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
        /// is applied to any pods selected by this field. Multiple network policies can select the
        /// same set of pods.  In this case, the ingress rules for each are combined additively.
        /// This field is NOT optional and follows standard label selector semantics. An empty
        /// podSelector matches all pods in this namespace.
        /// </summary>
        [Input("podSelector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> PodSelector { get; set; } = null!;

        [Input("egress")]
        private InputList<Extensions.V1Beta1.NetworkPolicyEgressRuleArgs>? _egress;

        /// <summary>
        /// List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if
        /// there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
        /// traffic), OR if the traffic matches at least one egress rule across all of the
        /// NetworkPolicy objects whose podSelector matches the pod. If this field is empty then
        /// this NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the
        /// pods it selects are isolated by default). This field is beta-level in 1.8
        /// </summary>
        public InputList<Extensions.V1Beta1.NetworkPolicyEgressRuleArgs> Egress
        {
            get => _egress ?? (_egress = new InputList<Extensions.V1Beta1.NetworkPolicyEgressRuleArgs>());
            set => _egress = value;
        }

        [Input("ingress")]
        private InputList<Extensions.V1Beta1.NetworkPolicyIngressRuleArgs>? _ingress;

        /// <summary>
        /// List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if
        /// there are no NetworkPolicies selecting the pod OR if the traffic source is the pod's
        /// local node, OR if the traffic matches at least one ingress rule across all of the
        /// NetworkPolicy objects whose podSelector matches the pod. If this field is empty then
        /// this NetworkPolicy does not allow any traffic (and serves solely to ensure that the pods
        /// it selects are isolated by default).
        /// </summary>
        public InputList<Extensions.V1Beta1.NetworkPolicyIngressRuleArgs> Ingress
        {
            get => _ingress ?? (_ingress = new InputList<Extensions.V1Beta1.NetworkPolicyIngressRuleArgs>());
            set => _ingress = value;
        }

        [Input("policyTypes")]
        private InputList<string>? _policyTypes;

        /// <summary>
        /// List of rule types that the NetworkPolicy relates to. Valid options are "Ingress",
        /// "Egress", or "Ingress,Egress". If this field is not specified, it will default based on
        /// the existence of Ingress or Egress rules; policies that contain an Egress section are
        /// assumed to affect Egress, and all policies (whether or not they contain an Ingress
        /// section) are assumed to affect Ingress. If you want to write an egress-only policy, you
        /// must explicitly specify policyTypes [ "Egress" ]. Likewise, if you want to write a
        /// policy that specifies that no egress is allowed, you must specify a policyTypes value
        /// that include "Egress" (since such a policy would not include an Egress section and would
        /// otherwise default to just [ "Ingress" ]). This field is beta-level in 1.8
        /// </summary>
        public InputList<string> PolicyTypes
        {
            get => _policyTypes ?? (_policyTypes = new InputList<string>());
            set => _policyTypes = value;
        }

    }

    /// <summary>
    /// PodSecurityPolicy governs the ability to make requests that affect the Security Context that
    /// will be applied to a pod and container. Deprecated: use PodSecurityPolicy from policy API
    /// Group instead.
    /// </summary>
    public class PodSecurityPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// spec defines the policy enforced.
        /// </summary>
        [Input("spec")]
        public Input<Extensions.V1Beta1.PodSecurityPolicySpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicyList is a list of PodSecurityPolicy objects. Deprecated: use
    /// PodSecurityPolicyList from policy API Group instead.
    /// </summary>
    public class PodSecurityPolicyListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Extensions.V1Beta1.PodSecurityPolicyArgs>? _items;

        /// <summary>
        /// items is a list of schema objects.
        /// </summary>
        public InputList<Extensions.V1Beta1.PodSecurityPolicyArgs> Items
        {
            get => _items ?? (_items = new InputList<Extensions.V1Beta1.PodSecurityPolicyArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicySpec defines the policy enforced. Deprecated: use PodSecurityPolicySpec
    /// from policy API Group instead.
    /// </summary>
    public class PodSecurityPolicySpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
        [Input("fsGroup", required: true)]
        public Input<Extensions.V1Beta1.FSGroupStrategyOptionsArgs> FsGroup { get; set; } = null!;

        /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be
        /// set.
        /// </summary>
        [Input("runAsUser", required: true)]
        public Input<Extensions.V1Beta1.RunAsUserStrategyOptionsArgs> RunAsUser { get; set; } = null!;

        /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        [Input("seLinux", required: true)]
        public Input<Extensions.V1Beta1.SELinuxStrategyOptionsArgs> SeLinux { get; set; } = null!;

        /// <summary>
        /// supplementalGroups is the strategy that will dictate what supplemental groups are used
        /// by the SecurityContext.
        /// </summary>
        [Input("supplementalGroups", required: true)]
        public Input<Extensions.V1Beta1.SupplementalGroupsStrategyOptionsArgs> SupplementalGroups { get; set; } = null!;

        /// <summary>
        /// allowPrivilegeEscalation determines if a pod can request to allow privilege escalation.
        /// If unspecified, defaults to true.
        /// </summary>
        [Input("allowPrivilegeEscalation")]
        public Input<bool>? AllowPrivilegeEscalation { get; set; }

        [Input("allowedCSIDrivers")]
        private InputList<Extensions.V1Beta1.AllowedCSIDriverArgs>? _allowedCSIDrivers;

        /// <summary>
        /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be
        /// embedded within a pod spec. An empty value indicates that any CSI driver can be used for
        /// inline ephemeral volumes.
        /// </summary>
        public InputList<Extensions.V1Beta1.AllowedCSIDriverArgs> AllowedCSIDrivers
        {
            get => _allowedCSIDrivers ?? (_allowedCSIDrivers = new InputList<Extensions.V1Beta1.AllowedCSIDriverArgs>());
            set => _allowedCSIDrivers = value;
        }

        [Input("allowedCapabilities")]
        private InputList<string>? _allowedCapabilities;

        /// <summary>
        /// allowedCapabilities is a list of capabilities that can be requested to add to the
        /// container. Capabilities in this field may be added at the pod author's discretion. You
        /// must not list a capability in both allowedCapabilities and requiredDropCapabilities.
        /// </summary>
        public InputList<string> AllowedCapabilities
        {
            get => _allowedCapabilities ?? (_allowedCapabilities = new InputList<string>());
            set => _allowedCapabilities = value;
        }

        [Input("allowedFlexVolumes")]
        private InputList<Extensions.V1Beta1.AllowedFlexVolumeArgs>? _allowedFlexVolumes;

        /// <summary>
        /// allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that
        /// all Flexvolumes may be used.  This parameter is effective only when the usage of the
        /// Flexvolumes is allowed in the "volumes" field.
        /// </summary>
        public InputList<Extensions.V1Beta1.AllowedFlexVolumeArgs> AllowedFlexVolumes
        {
            get => _allowedFlexVolumes ?? (_allowedFlexVolumes = new InputList<Extensions.V1Beta1.AllowedFlexVolumeArgs>());
            set => _allowedFlexVolumes = value;
        }

        [Input("allowedHostPaths")]
        private InputList<Extensions.V1Beta1.AllowedHostPathArgs>? _allowedHostPaths;

        /// <summary>
        /// allowedHostPaths is a white list of allowed host paths. Empty indicates that all host
        /// paths may be used.
        /// </summary>
        public InputList<Extensions.V1Beta1.AllowedHostPathArgs> AllowedHostPaths
        {
            get => _allowedHostPaths ?? (_allowedHostPaths = new InputList<Extensions.V1Beta1.AllowedHostPathArgs>());
            set => _allowedHostPaths = value;
        }

        [Input("allowedProcMountTypes")]
        private InputList<string>? _allowedProcMountTypes;

        /// <summary>
        /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates
        /// that only the DefaultProcMountType may be used. This requires the ProcMountType feature
        /// flag to be enabled.
        /// </summary>
        public InputList<string> AllowedProcMountTypes
        {
            get => _allowedProcMountTypes ?? (_allowedProcMountTypes = new InputList<string>());
            set => _allowedProcMountTypes = value;
        }

        [Input("allowedUnsafeSysctls")]
        private InputList<string>? _allowedUnsafeSysctls;

        /// <summary>
        /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
        /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
        /// as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet
        /// has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
        /// 
        /// Examples: e.g. "foo/*" allows "foo/bar", "foo/baz", etc. e.g. "foo.*" allows "foo.bar",
        /// "foo.baz", etc.
        /// </summary>
        public InputList<string> AllowedUnsafeSysctls
        {
            get => _allowedUnsafeSysctls ?? (_allowedUnsafeSysctls = new InputList<string>());
            set => _allowedUnsafeSysctls = value;
        }

        [Input("defaultAddCapabilities")]
        private InputList<string>? _defaultAddCapabilities;

        /// <summary>
        /// defaultAddCapabilities is the default set of capabilities that will be added to the
        /// container unless the pod spec specifically drops the capability.  You may not list a
        /// capability in both defaultAddCapabilities and requiredDropCapabilities. Capabilities
        /// added here are implicitly allowed, and need not be included in the allowedCapabilities
        /// list.
        /// </summary>
        public InputList<string> DefaultAddCapabilities
        {
            get => _defaultAddCapabilities ?? (_defaultAddCapabilities = new InputList<string>());
            set => _defaultAddCapabilities = value;
        }

        /// <summary>
        /// defaultAllowPrivilegeEscalation controls the default setting for whether a process can
        /// gain more privileges than its parent process.
        /// </summary>
        [Input("defaultAllowPrivilegeEscalation")]
        public Input<bool>? DefaultAllowPrivilegeEscalation { get; set; }

        [Input("forbiddenSysctls")]
        private InputList<string>? _forbiddenSysctls;

        /// <summary>
        /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry
        /// is either a plain sysctl name or ends in "*" in which case it is considered as a prefix
        /// of forbidden sysctls. Single * means all sysctls are forbidden.
        /// 
        /// Examples: e.g. "foo/*" forbids "foo/bar", "foo/baz", etc. e.g. "foo.*" forbids
        /// "foo.bar", "foo.baz", etc.
        /// </summary>
        public InputList<string> ForbiddenSysctls
        {
            get => _forbiddenSysctls ?? (_forbiddenSysctls = new InputList<string>());
            set => _forbiddenSysctls = value;
        }

        /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
        [Input("hostIPC")]
        public Input<bool>? HostIPC { get; set; }

        /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
        [Input("hostNetwork")]
        public Input<bool>? HostNetwork { get; set; }

        /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
        [Input("hostPID")]
        public Input<bool>? HostPID { get; set; }

        [Input("hostPorts")]
        private InputList<Extensions.V1Beta1.HostPortRangeArgs>? _hostPorts;

        /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
        public InputList<Extensions.V1Beta1.HostPortRangeArgs> HostPorts
        {
            get => _hostPorts ?? (_hostPorts = new InputList<Extensions.V1Beta1.HostPortRangeArgs>());
            set => _hostPorts = value;
        }

        /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// readOnlyRootFilesystem when set to true will force containers to run with a read only
        /// root file system.  If the container specifically requests to run with a non-read only
        /// root file system the PSP should deny the pod. If set to false the container may run with
        /// a read only root file system if it wishes but it will not be forced to.
        /// </summary>
        [Input("readOnlyRootFilesystem")]
        public Input<bool>? ReadOnlyRootFilesystem { get; set; }

        [Input("requiredDropCapabilities")]
        private InputList<string>? _requiredDropCapabilities;

        /// <summary>
        /// requiredDropCapabilities are the capabilities that will be dropped from the container.
        /// These are required to be dropped and cannot be added.
        /// </summary>
        public InputList<string> RequiredDropCapabilities
        {
            get => _requiredDropCapabilities ?? (_requiredDropCapabilities = new InputList<string>());
            set => _requiredDropCapabilities = value;
        }

        /// <summary>
        /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be
        /// set. If this field is omitted, the pod's RunAsGroup can take any value. This field
        /// requires the RunAsGroup feature gate to be enabled.
        /// </summary>
        [Input("runAsGroup")]
        public Input<Extensions.V1Beta1.RunAsGroupStrategyOptionsArgs>? RunAsGroup { get; set; }

        /// <summary>
        /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
        /// If this field is omitted, the pod's runtimeClassName field is unrestricted. Enforcement
        /// of this field depends on the RuntimeClass feature gate being enabled.
        /// </summary>
        [Input("runtimeClass")]
        public Input<Extensions.V1Beta1.RuntimeClassStrategyOptionsArgs>? RuntimeClass { get; set; }

        [Input("volumes")]
        private InputList<string>? _volumes;

        /// <summary>
        /// volumes is a white list of allowed volume plugins. Empty indicates that no volumes may
        /// be used. To allow all volumes you may use '*'.
        /// </summary>
        public InputList<string> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<string>());
            set => _volumes = value;
        }

    }

    /// <summary>
    /// DEPRECATED - extensions/v1beta1/ReplicaSet is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/ReplicaSet instead.
    /// 
    /// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
    /// </summary>
    public class ReplicaSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
        /// that the ReplicaSet manages. Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec defines the specification of the desired behavior of the ReplicaSet. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Extensions.V1Beta1.ReplicaSetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// ReplicaSetCondition describes the state of a replica set at a certain point.
    /// </summary>
    public class ReplicaSetConditionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        /// <summary>
        /// Type of replica set condition.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
        [Input("lastTransitionTime")]
        public Input<string>? LastTransitionTime { get; set; }

        /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// ReplicaSetList is a collection of ReplicaSets.
    /// </summary>
    public class ReplicaSetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Extensions.V1Beta1.ReplicaSetArgs>? _items;

        /// <summary>
        /// List of ReplicaSets. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
        public InputList<Extensions.V1Beta1.ReplicaSetArgs> Items
        {
            get => _items ?? (_items = new InputList<Extensions.V1Beta1.ReplicaSetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ReplicaSetSpec is the specification of a ReplicaSet.
    /// </summary>
    public class ReplicaSetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
        [Input("minReadySeconds")]
        public Input<int>? MinReadySeconds { get; set; }

        /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Selector is a label query over pods that should match the replica count. If the selector
        /// is empty, it is defaulted to the labels present on the pod template. Label keys and
        /// values that must match in order to be controlled by this replica set. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

        /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
        [Input("template")]
        public Input<Core.V1.PodTemplateSpecArgs>? Template { get; set; }

    }

    /// <summary>
    /// ReplicaSetStatus represents the current status of a ReplicaSet.
    /// </summary>
    public class ReplicaSetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this replica
        /// set.
        /// </summary>
        [Input("availableReplicas")]
        public Input<int>? AvailableReplicas { get; set; }

        [Input("conditions")]
        private InputList<Extensions.V1Beta1.ReplicaSetConditionArgs>? _conditions;

        /// <summary>
        /// Represents the latest available observations of a replica set's current state.
        /// </summary>
        public InputList<Extensions.V1Beta1.ReplicaSetConditionArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Extensions.V1Beta1.ReplicaSetConditionArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replicaset.
        /// </summary>
        [Input("fullyLabeledReplicas")]
        public Input<int>? FullyLabeledReplicas { get; set; }

        /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

        /// <summary>
        /// The number of ready replicas for this replica set.
        /// </summary>
        [Input("readyReplicas")]
        public Input<int>? ReadyReplicas { get; set; }

    }

    /// <summary>
    /// DEPRECATED.
    /// </summary>
    public class RollbackConfigArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The revision to rollback to. If set to 0, rollback to the last revision.
        /// </summary>
        [Input("revision")]
        public Input<int>? Revision { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of daemon set rolling update.
    /// </summary>
    public class RollingUpdateDaemonSetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The maximum number of DaemonSet pods that can be unavailable during the update. Value
        /// can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at
        /// the start of the update (ex: 10%). Absolute number is calculated from percentage by
        /// rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at
        /// most 30% of the total number of nodes that should be running the daemon pod (i.e.
        /// status.desiredNumberScheduled) can have their pods stopped for an update at any given
        /// time. The update starts by stopping at most 30% of those DaemonSet pods and then brings
        /// up new DaemonSet pods in their place. Once the new pods are available, it then proceeds
        /// onto other DaemonSet pods, thus ensuring that at least 70% of original number of
        /// DaemonSet pods are available at all times during the update.
        /// </summary>
        [Input("maxUnavailable")]
        public InputUnion<int,string>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    public class RollingUpdateDeploymentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. By default, a value of 1 is used. Example: when this is set to 30%, the new
        /// RC can be scaled up immediately when the rolling update starts, such that the total
        /// number of old and new pods do not exceed 130% of desired pods. Once old pods have been
        /// killed, new RC can be scaled up further, ensuring that total number of pods running at
        /// any time during the update is at most 130% of desired pods.
        /// </summary>
        [Input("maxSurge")]
        public InputUnion<int,string>? MaxSurge { get; set; }

        /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. By
        /// default, a fixed value of 1 is used. Example: when this is set to 30%, the old RC can be
        /// scaled down to 70% of desired pods immediately when the rolling update starts. Once new
        /// pods are ready, old RC can be scaled down further, followed by scaling up the new RC,
        /// ensuring that the total number of pods available at all times during the update is at
        /// least 70% of desired pods.
        /// </summary>
        [Input("maxUnavailable")]
        public InputUnion<int,string>? MaxUnavailable { get; set; }

    }

    /// <summary>
    /// RunAsGroupStrategyOptions defines the strategy type and any options used to create the
    /// strategy. Deprecated: use RunAsGroupStrategyOptions from policy API Group instead.
    /// </summary>
    public class RunAsGroupStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
        /// </summary>
        [Input("rule", required: true)]
        public Input<string> Rule { get; set; } = null!;

        [Input("ranges")]
        private InputList<Extensions.V1Beta1.IDRangeArgs>? _ranges;

        /// <summary>
        /// ranges are the allowed ranges of gids that may be used. If you would like to force a
        /// single gid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
        public InputList<Extensions.V1Beta1.IDRangeArgs> Ranges
        {
            get => _ranges ?? (_ranges = new InputList<Extensions.V1Beta1.IDRangeArgs>());
            set => _ranges = value;
        }

    }

    /// <summary>
    /// RunAsUserStrategyOptions defines the strategy type and any options used to create the
    /// strategy. Deprecated: use RunAsUserStrategyOptions from policy API Group instead.
    /// </summary>
    public class RunAsUserStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
        [Input("rule", required: true)]
        public Input<string> Rule { get; set; } = null!;

        [Input("ranges")]
        private InputList<Extensions.V1Beta1.IDRangeArgs>? _ranges;

        /// <summary>
        /// ranges are the allowed ranges of uids that may be used. If you would like to force a
        /// single uid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
        public InputList<Extensions.V1Beta1.IDRangeArgs> Ranges
        {
            get => _ranges ?? (_ranges = new InputList<Extensions.V1Beta1.IDRangeArgs>());
            set => _ranges = value;
        }

    }

    /// <summary>
    /// RuntimeClassStrategyOptions define the strategy that will dictate the allowable
    /// RuntimeClasses for a pod.
    /// </summary>
    public class RuntimeClassStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        [Input("allowedRuntimeClassNames", required: true)]
        private InputList<string>? _allowedRuntimeClassNames;

        /// <summary>
        /// allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a
        /// pod. A value of "*" means that any RuntimeClass name is allowed, and must be the only
        /// item in the list. An empty list requires the RuntimeClassName field to be unset.
        /// </summary>
        public InputList<string> AllowedRuntimeClassNames
        {
            get => _allowedRuntimeClassNames ?? (_allowedRuntimeClassNames = new InputList<string>());
            set => _allowedRuntimeClassNames = value;
        }

        /// <summary>
        /// defaultRuntimeClassName is the default RuntimeClassName to set on the pod. The default
        /// MUST be allowed by the allowedRuntimeClassNames list. A value of nil does not mutate the
        /// Pod.
        /// </summary>
        [Input("defaultRuntimeClassName")]
        public Input<string>? DefaultRuntimeClassName { get; set; }

    }

    /// <summary>
    /// SELinuxStrategyOptions defines the strategy type and any options used to create the
    /// strategy. Deprecated: use SELinuxStrategyOptions from policy API Group instead.
    /// </summary>
    public class SELinuxStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// rule is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        [Input("rule", required: true)]
        public Input<string> Rule { get; set; } = null!;

        /// <summary>
        /// seLinuxOptions required to run as; required for MustRunAs More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        [Input("seLinuxOptions")]
        public Input<Core.V1.SELinuxOptionsArgs>? SeLinuxOptions { get; set; }

    }

    /// <summary>
    /// represents a scaling request for a resource.
    /// </summary>
    public class ScaleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
        [Input("spec")]
        public Input<Extensions.V1Beta1.ScaleSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// describes the attributes of a scale subresource
    /// </summary>
    public class ScaleSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

    }

    /// <summary>
    /// represents the current status of a scale subresource.
    /// </summary>
    public class ScaleStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
        [Input("replicas", required: true)]
        public Input<int> Replicas { get; set; } = null!;

        [Input("selector")]
        private InputMap<string>? _selector;

        /// <summary>
        /// label query over pods that should match the replicas count. More info:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
        public InputMap<string> Selector
        {
            get => _selector ?? (_selector = new InputMap<string>());
            set => _selector = value;
        }

        /// <summary>
        /// label selector for pods that should match the replicas count. This is a serializated
        /// version of both map-based and more expressive set-based selectors. This is done to avoid
        /// introspection in the clients. The string will be in the same format as the query-param
        /// syntax. If the target type only supports map-based selectors, both this field and
        /// map-based selector field are populated. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
        [Input("targetSelector")]
        public Input<string>? TargetSelector { get; set; }

    }

    /// <summary>
    /// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the
    /// strategy. Deprecated: use SupplementalGroupsStrategyOptions from policy API Group instead.
    /// </summary>
    public class SupplementalGroupsStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        [Input("ranges")]
        private InputList<Extensions.V1Beta1.IDRangeArgs>? _ranges;

        /// <summary>
        /// ranges are the allowed ranges of supplemental groups.  If you would like to force a
        /// single supplemental group then supply a single range with the same start and end.
        /// Required for MustRunAs.
        /// </summary>
        public InputList<Extensions.V1Beta1.IDRangeArgs> Ranges
        {
            get => _ranges ?? (_ranges = new InputList<Extensions.V1Beta1.IDRangeArgs>());
            set => _ranges = value;
        }

        /// <summary>
        /// rule is the strategy that will dictate what supplemental groups is used in the
        /// SecurityContext.
        /// </summary>
        [Input("rule")]
        public Input<string>? Rule { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Meta
{
  namespace V1
  {
    /// <summary>
    /// APIGroup contains the name, the supported versions, and the preferred version of a group.
    /// </summary>
    public class APIGroupArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// name is the name of the group.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("versions", required: true)]
        private InputList<Meta.V1.GroupVersionForDiscoveryArgs>? _versions;

        /// <summary>
        /// versions are the versions supported in this group.
        /// </summary>
        public InputList<Meta.V1.GroupVersionForDiscoveryArgs> Versions
        {
            get => _versions ?? (_versions = new InputList<Meta.V1.GroupVersionForDiscoveryArgs>());
            set => _versions = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// preferredVersion is the version preferred by the API server, which probably is the
        /// storage version.
        /// </summary>
        [Input("preferredVersion")]
        public Input<Meta.V1.GroupVersionForDiscoveryArgs>? PreferredVersion { get; set; }

        [Input("serverAddressByClientCIDRs")]
        private InputList<Meta.V1.ServerAddressByClientCIDRArgs>? _serverAddressByClientCIDRs;

        /// <summary>
        /// a map of client CIDR to server address that is serving this group. This is to help
        /// clients reach servers in the most network-efficient way possible. Clients can use the
        /// appropriate server address as per the CIDR that they match. In case of multiple matches,
        /// clients should use the longest matching CIDR. The server returns only those CIDRs that
        /// it thinks that the client can match. For example: the master will return an internal IP
        /// CIDR only, if the client reaches the server using an internal IP. Server looks at
        /// X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get
        /// the client IP.
        /// </summary>
        public InputList<Meta.V1.ServerAddressByClientCIDRArgs> ServerAddressByClientCIDRs
        {
            get => _serverAddressByClientCIDRs ?? (_serverAddressByClientCIDRs = new InputList<Meta.V1.ServerAddressByClientCIDRArgs>());
            set => _serverAddressByClientCIDRs = value;
        }

    }

    /// <summary>
    /// APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis.
    /// </summary>
    public class APIGroupListArgs : Pulumi.ResourceArgs
    {
        [Input("groups", required: true)]
        private InputList<Meta.V1.APIGroupArgs>? _groups;

        /// <summary>
        /// groups is a list of APIGroup.
        /// </summary>
        public InputList<Meta.V1.APIGroupArgs> Groups
        {
            get => _groups ?? (_groups = new InputList<Meta.V1.APIGroupArgs>());
            set => _groups = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

    }

    /// <summary>
    /// APIResource specifies the name of a resource and whether it is namespaced.
    /// </summary>
    public class APIResourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// name is the plural name of the resource.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// namespaced indicates if a resource is namespaced or not.
        /// </summary>
        [Input("namespaced", required: true)]
        public Input<bool> Namespaced { get; set; } = null!;

        /// <summary>
        /// singularName is the singular name of the resource.  This allows clients to handle plural
        /// and singular opaquely. The singularName is more correct for reporting status on a single
        /// item and both singular and plural are allowed from the kubectl CLI interface.
        /// </summary>
        [Input("singularName", required: true)]
        public Input<string> SingularName { get; set; } = null!;

        [Input("verbs", required: true)]
        private InputList<string>? _verbs;

        /// <summary>
        /// verbs is a list of supported kube verbs (this includes get, list, watch, create, update,
        /// patch, delete, deletecollection, and proxy)
        /// </summary>
        public InputList<string> Verbs
        {
            get => _verbs ?? (_verbs = new InputList<string>());
            set => _verbs = value;
        }

        [Input("categories")]
        private InputList<string>? _categories;

        /// <summary>
        /// categories is a list of the grouped resources this resource belongs to (e.g. 'all')
        /// </summary>
        public InputList<string> Categories
        {
            get => _categories ?? (_categories = new InputList<string>());
            set => _categories = value;
        }

        /// <summary>
        /// group is the preferred group of the resource.  Empty implies the group of the containing
        /// resource list. For subresources, this may have a different value, for example: Scale".
        /// </summary>
        [Input("group")]
        public Input<string>? Group { get; set; }

        [Input("shortNames")]
        private InputList<string>? _shortNames;

        /// <summary>
        /// shortNames is a list of suggested short names of the resource.
        /// </summary>
        public InputList<string> ShortNames
        {
            get => _shortNames ?? (_shortNames = new InputList<string>());
            set => _shortNames = value;
        }

        /// <summary>
        /// The hash value of the storage version, the version this resource is converted to when
        /// written to the data store. Value must be treated as opaque by clients. Only equality
        /// comparison on the value is valid. This is an alpha feature and may change or be removed
        /// in the future. The field is populated by the apiserver only if the StorageVersionHash
        /// feature gate is enabled. This field will remain optional even if it graduates.
        /// </summary>
        [Input("storageVersionHash")]
        public Input<string>? StorageVersionHash { get; set; }

        /// <summary>
        /// version is the preferred version of the resource.  Empty implies the version of the
        /// containing resource list For subresources, this may have a different value, for example:
        /// v1 (while inside a v1beta1 version of the core resource's group)".
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

    }

    /// <summary>
    /// APIResourceList is a list of APIResource, it is used to expose the name of the resources
    /// supported in a specific group and version, and if the resource is namespaced.
    /// </summary>
    public class APIResourceListArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// groupVersion is the group and version this APIResourceList is for.
        /// </summary>
        [Input("groupVersion", required: true)]
        public Input<string> GroupVersion { get; set; } = null!;

        [Input("resources", required: true)]
        private InputList<Meta.V1.APIResourceArgs>? _resources;

        /// <summary>
        /// resources contains the name of the resources and if they are namespaced.
        /// </summary>
        public InputList<Meta.V1.APIResourceArgs> Resources
        {
            get => _resources ?? (_resources = new InputList<Meta.V1.APIResourceArgs>());
            set => _resources = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

    }

    /// <summary>
    /// APIVersions lists the versions that are available, to allow clients to discover the API at
    /// /api, which is the root path of the legacy v1 API.
    /// </summary>
    public class APIVersionsArgs : Pulumi.ResourceArgs
    {
        [Input("serverAddressByClientCIDRs", required: true)]
        private InputList<Meta.V1.ServerAddressByClientCIDRArgs>? _serverAddressByClientCIDRs;

        /// <summary>
        /// a map of client CIDR to server address that is serving this group. This is to help
        /// clients reach servers in the most network-efficient way possible. Clients can use the
        /// appropriate server address as per the CIDR that they match. In case of multiple matches,
        /// clients should use the longest matching CIDR. The server returns only those CIDRs that
        /// it thinks that the client can match. For example: the master will return an internal IP
        /// CIDR only, if the client reaches the server using an internal IP. Server looks at
        /// X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get
        /// the client IP.
        /// </summary>
        public InputList<Meta.V1.ServerAddressByClientCIDRArgs> ServerAddressByClientCIDRs
        {
            get => _serverAddressByClientCIDRs ?? (_serverAddressByClientCIDRs = new InputList<Meta.V1.ServerAddressByClientCIDRArgs>());
            set => _serverAddressByClientCIDRs = value;
        }

        [Input("versions", required: true)]
        private InputList<string>? _versions;

        /// <summary>
        /// versions are the api versions that are available.
        /// </summary>
        public InputList<string> Versions
        {
            get => _versions ?? (_versions = new InputList<string>());
            set => _versions = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

    }

    /// <summary>
    /// DeleteOptions may be provided when deleting an API object.
    /// </summary>
    public class DeleteOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        [Input("dryRun")]
        private InputList<string>? _dryRun;

        /// <summary>
        /// When present, indicates that modifications should not be persisted. An invalid or
        /// unrecognized dryRun directive will result in an error response and no further processing
        /// of the request. Valid values are: - All: all dry run stages will be processed
        /// </summary>
        public InputList<string> DryRun
        {
            get => _dryRun ?? (_dryRun = new InputList<string>());
            set => _dryRun = value;
        }

        /// <summary>
        /// The duration in seconds before the object should be deleted. Value must be non-negative
        /// integer. The value zero indicates delete immediately. If this value is nil, the default
        /// grace period for the specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </summary>
        [Input("gracePeriodSeconds")]
        public Input<int>? GracePeriodSeconds { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be
        /// added to/removed from the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </summary>
        [Input("orphanDependents")]
        public Input<bool>? OrphanDependents { get; set; }

        /// <summary>
        /// Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict
        /// status will be returned.
        /// </summary>
        [Input("preconditions")]
        public Input<Meta.V1.PreconditionsArgs>? Preconditions { get; set; }

        /// <summary>
        /// Whether and how garbage collection will be performed. Either this field or
        /// OrphanDependents may be set, but not both. The default policy is decided by the existing
        /// finalizer set in the metadata.finalizers and the resource-specific default policy.
        /// Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the
        /// garbage collector to delete the dependents in the background; 'Foreground' - a cascading
        /// policy that deletes all dependents in the foreground.
        /// </summary>
        [Input("propagationPolicy")]
        public Input<string>? PropagationPolicy { get; set; }

    }

    /// <summary>
    /// GroupVersion contains the "group/version" and "version" string of a version. It is made a
    /// struct to keep extensibility.
    /// </summary>
    public class GroupVersionForDiscoveryArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// groupVersion specifies the API group and version in the form "group/version"
        /// </summary>
        [Input("groupVersion", required: true)]
        public Input<string> GroupVersion { get; set; } = null!;

        /// <summary>
        /// version specifies the version in the form of "version". This is to save the clients the
        /// trouble of splitting the GroupVersion.
        /// </summary>
        [Input("version", required: true)]
        public Input<string> Version { get; set; } = null!;

    }

    /// <summary>
    /// A label selector is a label query over a set of resources. The result of matchLabels and
    /// matchExpressions are ANDed. An empty label selector matches all objects. A null label
    /// selector matches no objects.
    /// </summary>
    public class LabelSelectorArgs : Pulumi.ResourceArgs
    {
        [Input("matchExpressions")]
        private InputList<Meta.V1.LabelSelectorRequirementArgs>? _matchExpressions;

        /// <summary>
        /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
        public InputList<Meta.V1.LabelSelectorRequirementArgs> MatchExpressions
        {
            get => _matchExpressions ?? (_matchExpressions = new InputList<Meta.V1.LabelSelectorRequirementArgs>());
            set => _matchExpressions = value;
        }

        [Input("matchLabels")]
        private InputMap<string>? _matchLabels;

        /// <summary>
        /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map
        /// is equivalent to an element of matchExpressions, whose key field is "key", the operator
        /// is "In", and the values array contains only "value". The requirements are ANDed.
        /// </summary>
        public InputMap<string> MatchLabels
        {
            get => _matchLabels ?? (_matchLabels = new InputMap<string>());
            set => _matchLabels = value;
        }

    }

    /// <summary>
    /// A label selector requirement is a selector that contains values, a key, and an operator that
    /// relates the key and values.
    /// </summary>
    public class LabelSelectorRequirementArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// key is the label key that the selector applies to.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// operator represents a key's relationship to a set of values. Valid operators are In,
        /// NotIn, Exists and DoesNotExist.
        /// </summary>
        [Input("operator", required: true)]
        public Input<string> Operator { get; set; } = null!;

        [Input("values")]
        private InputList<string>? _values;

        /// <summary>
        /// values is an array of string values. If the operator is In or NotIn, the values array
        /// must be non-empty. If the operator is Exists or DoesNotExist, the values array must be
        /// empty. This array is replaced during a strategic merge patch.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

    }

    /// <summary>
    /// ListMeta describes metadata that synthetic resources must have, including lists and various
    /// status objects. A resource may have only one of {ObjectMeta, ListMeta}.
    /// </summary>
    public class ListMetaArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// continue may be set if the user set a limit on the number of items returned, and
        /// indicates that the server has more data available. The value is opaque and may be used
        /// to issue another request to the endpoint that served this list to retrieve the next set
        /// of available objects. Continuing a consistent list may not be possible if the server
        /// configuration has changed or more than a few minutes have passed. The resourceVersion
        /// field returned when using this continue value will be identical to the value in the
        /// first response, unless you have received this token from an error message.
        /// </summary>
        [Input("continue")]
        public Input<string>? Continue { get; set; }

        /// <summary>
        /// remainingItemCount is the number of subsequent items in the list which are not included
        /// in this list response. If the list request contained label or field selectors, then the
        /// number of remaining items is unknown and the field will be left unset and omitted during
        /// serialization. If the list is complete (either because it is not chunking or because
        /// this is the last chunk), then there are no more remaining items and this field will be
        /// left unset and omitted during serialization. Servers older than v1.15 do not set this
        /// field. The intended use of the remainingItemCount is *estimating* the size of a
        /// collection. Clients should not rely on the remainingItemCount to be set or to be exact.
        /// </summary>
        [Input("remainingItemCount")]
        public Input<int>? RemainingItemCount { get; set; }

        /// <summary>
        /// String that identifies the server's internal version of this object that can be used by
        /// clients to determine when objects have changed. Value must be treated as opaque by
        /// clients and passed unmodified back to the server. Populated by the system. Read-only.
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
        [Input("resourceVersion")]
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// selfLink is a URL representing this object. Populated by the system. Read-only.
        /// 
        /// DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is
        /// planned to be removed in 1.21 release.
        /// </summary>
        [Input("selfLink")]
        public Input<string>? SelfLink { get; set; }

    }

    /// <summary>
    /// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that
    /// the fieldset applies to.
    /// </summary>
    public class ManagedFieldsEntryArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the version of this resource that this field set applies to. The
        /// format is "group/version" just like the top-level APIVersion field. It is necessary to
        /// track the version of a field set because it cannot be automatically converted.
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// FieldsType is the discriminator for the different fields format and version. There is
        /// currently only one possible value: "FieldsV1"
        /// </summary>
        [Input("fieldsType")]
        public Input<string>? FieldsType { get; set; }

        /// <summary>
        /// FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
        /// </summary>
        [Input("fieldsV1")]
        public Input<string>? FieldsV1 { get; set; }

        /// <summary>
        /// Manager is an identifier of the workflow managing these fields.
        /// </summary>
        [Input("manager")]
        public Input<string>? Manager { get; set; }

        /// <summary>
        /// Operation is the type of operation which lead to this ManagedFieldsEntry being created.
        /// The only valid values for this field are 'Apply' and 'Update'.
        /// </summary>
        [Input("operation")]
        public Input<string>? Operation { get; set; }

        /// <summary>
        /// Time is timestamp of when these fields were set. It should always be empty if Operation
        /// is 'Apply'
        /// </summary>
        [Input("time")]
        public Input<string>? Time { get; set; }

    }

    /// <summary>
    /// ObjectMeta is metadata that all persisted resources must have, which includes all objects
    /// users must create.
    /// </summary>
    public class ObjectMetaArgs : Pulumi.ResourceArgs
    {
        [Input("annotations")]
        private InputMap<string>? _annotations;

        /// <summary>
        /// Annotations is an unstructured key value map stored with a resource that may be set by
        /// external tools to store and retrieve arbitrary metadata. They are not queryable and
        /// should be preserved when modifying objects. More info:
        /// http://kubernetes.io/docs/user-guide/annotations
        /// </summary>
        public InputMap<string> Annotations
        {
            get => _annotations ?? (_annotations = new InputMap<string>());
            set => _annotations = value;
        }

        /// <summary>
        /// The name of the cluster which the object belongs to. This is used to distinguish
        /// resources with same name and namespace in different clusters. This field is not set
        /// anywhere right now and apiserver is going to ignore it if set in create or update
        /// request.
        /// </summary>
        [Input("clusterName")]
        public Input<string>? ClusterName { get; set; }

        /// <summary>
        /// CreationTimestamp is a timestamp representing the server time when this object was
        /// created. It is not guaranteed to be set in happens-before order across separate
        /// operations. Clients may not set this value. It is represented in RFC3339 form and is in
        /// UTC.
        /// 
        /// Populated by the system. Read-only. Null for lists. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("creationTimestamp")]
        public Input<string>? CreationTimestamp { get; set; }

        /// <summary>
        /// Number of seconds allowed for this object to gracefully terminate before it will be
        /// removed from the system. Only set when deletionTimestamp is also set. May only be
        /// shortened. Read-only.
        /// </summary>
        [Input("deletionGracePeriodSeconds")]
        public Input<int>? DeletionGracePeriodSeconds { get; set; }

        /// <summary>
        /// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
        /// field is set by the server when a graceful deletion is requested by the user, and is not
        /// directly settable by a client. The resource is expected to be deleted (no longer visible
        /// from resource lists, and not reachable by name) after the time in this field, once the
        /// finalizers list is empty. As long as the finalizers list contains items, deletion is
        /// blocked. Once the deletionTimestamp is set, this value may not be unset or be set
        /// further into the future, although it may be shortened or the resource may be deleted
        /// prior to this time. For example, a user may request that a pod is deleted in 30 seconds.
        /// The Kubelet will react by sending a graceful termination signal to the containers in the
        /// pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to
        /// the container and after cleanup, remove the pod from the API. In the presence of network
        /// partitions, this object may still exist after this timestamp, until an administrator or
        /// automated process can determine the resource is fully terminated. If not set, graceful
        /// deletion of the object has not been requested.
        /// 
        /// Populated by the system when a graceful deletion is requested. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("deletionTimestamp")]
        public Input<string>? DeletionTimestamp { get; set; }

        [Input("finalizers")]
        private InputList<string>? _finalizers;

        /// <summary>
        /// Must be empty before the object is deleted from the registry. Each entry is an
        /// identifier for the responsible component that will remove the entry from the list. If
        /// the deletionTimestamp of the object is non-nil, entries in this list can only be
        /// removed.
        /// </summary>
        public InputList<string> Finalizers
        {
            get => _finalizers ?? (_finalizers = new InputList<string>());
            set => _finalizers = value;
        }

        /// <summary>
        /// GenerateName is an optional prefix, used by the server, to generate a unique name ONLY
        /// IF the Name field has not been provided. If this field is used, the name returned to the
        /// client will be different than the name passed. This value will also be combined with a
        /// unique suffix. The provided value has the same validation rules as the Name field, and
        /// may be truncated by the length of the suffix required to make the value unique on the
        /// server.
        /// 
        /// If this field is specified and the generated name exists, the server will NOT return a
        /// 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout
        /// indicating a unique name could not be found in the time allotted, and the client should
        /// retry (optionally after the time indicated in the Retry-After header).
        /// 
        /// Applied only if Name is not specified. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
        /// </summary>
        [Input("generateName")]
        public Input<string>? GenerateName { get; set; }

        /// <summary>
        /// A sequence number representing a specific generation of the desired state. Populated by
        /// the system. Read-only.
        /// </summary>
        [Input("generation")]
        public Input<int>? Generation { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Map of string keys and values that can be used to organize and categorize (scope and
        /// select) objects. May match selectors of replication controllers and services. More info:
        /// http://kubernetes.io/docs/user-guide/labels
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        [Input("managedFields")]
        private InputList<Meta.V1.ManagedFieldsEntryArgs>? _managedFields;

        /// <summary>
        /// ManagedFields maps workflow-id and version to the set of fields that are managed by that
        /// workflow. This is mostly for internal housekeeping, and users typically shouldn't need
        /// to set or understand this field. A workflow can be the user's name, a controller's name,
        /// or the name of a specific apply path like "ci-cd". The set of fields is always in the
        /// version that the workflow used when modifying the object.
        /// </summary>
        public InputList<Meta.V1.ManagedFieldsEntryArgs> ManagedFields
        {
            get => _managedFields ?? (_managedFields = new InputList<Meta.V1.ManagedFieldsEntryArgs>());
            set => _managedFields = value;
        }

        /// <summary>
        /// Name must be unique within a namespace. Is required when creating resources, although
        /// some resources may allow a client to request the generation of an appropriate name
        /// automatically. Name is primarily intended for creation idempotence and configuration
        /// definition. Cannot be updated. More info:
        /// http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Namespace defines the space within each name must be unique. An empty namespace is
        /// equivalent to the "default" namespace, but "default" is the canonical representation.
        /// Not all objects are required to be scoped to a namespace - the value of this field for
        /// those objects will be empty.
        /// 
        /// Must be a DNS_LABEL. Cannot be updated. More info:
        /// http://kubernetes.io/docs/user-guide/namespaces
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

        [Input("ownerReferences")]
        private InputList<Meta.V1.OwnerReferenceArgs>? _ownerReferences;

        /// <summary>
        /// List of objects depended by this object. If ALL objects in the list have been deleted,
        /// this object will be garbage collected. If this object is managed by a controller, then
        /// an entry in this list will point to this controller, with the controller field set to
        /// true. There cannot be more than one managing controller.
        /// </summary>
        public InputList<Meta.V1.OwnerReferenceArgs> OwnerReferences
        {
            get => _ownerReferences ?? (_ownerReferences = new InputList<Meta.V1.OwnerReferenceArgs>());
            set => _ownerReferences = value;
        }

        /// <summary>
        /// An opaque value that represents the internal version of this object that can be used by
        /// clients to determine when objects have changed. May be used for optimistic concurrency,
        /// change detection, and the watch operation on a resource or set of resources. Clients
        /// must treat these values as opaque and passed unmodified back to the server. They may
        /// only be valid for a particular resource or set of resources.
        /// 
        /// Populated by the system. Read-only. Value must be treated as opaque by clients and .
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
        [Input("resourceVersion")]
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// SelfLink is a URL representing this object. Populated by the system. Read-only.
        /// 
        /// DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is
        /// planned to be removed in 1.21 release.
        /// </summary>
        [Input("selfLink")]
        public Input<string>? SelfLink { get; set; }

        /// <summary>
        /// UID is the unique in time and space value for this object. It is typically generated by
        /// the server on successful creation of a resource and is not allowed to change on PUT
        /// operations.
        /// 
        /// Populated by the system. Read-only. More info:
        /// http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// OwnerReference contains enough information to let you identify an owning object. An owning
    /// object must be in the same namespace as the dependent, or be cluster-scoped, so there is no
    /// namespace field.
    /// </summary>
    public class OwnerReferenceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// API version of the referent.
        /// </summary>
        [Input("apiVersion", required: true)]
        public Input<string> ApiVersion { get; set; } = null!;

        /// <summary>
        /// Kind of the referent. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
        [Input("uid", required: true)]
        public Input<string> Uid { get; set; } = null!;

        /// <summary>
        /// If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot
        /// be deleted from the key-value store until this reference is removed. Defaults to false.
        /// To set this field, a user needs "delete" permission of the owner, otherwise 422
        /// (Unprocessable Entity) will be returned.
        /// </summary>
        [Input("blockOwnerDeletion")]
        public Input<bool>? BlockOwnerDeletion { get; set; }

        /// <summary>
        /// If true, this reference points to the managing controller.
        /// </summary>
        [Input("controller")]
        public Input<bool>? Controller { get; set; }

    }

    /// <summary>
    /// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
    /// </summary>
    public class PreconditionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specifies the target ResourceVersion
        /// </summary>
        [Input("resourceVersion")]
        public Input<string>? ResourceVersion { get; set; }

        /// <summary>
        /// Specifies the target UID.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// ServerAddressByClientCIDR helps the client to determine the server address that they should
    /// use, depending on the clientCIDR that they match.
    /// </summary>
    public class ServerAddressByClientCIDRArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The CIDR with which clients can match their IP to figure out the server address that
        /// they should use.
        /// </summary>
        [Input("clientCIDR", required: true)]
        public Input<string> ClientCIDR { get; set; } = null!;

        /// <summary>
        /// Address of this server, suitable for a client that matches the above CIDR. This can be a
        /// hostname, hostname:port, IP or IP:port.
        /// </summary>
        [Input("serverAddress", required: true)]
        public Input<string> ServerAddress { get; set; } = null!;

    }

    /// <summary>
    /// Status is a return value for calls that don't return other objects.
    /// </summary>
    public class StatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Suggested HTTP return code for this status, 0 if not set.
        /// </summary>
        [Input("code")]
        public Input<int>? Code { get; set; }

        /// <summary>
        /// Extended data associated with the reason.  Each reason may define its own extended
        /// details. This field is optional and the data returned is not guaranteed to conform to
        /// any schema except that defined by the reason type.
        /// </summary>
        [Input("details")]
        public Input<Meta.V1.StatusDetailsArgs>? Details { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// A human-readable description of the status of this operation.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// A machine-readable description of why this operation is in the "Failure" status. If this
        /// value is empty there is no information available. A Reason clarifies an HTTP status code
        /// but does not override it.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatusCause provides more information about an api.Status failure, including cases when
    /// multiple errors are encountered.
    /// </summary>
    public class StatusCauseArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The field of the resource that has caused this error, as named by its JSON
        /// serialization. May include dot and postfix notation for nested attributes. Arrays are
        /// zero-indexed.  Fields may appear more than once in an array of causes due to fields
        /// having multiple errors. Optional.
        /// 
        /// Examples:
        ///   "name" - the field "name" on the current resource
        ///   "items[0].name" - the field "name" on the first array entry in "items"
        /// </summary>
        [Input("field")]
        public Input<string>? Field { get; set; }

        /// <summary>
        /// A human-readable description of the cause of the error.  This field may be presented
        /// as-is to a reader.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// A machine-readable description of the cause of the error. If this value is empty there
        /// is no information available.
        /// </summary>
        [Input("reason")]
        public Input<string>? Reason { get; set; }

    }

    /// <summary>
    /// StatusDetails is a set of additional properties that MAY be set by the server to provide
    /// additional information about a response. The Reason field of a Status object defines what
    /// attributes will be set. Clients must ignore fields that do not match the defined type of
    /// each attribute, and should assume that any attribute may be empty, invalid, or under
    /// defined.
    /// </summary>
    public class StatusDetailsArgs : Pulumi.ResourceArgs
    {
        [Input("causes")]
        private InputList<Meta.V1.StatusCauseArgs>? _causes;

        /// <summary>
        /// The Causes array includes more details associated with the StatusReason failure. Not all
        /// StatusReasons may provide detailed causes.
        /// </summary>
        public InputList<Meta.V1.StatusCauseArgs> Causes
        {
            get => _causes ?? (_causes = new InputList<Meta.V1.StatusCauseArgs>());
            set => _causes = value;
        }

        /// <summary>
        /// The group attribute of the resource associated with the status StatusReason.
        /// </summary>
        [Input("group")]
        public Input<string>? Group { get; set; }

        /// <summary>
        /// The kind attribute of the resource associated with the status StatusReason. On some
        /// operations may differ from the requested resource Kind. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// The name attribute of the resource associated with the status StatusReason (when there
        /// is a single name which can be described).
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// If specified, the time in seconds before the operation should be retried. Some errors
        /// may indicate the client must take an alternate action - for those errors this field may
        /// indicate how long to wait before taking the alternate action.
        /// </summary>
        [Input("retryAfterSeconds")]
        public Input<int>? RetryAfterSeconds { get; set; }

        /// <summary>
        /// UID of the resource. (when there is a single resource which can be described). More
        /// info: http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

    }

    /// <summary>
    /// Event represents a single event to a watched resource.
    /// </summary>
    public class WatchEventArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Object is:
        ///  * If Type is Added or Modified: the new state of the object.
        ///  * If Type is Deleted: the state of the object immediately before deletion.
        ///  * If Type is Error: *Status is recommended; other types may make sense
        ///    depending on context.
        /// </summary>
        [Input("object", required: true)]
        public Input<string> Object { get; set; } = null!;

        
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Networking
{
  namespace V1
  {
    /// <summary>
    /// IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
    /// matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
    /// not be included within this rule.
    /// </summary>
    public class IPBlockArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24"
        /// </summary>
        [Input("cidr", required: true)]
        public Input<string> Cidr { get; set; } = null!;

        [Input("except")]
        private InputList<string>? _except;

        /// <summary>
        /// Except is a slice of CIDRs that should not be included within an IP Block Valid examples
        /// are "192.168.1.1/24" Except values will be rejected if they are outside the CIDR range
        /// </summary>
        public InputList<string> Except
        {
            get => _except ?? (_except = new InputList<string>());
            set => _except = value;
        }

    }

    /// <summary>
    /// NetworkPolicy describes what network traffic is allowed for a set of Pods
    /// </summary>
    public class NetworkPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior for this NetworkPolicy.
        /// </summary>
        [Input("spec")]
        public Input<Networking.V1.NetworkPolicySpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
    /// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to. This
    /// type is beta-level in 1.8
    /// </summary>
    public class NetworkPolicyEgressRuleArgs : Pulumi.ResourceArgs
    {
        [Input("ports")]
        private InputList<Networking.V1.NetworkPolicyPortArgs>? _ports;

        /// <summary>
        /// List of destination ports for outgoing traffic. Each item in this list is combined using
        /// a logical OR. If this field is empty or missing, this rule matches all ports (traffic
        /// not restricted by port). If this field is present and contains at least one item, then
        /// this rule allows traffic only if the traffic matches at least one port in the list.
        /// </summary>
        public InputList<Networking.V1.NetworkPolicyPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Networking.V1.NetworkPolicyPortArgs>());
            set => _ports = value;
        }

        [Input("to")]
        private InputList<Networking.V1.NetworkPolicyPeerArgs>? _to;

        /// <summary>
        /// List of destinations for outgoing traffic of pods selected for this rule. Items in this
        /// list are combined using a logical OR operation. If this field is empty or missing, this
        /// rule matches all destinations (traffic not restricted by destination). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the to list.
        /// </summary>
        public InputList<Networking.V1.NetworkPolicyPeerArgs> To
        {
            get => _to ?? (_to = new InputList<Networking.V1.NetworkPolicyPeerArgs>());
            set => _to = value;
        }

    }

    /// <summary>
    /// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
    /// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
    /// </summary>
    public class NetworkPolicyIngressRuleArgs : Pulumi.ResourceArgs
    {
        [Input("from")]
        private InputList<Networking.V1.NetworkPolicyPeerArgs>? _from;

        /// <summary>
        /// List of sources which should be able to access the pods selected for this rule. Items in
        /// this list are combined using a logical OR operation. If this field is empty or missing,
        /// this rule matches all sources (traffic not restricted by source). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the from list.
        /// </summary>
        public InputList<Networking.V1.NetworkPolicyPeerArgs> From
        {
            get => _from ?? (_from = new InputList<Networking.V1.NetworkPolicyPeerArgs>());
            set => _from = value;
        }

        [Input("ports")]
        private InputList<Networking.V1.NetworkPolicyPortArgs>? _ports;

        /// <summary>
        /// List of ports which should be made accessible on the pods selected for this rule. Each
        /// item in this list is combined using a logical OR. If this field is empty or missing,
        /// this rule matches all ports (traffic not restricted by port). If this field is present
        /// and contains at least one item, then this rule allows traffic only if the traffic
        /// matches at least one port in the list.
        /// </summary>
        public InputList<Networking.V1.NetworkPolicyPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Networking.V1.NetworkPolicyPortArgs>());
            set => _ports = value;
        }

    }

    /// <summary>
    /// NetworkPolicyList is a list of NetworkPolicy objects.
    /// </summary>
    public class NetworkPolicyListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Networking.V1.NetworkPolicyArgs>? _items;

        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public InputList<Networking.V1.NetworkPolicyArgs> Items
        {
            get => _items ?? (_items = new InputList<Networking.V1.NetworkPolicyArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// NetworkPolicyPeer describes a peer to allow traffic from. Only certain combinations of
    /// fields are allowed
    /// </summary>
    public class NetworkPolicyPeerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// IPBlock defines policy on a particular IPBlock. If this field is set then neither of the
        /// other fields can be.
        /// </summary>
        [Input("ipBlock")]
        public Input<Networking.V1.IPBlockArgs>? IpBlock { get; set; }

        /// <summary>
        /// Selects Namespaces using cluster-scoped labels. This field follows standard label
        /// selector semantics; if present but empty, it selects all namespaces.
        /// 
        /// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects all Pods in the Namespaces selected by NamespaceSelector.
        /// </summary>
        [Input("namespaceSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? NamespaceSelector { get; set; }

        /// <summary>
        /// This is a label selector which selects Pods. This field follows standard label selector
        /// semantics; if present but empty, it selects all pods.
        /// 
        /// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects the Pods matching PodSelector in the policy's own Namespace.
        /// </summary>
        [Input("podSelector")]
        public Input<Meta.V1.LabelSelectorArgs>? PodSelector { get; set; }

    }

    /// <summary>
    /// NetworkPolicyPort describes a port to allow traffic on
    /// </summary>
    public class NetworkPolicyPortArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The port on the given protocol. This can either be a numerical or named port on a pod.
        /// If this field is not provided, this matches all port names and numbers.
        /// </summary>
        [Input("port")]
        public InputUnion<int,string>? Port { get; set; }

        /// <summary>
        /// The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field
        /// defaults to TCP.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

    }

    /// <summary>
    /// NetworkPolicySpec provides the specification of a NetworkPolicy
    /// </summary>
    public class NetworkPolicySpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Selects the pods to which this NetworkPolicy object applies. The array of ingress rules
        /// is applied to any pods selected by this field. Multiple network policies can select the
        /// same set of pods. In this case, the ingress rules for each are combined additively. This
        /// field is NOT optional and follows standard label selector semantics. An empty
        /// podSelector matches all pods in this namespace.
        /// </summary>
        [Input("podSelector", required: true)]
        public Input<Meta.V1.LabelSelectorArgs> PodSelector { get; set; } = null!;

        [Input("egress")]
        private InputList<Networking.V1.NetworkPolicyEgressRuleArgs>? _egress;

        /// <summary>
        /// List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if
        /// there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
        /// traffic), OR if the traffic matches at least one egress rule across all of the
        /// NetworkPolicy objects whose podSelector matches the pod. If this field is empty then
        /// this NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the
        /// pods it selects are isolated by default). This field is beta-level in 1.8
        /// </summary>
        public InputList<Networking.V1.NetworkPolicyEgressRuleArgs> Egress
        {
            get => _egress ?? (_egress = new InputList<Networking.V1.NetworkPolicyEgressRuleArgs>());
            set => _egress = value;
        }

        [Input("ingress")]
        private InputList<Networking.V1.NetworkPolicyIngressRuleArgs>? _ingress;

        /// <summary>
        /// List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if
        /// there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
        /// traffic), OR if the traffic source is the pod's local node, OR if the traffic matches at
        /// least one ingress rule across all of the NetworkPolicy objects whose podSelector matches
        /// the pod. If this field is empty then this NetworkPolicy does not allow any traffic (and
        /// serves solely to ensure that the pods it selects are isolated by default)
        /// </summary>
        public InputList<Networking.V1.NetworkPolicyIngressRuleArgs> Ingress
        {
            get => _ingress ?? (_ingress = new InputList<Networking.V1.NetworkPolicyIngressRuleArgs>());
            set => _ingress = value;
        }

        [Input("policyTypes")]
        private InputList<string>? _policyTypes;

        /// <summary>
        /// List of rule types that the NetworkPolicy relates to. Valid options are "Ingress",
        /// "Egress", or "Ingress,Egress". If this field is not specified, it will default based on
        /// the existence of Ingress or Egress rules; policies that contain an Egress section are
        /// assumed to affect Egress, and all policies (whether or not they contain an Ingress
        /// section) are assumed to affect Ingress. If you want to write an egress-only policy, you
        /// must explicitly specify policyTypes [ "Egress" ]. Likewise, if you want to write a
        /// policy that specifies that no egress is allowed, you must specify a policyTypes value
        /// that include "Egress" (since such a policy would not include an Egress section and would
        /// otherwise default to just [ "Ingress" ]). This field is beta-level in 1.8
        /// </summary>
        public InputList<string> PolicyTypes
        {
            get => _policyTypes ?? (_policyTypes = new InputList<string>());
            set => _policyTypes = value;
        }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are
    /// forwarded to the backend.
    /// </summary>
    public class HTTPIngressPathArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Backend defines the referenced service endpoint to which the traffic will be forwarded
        /// to.
        /// </summary>
        [Input("backend", required: true)]
        public Input<Networking.V1Beta1.IngressBackendArgs> Backend { get; set; } = null!;

        /// <summary>
        /// Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the
        /// egrep/unix syntax, not the perl syntax) matched against the path of an incoming request.
        /// Currently it can contain characters disallowed from the conventional "path" part of a
        /// URL as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path
        /// defaults to a catch all sending traffic to the backend.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

    }

    /// <summary>
    /// HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example:
    /// http://&amp;lt;host&amp;gt;/&amp;lt;path&amp;gt;?&amp;lt;searchpart&amp;gt; -&amp;gt;
    /// backend where where parts of the url correspond to RFC 3986, this resource will be used to
    /// match against everything after the last '/' and before the first '?' or '#'.
    /// </summary>
    public class HTTPIngressRuleValueArgs : Pulumi.ResourceArgs
    {
        [Input("paths", required: true)]
        private InputList<Networking.V1Beta1.HTTPIngressPathArgs>? _paths;

        /// <summary>
        /// A collection of paths that map requests to backends.
        /// </summary>
        public InputList<Networking.V1Beta1.HTTPIngressPathArgs> Paths
        {
            get => _paths ?? (_paths = new InputList<Networking.V1Beta1.HTTPIngressPathArgs>());
            set => _paths = value;
        }

    }

    /// <summary>
    /// Ingress is a collection of rules that allow inbound connections to reach the endpoints
    /// defined by a backend. An Ingress can be configured to give services externally-reachable
    /// urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
    /// </summary>
    public class IngressArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Spec is the desired state of the Ingress. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec")]
        public Input<Networking.V1Beta1.IngressSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// IngressBackend describes all endpoints for a given service and port.
    /// </summary>
    public class IngressBackendArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specifies the name of the referenced service.
        /// </summary>
        [Input("serviceName", required: true)]
        public Input<string> ServiceName { get; set; } = null!;

        /// <summary>
        /// Specifies the port of the referenced service.
        /// </summary>
        [Input("servicePort", required: true)]
        public InputUnion<int,string> ServicePort { get; set; } = null!;

    }

    /// <summary>
    /// IngressList is a collection of Ingress.
    /// </summary>
    public class IngressListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Networking.V1Beta1.IngressArgs>? _items;

        /// <summary>
        /// Items is the list of Ingress.
        /// </summary>
        public InputList<Networking.V1Beta1.IngressArgs> Items
        {
            get => _items ?? (_items = new InputList<Networking.V1Beta1.IngressArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// IngressRule represents the rules mapping the paths under a specified host to the related
    /// backend services. Incoming requests are first evaluated for a host match, then routed to the
    /// backend associated with the matching IngressRuleValue.
    /// </summary>
    public class IngressRuleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note
        /// the following deviations from the "host" part of the URI as defined in the RFC: 1. IPs
        /// are not allowed. Currently an IngressRuleValue can only apply to the
        /// 	  IP in the Spec of the parent Ingress.
        /// 2. The `:` delimiter is not respected because ports are not allowed.
        /// 	  Currently the port of an Ingress is implicitly :80 for http and
        /// 	  :443 for https.
        /// Both these may change in the future. Incoming requests are matched against the host
        /// before the IngressRuleValue. If the host is unspecified, the Ingress routes all traffic
        /// based on the specified IngressRuleValue.
        /// </summary>
        [Input("host")]
        public Input<string>? Host { get; set; }

        
        [Input("http")]
        public Input<Networking.V1Beta1.HTTPIngressRuleValueArgs>? Http { get; set; }

    }

    /// <summary>
    /// IngressSpec describes the Ingress the user wishes to exist.
    /// </summary>
    public class IngressSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A default backend capable of servicing requests that don't match any rule. At least one
        /// of 'backend' or 'rules' must be specified. This field is optional to allow the
        /// loadbalancer controller or defaulting logic to specify a global default.
        /// </summary>
        [Input("backend")]
        public Input<Networking.V1Beta1.IngressBackendArgs>? Backend { get; set; }

        [Input("rules")]
        private InputList<Networking.V1Beta1.IngressRuleArgs>? _rules;

        /// <summary>
        /// A list of host rules used to configure the Ingress. If unspecified, or no rule matches,
        /// all traffic is sent to the default backend.
        /// </summary>
        public InputList<Networking.V1Beta1.IngressRuleArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<Networking.V1Beta1.IngressRuleArgs>());
            set => _rules = value;
        }

        [Input("tls")]
        private InputList<Networking.V1Beta1.IngressTLSArgs>? _tls;

        /// <summary>
        /// TLS configuration. Currently the Ingress only supports a single TLS port, 443. If
        /// multiple members of this list specify different hosts, they will be multiplexed on the
        /// same port according to the hostname specified through the SNI TLS extension, if the
        /// ingress controller fulfilling the ingress supports SNI.
        /// </summary>
        public InputList<Networking.V1Beta1.IngressTLSArgs> Tls
        {
            get => _tls ?? (_tls = new InputList<Networking.V1Beta1.IngressTLSArgs>());
            set => _tls = value;
        }

    }

    /// <summary>
    /// IngressStatus describe the current state of the Ingress.
    /// </summary>
    public class IngressStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// LoadBalancer contains the current status of the load-balancer.
        /// </summary>
        [Input("loadBalancer")]
        public Input<Core.V1.LoadBalancerStatusArgs>? LoadBalancer { get; set; }

    }

    /// <summary>
    /// IngressTLS describes the transport layer security associated with an Ingress.
    /// </summary>
    public class IngressTLSArgs : Pulumi.ResourceArgs
    {
        [Input("hosts")]
        private InputList<string>? _hosts;

        /// <summary>
        /// Hosts are a list of hosts included in the TLS certificate. The values in this list must
        /// match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the
        /// loadbalancer controller fulfilling this Ingress, if left unspecified.
        /// </summary>
        public InputList<string> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<string>());
            set => _hosts = value;
        }

        /// <summary>
        /// SecretName is the name of the secret used to terminate SSL traffic on 443. Field is left
        /// optional to allow SSL routing based on SNI hostname alone. If the SNI host in a listener
        /// conflicts with the "Host" header field used by an IngressRule, the SNI host is used for
        /// termination and value of the Host header is used for routing.
        /// </summary>
        [Input("secretName")]
        public Input<string>? SecretName { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Node
{
  namespace V1Alpha1
  {
    /// <summary>
    /// Overhead structure represents the resource overhead associated with running a pod.
    /// </summary>
    public class OverheadArgs : Pulumi.ResourceArgs
    {
        [Input("podFixed")]
        private InputMap<string>? _podFixed;

        /// <summary>
        /// PodFixed represents the fixed resource overhead associated with running a pod.
        /// </summary>
        public InputMap<string> PodFixed
        {
            get => _podFixed ?? (_podFixed = new InputMap<string>());
            set => _podFixed = value;
        }

    }

    /// <summary>
    /// RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass
    /// is used to determine which container runtime is used to run all containers in a pod.
    /// RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and
    /// referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName
    /// reference before running the pod.  For more details, see
    /// https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
    /// </summary>
    public class RuntimeClassArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specification of the RuntimeClass More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
        [Input("spec", required: true)]
        public Input<Node.V1Alpha1.RuntimeClassSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RuntimeClassList is a list of RuntimeClass objects.
    /// </summary>
    public class RuntimeClassListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Node.V1Alpha1.RuntimeClassArgs>? _items;

        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public InputList<Node.V1Alpha1.RuntimeClassArgs> Items
        {
            get => _items ?? (_items = new InputList<Node.V1Alpha1.RuntimeClassArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RuntimeClassSpec is a specification of a RuntimeClass. It contains parameters that are
    /// required to describe the RuntimeClass to the Container Runtime Interface (CRI)
    /// implementation, as well as any other components that need to understand how the pod will be
    /// run. The RuntimeClassSpec is immutable.
    /// </summary>
    public class RuntimeClassSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RuntimeHandler specifies the underlying runtime and configuration that the CRI
        /// implementation will use to handle pods of this class. The possible values are specific
        /// to the node &amp; CRI configuration.  It is assumed that all handlers are available on
        /// every node, and handlers of the same name are equivalent on every node. For example, a
        /// handler called "runc" might specify that the runc OCI runtime (using native Linux
        /// containers) will be used to run the containers in a pod. The RuntimeHandler must conform
        /// to the DNS Label (RFC 1123) requirements and is immutable.
        /// </summary>
        [Input("runtimeHandler", required: true)]
        public Input<string> RuntimeHandler { get; set; } = null!;

        /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a given
        /// RuntimeClass. For more details, see
        /// https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
        /// alpha-level as of Kubernetes v1.15, and is only honored by servers that enable the
        /// PodOverhead feature.
        /// </summary>
        [Input("overhead")]
        public Input<Node.V1Alpha1.OverheadArgs>? Overhead { get; set; }

        /// <summary>
        /// Scheduling holds the scheduling constraints to ensure that pods running with this
        /// RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this
        /// RuntimeClass is assumed to be supported by all nodes.
        /// </summary>
        [Input("scheduling")]
        public Input<Node.V1Alpha1.SchedulingArgs>? Scheduling { get; set; }

    }

    /// <summary>
    /// Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.
    /// </summary>
    public class SchedulingArgs : Pulumi.ResourceArgs
    {
        [Input("nodeSelector")]
        private InputMap<string>? _nodeSelector;

        /// <summary>
        /// nodeSelector lists labels that must be present on nodes that support this RuntimeClass.
        /// Pods using this RuntimeClass can only be scheduled to a node matched by this selector.
        /// The RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any
        /// conflicts will cause the pod to be rejected in admission.
        /// </summary>
        public InputMap<string> NodeSelector
        {
            get => _nodeSelector ?? (_nodeSelector = new InputMap<string>());
            set => _nodeSelector = value;
        }

        [Input("tolerations")]
        private InputList<Core.V1.TolerationArgs>? _tolerations;

        /// <summary>
        /// tolerations are appended (excluding duplicates) to pods running with this RuntimeClass
        /// during admission, effectively unioning the set of nodes tolerated by the pod and the
        /// RuntimeClass.
        /// </summary>
        public InputList<Core.V1.TolerationArgs> Tolerations
        {
            get => _tolerations ?? (_tolerations = new InputList<Core.V1.TolerationArgs>());
            set => _tolerations = value;
        }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// Overhead structure represents the resource overhead associated with running a pod.
    /// </summary>
    public class OverheadArgs : Pulumi.ResourceArgs
    {
        [Input("podFixed")]
        private InputMap<string>? _podFixed;

        /// <summary>
        /// PodFixed represents the fixed resource overhead associated with running a pod.
        /// </summary>
        public InputMap<string> PodFixed
        {
            get => _podFixed ?? (_podFixed = new InputMap<string>());
            set => _podFixed = value;
        }

    }

    /// <summary>
    /// RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass
    /// is used to determine which container runtime is used to run all containers in a pod.
    /// RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and
    /// referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName
    /// reference before running the pod.  For more details, see
    /// https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
    /// </summary>
    public class RuntimeClassArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Handler specifies the underlying runtime and configuration that the CRI implementation
        /// will use to handle pods of this class. The possible values are specific to the node
        /// &amp; CRI configuration.  It is assumed that all handlers are available on every node,
        /// and handlers of the same name are equivalent on every node. For example, a handler
        /// called "runc" might specify that the runc OCI runtime (using native Linux containers)
        /// will be used to run the containers in a pod. The Handler must conform to the DNS Label
        /// (RFC 1123) requirements, and is immutable.
        /// </summary>
        [Input("handler", required: true)]
        public Input<string> Handler { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a given
        /// RuntimeClass. For more details, see
        /// https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
        /// alpha-level as of Kubernetes v1.15, and is only honored by servers that enable the
        /// PodOverhead feature.
        /// </summary>
        [Input("overhead")]
        public Input<Node.V1Beta1.OverheadArgs>? Overhead { get; set; }

        /// <summary>
        /// Scheduling holds the scheduling constraints to ensure that pods running with this
        /// RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this
        /// RuntimeClass is assumed to be supported by all nodes.
        /// </summary>
        [Input("scheduling")]
        public Input<Node.V1Beta1.SchedulingArgs>? Scheduling { get; set; }

    }

    /// <summary>
    /// RuntimeClassList is a list of RuntimeClass objects.
    /// </summary>
    public class RuntimeClassListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Node.V1Beta1.RuntimeClassArgs>? _items;

        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public InputList<Node.V1Beta1.RuntimeClassArgs> Items
        {
            get => _items ?? (_items = new InputList<Node.V1Beta1.RuntimeClassArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.
    /// </summary>
    public class SchedulingArgs : Pulumi.ResourceArgs
    {
        [Input("nodeSelector")]
        private InputMap<string>? _nodeSelector;

        /// <summary>
        /// nodeSelector lists labels that must be present on nodes that support this RuntimeClass.
        /// Pods using this RuntimeClass can only be scheduled to a node matched by this selector.
        /// The RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any
        /// conflicts will cause the pod to be rejected in admission.
        /// </summary>
        public InputMap<string> NodeSelector
        {
            get => _nodeSelector ?? (_nodeSelector = new InputMap<string>());
            set => _nodeSelector = value;
        }

        [Input("tolerations")]
        private InputList<Core.V1.TolerationArgs>? _tolerations;

        /// <summary>
        /// tolerations are appended (excluding duplicates) to pods running with this RuntimeClass
        /// during admission, effectively unioning the set of nodes tolerated by the pod and the
        /// RuntimeClass.
        /// </summary>
        public InputList<Core.V1.TolerationArgs> Tolerations
        {
            get => _tolerations ?? (_tolerations = new InputList<Core.V1.TolerationArgs>());
            set => _tolerations = value;
        }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Pkg
{
  namespace Version
  {
    /// <summary>
    /// Info contains versioning information. how we'll want to distribute that information.
    /// </summary>
    public class InfoArgs : Pulumi.ResourceArgs
    {
        
        [Input("buildDate", required: true)]
        public Input<string> BuildDate { get; set; } = null!;

        
        [Input("compiler", required: true)]
        public Input<string> Compiler { get; set; } = null!;

        
        [Input("gitCommit", required: true)]
        public Input<string> GitCommit { get; set; } = null!;

        
        [Input("gitTreeState", required: true)]
        public Input<string> GitTreeState { get; set; } = null!;

        
        [Input("gitVersion", required: true)]
        public Input<string> GitVersion { get; set; } = null!;

        
        [Input("goVersion", required: true)]
        public Input<string> GoVersion { get; set; } = null!;

        
        [Input("major", required: true)]
        public Input<string> Major { get; set; } = null!;

        
        [Input("minor", required: true)]
        public Input<string> Minor { get; set; } = null!;

        
        [Input("platform", required: true)]
        public Input<string> Platform { get; set; } = null!;

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Policy
{
  namespace V1Beta1
  {
    /// <summary>
    /// AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
    /// </summary>
    public class AllowedCSIDriverArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name is the registered name of the CSI driver
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
    /// </summary>
    public class AllowedFlexVolumeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// driver is the name of the Flexvolume driver.
        /// </summary>
        [Input("driver", required: true)]
        public Input<string> Driver { get; set; } = null!;

    }

    /// <summary>
    /// AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods
    /// to use. It requires the path prefix to be defined.
    /// </summary>
    public class AllowedHostPathArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// pathPrefix is the path prefix that the host volume must match. It does not support `*`.
        /// Trailing slashes are trimmed when validating the path prefix with a host path.
        /// 
        /// Examples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo` would not allow
        /// `/food` or `/etc/foo`
        /// </summary>
        [Input("pathPrefix")]
        public Input<string>? PathPrefix { get; set; }

        /// <summary>
        /// when set to true, will allow host volumes matching the pathPrefix only if all volume
        /// mounts are readOnly.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

    }

    /// <summary>
    /// Eviction evicts a pod from its node subject to certain policies and safety constraints. This
    /// is a subresource of Pod.  A request to cause such an eviction is created by POSTing to
    /// .../pods/&amp;lt;pod name&amp;gt;/evictions.
    /// </summary>
    public class EvictionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// DeleteOptions may be provided
        /// </summary>
        [Input("deleteOptions")]
        public Input<Meta.V1.DeleteOptionsArgs>? DeleteOptions { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// ObjectMeta describes the pod that is being evicted.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
    /// </summary>
    public class FSGroupStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        [Input("ranges")]
        private InputList<Policy.V1Beta1.IDRangeArgs>? _ranges;

        /// <summary>
        /// ranges are the allowed ranges of fs groups.  If you would like to force a single fs
        /// group then supply a single range with the same start and end. Required for MustRunAs.
        /// </summary>
        public InputList<Policy.V1Beta1.IDRangeArgs> Ranges
        {
            get => _ranges ?? (_ranges = new InputList<Policy.V1Beta1.IDRangeArgs>());
            set => _ranges = value;
        }

        /// <summary>
        /// rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
        /// </summary>
        [Input("rule")]
        public Input<string>? Rule { get; set; }

    }

    /// <summary>
    /// HostPortRange defines a range of host ports that will be enabled by a policy for pods to
    /// use.  It requires both the start and end to be defined.
    /// </summary>
    public class HostPortRangeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
        [Input("max", required: true)]
        public Input<int> Max { get; set; } = null!;

        /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
        [Input("min", required: true)]
        public Input<int> Min { get; set; } = null!;

    }

    /// <summary>
    /// IDRange provides a min/max of an allowed range of IDs.
    /// </summary>
    public class IDRangeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
        [Input("max", required: true)]
        public Input<int> Max { get; set; } = null!;

        /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
        [Input("min", required: true)]
        public Input<int> Min { get; set; } = null!;

    }

    /// <summary>
    /// PodDisruptionBudget is an object to define the max disruption that can be caused to a
    /// collection of pods
    /// </summary>
    public class PodDisruptionBudgetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// Specification of the desired behavior of the PodDisruptionBudget.
        /// </summary>
        [Input("spec")]
        public Input<Policy.V1Beta1.PodDisruptionBudgetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
    /// </summary>
    public class PodDisruptionBudgetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Policy.V1Beta1.PodDisruptionBudgetArgs>? _items;

        
        public InputList<Policy.V1Beta1.PodDisruptionBudgetArgs> Items
        {
            get => _items ?? (_items = new InputList<Policy.V1Beta1.PodDisruptionBudgetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
    /// </summary>
    public class PodDisruptionBudgetSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are
        /// unavailable after the eviction, i.e. even in absence of the evicted pod. For example,
        /// one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive
        /// setting with "minAvailable".
        /// </summary>
        [Input("maxUnavailable")]
        public InputUnion<int,string>? MaxUnavailable { get; set; }

        /// <summary>
        /// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still
        /// be available after the eviction, i.e. even in the absence of the evicted pod.  So for
        /// example you can prevent all voluntary evictions by specifying "100%".
        /// </summary>
        [Input("minAvailable")]
        public InputUnion<int,string>? MinAvailable { get; set; }

        /// <summary>
        /// Label query over pods whose evictions are managed by the disruption budget.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

    }

    /// <summary>
    /// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget.
    /// Status may trail the actual state of a system.
    /// </summary>
    public class PodDisruptionBudgetStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// current number of healthy pods
        /// </summary>
        [Input("currentHealthy", required: true)]
        public Input<int> CurrentHealthy { get; set; } = null!;

        /// <summary>
        /// minimum desired number of healthy pods
        /// </summary>
        [Input("desiredHealthy", required: true)]
        public Input<int> DesiredHealthy { get; set; } = null!;

        /// <summary>
        /// Number of pod disruptions that are currently allowed.
        /// </summary>
        [Input("disruptionsAllowed", required: true)]
        public Input<int> DisruptionsAllowed { get; set; } = null!;

        /// <summary>
        /// total number of pods counted by this disruption budget
        /// </summary>
        [Input("expectedPods", required: true)]
        public Input<int> ExpectedPods { get; set; } = null!;

        [Input("disruptedPods")]
        private InputMap<string>? _disruptedPods;

        /// <summary>
        /// DisruptedPods contains information about pods whose eviction was processed by the API
        /// server eviction subresource handler but has not yet been observed by the
        /// PodDisruptionBudget controller. A pod will be in this map from the time when the API
        /// server processed the eviction request to the time when the pod is seen by PDB controller
        /// as having been marked for deletion (or after a timeout). The key in the map is the name
        /// of the pod and the value is the time when the API server processed the eviction request.
        /// If the deletion didn't occur and a pod is still there it will be removed from the list
        /// automatically by PodDisruptionBudget controller after some time. If everything goes
        /// smooth this map should be empty for the most of the time. Large number of entries in the
        /// map may indicate problems with pod deletions.
        /// </summary>
        public InputMap<string> DisruptedPods
        {
            get => _disruptedPods ?? (_disruptedPods = new InputMap<string>());
            set => _disruptedPods = value;
        }

        /// <summary>
        /// Most recent generation observed when updating this PDB status. PodDisruptionsAllowed and
        /// other status informatio is valid only if observedGeneration equals to PDB's object
        /// generation.
        /// </summary>
        [Input("observedGeneration")]
        public Input<int>? ObservedGeneration { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicy governs the ability to make requests that affect the Security Context that
    /// will be applied to a pod and container.
    /// </summary>
    public class PodSecurityPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// spec defines the policy enforced.
        /// </summary>
        [Input("spec")]
        public Input<Policy.V1Beta1.PodSecurityPolicySpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicyList is a list of PodSecurityPolicy objects.
    /// </summary>
    public class PodSecurityPolicyListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Policy.V1Beta1.PodSecurityPolicyArgs>? _items;

        /// <summary>
        /// items is a list of schema objects.
        /// </summary>
        public InputList<Policy.V1Beta1.PodSecurityPolicyArgs> Items
        {
            get => _items ?? (_items = new InputList<Policy.V1Beta1.PodSecurityPolicyArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PodSecurityPolicySpec defines the policy enforced.
    /// </summary>
    public class PodSecurityPolicySpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
        [Input("fsGroup", required: true)]
        public Input<Policy.V1Beta1.FSGroupStrategyOptionsArgs> FsGroup { get; set; } = null!;

        /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be
        /// set.
        /// </summary>
        [Input("runAsUser", required: true)]
        public Input<Policy.V1Beta1.RunAsUserStrategyOptionsArgs> RunAsUser { get; set; } = null!;

        /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        [Input("seLinux", required: true)]
        public Input<Policy.V1Beta1.SELinuxStrategyOptionsArgs> SeLinux { get; set; } = null!;

        /// <summary>
        /// supplementalGroups is the strategy that will dictate what supplemental groups are used
        /// by the SecurityContext.
        /// </summary>
        [Input("supplementalGroups", required: true)]
        public Input<Policy.V1Beta1.SupplementalGroupsStrategyOptionsArgs> SupplementalGroups { get; set; } = null!;

        /// <summary>
        /// allowPrivilegeEscalation determines if a pod can request to allow privilege escalation.
        /// If unspecified, defaults to true.
        /// </summary>
        [Input("allowPrivilegeEscalation")]
        public Input<bool>? AllowPrivilegeEscalation { get; set; }

        [Input("allowedCSIDrivers")]
        private InputList<Policy.V1Beta1.AllowedCSIDriverArgs>? _allowedCSIDrivers;

        /// <summary>
        /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be
        /// embedded within a pod spec. An empty value indicates that any CSI driver can be used for
        /// inline ephemeral volumes. This is an alpha field, and is only honored if the API server
        /// enables the CSIInlineVolume feature gate.
        /// </summary>
        public InputList<Policy.V1Beta1.AllowedCSIDriverArgs> AllowedCSIDrivers
        {
            get => _allowedCSIDrivers ?? (_allowedCSIDrivers = new InputList<Policy.V1Beta1.AllowedCSIDriverArgs>());
            set => _allowedCSIDrivers = value;
        }

        [Input("allowedCapabilities")]
        private InputList<string>? _allowedCapabilities;

        /// <summary>
        /// allowedCapabilities is a list of capabilities that can be requested to add to the
        /// container. Capabilities in this field may be added at the pod author's discretion. You
        /// must not list a capability in both allowedCapabilities and requiredDropCapabilities.
        /// </summary>
        public InputList<string> AllowedCapabilities
        {
            get => _allowedCapabilities ?? (_allowedCapabilities = new InputList<string>());
            set => _allowedCapabilities = value;
        }

        [Input("allowedFlexVolumes")]
        private InputList<Policy.V1Beta1.AllowedFlexVolumeArgs>? _allowedFlexVolumes;

        /// <summary>
        /// allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that
        /// all Flexvolumes may be used.  This parameter is effective only when the usage of the
        /// Flexvolumes is allowed in the "volumes" field.
        /// </summary>
        public InputList<Policy.V1Beta1.AllowedFlexVolumeArgs> AllowedFlexVolumes
        {
            get => _allowedFlexVolumes ?? (_allowedFlexVolumes = new InputList<Policy.V1Beta1.AllowedFlexVolumeArgs>());
            set => _allowedFlexVolumes = value;
        }

        [Input("allowedHostPaths")]
        private InputList<Policy.V1Beta1.AllowedHostPathArgs>? _allowedHostPaths;

        /// <summary>
        /// allowedHostPaths is a white list of allowed host paths. Empty indicates that all host
        /// paths may be used.
        /// </summary>
        public InputList<Policy.V1Beta1.AllowedHostPathArgs> AllowedHostPaths
        {
            get => _allowedHostPaths ?? (_allowedHostPaths = new InputList<Policy.V1Beta1.AllowedHostPathArgs>());
            set => _allowedHostPaths = value;
        }

        [Input("allowedProcMountTypes")]
        private InputList<string>? _allowedProcMountTypes;

        /// <summary>
        /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates
        /// that only the DefaultProcMountType may be used. This requires the ProcMountType feature
        /// flag to be enabled.
        /// </summary>
        public InputList<string> AllowedProcMountTypes
        {
            get => _allowedProcMountTypes ?? (_allowedProcMountTypes = new InputList<string>());
            set => _allowedProcMountTypes = value;
        }

        [Input("allowedUnsafeSysctls")]
        private InputList<string>? _allowedUnsafeSysctls;

        /// <summary>
        /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
        /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
        /// as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet
        /// has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
        /// 
        /// Examples: e.g. "foo/*" allows "foo/bar", "foo/baz", etc. e.g. "foo.*" allows "foo.bar",
        /// "foo.baz", etc.
        /// </summary>
        public InputList<string> AllowedUnsafeSysctls
        {
            get => _allowedUnsafeSysctls ?? (_allowedUnsafeSysctls = new InputList<string>());
            set => _allowedUnsafeSysctls = value;
        }

        [Input("defaultAddCapabilities")]
        private InputList<string>? _defaultAddCapabilities;

        /// <summary>
        /// defaultAddCapabilities is the default set of capabilities that will be added to the
        /// container unless the pod spec specifically drops the capability.  You may not list a
        /// capability in both defaultAddCapabilities and requiredDropCapabilities. Capabilities
        /// added here are implicitly allowed, and need not be included in the allowedCapabilities
        /// list.
        /// </summary>
        public InputList<string> DefaultAddCapabilities
        {
            get => _defaultAddCapabilities ?? (_defaultAddCapabilities = new InputList<string>());
            set => _defaultAddCapabilities = value;
        }

        /// <summary>
        /// defaultAllowPrivilegeEscalation controls the default setting for whether a process can
        /// gain more privileges than its parent process.
        /// </summary>
        [Input("defaultAllowPrivilegeEscalation")]
        public Input<bool>? DefaultAllowPrivilegeEscalation { get; set; }

        [Input("forbiddenSysctls")]
        private InputList<string>? _forbiddenSysctls;

        /// <summary>
        /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry
        /// is either a plain sysctl name or ends in "*" in which case it is considered as a prefix
        /// of forbidden sysctls. Single * means all sysctls are forbidden.
        /// 
        /// Examples: e.g. "foo/*" forbids "foo/bar", "foo/baz", etc. e.g. "foo.*" forbids
        /// "foo.bar", "foo.baz", etc.
        /// </summary>
        public InputList<string> ForbiddenSysctls
        {
            get => _forbiddenSysctls ?? (_forbiddenSysctls = new InputList<string>());
            set => _forbiddenSysctls = value;
        }

        /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
        [Input("hostIPC")]
        public Input<bool>? HostIPC { get; set; }

        /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
        [Input("hostNetwork")]
        public Input<bool>? HostNetwork { get; set; }

        /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
        [Input("hostPID")]
        public Input<bool>? HostPID { get; set; }

        [Input("hostPorts")]
        private InputList<Policy.V1Beta1.HostPortRangeArgs>? _hostPorts;

        /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
        public InputList<Policy.V1Beta1.HostPortRangeArgs> HostPorts
        {
            get => _hostPorts ?? (_hostPorts = new InputList<Policy.V1Beta1.HostPortRangeArgs>());
            set => _hostPorts = value;
        }

        /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// readOnlyRootFilesystem when set to true will force containers to run with a read only
        /// root file system.  If the container specifically requests to run with a non-read only
        /// root file system the PSP should deny the pod. If set to false the container may run with
        /// a read only root file system if it wishes but it will not be forced to.
        /// </summary>
        [Input("readOnlyRootFilesystem")]
        public Input<bool>? ReadOnlyRootFilesystem { get; set; }

        [Input("requiredDropCapabilities")]
        private InputList<string>? _requiredDropCapabilities;

        /// <summary>
        /// requiredDropCapabilities are the capabilities that will be dropped from the container.
        /// These are required to be dropped and cannot be added.
        /// </summary>
        public InputList<string> RequiredDropCapabilities
        {
            get => _requiredDropCapabilities ?? (_requiredDropCapabilities = new InputList<string>());
            set => _requiredDropCapabilities = value;
        }

        /// <summary>
        /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be
        /// set. If this field is omitted, the pod's RunAsGroup can take any value. This field
        /// requires the RunAsGroup feature gate to be enabled.
        /// </summary>
        [Input("runAsGroup")]
        public Input<Policy.V1Beta1.RunAsGroupStrategyOptionsArgs>? RunAsGroup { get; set; }

        /// <summary>
        /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
        /// If this field is omitted, the pod's runtimeClassName field is unrestricted. Enforcement
        /// of this field depends on the RuntimeClass feature gate being enabled.
        /// </summary>
        [Input("runtimeClass")]
        public Input<Policy.V1Beta1.RuntimeClassStrategyOptionsArgs>? RuntimeClass { get; set; }

        [Input("volumes")]
        private InputList<string>? _volumes;

        /// <summary>
        /// volumes is a white list of allowed volume plugins. Empty indicates that no volumes may
        /// be used. To allow all volumes you may use '*'.
        /// </summary>
        public InputList<string> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<string>());
            set => _volumes = value;
        }

    }

    /// <summary>
    /// RunAsGroupStrategyOptions defines the strategy type and any options used to create the
    /// strategy.
    /// </summary>
    public class RunAsGroupStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
        /// </summary>
        [Input("rule", required: true)]
        public Input<string> Rule { get; set; } = null!;

        [Input("ranges")]
        private InputList<Policy.V1Beta1.IDRangeArgs>? _ranges;

        /// <summary>
        /// ranges are the allowed ranges of gids that may be used. If you would like to force a
        /// single gid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
        public InputList<Policy.V1Beta1.IDRangeArgs> Ranges
        {
            get => _ranges ?? (_ranges = new InputList<Policy.V1Beta1.IDRangeArgs>());
            set => _ranges = value;
        }

    }

    /// <summary>
    /// RunAsUserStrategyOptions defines the strategy type and any options used to create the
    /// strategy.
    /// </summary>
    public class RunAsUserStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
        [Input("rule", required: true)]
        public Input<string> Rule { get; set; } = null!;

        [Input("ranges")]
        private InputList<Policy.V1Beta1.IDRangeArgs>? _ranges;

        /// <summary>
        /// ranges are the allowed ranges of uids that may be used. If you would like to force a
        /// single uid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
        public InputList<Policy.V1Beta1.IDRangeArgs> Ranges
        {
            get => _ranges ?? (_ranges = new InputList<Policy.V1Beta1.IDRangeArgs>());
            set => _ranges = value;
        }

    }

    /// <summary>
    /// RuntimeClassStrategyOptions define the strategy that will dictate the allowable
    /// RuntimeClasses for a pod.
    /// </summary>
    public class RuntimeClassStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        [Input("allowedRuntimeClassNames", required: true)]
        private InputList<string>? _allowedRuntimeClassNames;

        /// <summary>
        /// allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a
        /// pod. A value of "*" means that any RuntimeClass name is allowed, and must be the only
        /// item in the list. An empty list requires the RuntimeClassName field to be unset.
        /// </summary>
        public InputList<string> AllowedRuntimeClassNames
        {
            get => _allowedRuntimeClassNames ?? (_allowedRuntimeClassNames = new InputList<string>());
            set => _allowedRuntimeClassNames = value;
        }

        /// <summary>
        /// defaultRuntimeClassName is the default RuntimeClassName to set on the pod. The default
        /// MUST be allowed by the allowedRuntimeClassNames list. A value of nil does not mutate the
        /// Pod.
        /// </summary>
        [Input("defaultRuntimeClassName")]
        public Input<string>? DefaultRuntimeClassName { get; set; }

    }

    /// <summary>
    /// SELinuxStrategyOptions defines the strategy type and any options used to create the
    /// strategy.
    /// </summary>
    public class SELinuxStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// rule is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        [Input("rule", required: true)]
        public Input<string> Rule { get; set; } = null!;

        /// <summary>
        /// seLinuxOptions required to run as; required for MustRunAs More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        [Input("seLinuxOptions")]
        public Input<Core.V1.SELinuxOptionsArgs>? SeLinuxOptions { get; set; }

    }

    /// <summary>
    /// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the
    /// strategy.
    /// </summary>
    public class SupplementalGroupsStrategyOptionsArgs : Pulumi.ResourceArgs
    {
        [Input("ranges")]
        private InputList<Policy.V1Beta1.IDRangeArgs>? _ranges;

        /// <summary>
        /// ranges are the allowed ranges of supplemental groups.  If you would like to force a
        /// single supplemental group then supply a single range with the same start and end.
        /// Required for MustRunAs.
        /// </summary>
        public InputList<Policy.V1Beta1.IDRangeArgs> Ranges
        {
            get => _ranges ?? (_ranges = new InputList<Policy.V1Beta1.IDRangeArgs>());
            set => _ranges = value;
        }

        /// <summary>
        /// rule is the strategy that will dictate what supplemental groups is used in the
        /// SecurityContext.
        /// </summary>
        [Input("rule")]
        public Input<string>? Rule { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Rbac
{
  namespace V1
  {
    /// <summary>
    /// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
    /// </summary>
    public class AggregationRuleArgs : Pulumi.ResourceArgs
    {
        [Input("clusterRoleSelectors")]
        private InputList<Meta.V1.LabelSelectorArgs>? _clusterRoleSelectors;

        /// <summary>
        /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles
        /// and create the rules. If any of the selectors match, then the ClusterRole's permissions
        /// will be added
        /// </summary>
        public InputList<Meta.V1.LabelSelectorArgs> ClusterRoleSelectors
        {
            get => _clusterRoleSelectors ?? (_clusterRoleSelectors = new InputList<Meta.V1.LabelSelectorArgs>());
            set => _clusterRoleSelectors = value;
        }

    }

    /// <summary>
    /// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
    /// unit by a RoleBinding or ClusterRoleBinding.
    /// </summary>
    public class ClusterRoleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// AggregationRule is an optional field that describes how to build the Rules for this
        /// ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
        /// changes to Rules will be stomped by the controller.
        /// </summary>
        [Input("aggregationRule")]
        public Input<Rbac.V1.AggregationRuleArgs>? AggregationRule { get; set; }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("rules")]
        private InputList<Rbac.V1.PolicyRuleArgs>? _rules;

        /// <summary>
        /// Rules holds all the PolicyRules for this ClusterRole
        /// </summary>
        public InputList<Rbac.V1.PolicyRuleArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<Rbac.V1.PolicyRuleArgs>());
            set => _rules = value;
        }

    }

    /// <summary>
    /// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
    /// ClusterRole in the global namespace, and adds who information via Subject.
    /// </summary>
    public class ClusterRoleBindingArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot
        /// be resolved, the Authorizer must return an error.
        /// </summary>
        [Input("roleRef", required: true)]
        public Input<Rbac.V1.RoleRefArgs> RoleRef { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("subjects")]
        private InputList<Rbac.V1.SubjectArgs>? _subjects;

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public InputList<Rbac.V1.SubjectArgs> Subjects
        {
            get => _subjects ?? (_subjects = new InputList<Rbac.V1.SubjectArgs>());
            set => _subjects = value;
        }

    }

    /// <summary>
    /// ClusterRoleBindingList is a collection of ClusterRoleBindings
    /// </summary>
    public class ClusterRoleBindingListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1.ClusterRoleBindingArgs>? _items;

        /// <summary>
        /// Items is a list of ClusterRoleBindings
        /// </summary>
        public InputList<Rbac.V1.ClusterRoleBindingArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1.ClusterRoleBindingArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ClusterRoleList is a collection of ClusterRoles
    /// </summary>
    public class ClusterRoleListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1.ClusterRoleArgs>? _items;

        /// <summary>
        /// Items is a list of ClusterRoles
        /// </summary>
        public InputList<Rbac.V1.ClusterRoleArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1.ClusterRoleArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PolicyRule holds information that describes a policy rule, but does not contain information
    /// about who the rule applies to or which namespace the rule applies to.
    /// </summary>
    public class PolicyRuleArgs : Pulumi.ResourceArgs
    {
        [Input("verbs", required: true)]
        private InputList<string>? _verbs;

        /// <summary>
        /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
        /// contained in this rule.  VerbAll represents all kinds.
        /// </summary>
        public InputList<string> Verbs
        {
            get => _verbs ?? (_verbs = new InputList<string>());
            set => _verbs = value;
        }

        [Input("apiGroups")]
        private InputList<string>? _apiGroups;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.
        /// </summary>
        public InputList<string> ApiGroups
        {
            get => _apiGroups ?? (_apiGroups = new InputList<string>());
            set => _apiGroups = value;
        }

        [Input("nonResourceURLs")]
        private InputList<string>? _nonResourceURLs;

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path Since non-resource URLs are not
        /// namespaced, this field is only applicable for ClusterRoles referenced from a
        /// ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or
        /// "secrets") or non-resource URL paths (such as "/api"),  but not both.
        /// </summary>
        public InputList<string> NonResourceURLs
        {
            get => _nonResourceURLs ?? (_nonResourceURLs = new InputList<string>());
            set => _nonResourceURLs = value;
        }

        [Input("resourceNames")]
        private InputList<string>? _resourceNames;

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.
        /// </summary>
        public InputList<string> ResourceNames
        {
            get => _resourceNames ?? (_resourceNames = new InputList<string>());
            set => _resourceNames = value;
        }

        [Input("resources")]
        private InputList<string>? _resources;

        /// <summary>
        /// Resources is a list of resources this rule applies to.  ResourceAll represents all
        /// resources.
        /// </summary>
        public InputList<string> Resources
        {
            get => _resources ?? (_resources = new InputList<string>());
            set => _resources = value;
        }

    }

    /// <summary>
    /// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
    /// RoleBinding.
    /// </summary>
    public class RoleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("rules")]
        private InputList<Rbac.V1.PolicyRuleArgs>? _rules;

        /// <summary>
        /// Rules holds all the PolicyRules for this Role
        /// </summary>
        public InputList<Rbac.V1.PolicyRuleArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<Rbac.V1.PolicyRuleArgs>());
            set => _rules = value;
        }

    }

    /// <summary>
    /// RoleBinding references a role, but does not contain it.  It can reference a Role in the same
    /// namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
    /// namespace information by which namespace it exists in.  RoleBindings in a given namespace
    /// only have effect in that namespace.
    /// </summary>
    public class RoleBindingArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global
        /// namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
        /// </summary>
        [Input("roleRef", required: true)]
        public Input<Rbac.V1.RoleRefArgs> RoleRef { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("subjects")]
        private InputList<Rbac.V1.SubjectArgs>? _subjects;

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public InputList<Rbac.V1.SubjectArgs> Subjects
        {
            get => _subjects ?? (_subjects = new InputList<Rbac.V1.SubjectArgs>());
            set => _subjects = value;
        }

    }

    /// <summary>
    /// RoleBindingList is a collection of RoleBindings
    /// </summary>
    public class RoleBindingListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1.RoleBindingArgs>? _items;

        /// <summary>
        /// Items is a list of RoleBindings
        /// </summary>
        public InputList<Rbac.V1.RoleBindingArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1.RoleBindingArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleList is a collection of Roles
    /// </summary>
    public class RoleListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1.RoleArgs>? _items;

        /// <summary>
        /// Items is a list of Roles
        /// </summary>
        public InputList<Rbac.V1.RoleArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1.RoleArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleRef contains information that points to the role being used
    /// </summary>
    public class RoleRefArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIGroup is the group for the resource being referenced
        /// </summary>
        [Input("apiGroup", required: true)]
        public Input<string> ApiGroup { get; set; } = null!;

        /// <summary>
        /// Kind is the type of resource being referenced
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// Subject contains a reference to the object or user identities a role binding applies to.
    /// This can either hold a direct API object reference, or a value for non-objects such as user
    /// and group names.
    /// </summary>
    public class SubjectArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Kind of object being referenced. Values defined by this API group are "User", "Group",
        /// and "ServiceAccount". If the Authorizer does not recognized the kind value, the
        /// Authorizer should report an error.
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name of the object being referenced.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// APIGroup holds the API group of the referenced subject. Defaults to "" for
        /// ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group
        /// subjects.
        /// </summary>
        [Input("apiGroup")]
        public Input<string>? ApiGroup { get; set; }

        /// <summary>
        /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User"
        /// or "Group", and this value is not empty the Authorizer should report an error.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

    }

  }

  namespace V1Alpha1
  {
    /// <summary>
    /// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
    /// </summary>
    public class AggregationRuleArgs : Pulumi.ResourceArgs
    {
        [Input("clusterRoleSelectors")]
        private InputList<Meta.V1.LabelSelectorArgs>? _clusterRoleSelectors;

        /// <summary>
        /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles
        /// and create the rules. If any of the selectors match, then the ClusterRole's permissions
        /// will be added
        /// </summary>
        public InputList<Meta.V1.LabelSelectorArgs> ClusterRoleSelectors
        {
            get => _clusterRoleSelectors ?? (_clusterRoleSelectors = new InputList<Meta.V1.LabelSelectorArgs>());
            set => _clusterRoleSelectors = value;
        }

    }

    /// <summary>
    /// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
    /// unit by a RoleBinding or ClusterRoleBinding.
    /// </summary>
    public class ClusterRoleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// AggregationRule is an optional field that describes how to build the Rules for this
        /// ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
        /// changes to Rules will be stomped by the controller.
        /// </summary>
        [Input("aggregationRule")]
        public Input<Rbac.V1Alpha1.AggregationRuleArgs>? AggregationRule { get; set; }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("rules")]
        private InputList<Rbac.V1Alpha1.PolicyRuleArgs>? _rules;

        /// <summary>
        /// Rules holds all the PolicyRules for this ClusterRole
        /// </summary>
        public InputList<Rbac.V1Alpha1.PolicyRuleArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<Rbac.V1Alpha1.PolicyRuleArgs>());
            set => _rules = value;
        }

    }

    /// <summary>
    /// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
    /// ClusterRole in the global namespace, and adds who information via Subject.
    /// </summary>
    public class ClusterRoleBindingArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot
        /// be resolved, the Authorizer must return an error.
        /// </summary>
        [Input("roleRef", required: true)]
        public Input<Rbac.V1Alpha1.RoleRefArgs> RoleRef { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("subjects")]
        private InputList<Rbac.V1Alpha1.SubjectArgs>? _subjects;

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public InputList<Rbac.V1Alpha1.SubjectArgs> Subjects
        {
            get => _subjects ?? (_subjects = new InputList<Rbac.V1Alpha1.SubjectArgs>());
            set => _subjects = value;
        }

    }

    /// <summary>
    /// ClusterRoleBindingList is a collection of ClusterRoleBindings
    /// </summary>
    public class ClusterRoleBindingListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1Alpha1.ClusterRoleBindingArgs>? _items;

        /// <summary>
        /// Items is a list of ClusterRoleBindings
        /// </summary>
        public InputList<Rbac.V1Alpha1.ClusterRoleBindingArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1Alpha1.ClusterRoleBindingArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ClusterRoleList is a collection of ClusterRoles
    /// </summary>
    public class ClusterRoleListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1Alpha1.ClusterRoleArgs>? _items;

        /// <summary>
        /// Items is a list of ClusterRoles
        /// </summary>
        public InputList<Rbac.V1Alpha1.ClusterRoleArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1Alpha1.ClusterRoleArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PolicyRule holds information that describes a policy rule, but does not contain information
    /// about who the rule applies to or which namespace the rule applies to.
    /// </summary>
    public class PolicyRuleArgs : Pulumi.ResourceArgs
    {
        [Input("verbs", required: true)]
        private InputList<string>? _verbs;

        /// <summary>
        /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
        /// contained in this rule.  VerbAll represents all kinds.
        /// </summary>
        public InputList<string> Verbs
        {
            get => _verbs ?? (_verbs = new InputList<string>());
            set => _verbs = value;
        }

        [Input("apiGroups")]
        private InputList<string>? _apiGroups;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.
        /// </summary>
        public InputList<string> ApiGroups
        {
            get => _apiGroups ?? (_apiGroups = new InputList<string>());
            set => _apiGroups = value;
        }

        [Input("nonResourceURLs")]
        private InputList<string>? _nonResourceURLs;

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path This name is intentionally
        /// different than the internal type so that the DefaultConvert works nicely and because the
        /// ordering may be different. Since non-resource URLs are not namespaced, this field is
        /// only applicable for ClusterRoles referenced from a ClusterRoleBinding. Rules can either
        /// apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as
        /// "/api"),  but not both.
        /// </summary>
        public InputList<string> NonResourceURLs
        {
            get => _nonResourceURLs ?? (_nonResourceURLs = new InputList<string>());
            set => _nonResourceURLs = value;
        }

        [Input("resourceNames")]
        private InputList<string>? _resourceNames;

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.
        /// </summary>
        public InputList<string> ResourceNames
        {
            get => _resourceNames ?? (_resourceNames = new InputList<string>());
            set => _resourceNames = value;
        }

        [Input("resources")]
        private InputList<string>? _resources;

        /// <summary>
        /// Resources is a list of resources this rule applies to.  ResourceAll represents all
        /// resources.
        /// </summary>
        public InputList<string> Resources
        {
            get => _resources ?? (_resources = new InputList<string>());
            set => _resources = value;
        }

    }

    /// <summary>
    /// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
    /// RoleBinding.
    /// </summary>
    public class RoleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("rules")]
        private InputList<Rbac.V1Alpha1.PolicyRuleArgs>? _rules;

        /// <summary>
        /// Rules holds all the PolicyRules for this Role
        /// </summary>
        public InputList<Rbac.V1Alpha1.PolicyRuleArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<Rbac.V1Alpha1.PolicyRuleArgs>());
            set => _rules = value;
        }

    }

    /// <summary>
    /// RoleBinding references a role, but does not contain it.  It can reference a Role in the same
    /// namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
    /// namespace information by which namespace it exists in.  RoleBindings in a given namespace
    /// only have effect in that namespace.
    /// </summary>
    public class RoleBindingArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global
        /// namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
        /// </summary>
        [Input("roleRef", required: true)]
        public Input<Rbac.V1Alpha1.RoleRefArgs> RoleRef { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("subjects")]
        private InputList<Rbac.V1Alpha1.SubjectArgs>? _subjects;

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public InputList<Rbac.V1Alpha1.SubjectArgs> Subjects
        {
            get => _subjects ?? (_subjects = new InputList<Rbac.V1Alpha1.SubjectArgs>());
            set => _subjects = value;
        }

    }

    /// <summary>
    /// RoleBindingList is a collection of RoleBindings
    /// </summary>
    public class RoleBindingListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1Alpha1.RoleBindingArgs>? _items;

        /// <summary>
        /// Items is a list of RoleBindings
        /// </summary>
        public InputList<Rbac.V1Alpha1.RoleBindingArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1Alpha1.RoleBindingArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleList is a collection of Roles
    /// </summary>
    public class RoleListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1Alpha1.RoleArgs>? _items;

        /// <summary>
        /// Items is a list of Roles
        /// </summary>
        public InputList<Rbac.V1Alpha1.RoleArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1Alpha1.RoleArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleRef contains information that points to the role being used
    /// </summary>
    public class RoleRefArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIGroup is the group for the resource being referenced
        /// </summary>
        [Input("apiGroup", required: true)]
        public Input<string> ApiGroup { get; set; } = null!;

        /// <summary>
        /// Kind is the type of resource being referenced
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// Subject contains a reference to the object or user identities a role binding applies to.
    /// This can either hold a direct API object reference, or a value for non-objects such as user
    /// and group names.
    /// </summary>
    public class SubjectArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Kind of object being referenced. Values defined by this API group are "User", "Group",
        /// and "ServiceAccount". If the Authorizer does not recognized the kind value, the
        /// Authorizer should report an error.
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name of the object being referenced.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// APIVersion holds the API group and version of the referenced subject. Defaults to "v1"
        /// for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io/v1alpha1" for User
        /// and Group subjects.
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User"
        /// or "Group", and this value is not empty the Authorizer should report an error.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
    /// </summary>
    public class AggregationRuleArgs : Pulumi.ResourceArgs
    {
        [Input("clusterRoleSelectors")]
        private InputList<Meta.V1.LabelSelectorArgs>? _clusterRoleSelectors;

        /// <summary>
        /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles
        /// and create the rules. If any of the selectors match, then the ClusterRole's permissions
        /// will be added
        /// </summary>
        public InputList<Meta.V1.LabelSelectorArgs> ClusterRoleSelectors
        {
            get => _clusterRoleSelectors ?? (_clusterRoleSelectors = new InputList<Meta.V1.LabelSelectorArgs>());
            set => _clusterRoleSelectors = value;
        }

    }

    /// <summary>
    /// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
    /// unit by a RoleBinding or ClusterRoleBinding.
    /// </summary>
    public class ClusterRoleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// AggregationRule is an optional field that describes how to build the Rules for this
        /// ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
        /// changes to Rules will be stomped by the controller.
        /// </summary>
        [Input("aggregationRule")]
        public Input<Rbac.V1Beta1.AggregationRuleArgs>? AggregationRule { get; set; }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("rules")]
        private InputList<Rbac.V1Beta1.PolicyRuleArgs>? _rules;

        /// <summary>
        /// Rules holds all the PolicyRules for this ClusterRole
        /// </summary>
        public InputList<Rbac.V1Beta1.PolicyRuleArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<Rbac.V1Beta1.PolicyRuleArgs>());
            set => _rules = value;
        }

    }

    /// <summary>
    /// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
    /// ClusterRole in the global namespace, and adds who information via Subject.
    /// </summary>
    public class ClusterRoleBindingArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot
        /// be resolved, the Authorizer must return an error.
        /// </summary>
        [Input("roleRef", required: true)]
        public Input<Rbac.V1Beta1.RoleRefArgs> RoleRef { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("subjects")]
        private InputList<Rbac.V1Beta1.SubjectArgs>? _subjects;

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public InputList<Rbac.V1Beta1.SubjectArgs> Subjects
        {
            get => _subjects ?? (_subjects = new InputList<Rbac.V1Beta1.SubjectArgs>());
            set => _subjects = value;
        }

    }

    /// <summary>
    /// ClusterRoleBindingList is a collection of ClusterRoleBindings
    /// </summary>
    public class ClusterRoleBindingListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1Beta1.ClusterRoleBindingArgs>? _items;

        /// <summary>
        /// Items is a list of ClusterRoleBindings
        /// </summary>
        public InputList<Rbac.V1Beta1.ClusterRoleBindingArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1Beta1.ClusterRoleBindingArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// ClusterRoleList is a collection of ClusterRoles
    /// </summary>
    public class ClusterRoleListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1Beta1.ClusterRoleArgs>? _items;

        /// <summary>
        /// Items is a list of ClusterRoles
        /// </summary>
        public InputList<Rbac.V1Beta1.ClusterRoleArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1Beta1.ClusterRoleArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PolicyRule holds information that describes a policy rule, but does not contain information
    /// about who the rule applies to or which namespace the rule applies to.
    /// </summary>
    public class PolicyRuleArgs : Pulumi.ResourceArgs
    {
        [Input("verbs", required: true)]
        private InputList<string>? _verbs;

        /// <summary>
        /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
        /// contained in this rule.  VerbAll represents all kinds.
        /// </summary>
        public InputList<string> Verbs
        {
            get => _verbs ?? (_verbs = new InputList<string>());
            set => _verbs = value;
        }

        [Input("apiGroups")]
        private InputList<string>? _apiGroups;

        /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.
        /// </summary>
        public InputList<string> ApiGroups
        {
            get => _apiGroups ?? (_apiGroups = new InputList<string>());
            set => _apiGroups = value;
        }

        [Input("nonResourceURLs")]
        private InputList<string>? _nonResourceURLs;

        /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path Since non-resource URLs are not
        /// namespaced, this field is only applicable for ClusterRoles referenced from a
        /// ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or
        /// "secrets") or non-resource URL paths (such as "/api"),  but not both.
        /// </summary>
        public InputList<string> NonResourceURLs
        {
            get => _nonResourceURLs ?? (_nonResourceURLs = new InputList<string>());
            set => _nonResourceURLs = value;
        }

        [Input("resourceNames")]
        private InputList<string>? _resourceNames;

        /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.
        /// </summary>
        public InputList<string> ResourceNames
        {
            get => _resourceNames ?? (_resourceNames = new InputList<string>());
            set => _resourceNames = value;
        }

        [Input("resources")]
        private InputList<string>? _resources;

        /// <summary>
        /// Resources is a list of resources this rule applies to.  '*' represents all resources in
        /// the specified apiGroups. '*/foo' represents the subresource 'foo' for all resources in
        /// the specified apiGroups.
        /// </summary>
        public InputList<string> Resources
        {
            get => _resources ?? (_resources = new InputList<string>());
            set => _resources = value;
        }

    }

    /// <summary>
    /// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
    /// RoleBinding.
    /// </summary>
    public class RoleArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("rules")]
        private InputList<Rbac.V1Beta1.PolicyRuleArgs>? _rules;

        /// <summary>
        /// Rules holds all the PolicyRules for this Role
        /// </summary>
        public InputList<Rbac.V1Beta1.PolicyRuleArgs> Rules
        {
            get => _rules ?? (_rules = new InputList<Rbac.V1Beta1.PolicyRuleArgs>());
            set => _rules = value;
        }

    }

    /// <summary>
    /// RoleBinding references a role, but does not contain it.  It can reference a Role in the same
    /// namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
    /// namespace information by which namespace it exists in.  RoleBindings in a given namespace
    /// only have effect in that namespace.
    /// </summary>
    public class RoleBindingArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global
        /// namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
        /// </summary>
        [Input("roleRef", required: true)]
        public Input<Rbac.V1Beta1.RoleRefArgs> RoleRef { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("subjects")]
        private InputList<Rbac.V1Beta1.SubjectArgs>? _subjects;

        /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
        public InputList<Rbac.V1Beta1.SubjectArgs> Subjects
        {
            get => _subjects ?? (_subjects = new InputList<Rbac.V1Beta1.SubjectArgs>());
            set => _subjects = value;
        }

    }

    /// <summary>
    /// RoleBindingList is a collection of RoleBindings
    /// </summary>
    public class RoleBindingListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1Beta1.RoleBindingArgs>? _items;

        /// <summary>
        /// Items is a list of RoleBindings
        /// </summary>
        public InputList<Rbac.V1Beta1.RoleBindingArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1Beta1.RoleBindingArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleList is a collection of Roles
    /// </summary>
    public class RoleListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Rbac.V1Beta1.RoleArgs>? _items;

        /// <summary>
        /// Items is a list of Roles
        /// </summary>
        public InputList<Rbac.V1Beta1.RoleArgs> Items
        {
            get => _items ?? (_items = new InputList<Rbac.V1Beta1.RoleArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// RoleRef contains information that points to the role being used
    /// </summary>
    public class RoleRefArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIGroup is the group for the resource being referenced
        /// </summary>
        [Input("apiGroup", required: true)]
        public Input<string> ApiGroup { get; set; } = null!;

        /// <summary>
        /// Kind is the type of resource being referenced
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

    }

    /// <summary>
    /// Subject contains a reference to the object or user identities a role binding applies to.
    /// This can either hold a direct API object reference, or a value for non-objects such as user
    /// and group names.
    /// </summary>
    public class SubjectArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Kind of object being referenced. Values defined by this API group are "User", "Group",
        /// and "ServiceAccount". If the Authorizer does not recognized the kind value, the
        /// Authorizer should report an error.
        /// </summary>
        [Input("kind", required: true)]
        public Input<string> Kind { get; set; } = null!;

        /// <summary>
        /// Name of the object being referenced.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// APIGroup holds the API group of the referenced subject. Defaults to "" for
        /// ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group
        /// subjects.
        /// </summary>
        [Input("apiGroup")]
        public Input<string>? ApiGroup { get; set; }

        /// <summary>
        /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User"
        /// or "Group", and this value is not empty the Authorizer should report an error.
        /// </summary>
        [Input("namespace")]
        public Input<string>? Namespace { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Scheduling
{
  namespace V1
  {
    /// <summary>
    /// PriorityClass defines mapping from a priority class name to the priority integer value. The
    /// value can be any valid integer.
    /// </summary>
    public class PriorityClassArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The value of this priority class. This is the actual priority that pods receive when
        /// they have the name of this class in their pod spec.
        /// </summary>
        [Input("value", required: true)]
        public Input<int> Value { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// description is an arbitrary string that usually provides guidelines on when this
        /// priority class should be used.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// globalDefault specifies whether this PriorityClass should be considered as the default
        /// priority for pods that do not have any priority class. Only one PriorityClass can be
        /// marked as `globalDefault`. However, if more than one PriorityClasses exists with their
        /// `globalDefault` field set to true, the smallest value of such global default
        /// PriorityClasses will be used as the default priority.
        /// </summary>
        [Input("globalDefault")]
        public Input<bool>? GlobalDefault { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
        [Input("preemptionPolicy")]
        public Input<string>? PreemptionPolicy { get; set; }

    }

    /// <summary>
    /// PriorityClassList is a collection of priority classes.
    /// </summary>
    public class PriorityClassListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Scheduling.V1.PriorityClassArgs>? _items;

        /// <summary>
        /// items is the list of PriorityClasses
        /// </summary>
        public InputList<Scheduling.V1.PriorityClassArgs> Items
        {
            get => _items ?? (_items = new InputList<Scheduling.V1.PriorityClassArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

  }

  namespace V1Alpha1
  {
    /// <summary>
    /// DEPRECATED - This group version of PriorityClass is deprecated by
    /// scheduling.k8s.io/v1/PriorityClass. PriorityClass defines mapping from a priority class name
    /// to the priority integer value. The value can be any valid integer.
    /// </summary>
    public class PriorityClassArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The value of this priority class. This is the actual priority that pods receive when
        /// they have the name of this class in their pod spec.
        /// </summary>
        [Input("value", required: true)]
        public Input<int> Value { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// description is an arbitrary string that usually provides guidelines on when this
        /// priority class should be used.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// globalDefault specifies whether this PriorityClass should be considered as the default
        /// priority for pods that do not have any priority class. Only one PriorityClass can be
        /// marked as `globalDefault`. However, if more than one PriorityClasses exists with their
        /// `globalDefault` field set to true, the smallest value of such global default
        /// PriorityClasses will be used as the default priority.
        /// </summary>
        [Input("globalDefault")]
        public Input<bool>? GlobalDefault { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
        [Input("preemptionPolicy")]
        public Input<string>? PreemptionPolicy { get; set; }

    }

    /// <summary>
    /// PriorityClassList is a collection of priority classes.
    /// </summary>
    public class PriorityClassListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Scheduling.V1Alpha1.PriorityClassArgs>? _items;

        /// <summary>
        /// items is the list of PriorityClasses
        /// </summary>
        public InputList<Scheduling.V1Alpha1.PriorityClassArgs> Items
        {
            get => _items ?? (_items = new InputList<Scheduling.V1Alpha1.PriorityClassArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// DEPRECATED - This group version of PriorityClass is deprecated by
    /// scheduling.k8s.io/v1/PriorityClass. PriorityClass defines mapping from a priority class name
    /// to the priority integer value. The value can be any valid integer.
    /// </summary>
    public class PriorityClassArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The value of this priority class. This is the actual priority that pods receive when
        /// they have the name of this class in their pod spec.
        /// </summary>
        [Input("value", required: true)]
        public Input<int> Value { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// description is an arbitrary string that usually provides guidelines on when this
        /// priority class should be used.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// globalDefault specifies whether this PriorityClass should be considered as the default
        /// priority for pods that do not have any priority class. Only one PriorityClass can be
        /// marked as `globalDefault`. However, if more than one PriorityClasses exists with their
        /// `globalDefault` field set to true, the smallest value of such global default
        /// PriorityClasses will be used as the default priority.
        /// </summary>
        [Input("globalDefault")]
        public Input<bool>? GlobalDefault { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
        [Input("preemptionPolicy")]
        public Input<string>? PreemptionPolicy { get; set; }

    }

    /// <summary>
    /// PriorityClassList is a collection of priority classes.
    /// </summary>
    public class PriorityClassListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Scheduling.V1Beta1.PriorityClassArgs>? _items;

        /// <summary>
        /// items is the list of PriorityClasses
        /// </summary>
        public InputList<Scheduling.V1Beta1.PriorityClassArgs> Items
        {
            get => _items ?? (_items = new InputList<Scheduling.V1Beta1.PriorityClassArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Settings
{
  namespace V1Alpha1
  {
    /// <summary>
    /// PodPreset is a policy resource that defines additional runtime requirements for a Pod.
    /// </summary>
    public class PodPresetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        
        [Input("spec")]
        public Input<Settings.V1Alpha1.PodPresetSpecArgs>? Spec { get; set; }

    }

    /// <summary>
    /// PodPresetList is a list of PodPreset objects.
    /// </summary>
    public class PodPresetListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Settings.V1Alpha1.PodPresetArgs>? _items;

        /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
        public InputList<Settings.V1Alpha1.PodPresetArgs> Items
        {
            get => _items ?? (_items = new InputList<Settings.V1Alpha1.PodPresetArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// PodPresetSpec is a description of a pod preset.
    /// </summary>
    public class PodPresetSpecArgs : Pulumi.ResourceArgs
    {
        [Input("env")]
        private InputList<Core.V1.EnvVarArgs>? _env;

        /// <summary>
        /// Env defines the collection of EnvVar to inject into containers.
        /// </summary>
        public InputList<Core.V1.EnvVarArgs> Env
        {
            get => _env ?? (_env = new InputList<Core.V1.EnvVarArgs>());
            set => _env = value;
        }

        [Input("envFrom")]
        private InputList<Core.V1.EnvFromSourceArgs>? _envFrom;

        /// <summary>
        /// EnvFrom defines the collection of EnvFromSource to inject into containers.
        /// </summary>
        public InputList<Core.V1.EnvFromSourceArgs> EnvFrom
        {
            get => _envFrom ?? (_envFrom = new InputList<Core.V1.EnvFromSourceArgs>());
            set => _envFrom = value;
        }

        /// <summary>
        /// Selector is a label query over a set of resources, in this case pods. Required.
        /// </summary>
        [Input("selector")]
        public Input<Meta.V1.LabelSelectorArgs>? Selector { get; set; }

        [Input("volumeMounts")]
        private InputList<Core.V1.VolumeMountArgs>? _volumeMounts;

        /// <summary>
        /// VolumeMounts defines the collection of VolumeMount to inject into containers.
        /// </summary>
        public InputList<Core.V1.VolumeMountArgs> VolumeMounts
        {
            get => _volumeMounts ?? (_volumeMounts = new InputList<Core.V1.VolumeMountArgs>());
            set => _volumeMounts = value;
        }

        [Input("volumes")]
        private InputList<Core.V1.VolumeArgs>? _volumes;

        /// <summary>
        /// Volumes defines the collection of Volume to inject into the pod.
        /// </summary>
        public InputList<Core.V1.VolumeArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<Core.V1.VolumeArgs>());
            set => _volumes = value;
        }

    }

  }

}

namespace Pulumi.Kubernetes.Types.Inputs.Storage
{
  namespace V1
  {
    /// <summary>
    /// StorageClass describes the parameters for a class of storage for which PersistentVolumes can
    /// be dynamically provisioned.
    /// 
    /// StorageClasses are non-namespaced; the name of the storage class according to etcd is in
    /// ObjectMeta.Name.
    /// </summary>
    public class StorageClassArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Provisioner indicates the type of the provisioner.
        /// </summary>
        [Input("provisioner", required: true)]
        public Input<string> Provisioner { get; set; } = null!;

        /// <summary>
        /// AllowVolumeExpansion shows whether the storage class allow volume expand
        /// </summary>
        [Input("allowVolumeExpansion")]
        public Input<bool>? AllowVolumeExpansion { get; set; }

        [Input("allowedTopologies")]
        private InputList<Core.V1.TopologySelectorTermArgs>? _allowedTopologies;

        /// <summary>
        /// Restrict the node topologies where volumes can be dynamically provisioned. Each volume
        /// plugin defines its own supported topology specifications. An empty TopologySelectorTerm
        /// list means there is no topology restriction. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
        public InputList<Core.V1.TopologySelectorTermArgs> AllowedTopologies
        {
            get => _allowedTopologies ?? (_allowedTopologies = new InputList<Core.V1.TopologySelectorTermArgs>());
            set => _allowedTopologies = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("mountOptions")]
        private InputList<string>? _mountOptions;

        /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with these
        /// mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if
        /// one is invalid.
        /// </summary>
        public InputList<string> MountOptions
        {
            get => _mountOptions ?? (_mountOptions = new InputList<string>());
            set => _mountOptions = value;
        }

        [Input("parameters")]
        private InputMap<string>? _parameters;

        /// <summary>
        /// Parameters holds the parameters for the provisioner that should create volumes of this
        /// storage class.
        /// </summary>
        public InputMap<string> Parameters
        {
            get => _parameters ?? (_parameters = new InputMap<string>());
            set => _parameters = value;
        }

        /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with this
        /// reclaimPolicy. Defaults to Delete.
        /// </summary>
        [Input("reclaimPolicy")]
        public Input<string>? ReclaimPolicy { get; set; }

        /// <summary>
        /// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.
        /// When unset, VolumeBindingImmediate is used. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
        [Input("volumeBindingMode")]
        public Input<string>? VolumeBindingMode { get; set; }

    }

    /// <summary>
    /// StorageClassList is a collection of storage classes.
    /// </summary>
    public class StorageClassListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Storage.V1.StorageClassArgs>? _items;

        /// <summary>
        /// Items is the list of StorageClasses
        /// </summary>
        public InputList<Storage.V1.StorageClassArgs> Items
        {
            get => _items ?? (_items = new InputList<Storage.V1.StorageClassArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachment captures the intent to attach or detach the specified volume to/from the
    /// specified node.
    /// 
    /// VolumeAttachment objects are non-namespaced.
    /// </summary>
    public class VolumeAttachmentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
        /// system.
        /// </summary>
        [Input("spec", required: true)]
        public Input<Storage.V1.VolumeAttachmentSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentList is a collection of VolumeAttachment objects.
    /// </summary>
    public class VolumeAttachmentListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Storage.V1.VolumeAttachmentArgs>? _items;

        /// <summary>
        /// Items is the list of VolumeAttachments
        /// </summary>
        public InputList<Storage.V1.VolumeAttachmentArgs> Items
        {
            get => _items ?? (_items = new InputList<Storage.V1.VolumeAttachmentArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSource represents a volume that should be attached. Right now only
    /// PersistenVolumes can be attached via external attacher, in future we may allow also inline
    /// volumes in pods. Exactly one member can be set.
    /// </summary>
    public class VolumeAttachmentSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// inlineVolumeSpec contains all the information necessary to attach a persistent volume
        /// defined by a pod's inline VolumeSource. This field is populated only for the
        /// CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to
        /// a PersistentVolumeSpec. This field is alpha-level and is only honored by servers that
        /// enabled the CSIMigration feature.
        /// </summary>
        [Input("inlineVolumeSpec")]
        public Input<Core.V1.PersistentVolumeSpecArgs>? InlineVolumeSpec { get; set; }

        /// <summary>
        /// Name of the persistent volume to attach.
        /// </summary>
        [Input("persistentVolumeName")]
        public Input<string>? PersistentVolumeName { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
    /// </summary>
    public class VolumeAttachmentSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Attacher indicates the name of the volume driver that MUST handle this request. This is
        /// the name returned by GetPluginName().
        /// </summary>
        [Input("attacher", required: true)]
        public Input<string> Attacher { get; set; } = null!;

        /// <summary>
        /// The node that the volume should be attached to.
        /// </summary>
        [Input("nodeName", required: true)]
        public Input<string> NodeName { get; set; } = null!;

        /// <summary>
        /// Source represents the volume that should be attached.
        /// </summary>
        [Input("source", required: true)]
        public Input<Storage.V1.VolumeAttachmentSourceArgs> Source { get; set; } = null!;

    }

    /// <summary>
    /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
    /// </summary>
    public class VolumeAttachmentStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Indicates the volume is successfully attached. This field must only be set by the entity
        /// completing the attach operation, i.e. the external-attacher.
        /// </summary>
        [Input("attached", required: true)]
        public Input<bool> Attached { get; set; } = null!;

        /// <summary>
        /// The last error encountered during attach operation, if any. This field must only be set
        /// by the entity completing the attach operation, i.e. the external-attacher.
        /// </summary>
        [Input("attachError")]
        public Input<Storage.V1.VolumeErrorArgs>? AttachError { get; set; }

        [Input("attachmentMetadata")]
        private InputMap<string>? _attachmentMetadata;

        /// <summary>
        /// Upon successful attach, this field is populated with any information returned by the
        /// attach operation that must be passed into subsequent WaitForAttach or Mount calls. This
        /// field must only be set by the entity completing the attach operation, i.e. the
        /// external-attacher.
        /// </summary>
        public InputMap<string> AttachmentMetadata
        {
            get => _attachmentMetadata ?? (_attachmentMetadata = new InputMap<string>());
            set => _attachmentMetadata = value;
        }

        /// <summary>
        /// The last error encountered during detach operation, if any. This field must only be set
        /// by the entity completing the detach operation, i.e. the external-attacher.
        /// </summary>
        [Input("detachError")]
        public Input<Storage.V1.VolumeErrorArgs>? DetachError { get; set; }

    }

    /// <summary>
    /// VolumeError captures an error encountered during a volume operation.
    /// </summary>
    public class VolumeErrorArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// String detailing the error encountered during Attach or Detach operation. This string
        /// may be logged, so it should not contain sensitive information.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Time the error was encountered.
        /// </summary>
        [Input("time")]
        public Input<string>? Time { get; set; }

    }

  }

  namespace V1Alpha1
  {
    /// <summary>
    /// VolumeAttachment captures the intent to attach or detach the specified volume to/from the
    /// specified node.
    /// 
    /// VolumeAttachment objects are non-namespaced.
    /// </summary>
    public class VolumeAttachmentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
        /// system.
        /// </summary>
        [Input("spec", required: true)]
        public Input<Storage.V1Alpha1.VolumeAttachmentSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentList is a collection of VolumeAttachment objects.
    /// </summary>
    public class VolumeAttachmentListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Storage.V1Alpha1.VolumeAttachmentArgs>? _items;

        /// <summary>
        /// Items is the list of VolumeAttachments
        /// </summary>
        public InputList<Storage.V1Alpha1.VolumeAttachmentArgs> Items
        {
            get => _items ?? (_items = new InputList<Storage.V1Alpha1.VolumeAttachmentArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSource represents a volume that should be attached. Right now only
    /// PersistenVolumes can be attached via external attacher, in future we may allow also inline
    /// volumes in pods. Exactly one member can be set.
    /// </summary>
    public class VolumeAttachmentSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// inlineVolumeSpec contains all the information necessary to attach a persistent volume
        /// defined by a pod's inline VolumeSource. This field is populated only for the
        /// CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to
        /// a PersistentVolumeSpec. This field is alpha-level and is only honored by servers that
        /// enabled the CSIMigration feature.
        /// </summary>
        [Input("inlineVolumeSpec")]
        public Input<Core.V1.PersistentVolumeSpecArgs>? InlineVolumeSpec { get; set; }

        /// <summary>
        /// Name of the persistent volume to attach.
        /// </summary>
        [Input("persistentVolumeName")]
        public Input<string>? PersistentVolumeName { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
    /// </summary>
    public class VolumeAttachmentSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Attacher indicates the name of the volume driver that MUST handle this request. This is
        /// the name returned by GetPluginName().
        /// </summary>
        [Input("attacher", required: true)]
        public Input<string> Attacher { get; set; } = null!;

        /// <summary>
        /// The node that the volume should be attached to.
        /// </summary>
        [Input("nodeName", required: true)]
        public Input<string> NodeName { get; set; } = null!;

        /// <summary>
        /// Source represents the volume that should be attached.
        /// </summary>
        [Input("source", required: true)]
        public Input<Storage.V1Alpha1.VolumeAttachmentSourceArgs> Source { get; set; } = null!;

    }

    /// <summary>
    /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
    /// </summary>
    public class VolumeAttachmentStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Indicates the volume is successfully attached. This field must only be set by the entity
        /// completing the attach operation, i.e. the external-attacher.
        /// </summary>
        [Input("attached", required: true)]
        public Input<bool> Attached { get; set; } = null!;

        /// <summary>
        /// The last error encountered during attach operation, if any. This field must only be set
        /// by the entity completing the attach operation, i.e. the external-attacher.
        /// </summary>
        [Input("attachError")]
        public Input<Storage.V1Alpha1.VolumeErrorArgs>? AttachError { get; set; }

        [Input("attachmentMetadata")]
        private InputMap<string>? _attachmentMetadata;

        /// <summary>
        /// Upon successful attach, this field is populated with any information returned by the
        /// attach operation that must be passed into subsequent WaitForAttach or Mount calls. This
        /// field must only be set by the entity completing the attach operation, i.e. the
        /// external-attacher.
        /// </summary>
        public InputMap<string> AttachmentMetadata
        {
            get => _attachmentMetadata ?? (_attachmentMetadata = new InputMap<string>());
            set => _attachmentMetadata = value;
        }

        /// <summary>
        /// The last error encountered during detach operation, if any. This field must only be set
        /// by the entity completing the detach operation, i.e. the external-attacher.
        /// </summary>
        [Input("detachError")]
        public Input<Storage.V1Alpha1.VolumeErrorArgs>? DetachError { get; set; }

    }

    /// <summary>
    /// VolumeError captures an error encountered during a volume operation.
    /// </summary>
    public class VolumeErrorArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// String detailing the error encountered during Attach or Detach operation. This string
        /// maybe logged, so it should not contain sensitive information.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Time the error was encountered.
        /// </summary>
        [Input("time")]
        public Input<string>? Time { get; set; }

    }

  }

  namespace V1Beta1
  {
    /// <summary>
    /// CSIDriver captures information about a Container Storage Interface (CSI) volume driver
    /// deployed on the cluster. CSI drivers do not need to create the CSIDriver object directly.
    /// Instead they may use the cluster-driver-registrar sidecar container. When deployed with a
    /// CSI driver it automatically creates a CSIDriver object representing the driver. Kubernetes
    /// attach detach controller uses this object to determine whether attach is required. Kubelet
    /// uses this object to determine whether pod information needs to be passed on mount. CSIDriver
    /// objects are non-namespaced.
    /// </summary>
    public class CSIDriverArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specification of the CSI Driver.
        /// </summary>
        [Input("spec", required: true)]
        public Input<Storage.V1Beta1.CSIDriverSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata. metadata.Name indicates the name of the CSI driver that this
        /// object refers to; it MUST be the same name returned by the CSI GetPluginName() call for
        /// that driver. The driver name must be 63 characters or less, beginning and ending with an
        /// alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and alphanumerics
        /// between. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CSIDriverList is a collection of CSIDriver objects.
    /// </summary>
    public class CSIDriverListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Storage.V1Beta1.CSIDriverArgs>? _items;

        /// <summary>
        /// items is the list of CSIDriver
        /// </summary>
        public InputList<Storage.V1Beta1.CSIDriverArgs> Items
        {
            get => _items ?? (_items = new InputList<Storage.V1Beta1.CSIDriverArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CSIDriverSpec is the specification of a CSIDriver.
    /// </summary>
    public class CSIDriverSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// attachRequired indicates this CSI volume driver requires an attach operation (because it
        /// implements the CSI ControllerPublishVolume() method), and that the Kubernetes attach
        /// detach controller should call the attach volume interface which checks the
        /// volumeattachment status and waits until the volume is attached before proceeding to
        /// mounting. The CSI external-attacher coordinates with CSI volume driver and updates the
        /// volumeattachment status when the attach operation is complete. If the CSIDriverRegistry
        /// feature gate is enabled and the value is specified to false, the attach operation will
        /// be skipped. Otherwise the attach operation will be called.
        /// </summary>
        [Input("attachRequired")]
        public Input<bool>? AttachRequired { get; set; }

        /// <summary>
        /// If set to true, podInfoOnMount indicates this CSI volume driver requires additional pod
        /// information (like podName, podUID, etc.) during mount operations. If set to false, pod
        /// information will not be passed on mount. Default is false. The CSI driver specifies
        /// podInfoOnMount as part of driver deployment. If true, Kubelet will pass pod information
        /// as VolumeContext in the CSI NodePublishVolume() calls. The CSI driver is responsible for
        /// parsing and validating the information passed in as VolumeContext. The following
        /// VolumeConext will be passed if podInfoOnMount is set to true. This list might grow, but
        /// the prefix will be used. "csi.storage.k8s.io/pod.name": pod.Name
        /// "csi.storage.k8s.io/pod.namespace": pod.Namespace "csi.storage.k8s.io/pod.uid":
        /// string(pod.UID) "csi.storage.k8s.io/ephemeral": "true" iff the volume is an ephemeral
        /// inline volume
        ///                                 defined by a CSIVolumeSource, otherwise "false"
        /// 
        /// "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only required
        /// for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
        /// Other drivers can leave pod info disabled and/or ignore this field. As Kubernetes 1.15
        /// doesn't support this field, drivers can only support one mode when deployed on such a
        /// cluster and the deployment determines which mode that is, for example via a command line
        /// parameter of the driver.
        /// </summary>
        [Input("podInfoOnMount")]
        public Input<bool>? PodInfoOnMount { get; set; }

        [Input("volumeLifecycleModes")]
        private InputList<string>? _volumeLifecycleModes;

        /// <summary>
        /// VolumeLifecycleModes defines what kind of volumes this CSI volume driver supports. The
        /// default if the list is empty is "Persistent", which is the usage defined by the CSI
        /// specification and implemented in Kubernetes via the usual PV/PVC mechanism. The other
        /// mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec with
        /// CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod. A driver has
        /// to be aware of this because it is only going to get a NodePublishVolume call for such a
        /// volume. For more information about implementing this mode, see
        /// https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html A driver can support
        /// one or more of these modes and more modes may be added in the future.
        /// </summary>
        public InputList<string> VolumeLifecycleModes
        {
            get => _volumeLifecycleModes ?? (_volumeLifecycleModes = new InputList<string>());
            set => _volumeLifecycleModes = value;
        }

    }

    /// <summary>
    /// CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need
    /// to create the CSINode object directly. As long as they use the node-driver-registrar sidecar
    /// container, the kubelet will automatically populate the CSINode object for the CSI driver as
    /// part of kubelet plugin registration. CSINode has the same name as a node. If the object is
    /// missing, it means either there are no CSI Drivers available on the node, or the Kubelet
    /// version is low enough that it doesn't create this object. CSINode has an OwnerReference that
    /// points to the corresponding node object.
    /// </summary>
    public class CSINodeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// spec is the specification of CSINode
        /// </summary>
        [Input("spec", required: true)]
        public Input<Storage.V1Beta1.CSINodeSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// metadata.name must be the Kubernetes node name.
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CSINodeDriver holds information about the specification of one CSI driver installed on a
    /// node
    /// </summary>
    public class CSINodeDriverArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// This is the name of the CSI driver that this object refers to. This MUST be the same
        /// name returned by the CSI GetPluginName() call for that driver.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// nodeID of the node from the driver point of view. This field enables Kubernetes to
        /// communicate with storage systems that do not share the same nomenclature for nodes. For
        /// example, Kubernetes may refer to a given node as "node1", but the storage system may
        /// refer to the same node as "nodeA". When Kubernetes issues a command to the storage
        /// system to attach a volume to a specific node, it can use this field to refer to the node
        /// name using the ID that the storage system will understand, e.g. "nodeA" instead of
        /// "node1". This field is required.
        /// </summary>
        [Input("nodeID", required: true)]
        public Input<string> NodeID { get; set; } = null!;

        /// <summary>
        /// allocatable represents the volume resources of a node that are available for scheduling.
        /// </summary>
        [Input("allocatable")]
        public Input<Storage.V1Beta1.VolumeNodeResourcesArgs>? Allocatable { get; set; }

        [Input("topologyKeys")]
        private InputList<string>? _topologyKeys;

        /// <summary>
        /// topologyKeys is the list of keys supported by the driver. When a driver is initialized
        /// on a cluster, it provides a set of topology keys that it understands (e.g.
        /// "company.com/zone", "company.com/region"). When a driver is initialized on a node, it
        /// provides the same topology keys along with values. Kubelet will expose these topology
        /// keys as labels on its own node object. When Kubernetes does topology aware provisioning,
        /// it can use this list to determine which labels it should retrieve from the node object
        /// and pass back to the driver. It is possible for different nodes to use different
        /// topology keys. This can be empty if driver does not support topology.
        /// </summary>
        public InputList<string> TopologyKeys
        {
            get => _topologyKeys ?? (_topologyKeys = new InputList<string>());
            set => _topologyKeys = value;
        }

    }

    /// <summary>
    /// CSINodeList is a collection of CSINode objects.
    /// </summary>
    public class CSINodeListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Storage.V1Beta1.CSINodeArgs>? _items;

        /// <summary>
        /// items is the list of CSINode
        /// </summary>
        public InputList<Storage.V1Beta1.CSINodeArgs> Items
        {
            get => _items ?? (_items = new InputList<Storage.V1Beta1.CSINodeArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// CSINodeSpec holds information about the specification of all CSI drivers installed on a node
    /// </summary>
    public class CSINodeSpecArgs : Pulumi.ResourceArgs
    {
        [Input("drivers", required: true)]
        private InputList<Storage.V1Beta1.CSINodeDriverArgs>? _drivers;

        /// <summary>
        /// drivers is a list of information of all CSI Drivers existing on a node. If all drivers
        /// in the list are uninstalled, this can become empty.
        /// </summary>
        public InputList<Storage.V1Beta1.CSINodeDriverArgs> Drivers
        {
            get => _drivers ?? (_drivers = new InputList<Storage.V1Beta1.CSINodeDriverArgs>());
            set => _drivers = value;
        }

    }

    /// <summary>
    /// StorageClass describes the parameters for a class of storage for which PersistentVolumes can
    /// be dynamically provisioned.
    /// 
    /// StorageClasses are non-namespaced; the name of the storage class according to etcd is in
    /// ObjectMeta.Name.
    /// </summary>
    public class StorageClassArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Provisioner indicates the type of the provisioner.
        /// </summary>
        [Input("provisioner", required: true)]
        public Input<string> Provisioner { get; set; } = null!;

        /// <summary>
        /// AllowVolumeExpansion shows whether the storage class allow volume expand
        /// </summary>
        [Input("allowVolumeExpansion")]
        public Input<bool>? AllowVolumeExpansion { get; set; }

        [Input("allowedTopologies")]
        private InputList<Core.V1.TopologySelectorTermArgs>? _allowedTopologies;

        /// <summary>
        /// Restrict the node topologies where volumes can be dynamically provisioned. Each volume
        /// plugin defines its own supported topology specifications. An empty TopologySelectorTerm
        /// list means there is no topology restriction. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
        public InputList<Core.V1.TopologySelectorTermArgs> AllowedTopologies
        {
            get => _allowedTopologies ?? (_allowedTopologies = new InputList<Core.V1.TopologySelectorTermArgs>());
            set => _allowedTopologies = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

        [Input("mountOptions")]
        private InputList<string>? _mountOptions;

        /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with these
        /// mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if
        /// one is invalid.
        /// </summary>
        public InputList<string> MountOptions
        {
            get => _mountOptions ?? (_mountOptions = new InputList<string>());
            set => _mountOptions = value;
        }

        [Input("parameters")]
        private InputMap<string>? _parameters;

        /// <summary>
        /// Parameters holds the parameters for the provisioner that should create volumes of this
        /// storage class.
        /// </summary>
        public InputMap<string> Parameters
        {
            get => _parameters ?? (_parameters = new InputMap<string>());
            set => _parameters = value;
        }

        /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with this
        /// reclaimPolicy. Defaults to Delete.
        /// </summary>
        [Input("reclaimPolicy")]
        public Input<string>? ReclaimPolicy { get; set; }

        /// <summary>
        /// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.
        /// When unset, VolumeBindingImmediate is used. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
        [Input("volumeBindingMode")]
        public Input<string>? VolumeBindingMode { get; set; }

    }

    /// <summary>
    /// StorageClassList is a collection of storage classes.
    /// </summary>
    public class StorageClassListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Storage.V1Beta1.StorageClassArgs>? _items;

        /// <summary>
        /// Items is the list of StorageClasses
        /// </summary>
        public InputList<Storage.V1Beta1.StorageClassArgs> Items
        {
            get => _items ?? (_items = new InputList<Storage.V1Beta1.StorageClassArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachment captures the intent to attach or detach the specified volume to/from the
    /// specified node.
    /// 
    /// VolumeAttachment objects are non-namespaced.
    /// </summary>
    public class VolumeAttachmentArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
        /// system.
        /// </summary>
        [Input("spec", required: true)]
        public Input<Storage.V1Beta1.VolumeAttachmentSpecArgs> Spec { get; set; } = null!;

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ObjectMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentList is a collection of VolumeAttachment objects.
    /// </summary>
    public class VolumeAttachmentListArgs : Pulumi.ResourceArgs
    {
        [Input("items", required: true)]
        private InputList<Storage.V1Beta1.VolumeAttachmentArgs>? _items;

        /// <summary>
        /// Items is the list of VolumeAttachments
        /// </summary>
        public InputList<Storage.V1Beta1.VolumeAttachmentArgs> Items
        {
            get => _items ?? (_items = new InputList<Storage.V1Beta1.VolumeAttachmentArgs>());
            set => _items = value;
        }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Input("metadata")]
        public Input<Meta.V1.ListMetaArgs>? Metadata { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSource represents a volume that should be attached. Right now only
    /// PersistenVolumes can be attached via external attacher, in future we may allow also inline
    /// volumes in pods. Exactly one member can be set.
    /// </summary>
    public class VolumeAttachmentSourceArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// inlineVolumeSpec contains all the information necessary to attach a persistent volume
        /// defined by a pod's inline VolumeSource. This field is populated only for the
        /// CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to
        /// a PersistentVolumeSpec. This field is alpha-level and is only honored by servers that
        /// enabled the CSIMigration feature.
        /// </summary>
        [Input("inlineVolumeSpec")]
        public Input<Core.V1.PersistentVolumeSpecArgs>? InlineVolumeSpec { get; set; }

        /// <summary>
        /// Name of the persistent volume to attach.
        /// </summary>
        [Input("persistentVolumeName")]
        public Input<string>? PersistentVolumeName { get; set; }

    }

    /// <summary>
    /// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
    /// </summary>
    public class VolumeAttachmentSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Attacher indicates the name of the volume driver that MUST handle this request. This is
        /// the name returned by GetPluginName().
        /// </summary>
        [Input("attacher", required: true)]
        public Input<string> Attacher { get; set; } = null!;

        /// <summary>
        /// The node that the volume should be attached to.
        /// </summary>
        [Input("nodeName", required: true)]
        public Input<string> NodeName { get; set; } = null!;

        /// <summary>
        /// Source represents the volume that should be attached.
        /// </summary>
        [Input("source", required: true)]
        public Input<Storage.V1Beta1.VolumeAttachmentSourceArgs> Source { get; set; } = null!;

    }

    /// <summary>
    /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
    /// </summary>
    public class VolumeAttachmentStatusArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Indicates the volume is successfully attached. This field must only be set by the entity
        /// completing the attach operation, i.e. the external-attacher.
        /// </summary>
        [Input("attached", required: true)]
        public Input<bool> Attached { get; set; } = null!;

        /// <summary>
        /// The last error encountered during attach operation, if any. This field must only be set
        /// by the entity completing the attach operation, i.e. the external-attacher.
        /// </summary>
        [Input("attachError")]
        public Input<Storage.V1Beta1.VolumeErrorArgs>? AttachError { get; set; }

        [Input("attachmentMetadata")]
        private InputMap<string>? _attachmentMetadata;

        /// <summary>
        /// Upon successful attach, this field is populated with any information returned by the
        /// attach operation that must be passed into subsequent WaitForAttach or Mount calls. This
        /// field must only be set by the entity completing the attach operation, i.e. the
        /// external-attacher.
        /// </summary>
        public InputMap<string> AttachmentMetadata
        {
            get => _attachmentMetadata ?? (_attachmentMetadata = new InputMap<string>());
            set => _attachmentMetadata = value;
        }

        /// <summary>
        /// The last error encountered during detach operation, if any. This field must only be set
        /// by the entity completing the detach operation, i.e. the external-attacher.
        /// </summary>
        [Input("detachError")]
        public Input<Storage.V1Beta1.VolumeErrorArgs>? DetachError { get; set; }

    }

    /// <summary>
    /// VolumeError captures an error encountered during a volume operation.
    /// </summary>
    public class VolumeErrorArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// String detailing the error encountered during Attach or Detach operation. This string
        /// may be logged, so it should not contain sensitive information.
        /// </summary>
        [Input("message")]
        public Input<string>? Message { get; set; }

        /// <summary>
        /// Time the error was encountered.
        /// </summary>
        [Input("time")]
        public Input<string>? Time { get; set; }

    }

    /// <summary>
    /// VolumeNodeResources is a set of resource limits for scheduling of volumes.
    /// </summary>
    public class VolumeNodeResourcesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Maximum number of unique volumes managed by the CSI driver that can be used on a node. A
        /// volume that is both attached and mounted on a node is considered to be used once, not
        /// twice. The same rule applies for a unique volume that is shared among multiple pods on
        /// the same node. If this field is nil, then the supported number of volumes on this node
        /// is unbounded.
        /// </summary>
        [Input("count")]
        public Input<int>? Count { get; set; }

    }

  }

}

