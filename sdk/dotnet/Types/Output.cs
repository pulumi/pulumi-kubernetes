// *** WARNING: this file was generated by the Pulumi Kubernetes client generation tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Types.Outputs.AdmissionRegistration
{
  namespace V1
  {
    /// <summary>
    /// MutatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    [OutputType]
    public sealed class MutatingWebhook
    {
      /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy.
        /// </summary>
      public readonly ImmutableArray<string> AdmissionReviewVersions;

      /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
      public readonly AdmissionRegistration.V1.WebhookClientConfig ClientConfig;

      /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Fail.
        /// </summary>
      public readonly string FailurePolicy;

      /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Equivalent"
        /// </summary>
      public readonly string MatchPolicy;

      /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
      public readonly Meta.V1.LabelSelector NamespaceSelector;

      /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
      public readonly Meta.V1.LabelSelector ObjectSelector;

      /// <summary>
        /// reinvocationPolicy indicates whether this webhook should be called multiple times as
        /// part of a single admission evaluation. Allowed values are "Never" and "IfNeeded".
        /// 
        /// Never: the webhook will not be called more than once in a single admission evaluation.
        /// 
        /// IfNeeded: the webhook will be called at least one additional time as part of the
        /// admission evaluation if the object being admitted is modified by other admission plugins
        /// after the initial webhook call. Webhooks that specify this option *must* be idempotent,
        /// able to process objects they previously admitted. Note: * the number of additional
        /// invocations is not guaranteed to be exactly one. * if additional invocations result in
        /// further modifications to the object, webhooks are not guaranteed to be invoked again. *
        /// webhooks that use this option may be reordered to minimize the number of additional
        /// invocations. * to validate an object after all mutations are guaranteed complete, use a
        /// validating admission webhook instead.
        /// 
        /// Defaults to "Never".
        /// </summary>
      public readonly string ReinvocationPolicy;

      /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1.RuleWithOperations> Rules;

      /// <summary>
        /// SideEffects states whether this webhook has side effects. Acceptable values are: None,
        /// NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks
        /// with side effects MUST implement a reconciliation system, since a request may be
        /// rejected by a future step in the admission change and the side effects therefore need to
        /// be undone. Requests with the dryRun attribute will be auto-rejected if they match a
        /// webhook with sideEffects == Unknown or Some.
        /// </summary>
      public readonly string SideEffects;

      /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 10 seconds.
        /// </summary>
      public readonly int TimeoutSeconds;

      [OutputConstructor]
      private MutatingWebhook(
          ImmutableArray<string> @admissionReviewVersions,
          AdmissionRegistration.V1.WebhookClientConfig @clientConfig,
          string @failurePolicy,
          string @matchPolicy,
          string @name,
          Meta.V1.LabelSelector @namespaceSelector,
          Meta.V1.LabelSelector @objectSelector,
          string @reinvocationPolicy,
          ImmutableArray<AdmissionRegistration.V1.RuleWithOperations> @rules,
          string @sideEffects,
          int @timeoutSeconds)
      {
          this.AdmissionReviewVersions = @admissionReviewVersions;
          this.ClientConfig = @clientConfig;
          this.FailurePolicy = @failurePolicy;
          this.MatchPolicy = @matchPolicy;
          this.Name = @name;
          this.NamespaceSelector = @namespaceSelector;
          this.ObjectSelector = @objectSelector;
          this.ReinvocationPolicy = @reinvocationPolicy;
          this.Rules = @rules;
          this.SideEffects = @sideEffects;
          this.TimeoutSeconds = @timeoutSeconds;
      }

    }
    /// <summary>
    /// MutatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and may change the object.
    /// </summary>
    [OutputType]
    public sealed class MutatingWebhookConfiguration
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1.MutatingWebhook> Webhooks;

      [OutputConstructor]
      private MutatingWebhookConfiguration(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<AdmissionRegistration.V1.MutatingWebhook> @webhooks)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Webhooks = @webhooks;
      }

    }
    /// <summary>
    /// MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
    /// </summary>
    [OutputType]
    public sealed class MutatingWebhookConfigurationList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of MutatingWebhookConfiguration.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1.MutatingWebhookConfiguration> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private MutatingWebhookConfigurationList(
          string @apiVersion,
          ImmutableArray<AdmissionRegistration.V1.MutatingWebhookConfiguration> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure
    /// that all the tuple expansions are valid.
    /// </summary>
    [OutputType]
    public sealed class RuleWithOperations
    {
      /// <summary>
        /// APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
      public readonly ImmutableArray<string> ApiGroups;

      /// <summary>
        /// APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
      public readonly ImmutableArray<string> ApiVersions;

      /// <summary>
        /// Operations is the operations the admission hook cares about - CREATE, UPDATE, or * for
        /// all operations. If '*' is present, the length of the slice must be one. Required.
        /// </summary>
      public readonly ImmutableArray<string> Operations;

      /// <summary>
        /// Resources is a list of resources this rule applies to.
        /// 
        /// For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means
        /// all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale'
        /// means all scale subresources. '*/*' means all resources and their subresources.
        /// 
        /// If wildcard is present, the validation rule will ensure resources do not overlap with
        /// each other.
        /// 
        /// Depending on the enclosing object, subresources might not be allowed. Required.
        /// </summary>
      public readonly ImmutableArray<string> Resources;

      /// <summary>
        /// scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and
        /// "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace
        /// API objects are cluster-scoped. "Namespaced" means that only namespaced resources will
        /// match this rule. "*" means that there are no scope restrictions. Subresources match the
        /// scope of their parent resource. Default is "*".
        /// </summary>
      public readonly string Scope;

      [OutputConstructor]
      private RuleWithOperations(
          ImmutableArray<string> @apiGroups,
          ImmutableArray<string> @apiVersions,
          ImmutableArray<string> @operations,
          ImmutableArray<string> @resources,
          string @scope)
      {
          this.ApiGroups = @apiGroups;
          this.ApiVersions = @apiVersions;
          this.Operations = @operations;
          this.Resources = @resources;
          this.Scope = @scope;
      }

    }
    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    [OutputType]
    public sealed class ServiceReference
    {
      /// <summary>
        /// `name` is the name of the service. Required
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// `namespace` is the namespace of the service. Required
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// `path` is an optional URL path which will be sent in any request to this service.
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
      public readonly int Port;

      [OutputConstructor]
      private ServiceReference(
          string @name,
          string @namespace,
          string @path,
          int @port)
      {
          this.Name = @name;
          this.Namespace = @namespace;
          this.Path = @path;
          this.Port = @port;
      }

    }
    /// <summary>
    /// ValidatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    [OutputType]
    public sealed class ValidatingWebhook
    {
      /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy.
        /// </summary>
      public readonly ImmutableArray<string> AdmissionReviewVersions;

      /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
      public readonly AdmissionRegistration.V1.WebhookClientConfig ClientConfig;

      /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Fail.
        /// </summary>
      public readonly string FailurePolicy;

      /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Equivalent"
        /// </summary>
      public readonly string MatchPolicy;

      /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
      public readonly Meta.V1.LabelSelector NamespaceSelector;

      /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
      public readonly Meta.V1.LabelSelector ObjectSelector;

      /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1.RuleWithOperations> Rules;

      /// <summary>
        /// SideEffects states whether this webhook has side effects. Acceptable values are: None,
        /// NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks
        /// with side effects MUST implement a reconciliation system, since a request may be
        /// rejected by a future step in the admission change and the side effects therefore need to
        /// be undone. Requests with the dryRun attribute will be auto-rejected if they match a
        /// webhook with sideEffects == Unknown or Some.
        /// </summary>
      public readonly string SideEffects;

      /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 10 seconds.
        /// </summary>
      public readonly int TimeoutSeconds;

      [OutputConstructor]
      private ValidatingWebhook(
          ImmutableArray<string> @admissionReviewVersions,
          AdmissionRegistration.V1.WebhookClientConfig @clientConfig,
          string @failurePolicy,
          string @matchPolicy,
          string @name,
          Meta.V1.LabelSelector @namespaceSelector,
          Meta.V1.LabelSelector @objectSelector,
          ImmutableArray<AdmissionRegistration.V1.RuleWithOperations> @rules,
          string @sideEffects,
          int @timeoutSeconds)
      {
          this.AdmissionReviewVersions = @admissionReviewVersions;
          this.ClientConfig = @clientConfig;
          this.FailurePolicy = @failurePolicy;
          this.MatchPolicy = @matchPolicy;
          this.Name = @name;
          this.NamespaceSelector = @namespaceSelector;
          this.ObjectSelector = @objectSelector;
          this.Rules = @rules;
          this.SideEffects = @sideEffects;
          this.TimeoutSeconds = @timeoutSeconds;
      }

    }
    /// <summary>
    /// ValidatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and object without changing it.
    /// </summary>
    [OutputType]
    public sealed class ValidatingWebhookConfiguration
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1.ValidatingWebhook> Webhooks;

      [OutputConstructor]
      private ValidatingWebhookConfiguration(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<AdmissionRegistration.V1.ValidatingWebhook> @webhooks)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Webhooks = @webhooks;
      }

    }
    /// <summary>
    /// ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
    /// </summary>
    [OutputType]
    public sealed class ValidatingWebhookConfigurationList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of ValidatingWebhookConfiguration.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1.ValidatingWebhookConfiguration> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ValidatingWebhookConfigurationList(
          string @apiVersion,
          ImmutableArray<AdmissionRegistration.V1.ValidatingWebhookConfiguration> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook
    /// </summary>
    [OutputType]
    public sealed class WebhookClientConfig
    {
      /// <summary>
        /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's
        /// server certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
      public readonly string CaBundle;

      /// <summary>
        /// `service` is a reference to the service for this webhook. Either `service` or `url` must
        /// be specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
      public readonly AdmissionRegistration.V1.ServiceReference Service;

      /// <summary>
        /// `url` gives the location of the webhook, in standard URL form
        /// (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
      public readonly string Url;

      [OutputConstructor]
      private WebhookClientConfig(
          string @caBundle,
          AdmissionRegistration.V1.ServiceReference @service,
          string @url)
      {
          this.CaBundle = @caBundle;
          this.Service = @service;
          this.Url = @url;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// MutatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    [OutputType]
    public sealed class MutatingWebhook
    {
      /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy. Default to `['v1beta1']`.
        /// </summary>
      public readonly ImmutableArray<string> AdmissionReviewVersions;

      /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
      public readonly AdmissionRegistration.V1Beta1.WebhookClientConfig ClientConfig;

      /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Ignore.
        /// </summary>
      public readonly string FailurePolicy;

      /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Exact"
        /// </summary>
      public readonly string MatchPolicy;

      /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
      public readonly Meta.V1.LabelSelector NamespaceSelector;

      /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
      public readonly Meta.V1.LabelSelector ObjectSelector;

      /// <summary>
        /// reinvocationPolicy indicates whether this webhook should be called multiple times as
        /// part of a single admission evaluation. Allowed values are "Never" and "IfNeeded".
        /// 
        /// Never: the webhook will not be called more than once in a single admission evaluation.
        /// 
        /// IfNeeded: the webhook will be called at least one additional time as part of the
        /// admission evaluation if the object being admitted is modified by other admission plugins
        /// after the initial webhook call. Webhooks that specify this option *must* be idempotent,
        /// able to process objects they previously admitted. Note: * the number of additional
        /// invocations is not guaranteed to be exactly one. * if additional invocations result in
        /// further modifications to the object, webhooks are not guaranteed to be invoked again. *
        /// webhooks that use this option may be reordered to minimize the number of additional
        /// invocations. * to validate an object after all mutations are guaranteed complete, use a
        /// validating admission webhook instead.
        /// 
        /// Defaults to "Never".
        /// </summary>
      public readonly string ReinvocationPolicy;

      /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1Beta1.RuleWithOperations> Rules;

      /// <summary>
        /// SideEffects states whether this webhook has side effects. Acceptable values are:
        /// Unknown, None, Some, NoneOnDryRun Webhooks with side effects MUST implement a
        /// reconciliation system, since a request may be rejected by a future step in the admission
        /// change and the side effects therefore need to be undone. Requests with the dryRun
        /// attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or
        /// Some. Defaults to Unknown.
        /// </summary>
      public readonly string SideEffects;

      /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 30 seconds.
        /// </summary>
      public readonly int TimeoutSeconds;

      [OutputConstructor]
      private MutatingWebhook(
          ImmutableArray<string> @admissionReviewVersions,
          AdmissionRegistration.V1Beta1.WebhookClientConfig @clientConfig,
          string @failurePolicy,
          string @matchPolicy,
          string @name,
          Meta.V1.LabelSelector @namespaceSelector,
          Meta.V1.LabelSelector @objectSelector,
          string @reinvocationPolicy,
          ImmutableArray<AdmissionRegistration.V1Beta1.RuleWithOperations> @rules,
          string @sideEffects,
          int @timeoutSeconds)
      {
          this.AdmissionReviewVersions = @admissionReviewVersions;
          this.ClientConfig = @clientConfig;
          this.FailurePolicy = @failurePolicy;
          this.MatchPolicy = @matchPolicy;
          this.Name = @name;
          this.NamespaceSelector = @namespaceSelector;
          this.ObjectSelector = @objectSelector;
          this.ReinvocationPolicy = @reinvocationPolicy;
          this.Rules = @rules;
          this.SideEffects = @sideEffects;
          this.TimeoutSeconds = @timeoutSeconds;
      }

    }
    /// <summary>
    /// MutatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and may change the object. Deprecated in v1.16, planned for removal in
    /// v1.19. Use admissionregistration.k8s.io/v1 MutatingWebhookConfiguration instead.
    /// </summary>
    [OutputType]
    public sealed class MutatingWebhookConfiguration
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1Beta1.MutatingWebhook> Webhooks;

      [OutputConstructor]
      private MutatingWebhookConfiguration(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<AdmissionRegistration.V1Beta1.MutatingWebhook> @webhooks)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Webhooks = @webhooks;
      }

    }
    /// <summary>
    /// MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
    /// </summary>
    [OutputType]
    public sealed class MutatingWebhookConfigurationList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of MutatingWebhookConfiguration.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1Beta1.MutatingWebhookConfiguration> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private MutatingWebhookConfigurationList(
          string @apiVersion,
          ImmutableArray<AdmissionRegistration.V1Beta1.MutatingWebhookConfiguration> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure
    /// that all the tuple expansions are valid.
    /// </summary>
    [OutputType]
    public sealed class RuleWithOperations
    {
      /// <summary>
        /// APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
      public readonly ImmutableArray<string> ApiGroups;

      /// <summary>
        /// APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is
        /// present, the length of the slice must be one. Required.
        /// </summary>
      public readonly ImmutableArray<string> ApiVersions;

      /// <summary>
        /// Operations is the operations the admission hook cares about - CREATE, UPDATE, or * for
        /// all operations. If '*' is present, the length of the slice must be one. Required.
        /// </summary>
      public readonly ImmutableArray<string> Operations;

      /// <summary>
        /// Resources is a list of resources this rule applies to.
        /// 
        /// For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means
        /// all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale'
        /// means all scale subresources. '*/*' means all resources and their subresources.
        /// 
        /// If wildcard is present, the validation rule will ensure resources do not overlap with
        /// each other.
        /// 
        /// Depending on the enclosing object, subresources might not be allowed. Required.
        /// </summary>
      public readonly ImmutableArray<string> Resources;

      /// <summary>
        /// scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and
        /// "*" "Cluster" means that only cluster-scoped resources will match this rule. Namespace
        /// API objects are cluster-scoped. "Namespaced" means that only namespaced resources will
        /// match this rule. "*" means that there are no scope restrictions. Subresources match the
        /// scope of their parent resource. Default is "*".
        /// </summary>
      public readonly string Scope;

      [OutputConstructor]
      private RuleWithOperations(
          ImmutableArray<string> @apiGroups,
          ImmutableArray<string> @apiVersions,
          ImmutableArray<string> @operations,
          ImmutableArray<string> @resources,
          string @scope)
      {
          this.ApiGroups = @apiGroups;
          this.ApiVersions = @apiVersions;
          this.Operations = @operations;
          this.Resources = @resources;
          this.Scope = @scope;
      }

    }
    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    [OutputType]
    public sealed class ServiceReference
    {
      /// <summary>
        /// `name` is the name of the service. Required
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// `namespace` is the namespace of the service. Required
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// `path` is an optional URL path which will be sent in any request to this service.
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
      public readonly int Port;

      [OutputConstructor]
      private ServiceReference(
          string @name,
          string @namespace,
          string @path,
          int @port)
      {
          this.Name = @name;
          this.Namespace = @namespace;
          this.Path = @path;
          this.Port = @port;
      }

    }
    /// <summary>
    /// ValidatingWebhook describes an admission webhook and the resources and operations it applies
    /// to.
    /// </summary>
    [OutputType]
    public sealed class ValidatingWebhook
    {
      /// <summary>
        /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
        /// Webhook expects. API server will try to use first version in the list which it supports.
        /// If none of the versions specified in this list supported by API server, validation will
        /// fail for this object. If a persisted webhook configuration specifies allowed versions
        /// and does not include any versions known to the API Server, calls to the webhook will
        /// fail and be subject to the failure policy. Default to `['v1beta1']`.
        /// </summary>
      public readonly ImmutableArray<string> AdmissionReviewVersions;

      /// <summary>
        /// ClientConfig defines how to communicate with the hook. Required
        /// </summary>
      public readonly AdmissionRegistration.V1Beta1.WebhookClientConfig ClientConfig;

      /// <summary>
        /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
        /// allowed values are Ignore or Fail. Defaults to Ignore.
        /// </summary>
      public readonly string FailurePolicy;

      /// <summary>
        /// matchPolicy defines how the "rules" list is used to match incoming requests. Allowed
        /// values are "Exact" or "Equivalent".
        /// 
        /// - Exact: match a request only if it exactly matches a specified rule. For example, if
        /// deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but
        /// "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources:
        /// ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to
        /// the webhook.
        /// 
        /// - Equivalent: match a request if modifies a resource listed in rules, even via another
        /// API group or version. For example, if deployments can be modified via apps/v1,
        /// apps/v1beta1, and extensions/v1beta1, and "rules" only included `apiGroups:["apps"],
        /// apiVersions:["v1"], resources: ["deployments"]`, a request to apps/v1beta1 or
        /// extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
        /// 
        /// Defaults to "Exact"
        /// </summary>
      public readonly string MatchPolicy;

      /// <summary>
        /// The name of the admission webhook. Name should be fully qualified, e.g.,
        /// imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
        /// kubernetes.io is the name of the organization. Required.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// NamespaceSelector decides whether to run the webhook on an object based on whether the
        /// namespace for that object matches the selector. If the object itself is a namespace, the
        /// matching is performed on object.metadata.labels. If the object is another cluster scoped
        /// resource, it never skips the webhook.
        /// 
        /// For example, to run the webhook on any objects whose namespace is not associated with
        /// "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "runlevel",
        ///       "operator": "NotIn",
        ///       "values": [
        ///         "0",
        ///         "1"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// If instead you want to only run the webhook on any objects whose namespace is associated
        /// with the "environment" of "prod" or "staging"; you will set the selector as follows:
        /// "namespaceSelector": {
        ///   "matchExpressions": [
        ///     {
        ///       "key": "environment",
        ///       "operator": "In",
        ///       "values": [
        ///         "prod",
        ///         "staging"
        ///       ]
        ///     }
        ///   ]
        /// }
        /// 
        /// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more
        /// examples of label selectors.
        /// 
        /// Default to the empty LabelSelector, which matches everything.
        /// </summary>
      public readonly Meta.V1.LabelSelector NamespaceSelector;

      /// <summary>
        /// ObjectSelector decides whether to run the webhook based on if the object has matching
        /// labels. objectSelector is evaluated against both the oldObject and newObject that would
        /// be sent to the webhook, and is considered to match if either object matches the
        /// selector. A null object (oldObject in the case of create, or newObject in the case of
        /// delete) or an object that cannot have labels (like a DeploymentRollback or a
        /// PodProxyOptions object) is not considered to match. Use the object selector only if the
        /// webhook is opt-in, because end users may skip the admission webhook by setting the
        /// labels. Default to the empty LabelSelector, which matches everything.
        /// </summary>
      public readonly Meta.V1.LabelSelector ObjectSelector;

      /// <summary>
        /// Rules describes what operations on what resources/subresources the webhook cares about.
        /// The webhook cares about an operation if it matches _any_ Rule. However, in order to
        /// prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the
        /// cluster in a state which cannot be recovered from without completely disabling the
        /// plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on
        /// admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
        /// objects.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1Beta1.RuleWithOperations> Rules;

      /// <summary>
        /// SideEffects states whether this webhook has side effects. Acceptable values are:
        /// Unknown, None, Some, NoneOnDryRun Webhooks with side effects MUST implement a
        /// reconciliation system, since a request may be rejected by a future step in the admission
        /// change and the side effects therefore need to be undone. Requests with the dryRun
        /// attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or
        /// Some. Defaults to Unknown.
        /// </summary>
      public readonly string SideEffects;

      /// <summary>
        /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
        /// webhook call will be ignored or the API call will fail based on the failure policy. The
        /// timeout value must be between 1 and 30 seconds. Default to 30 seconds.
        /// </summary>
      public readonly int TimeoutSeconds;

      [OutputConstructor]
      private ValidatingWebhook(
          ImmutableArray<string> @admissionReviewVersions,
          AdmissionRegistration.V1Beta1.WebhookClientConfig @clientConfig,
          string @failurePolicy,
          string @matchPolicy,
          string @name,
          Meta.V1.LabelSelector @namespaceSelector,
          Meta.V1.LabelSelector @objectSelector,
          ImmutableArray<AdmissionRegistration.V1Beta1.RuleWithOperations> @rules,
          string @sideEffects,
          int @timeoutSeconds)
      {
          this.AdmissionReviewVersions = @admissionReviewVersions;
          this.ClientConfig = @clientConfig;
          this.FailurePolicy = @failurePolicy;
          this.MatchPolicy = @matchPolicy;
          this.Name = @name;
          this.NamespaceSelector = @namespaceSelector;
          this.ObjectSelector = @objectSelector;
          this.Rules = @rules;
          this.SideEffects = @sideEffects;
          this.TimeoutSeconds = @timeoutSeconds;
      }

    }
    /// <summary>
    /// ValidatingWebhookConfiguration describes the configuration of and admission webhook that
    /// accept or reject and object without changing it. Deprecated in v1.16, planned for removal in
    /// v1.19. Use admissionregistration.k8s.io/v1 ValidatingWebhookConfiguration instead.
    /// </summary>
    [OutputType]
    public sealed class ValidatingWebhookConfiguration
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Webhooks is a list of webhooks and the affected resources and operations.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1Beta1.ValidatingWebhook> Webhooks;

      [OutputConstructor]
      private ValidatingWebhookConfiguration(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<AdmissionRegistration.V1Beta1.ValidatingWebhook> @webhooks)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Webhooks = @webhooks;
      }

    }
    /// <summary>
    /// ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
    /// </summary>
    [OutputType]
    public sealed class ValidatingWebhookConfigurationList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of ValidatingWebhookConfiguration.
        /// </summary>
      public readonly ImmutableArray<AdmissionRegistration.V1Beta1.ValidatingWebhookConfiguration> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ValidatingWebhookConfigurationList(
          string @apiVersion,
          ImmutableArray<AdmissionRegistration.V1Beta1.ValidatingWebhookConfiguration> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook
    /// </summary>
    [OutputType]
    public sealed class WebhookClientConfig
    {
      /// <summary>
        /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's
        /// server certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
      public readonly string CaBundle;

      /// <summary>
        /// `service` is a reference to the service for this webhook. Either `service` or `url` must
        /// be specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
      public readonly AdmissionRegistration.V1Beta1.ServiceReference Service;

      /// <summary>
        /// `url` gives the location of the webhook, in standard URL form
        /// (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
      public readonly string Url;

      [OutputConstructor]
      private WebhookClientConfig(
          string @caBundle,
          AdmissionRegistration.V1Beta1.ServiceReference @service,
          string @url)
      {
          this.CaBundle = @caBundle;
          this.Service = @service;
          this.Url = @url;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.ApiExtensions
{
  namespace V1
  {
    /// <summary>
    /// CustomResourceColumnDefinition specifies a column for server side printing.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceColumnDefinition
    {
      /// <summary>
        /// description is a human readable description of this column.
        /// </summary>
      public readonly string Description;

      /// <summary>
        /// format is an optional OpenAPI type definition for this column. The 'name' format is
        /// applied to the primary identifier column to assist in clients identifying column is the
        /// resource name. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
      public readonly string Format;

      /// <summary>
        /// jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against
        /// each custom resource to produce the value for this column.
        /// </summary>
      public readonly string JsonPath;

      /// <summary>
        /// name is a human readable name for the column.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// priority is an integer defining the relative importance of this column compared to
        /// others. Lower numbers are considered higher priority. Columns that may be omitted in
        /// limited space scenarios should be given a priority greater than 0.
        /// </summary>
      public readonly int Priority;

      /// <summary>
        /// type is an OpenAPI type definition for this column. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private CustomResourceColumnDefinition(
          string @description,
          string @format,
          string @jsonPath,
          string @name,
          int @priority,
          string @type)
      {
          this.Description = @description;
          this.Format = @format;
          this.JsonPath = @jsonPath;
          this.Name = @name;
          this.Priority = @priority;
          this.Type = @type;
      }

    }
    /// <summary>
    /// CustomResourceConversion describes how to convert different versions of a CR.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceConversion
    {
      /// <summary>
        /// strategy specifies how custom resources are converted between versions. Allowed values
        /// are: - `None`: The converter only change the apiVersion and would not touch any other
        /// field in the custom resource. - `Webhook`: API Server will call to an external webhook
        /// to do the conversion. Additional information
        ///   is needed for this option. This requires spec.preserveUnknownFields to be false, and
        /// spec.conversion.webhook to be set.
        /// </summary>
      public readonly string Strategy;

      /// <summary>
        /// webhook describes how to call the conversion webhook. Required when `strategy` is set to
        /// `Webhook`.
        /// </summary>
      public readonly ApiExtensions.V1.WebhookConversion Webhook;

      [OutputConstructor]
      private CustomResourceConversion(
          string @strategy,
          ApiExtensions.V1.WebhookConversion @webhook)
      {
          this.Strategy = @strategy;
          this.Webhook = @webhook;
      }

    }
    /// <summary>
    /// CustomResourceDefinition represents a resource that should be exposed on the API server.
    /// Its name MUST be in the format &amp;lt;.spec.name&amp;gt;.&amp;lt;.spec.group&amp;gt;.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinition
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// spec describes how the user wants the resources to appear
        /// </summary>
      public readonly ApiExtensions.V1.CustomResourceDefinitionSpec Spec;

      /// <summary>
        /// status indicates the actual state of the CustomResourceDefinition
        /// </summary>
      public readonly ApiExtensions.V1.CustomResourceDefinitionStatus Status;

      [OutputConstructor]
      private CustomResourceDefinition(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ApiExtensions.V1.CustomResourceDefinitionSpec @spec,
          ApiExtensions.V1.CustomResourceDefinitionStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionCondition contains details for the current condition of this pod.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionCondition
    {
      /// <summary>
        /// lastTransitionTime last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// message is a human-readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// reason is a unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// type is the type of the condition. Types include Established, NamesAccepted and
        /// Terminating.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private CustomResourceDefinitionCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items list individual CustomResourceDefinition objects
        /// </summary>
      public readonly ImmutableArray<ApiExtensions.V1.CustomResourceDefinition> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private CustomResourceDefinitionList(
          string @apiVersion,
          ImmutableArray<ApiExtensions.V1.CustomResourceDefinition> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionNames
    {
      /// <summary>
        /// categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
        /// This is published in API discovery documents, and used by clients to support invocations
        /// like `kubectl get all`.
        /// </summary>
      public readonly ImmutableArray<string> Categories;

      /// <summary>
        /// kind is the serialized kind of the resource. It is normally CamelCase and singular.
        /// Custom resource instances will use this value as the `kind` attribute in API calls.
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
        /// </summary>
      public readonly string ListKind;

      /// <summary>
        /// plural is the plural name of the resource to serve. The custom resources are served
        /// under `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/.../&amp;lt;plural&amp;gt;`.
        /// Must match the name of the CustomResourceDefinition (in the form
        /// `&amp;lt;names.plural&amp;gt;.&amp;lt;group&amp;gt;`). Must be all lowercase.
        /// </summary>
      public readonly string Plural;

      /// <summary>
        /// shortNames are short names for the resource, exposed in API discovery documents, and
        /// used by clients to support invocations like `kubectl get &amp;lt;shortname&amp;gt;`. It
        /// must be all lowercase.
        /// </summary>
      public readonly ImmutableArray<string> ShortNames;

      /// <summary>
        /// singular is the singular name of the resource. It must be all lowercase. Defaults to
        /// lowercased `kind`.
        /// </summary>
      public readonly string Singular;

      [OutputConstructor]
      private CustomResourceDefinitionNames(
          ImmutableArray<string> @categories,
          string @kind,
          string @listKind,
          string @plural,
          ImmutableArray<string> @shortNames,
          string @singular)
      {
          this.Categories = @categories;
          this.Kind = @kind;
          this.ListKind = @listKind;
          this.Plural = @plural;
          this.ShortNames = @shortNames;
          this.Singular = @singular;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionSpec describes how a user wants their resource to appear
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionSpec
    {
      /// <summary>
        /// conversion defines conversion settings for the CRD.
        /// </summary>
      public readonly ApiExtensions.V1.CustomResourceConversion Conversion;

      /// <summary>
        /// group is the API group of the defined custom resource. The custom resources are served
        /// under `/apis/&amp;lt;group&amp;gt;/...`. Must match the name of the
        /// CustomResourceDefinition (in the form
        /// `&amp;lt;names.plural&amp;gt;.&amp;lt;group&amp;gt;`).
        /// </summary>
      public readonly string Group;

      /// <summary>
        /// names specify the resource and kind names for the custom resource.
        /// </summary>
      public readonly ApiExtensions.V1.CustomResourceDefinitionNames Names;

      /// <summary>
        /// preserveUnknownFields indicates that object fields which are not specified in the
        /// OpenAPI schema should be preserved when persisting to storage. apiVersion, kind,
        /// metadata and known fields inside metadata are always preserved. This field is deprecated
        /// in favor of setting `x-preserve-unknown-fields` to true in
        /// `spec.versions[*].schema.openAPIV3Schema`. See
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields
        /// for details.
        /// </summary>
      public readonly bool PreserveUnknownFields;

      /// <summary>
        /// scope indicates whether the defined custom resource is cluster- or namespace-scoped.
        /// Allowed values are `Cluster` and `Namespaced`.
        /// </summary>
      public readonly string Scope;

      /// <summary>
        /// versions is the list of all API versions of the defined custom resource. Version names
        /// are used to compute the order in which served versions are listed in API discovery. If
        /// the version string is "kube-like", it will sort above non "kube-like" version strings,
        /// which are ordered lexicographically. "Kube-like" versions start with a "v", then are
        /// followed by a number (the major version), then optionally the string "alpha" or "beta"
        /// and another number (the minor version). These are sorted first by GA &amp;gt; beta
        /// &amp;gt; alpha (where GA is a version with no suffix such as beta or alpha), and then by
        /// comparing major version, then minor version. An example sorted list of versions: v10,
        /// v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
        /// </summary>
      public readonly ImmutableArray<ApiExtensions.V1.CustomResourceDefinitionVersion> Versions;

      [OutputConstructor]
      private CustomResourceDefinitionSpec(
          ApiExtensions.V1.CustomResourceConversion @conversion,
          string @group,
          ApiExtensions.V1.CustomResourceDefinitionNames @names,
          bool @preserveUnknownFields,
          string @scope,
          ImmutableArray<ApiExtensions.V1.CustomResourceDefinitionVersion> @versions)
      {
          this.Conversion = @conversion;
          this.Group = @group;
          this.Names = @names;
          this.PreserveUnknownFields = @preserveUnknownFields;
          this.Scope = @scope;
          this.Versions = @versions;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionStatus
    {
      /// <summary>
        /// acceptedNames are the names that are actually being used to serve discovery. They may be
        /// different than the names in spec.
        /// </summary>
      public readonly ApiExtensions.V1.CustomResourceDefinitionNames AcceptedNames;

      /// <summary>
        /// conditions indicate state for particular aspects of a CustomResourceDefinition
        /// </summary>
      public readonly ImmutableArray<ApiExtensions.V1.CustomResourceDefinitionCondition> Conditions;

      /// <summary>
        /// storedVersions lists all versions of CustomResources that were ever persisted. Tracking
        /// these versions allows a migration path for stored versions in etcd. The field is mutable
        /// so a migration controller can finish a migration to another version (ensuring no old
        /// objects are left in storage), and then remove the rest of the versions from this list.
        /// Versions may not be removed from `spec.versions` while they exist in this list.
        /// </summary>
      public readonly ImmutableArray<string> StoredVersions;

      [OutputConstructor]
      private CustomResourceDefinitionStatus(
          ApiExtensions.V1.CustomResourceDefinitionNames @acceptedNames,
          ImmutableArray<ApiExtensions.V1.CustomResourceDefinitionCondition> @conditions,
          ImmutableArray<string> @storedVersions)
      {
          this.AcceptedNames = @acceptedNames;
          this.Conditions = @conditions;
          this.StoredVersions = @storedVersions;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionVersion describes a version for CRD.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionVersion
    {
      /// <summary>
        /// additionalPrinterColumns specifies additional columns returned in Table output. See
        /// https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
        /// for details. If no columns are specified, a single column displaying the age of the
        /// custom resource is used.
        /// </summary>
      public readonly ImmutableArray<ApiExtensions.V1.CustomResourceColumnDefinition> AdditionalPrinterColumns;

      /// <summary>
        /// name is the version name, e.g. “v1”, “v2beta1”, etc. The custom resources are
        /// served under this version at `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/...`
        /// if `served` is true.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// schema describes the schema used for validation, pruning, and defaulting of this version
        /// of the custom resource.
        /// </summary>
      public readonly ApiExtensions.V1.CustomResourceValidation Schema;

      /// <summary>
        /// served is a flag enabling/disabling this version from being served via REST APIs
        /// </summary>
      public readonly bool Served;

      /// <summary>
        /// storage indicates this version should be used when persisting custom resources to
        /// storage. There must be exactly one version with storage=true.
        /// </summary>
      public readonly bool Storage;

      /// <summary>
        /// subresources specify what subresources this version of the defined custom resource have.
        /// </summary>
      public readonly ApiExtensions.V1.CustomResourceSubresources Subresources;

      [OutputConstructor]
      private CustomResourceDefinitionVersion(
          ImmutableArray<ApiExtensions.V1.CustomResourceColumnDefinition> @additionalPrinterColumns,
          string @name,
          ApiExtensions.V1.CustomResourceValidation @schema,
          bool @served,
          bool @storage,
          ApiExtensions.V1.CustomResourceSubresources @subresources)
      {
          this.AdditionalPrinterColumns = @additionalPrinterColumns;
          this.Name = @name;
          this.Schema = @schema;
          this.Served = @served;
          this.Storage = @storage;
          this.Subresources = @subresources;
      }

    }
    /// <summary>
    /// CustomResourceSubresourceScale defines how to serve the scale subresource for
    /// CustomResources.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceSubresourceScale
    {
      /// <summary>
        /// labelSelectorPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status` or `.spec`. Must be set to work with
        /// HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not
        /// a complex selector struct) which contains a serialized label selector in string form.
        /// More info:
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource
        /// If there is no value under the given path in the custom resource, the `status.selector`
        /// value in the `/scale` subresource will default to the empty string.
        /// </summary>
      public readonly string LabelSelectorPath;

      /// <summary>
        /// specReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a
        /// JSON Path under `.spec`. If there is no value under the given path in the custom
        /// resource, the `/scale` subresource will return an error on GET.
        /// </summary>
      public readonly string SpecReplicasPath;

      /// <summary>
        /// statusReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status`. If there is no value under the given path in the custom
        /// resource, the `status.replicas` value in the `/scale` subresource will default to 0.
        /// </summary>
      public readonly string StatusReplicasPath;

      [OutputConstructor]
      private CustomResourceSubresourceScale(
          string @labelSelectorPath,
          string @specReplicasPath,
          string @statusReplicasPath)
      {
          this.LabelSelectorPath = @labelSelectorPath;
          this.SpecReplicasPath = @specReplicasPath;
          this.StatusReplicasPath = @statusReplicasPath;
      }

    }
    /// <summary>
    /// CustomResourceSubresources defines the status and scale subresources for CustomResources.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceSubresources
    {
      /// <summary>
        /// scale indicates the custom resource should serve a `/scale` subresource that returns an
        /// `autoscaling/v1` Scale object.
        /// </summary>
      public readonly ApiExtensions.V1.CustomResourceSubresourceScale Scale;

      /// <summary>
        /// status indicates the custom resource should serve a `/status` subresource. When enabled:
        /// 1. requests to the custom resource primary endpoint ignore changes to the `status`
        /// stanza of the object. 2. requests to the custom resource `/status` subresource ignore
        /// changes to anything other than the `status` stanza of the object.
        /// </summary>
      public readonly System.Text.Json.JsonElement Status;

      [OutputConstructor]
      private CustomResourceSubresources(
          ApiExtensions.V1.CustomResourceSubresourceScale @scale,
          System.Text.Json.JsonElement @status)
      {
          this.Scale = @scale;
          this.Status = @status;
      }

    }
    /// <summary>
    /// CustomResourceValidation is a list of validation methods for CustomResources.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceValidation
    {
      /// <summary>
        /// openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.
        /// </summary>
      public readonly ApiExtensions.V1.JSONSchemaProps OpenAPIV3Schema;

      [OutputConstructor]
      private CustomResourceValidation(
          ApiExtensions.V1.JSONSchemaProps @openAPIV3Schema)
      {
          this.OpenAPIV3Schema = @openAPIV3Schema;
      }

    }
    /// <summary>
    /// ExternalDocumentation allows referencing an external resource for extended documentation.
    /// </summary>
    [OutputType]
    public sealed class ExternalDocumentation
    {
      
      public readonly string Description;

      
      public readonly string Url;

      [OutputConstructor]
      private ExternalDocumentation(
          string @description,
          string @url)
      {
          this.Description = @description;
          this.Url = @url;
      }

    }
    /// <summary>
    /// JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
    /// </summary>
    [OutputType]
    public sealed class JSONSchemaProps
    {
      
      public readonly string Ref;

      
      public readonly string Schema;

      
      public readonly Union<ApiExtensions.V1.JSONSchemaProps,bool> AdditionalItems;

      
      public readonly Union<ApiExtensions.V1.JSONSchemaProps,bool> AdditionalProperties;

      
      public readonly ImmutableArray<ApiExtensions.V1.JSONSchemaProps> AllOf;

      
      public readonly ImmutableArray<ApiExtensions.V1.JSONSchemaProps> AnyOf;

      /// <summary>
        /// default is a default value for undefined object fields. Defaulting is a beta feature
        /// under the CustomResourceDefaulting feature gate. Defaulting requires
        /// spec.preserveUnknownFields to be false.
        /// </summary>
      public readonly System.Text.Json.JsonElement Default;

      
      public readonly ImmutableDictionary<string, ApiExtensions.V1.JSONSchemaProps> Definitions;

      
      public readonly ImmutableDictionary<string, Union<ApiExtensions.V1.JSONSchemaProps,ImmutableArray<string>>> Dependencies;

      
      public readonly string Description;

      
      public readonly ImmutableArray<System.Text.Json.JsonElement> Enum;

      
      public readonly System.Text.Json.JsonElement Example;

      
      public readonly bool ExclusiveMaximum;

      
      public readonly bool ExclusiveMinimum;

      
      public readonly ApiExtensions.V1.ExternalDocumentation ExternalDocs;

      /// <summary>
        /// format is an OpenAPI v3 format string. Unknown formats are ignored. The following
        /// formats are validated:
        /// 
        /// - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as
        /// parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang
        /// net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as
        /// defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang
        /// net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed
        /// by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an
        /// UUID that allows uppercase defined by the regex
        /// (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3
        /// that allows uppercase defined by the regex
        /// (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an
        /// UUID4 that allows uppercase defined by the regex
        /// (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5:
        /// an UUID5 that allows uppercase defined by the regex
        /// (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an
        /// ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10
        /// number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041"
        /// - creditcard: a credit card number defined by the regex
        /// ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$
        /// with any non digit characters mixed in - ssn: a U.S. social security number following
        /// the regex ^\d{3}[- ]?\d{2}[- ]?\d{4}$ - hexcolor: an hexadecimal color code like
        /// "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB
        /// color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data -
        /// password: any kind of string - date: a date string like "2006-01-02" as defined by
        /// full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang
        /// time.ParseDuration or compatible with Scala duration format - datetime: a date time
        /// string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
        /// </summary>
      public readonly string Format;

      
      public readonly string Id;

      
      public readonly Union<ApiExtensions.V1.JSONSchemaProps,ImmutableArray<string>> Items;

      
      public readonly int MaxItems;

      
      public readonly int MaxLength;

      
      public readonly int MaxProperties;

      
      public readonly double Maximum;

      
      public readonly int MinItems;

      
      public readonly int MinLength;

      
      public readonly int MinProperties;

      
      public readonly double Minimum;

      
      public readonly double MultipleOf;

      
      public readonly ApiExtensions.V1.JSONSchemaProps Not;

      
      public readonly bool Nullable;

      
      public readonly ImmutableArray<ApiExtensions.V1.JSONSchemaProps> OneOf;

      
      public readonly string Pattern;

      
      public readonly ImmutableDictionary<string, ApiExtensions.V1.JSONSchemaProps> PatternProperties;

      
      public readonly ImmutableDictionary<string, ApiExtensions.V1.JSONSchemaProps> Properties;

      
      public readonly ImmutableArray<string> Required;

      
      public readonly string Title;

      
      public readonly string Type;

      
      public readonly bool UniqueItems;

      /// <summary>
        /// x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes
        /// runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to
        /// further restrict the embedded object. kind, apiVersion and metadata are validated
        /// automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not
        /// have to be if the object is fully specified (up to kind, apiVersion, metadata).
        /// </summary>
      public readonly bool X_kubernetes_embedded_resource;

      /// <summary>
        /// x-kubernetes-int-or-string specifies that this value is either an integer or a string.
        /// If this is true, an empty type is allowed and type as child of anyOf is permitted if
        /// following one of the following patterns:
        /// 
        /// 1) anyOf:
        ///    - type: integer
        ///    - type: string
        /// 2) allOf:
        ///    - anyOf:
        ///      - type: integer
        ///      - type: string
        ///    - ... zero or more
        /// </summary>
      public readonly bool X_kubernetes_int_or_string;

      /// <summary>
        /// x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by
        /// specifying the keys used as the index of the map.
        /// 
        /// This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set
        /// to "map". Also, the values specified for this attribute must be a scalar typed field of
        /// the child structure (no nesting is supported).
        /// </summary>
      public readonly ImmutableArray<string> X_kubernetes_list_map_keys;

      /// <summary>
        /// x-kubernetes-list-type annotates an array to further describe its topology. This
        /// extension must only be used on lists and may have 3 possible values:
        /// 
        /// 1) `atomic`: the list is treated as a single entity, like a scalar.
        ///      Atomic lists will be entirely replaced when updated. This extension
        ///      may be used on any type of list (struct, scalar, ...).
        /// 2) `set`:
        ///      Sets are lists that must not have multiple items with the same value. Each
        ///      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an
        ///      array with x-kubernetes-list-type `atomic`.
        /// 3) `map`:
        ///      These lists are like maps in that their elements have a non-index key
        ///      used to identify them. Order is preserved upon merge. The map tag
        ///      must only be used on a list with elements of type object.
        /// Defaults to atomic for arrays.
        /// </summary>
      public readonly string X_kubernetes_list_type;

      /// <summary>
        /// x-kubernetes-map-type annotates an object to further describe its topology. This
        /// extension must only be used when type is object and may have 2 possible values:
        /// 
        /// 1) `granular`:
        ///      These maps are actual maps (key-value pairs) and each fields are independent
        ///      from each other (they can each be manipulated by separate actors). This is
        ///      the default behaviour for all maps.
        /// 2) `atomic`: the list is treated as a single entity, like a scalar.
        ///      Atomic maps will be entirely replaced when updated.
        /// </summary>
      public readonly string X_kubernetes_map_type;

      /// <summary>
        /// x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning
        /// fields which are not specified in the validation schema. This affects fields
        /// recursively, but switches back to normal pruning behaviour if nested properties or
        /// additionalProperties are specified in the schema. This can either be true or undefined.
        /// False is forbidden.
        /// </summary>
      public readonly bool X_kubernetes_preserve_unknown_fields;

      [OutputConstructor]
      private JSONSchemaProps(
          string @ref,
          string @schema,
          Union<ApiExtensions.V1.JSONSchemaProps,bool> @additionalItems,
          Union<ApiExtensions.V1.JSONSchemaProps,bool> @additionalProperties,
          ImmutableArray<ApiExtensions.V1.JSONSchemaProps> @allOf,
          ImmutableArray<ApiExtensions.V1.JSONSchemaProps> @anyOf,
          System.Text.Json.JsonElement @default,
          ImmutableDictionary<string, ApiExtensions.V1.JSONSchemaProps> @definitions,
          ImmutableDictionary<string, Union<ApiExtensions.V1.JSONSchemaProps,ImmutableArray<string>>> @dependencies,
          string @description,
          ImmutableArray<System.Text.Json.JsonElement> @enum,
          System.Text.Json.JsonElement @example,
          bool @exclusiveMaximum,
          bool @exclusiveMinimum,
          ApiExtensions.V1.ExternalDocumentation @externalDocs,
          string @format,
          string @id,
          Union<ApiExtensions.V1.JSONSchemaProps,ImmutableArray<string>> @items,
          int @maxItems,
          int @maxLength,
          int @maxProperties,
          double @maximum,
          int @minItems,
          int @minLength,
          int @minProperties,
          double @minimum,
          double @multipleOf,
          ApiExtensions.V1.JSONSchemaProps @not,
          bool @nullable,
          ImmutableArray<ApiExtensions.V1.JSONSchemaProps> @oneOf,
          string @pattern,
          ImmutableDictionary<string, ApiExtensions.V1.JSONSchemaProps> @patternProperties,
          ImmutableDictionary<string, ApiExtensions.V1.JSONSchemaProps> @properties,
          ImmutableArray<string> @required,
          string @title,
          string @type,
          bool @uniqueItems,
          bool @x_kubernetes_embedded_resource,
          bool @x_kubernetes_int_or_string,
          ImmutableArray<string> @x_kubernetes_list_map_keys,
          string @x_kubernetes_list_type,
          string @x_kubernetes_map_type,
          bool @x_kubernetes_preserve_unknown_fields)
      {
          this.Ref = @ref;
          this.Schema = @schema;
          this.AdditionalItems = @additionalItems;
          this.AdditionalProperties = @additionalProperties;
          this.AllOf = @allOf;
          this.AnyOf = @anyOf;
          this.Default = @default;
          this.Definitions = @definitions;
          this.Dependencies = @dependencies;
          this.Description = @description;
          this.Enum = @enum;
          this.Example = @example;
          this.ExclusiveMaximum = @exclusiveMaximum;
          this.ExclusiveMinimum = @exclusiveMinimum;
          this.ExternalDocs = @externalDocs;
          this.Format = @format;
          this.Id = @id;
          this.Items = @items;
          this.MaxItems = @maxItems;
          this.MaxLength = @maxLength;
          this.MaxProperties = @maxProperties;
          this.Maximum = @maximum;
          this.MinItems = @minItems;
          this.MinLength = @minLength;
          this.MinProperties = @minProperties;
          this.Minimum = @minimum;
          this.MultipleOf = @multipleOf;
          this.Not = @not;
          this.Nullable = @nullable;
          this.OneOf = @oneOf;
          this.Pattern = @pattern;
          this.PatternProperties = @patternProperties;
          this.Properties = @properties;
          this.Required = @required;
          this.Title = @title;
          this.Type = @type;
          this.UniqueItems = @uniqueItems;
          this.X_kubernetes_embedded_resource = @x_kubernetes_embedded_resource;
          this.X_kubernetes_int_or_string = @x_kubernetes_int_or_string;
          this.X_kubernetes_list_map_keys = @x_kubernetes_list_map_keys;
          this.X_kubernetes_list_type = @x_kubernetes_list_type;
          this.X_kubernetes_map_type = @x_kubernetes_map_type;
          this.X_kubernetes_preserve_unknown_fields = @x_kubernetes_preserve_unknown_fields;
      }

    }
    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    [OutputType]
    public sealed class ServiceReference
    {
      /// <summary>
        /// name is the name of the service. Required
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// namespace is the namespace of the service. Required
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// path is an optional URL path at which the webhook will be contacted.
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// port is an optional service port at which the webhook will be contacted. `port` should
        /// be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.
        /// </summary>
      public readonly int Port;

      [OutputConstructor]
      private ServiceReference(
          string @name,
          string @namespace,
          string @path,
          int @port)
      {
          this.Name = @name;
          this.Namespace = @namespace;
          this.Path = @path;
          this.Port = @port;
      }

    }
    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook.
    /// </summary>
    [OutputType]
    public sealed class WebhookClientConfig
    {
      /// <summary>
        /// caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server
        /// certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
      public readonly string CaBundle;

      /// <summary>
        /// service is a reference to the service for this webhook. Either service or url must be
        /// specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
      public readonly ApiExtensions.V1.ServiceReference Service;

      /// <summary>
        /// url gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
        /// Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
      public readonly string Url;

      [OutputConstructor]
      private WebhookClientConfig(
          string @caBundle,
          ApiExtensions.V1.ServiceReference @service,
          string @url)
      {
          this.CaBundle = @caBundle;
          this.Service = @service;
          this.Url = @url;
      }

    }
    /// <summary>
    /// WebhookConversion describes how to call a conversion webhook
    /// </summary>
    [OutputType]
    public sealed class WebhookConversion
    {
      /// <summary>
        /// clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
        /// </summary>
      public readonly ApiExtensions.V1.WebhookClientConfig ClientConfig;

      /// <summary>
        /// conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the
        /// Webhook expects. The API server will use the first version in the list which it
        /// supports. If none of the versions specified in this list are supported by API server,
        /// conversion will fail for the custom resource. If a persisted Webhook configuration
        /// specifies allowed versions and does not include any versions known to the API Server,
        /// calls to the webhook will fail.
        /// </summary>
      public readonly ImmutableArray<string> ConversionReviewVersions;

      [OutputConstructor]
      private WebhookConversion(
          ApiExtensions.V1.WebhookClientConfig @clientConfig,
          ImmutableArray<string> @conversionReviewVersions)
      {
          this.ClientConfig = @clientConfig;
          this.ConversionReviewVersions = @conversionReviewVersions;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// CustomResourceColumnDefinition specifies a column for server side printing.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceColumnDefinition
    {
      /// <summary>
        /// JSONPath is a simple JSON path (i.e. with array notation) which is evaluated against
        /// each custom resource to produce the value for this column.
        /// </summary>
      public readonly string JSONPath;

      /// <summary>
        /// description is a human readable description of this column.
        /// </summary>
      public readonly string Description;

      /// <summary>
        /// format is an optional OpenAPI type definition for this column. The 'name' format is
        /// applied to the primary identifier column to assist in clients identifying column is the
        /// resource name. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
      public readonly string Format;

      /// <summary>
        /// name is a human readable name for the column.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// priority is an integer defining the relative importance of this column compared to
        /// others. Lower numbers are considered higher priority. Columns that may be omitted in
        /// limited space scenarios should be given a priority greater than 0.
        /// </summary>
      public readonly int Priority;

      /// <summary>
        /// type is an OpenAPI type definition for this column. See
        /// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
        /// details.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private CustomResourceColumnDefinition(
          string @JSONPath,
          string @description,
          string @format,
          string @name,
          int @priority,
          string @type)
      {
          this.JSONPath = @JSONPath;
          this.Description = @description;
          this.Format = @format;
          this.Name = @name;
          this.Priority = @priority;
          this.Type = @type;
      }

    }
    /// <summary>
    /// CustomResourceConversion describes how to convert different versions of a CR.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceConversion
    {
      /// <summary>
        /// conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the
        /// Webhook expects. The API server will use the first version in the list which it
        /// supports. If none of the versions specified in this list are supported by API server,
        /// conversion will fail for the custom resource. If a persisted Webhook configuration
        /// specifies allowed versions and does not include any versions known to the API Server,
        /// calls to the webhook will fail. Defaults to `["v1beta1"]`.
        /// </summary>
      public readonly ImmutableArray<string> ConversionReviewVersions;

      /// <summary>
        /// strategy specifies how custom resources are converted between versions. Allowed values
        /// are: - `None`: The converter only change the apiVersion and would not touch any other
        /// field in the custom resource. - `Webhook`: API Server will call to an external webhook
        /// to do the conversion. Additional information
        ///   is needed for this option. This requires spec.preserveUnknownFields to be false, and
        /// spec.conversion.webhookClientConfig to be set.
        /// </summary>
      public readonly string Strategy;

      /// <summary>
        /// webhookClientConfig is the instructions for how to call the webhook if strategy is
        /// `Webhook`. Required when `strategy` is set to `Webhook`.
        /// </summary>
      public readonly ApiExtensions.V1Beta1.WebhookClientConfig WebhookClientConfig;

      [OutputConstructor]
      private CustomResourceConversion(
          ImmutableArray<string> @conversionReviewVersions,
          string @strategy,
          ApiExtensions.V1Beta1.WebhookClientConfig @webhookClientConfig)
      {
          this.ConversionReviewVersions = @conversionReviewVersions;
          this.Strategy = @strategy;
          this.WebhookClientConfig = @webhookClientConfig;
      }

    }
    /// <summary>
    /// CustomResourceDefinition represents a resource that should be exposed on the API server.
    /// Its name MUST be in the format &amp;lt;.spec.name&amp;gt;.&amp;lt;.spec.group&amp;gt;.
    /// Deprecated in v1.16, planned for removal in v1.19. Use apiextensions.k8s.io/v1
    /// CustomResourceDefinition instead.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinition
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// spec describes how the user wants the resources to appear
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceDefinitionSpec Spec;

      /// <summary>
        /// status indicates the actual state of the CustomResourceDefinition
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceDefinitionStatus Status;

      [OutputConstructor]
      private CustomResourceDefinition(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ApiExtensions.V1Beta1.CustomResourceDefinitionSpec @spec,
          ApiExtensions.V1Beta1.CustomResourceDefinitionStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionCondition contains details for the current condition of this pod.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionCondition
    {
      /// <summary>
        /// lastTransitionTime last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// message is a human-readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// reason is a unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// type is the type of the condition. Types include Established, NamesAccepted and
        /// Terminating.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private CustomResourceDefinitionCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items list individual CustomResourceDefinition objects
        /// </summary>
      public readonly ImmutableArray<ApiExtensions.V1Beta1.CustomResourceDefinition> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private CustomResourceDefinitionList(
          string @apiVersion,
          ImmutableArray<ApiExtensions.V1Beta1.CustomResourceDefinition> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionNames
    {
      /// <summary>
        /// categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
        /// This is published in API discovery documents, and used by clients to support invocations
        /// like `kubectl get all`.
        /// </summary>
      public readonly ImmutableArray<string> Categories;

      /// <summary>
        /// kind is the serialized kind of the resource. It is normally CamelCase and singular.
        /// Custom resource instances will use this value as the `kind` attribute in API calls.
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
        /// </summary>
      public readonly string ListKind;

      /// <summary>
        /// plural is the plural name of the resource to serve. The custom resources are served
        /// under `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/.../&amp;lt;plural&amp;gt;`.
        /// Must match the name of the CustomResourceDefinition (in the form
        /// `&amp;lt;names.plural&amp;gt;.&amp;lt;group&amp;gt;`). Must be all lowercase.
        /// </summary>
      public readonly string Plural;

      /// <summary>
        /// shortNames are short names for the resource, exposed in API discovery documents, and
        /// used by clients to support invocations like `kubectl get &amp;lt;shortname&amp;gt;`. It
        /// must be all lowercase.
        /// </summary>
      public readonly ImmutableArray<string> ShortNames;

      /// <summary>
        /// singular is the singular name of the resource. It must be all lowercase. Defaults to
        /// lowercased `kind`.
        /// </summary>
      public readonly string Singular;

      [OutputConstructor]
      private CustomResourceDefinitionNames(
          ImmutableArray<string> @categories,
          string @kind,
          string @listKind,
          string @plural,
          ImmutableArray<string> @shortNames,
          string @singular)
      {
          this.Categories = @categories;
          this.Kind = @kind;
          this.ListKind = @listKind;
          this.Plural = @plural;
          this.ShortNames = @shortNames;
          this.Singular = @singular;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionSpec describes how a user wants their resource to appear
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionSpec
    {
      /// <summary>
        /// additionalPrinterColumns specifies additional columns returned in Table output. See
        /// https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
        /// for details. If present, this field configures columns for all versions. Top-level and
        /// per-version columns are mutually exclusive. If no top-level or per-version columns are
        /// specified, a single column displaying the age of the custom resource is used.
        /// </summary>
      public readonly ImmutableArray<ApiExtensions.V1Beta1.CustomResourceColumnDefinition> AdditionalPrinterColumns;

      /// <summary>
        /// conversion defines conversion settings for the CRD.
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceConversion Conversion;

      /// <summary>
        /// group is the API group of the defined custom resource. The custom resources are served
        /// under `/apis/&amp;lt;group&amp;gt;/...`. Must match the name of the
        /// CustomResourceDefinition (in the form
        /// `&amp;lt;names.plural&amp;gt;.&amp;lt;group&amp;gt;`).
        /// </summary>
      public readonly string Group;

      /// <summary>
        /// names specify the resource and kind names for the custom resource.
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceDefinitionNames Names;

      /// <summary>
        /// preserveUnknownFields indicates that object fields which are not specified in the
        /// OpenAPI schema should be preserved when persisting to storage. apiVersion, kind,
        /// metadata and known fields inside metadata are always preserved. If false, schemas must
        /// be defined for all versions. Defaults to true in v1beta for backwards compatibility.
        /// Deprecated: will be required to be false in v1. Preservation of unknown fields can be
        /// specified in the validation schema using the `x-kubernetes-preserve-unknown-fields:
        /// true` extension. See
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields
        /// for details.
        /// </summary>
      public readonly bool PreserveUnknownFields;

      /// <summary>
        /// scope indicates whether the defined custom resource is cluster- or namespace-scoped.
        /// Allowed values are `Cluster` and `Namespaced`. Default is `Namespaced`.
        /// </summary>
      public readonly string Scope;

      /// <summary>
        /// subresources specify what subresources the defined custom resource has. If present, this
        /// field configures subresources for all versions. Top-level and per-version subresources
        /// are mutually exclusive.
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceSubresources Subresources;

      /// <summary>
        /// validation describes the schema used for validation and pruning of the custom resource.
        /// If present, this validation schema is used to validate all versions. Top-level and
        /// per-version schemas are mutually exclusive.
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceValidation Validation;

      /// <summary>
        /// version is the API version of the defined custom resource. The custom resources are
        /// served under `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/...`. Must match the
        /// name of the first item in the `versions` list if `version` and `versions` are both
        /// specified. Optional if `versions` is specified. Deprecated: use `versions` instead.
        /// </summary>
      public readonly string Version;

      /// <summary>
        /// versions is the list of all API versions of the defined custom resource. Optional if
        /// `version` is specified. The name of the first item in the `versions` list must match the
        /// `version` field if `version` and `versions` are both specified. Version names are used
        /// to compute the order in which served versions are listed in API discovery. If the
        /// version string is "kube-like", it will sort above non "kube-like" version strings, which
        /// are ordered lexicographically. "Kube-like" versions start with a "v", then are followed
        /// by a number (the major version), then optionally the string "alpha" or "beta" and
        /// another number (the minor version). These are sorted first by GA &amp;gt; beta &amp;gt;
        /// alpha (where GA is a version with no suffix such as beta or alpha), and then by
        /// comparing major version, then minor version. An example sorted list of versions: v10,
        /// v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
        /// </summary>
      public readonly ImmutableArray<ApiExtensions.V1Beta1.CustomResourceDefinitionVersion> Versions;

      [OutputConstructor]
      private CustomResourceDefinitionSpec(
          ImmutableArray<ApiExtensions.V1Beta1.CustomResourceColumnDefinition> @additionalPrinterColumns,
          ApiExtensions.V1Beta1.CustomResourceConversion @conversion,
          string @group,
          ApiExtensions.V1Beta1.CustomResourceDefinitionNames @names,
          bool @preserveUnknownFields,
          string @scope,
          ApiExtensions.V1Beta1.CustomResourceSubresources @subresources,
          ApiExtensions.V1Beta1.CustomResourceValidation @validation,
          string @version,
          ImmutableArray<ApiExtensions.V1Beta1.CustomResourceDefinitionVersion> @versions)
      {
          this.AdditionalPrinterColumns = @additionalPrinterColumns;
          this.Conversion = @conversion;
          this.Group = @group;
          this.Names = @names;
          this.PreserveUnknownFields = @preserveUnknownFields;
          this.Scope = @scope;
          this.Subresources = @subresources;
          this.Validation = @validation;
          this.Version = @version;
          this.Versions = @versions;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionStatus
    {
      /// <summary>
        /// acceptedNames are the names that are actually being used to serve discovery. They may be
        /// different than the names in spec.
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceDefinitionNames AcceptedNames;

      /// <summary>
        /// conditions indicate state for particular aspects of a CustomResourceDefinition
        /// </summary>
      public readonly ImmutableArray<ApiExtensions.V1Beta1.CustomResourceDefinitionCondition> Conditions;

      /// <summary>
        /// storedVersions lists all versions of CustomResources that were ever persisted. Tracking
        /// these versions allows a migration path for stored versions in etcd. The field is mutable
        /// so a migration controller can finish a migration to another version (ensuring no old
        /// objects are left in storage), and then remove the rest of the versions from this list.
        /// Versions may not be removed from `spec.versions` while they exist in this list.
        /// </summary>
      public readonly ImmutableArray<string> StoredVersions;

      [OutputConstructor]
      private CustomResourceDefinitionStatus(
          ApiExtensions.V1Beta1.CustomResourceDefinitionNames @acceptedNames,
          ImmutableArray<ApiExtensions.V1Beta1.CustomResourceDefinitionCondition> @conditions,
          ImmutableArray<string> @storedVersions)
      {
          this.AcceptedNames = @acceptedNames;
          this.Conditions = @conditions;
          this.StoredVersions = @storedVersions;
      }

    }
    /// <summary>
    /// CustomResourceDefinitionVersion describes a version for CRD.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceDefinitionVersion
    {
      /// <summary>
        /// additionalPrinterColumns specifies additional columns returned in Table output. See
        /// https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
        /// for details. Top-level and per-version columns are mutually exclusive. Per-version
        /// columns must not all be set to identical values (top-level columns should be used
        /// instead). If no top-level or per-version columns are specified, a single column
        /// displaying the age of the custom resource is used.
        /// </summary>
      public readonly ImmutableArray<ApiExtensions.V1Beta1.CustomResourceColumnDefinition> AdditionalPrinterColumns;

      /// <summary>
        /// name is the version name, e.g. “v1”, “v2beta1”, etc. The custom resources are
        /// served under this version at `/apis/&amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;/...`
        /// if `served` is true.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// schema describes the schema used for validation and pruning of this version of the
        /// custom resource. Top-level and per-version schemas are mutually exclusive. Per-version
        /// schemas must not all be set to identical values (top-level validation schema should be
        /// used instead).
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceValidation Schema;

      /// <summary>
        /// served is a flag enabling/disabling this version from being served via REST APIs
        /// </summary>
      public readonly bool Served;

      /// <summary>
        /// storage indicates this version should be used when persisting custom resources to
        /// storage. There must be exactly one version with storage=true.
        /// </summary>
      public readonly bool Storage;

      /// <summary>
        /// subresources specify what subresources this version of the defined custom resource have.
        /// Top-level and per-version subresources are mutually exclusive. Per-version subresources
        /// must not all be set to identical values (top-level subresources should be used instead).
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceSubresources Subresources;

      [OutputConstructor]
      private CustomResourceDefinitionVersion(
          ImmutableArray<ApiExtensions.V1Beta1.CustomResourceColumnDefinition> @additionalPrinterColumns,
          string @name,
          ApiExtensions.V1Beta1.CustomResourceValidation @schema,
          bool @served,
          bool @storage,
          ApiExtensions.V1Beta1.CustomResourceSubresources @subresources)
      {
          this.AdditionalPrinterColumns = @additionalPrinterColumns;
          this.Name = @name;
          this.Schema = @schema;
          this.Served = @served;
          this.Storage = @storage;
          this.Subresources = @subresources;
      }

    }
    /// <summary>
    /// CustomResourceSubresourceScale defines how to serve the scale subresource for
    /// CustomResources.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceSubresourceScale
    {
      /// <summary>
        /// labelSelectorPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status` or `.spec`. Must be set to work with
        /// HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not
        /// a complex selector struct) which contains a serialized label selector in string form.
        /// More info:
        /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource
        /// If there is no value under the given path in the custom resource, the `status.selector`
        /// value in the `/scale` subresource will default to the empty string.
        /// </summary>
      public readonly string LabelSelectorPath;

      /// <summary>
        /// specReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a
        /// JSON Path under `.spec`. If there is no value under the given path in the custom
        /// resource, the `/scale` subresource will return an error on GET.
        /// </summary>
      public readonly string SpecReplicasPath;

      /// <summary>
        /// statusReplicasPath defines the JSON path inside of a custom resource that corresponds to
        /// Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be
        /// a JSON Path under `.status`. If there is no value under the given path in the custom
        /// resource, the `status.replicas` value in the `/scale` subresource will default to 0.
        /// </summary>
      public readonly string StatusReplicasPath;

      [OutputConstructor]
      private CustomResourceSubresourceScale(
          string @labelSelectorPath,
          string @specReplicasPath,
          string @statusReplicasPath)
      {
          this.LabelSelectorPath = @labelSelectorPath;
          this.SpecReplicasPath = @specReplicasPath;
          this.StatusReplicasPath = @statusReplicasPath;
      }

    }
    /// <summary>
    /// CustomResourceSubresources defines the status and scale subresources for CustomResources.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceSubresources
    {
      /// <summary>
        /// scale indicates the custom resource should serve a `/scale` subresource that returns an
        /// `autoscaling/v1` Scale object.
        /// </summary>
      public readonly ApiExtensions.V1Beta1.CustomResourceSubresourceScale Scale;

      /// <summary>
        /// status indicates the custom resource should serve a `/status` subresource. When enabled:
        /// 1. requests to the custom resource primary endpoint ignore changes to the `status`
        /// stanza of the object. 2. requests to the custom resource `/status` subresource ignore
        /// changes to anything other than the `status` stanza of the object.
        /// </summary>
      public readonly System.Text.Json.JsonElement Status;

      [OutputConstructor]
      private CustomResourceSubresources(
          ApiExtensions.V1Beta1.CustomResourceSubresourceScale @scale,
          System.Text.Json.JsonElement @status)
      {
          this.Scale = @scale;
          this.Status = @status;
      }

    }
    /// <summary>
    /// CustomResourceValidation is a list of validation methods for CustomResources.
    /// </summary>
    [OutputType]
    public sealed class CustomResourceValidation
    {
      /// <summary>
        /// openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.
        /// </summary>
      public readonly ApiExtensions.V1Beta1.JSONSchemaProps OpenAPIV3Schema;

      [OutputConstructor]
      private CustomResourceValidation(
          ApiExtensions.V1Beta1.JSONSchemaProps @openAPIV3Schema)
      {
          this.OpenAPIV3Schema = @openAPIV3Schema;
      }

    }
    /// <summary>
    /// ExternalDocumentation allows referencing an external resource for extended documentation.
    /// </summary>
    [OutputType]
    public sealed class ExternalDocumentation
    {
      
      public readonly string Description;

      
      public readonly string Url;

      [OutputConstructor]
      private ExternalDocumentation(
          string @description,
          string @url)
      {
          this.Description = @description;
          this.Url = @url;
      }

    }
    /// <summary>
    /// JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
    /// </summary>
    [OutputType]
    public sealed class JSONSchemaProps
    {
      
      public readonly string Ref;

      
      public readonly string Schema;

      
      public readonly Union<ApiExtensions.V1Beta1.JSONSchemaProps,bool> AdditionalItems;

      
      public readonly Union<ApiExtensions.V1Beta1.JSONSchemaProps,bool> AdditionalProperties;

      
      public readonly ImmutableArray<ApiExtensions.V1Beta1.JSONSchemaProps> AllOf;

      
      public readonly ImmutableArray<ApiExtensions.V1Beta1.JSONSchemaProps> AnyOf;

      /// <summary>
        /// default is a default value for undefined object fields. Defaulting is a beta feature
        /// under the CustomResourceDefaulting feature gate. CustomResourceDefinitions with defaults
        /// must be created using the v1 (or newer) CustomResourceDefinition API.
        /// </summary>
      public readonly System.Text.Json.JsonElement Default;

      
      public readonly ImmutableDictionary<string, ApiExtensions.V1Beta1.JSONSchemaProps> Definitions;

      
      public readonly ImmutableDictionary<string, Union<ApiExtensions.V1Beta1.JSONSchemaProps,ImmutableArray<string>>> Dependencies;

      
      public readonly string Description;

      
      public readonly ImmutableArray<System.Text.Json.JsonElement> Enum;

      
      public readonly System.Text.Json.JsonElement Example;

      
      public readonly bool ExclusiveMaximum;

      
      public readonly bool ExclusiveMinimum;

      
      public readonly ApiExtensions.V1Beta1.ExternalDocumentation ExternalDocs;

      /// <summary>
        /// format is an OpenAPI v3 format string. Unknown formats are ignored. The following
        /// formats are validated:
        /// 
        /// - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as
        /// parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang
        /// net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as
        /// defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang
        /// net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed
        /// by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an
        /// UUID that allows uppercase defined by the regex
        /// (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3
        /// that allows uppercase defined by the regex
        /// (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an
        /// UUID4 that allows uppercase defined by the regex
        /// (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5:
        /// an UUID5 that allows uppercase defined by the regex
        /// (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an
        /// ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10
        /// number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041"
        /// - creditcard: a credit card number defined by the regex
        /// ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$
        /// with any non digit characters mixed in - ssn: a U.S. social security number following
        /// the regex ^\d{3}[- ]?\d{2}[- ]?\d{4}$ - hexcolor: an hexadecimal color code like
        /// "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB
        /// color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data -
        /// password: any kind of string - date: a date string like "2006-01-02" as defined by
        /// full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang
        /// time.ParseDuration or compatible with Scala duration format - datetime: a date time
        /// string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
        /// </summary>
      public readonly string Format;

      
      public readonly string Id;

      
      public readonly Union<ApiExtensions.V1Beta1.JSONSchemaProps,ImmutableArray<string>> Items;

      
      public readonly int MaxItems;

      
      public readonly int MaxLength;

      
      public readonly int MaxProperties;

      
      public readonly double Maximum;

      
      public readonly int MinItems;

      
      public readonly int MinLength;

      
      public readonly int MinProperties;

      
      public readonly double Minimum;

      
      public readonly double MultipleOf;

      
      public readonly ApiExtensions.V1Beta1.JSONSchemaProps Not;

      
      public readonly bool Nullable;

      
      public readonly ImmutableArray<ApiExtensions.V1Beta1.JSONSchemaProps> OneOf;

      
      public readonly string Pattern;

      
      public readonly ImmutableDictionary<string, ApiExtensions.V1Beta1.JSONSchemaProps> PatternProperties;

      
      public readonly ImmutableDictionary<string, ApiExtensions.V1Beta1.JSONSchemaProps> Properties;

      
      public readonly ImmutableArray<string> Required;

      
      public readonly string Title;

      
      public readonly string Type;

      
      public readonly bool UniqueItems;

      /// <summary>
        /// x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes
        /// runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to
        /// further restrict the embedded object. kind, apiVersion and metadata are validated
        /// automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not
        /// have to be if the object is fully specified (up to kind, apiVersion, metadata).
        /// </summary>
      public readonly bool X_kubernetes_embedded_resource;

      /// <summary>
        /// x-kubernetes-int-or-string specifies that this value is either an integer or a string.
        /// If this is true, an empty type is allowed and type as child of anyOf is permitted if
        /// following one of the following patterns:
        /// 
        /// 1) anyOf:
        ///    - type: integer
        ///    - type: string
        /// 2) allOf:
        ///    - anyOf:
        ///      - type: integer
        ///      - type: string
        ///    - ... zero or more
        /// </summary>
      public readonly bool X_kubernetes_int_or_string;

      /// <summary>
        /// x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by
        /// specifying the keys used as the index of the map.
        /// 
        /// This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set
        /// to "map". Also, the values specified for this attribute must be a scalar typed field of
        /// the child structure (no nesting is supported).
        /// </summary>
      public readonly ImmutableArray<string> X_kubernetes_list_map_keys;

      /// <summary>
        /// x-kubernetes-list-type annotates an array to further describe its topology. This
        /// extension must only be used on lists and may have 3 possible values:
        /// 
        /// 1) `atomic`: the list is treated as a single entity, like a scalar.
        ///      Atomic lists will be entirely replaced when updated. This extension
        ///      may be used on any type of list (struct, scalar, ...).
        /// 2) `set`:
        ///      Sets are lists that must not have multiple items with the same value. Each
        ///      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an
        ///      array with x-kubernetes-list-type `atomic`.
        /// 3) `map`:
        ///      These lists are like maps in that their elements have a non-index key
        ///      used to identify them. Order is preserved upon merge. The map tag
        ///      must only be used on a list with elements of type object.
        /// Defaults to atomic for arrays.
        /// </summary>
      public readonly string X_kubernetes_list_type;

      /// <summary>
        /// x-kubernetes-map-type annotates an object to further describe its topology. This
        /// extension must only be used when type is object and may have 2 possible values:
        /// 
        /// 1) `granular`:
        ///      These maps are actual maps (key-value pairs) and each fields are independent
        ///      from each other (they can each be manipulated by separate actors). This is
        ///      the default behaviour for all maps.
        /// 2) `atomic`: the list is treated as a single entity, like a scalar.
        ///      Atomic maps will be entirely replaced when updated.
        /// </summary>
      public readonly string X_kubernetes_map_type;

      /// <summary>
        /// x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning
        /// fields which are not specified in the validation schema. This affects fields
        /// recursively, but switches back to normal pruning behaviour if nested properties or
        /// additionalProperties are specified in the schema. This can either be true or undefined.
        /// False is forbidden.
        /// </summary>
      public readonly bool X_kubernetes_preserve_unknown_fields;

      [OutputConstructor]
      private JSONSchemaProps(
          string @ref,
          string @schema,
          Union<ApiExtensions.V1Beta1.JSONSchemaProps,bool> @additionalItems,
          Union<ApiExtensions.V1Beta1.JSONSchemaProps,bool> @additionalProperties,
          ImmutableArray<ApiExtensions.V1Beta1.JSONSchemaProps> @allOf,
          ImmutableArray<ApiExtensions.V1Beta1.JSONSchemaProps> @anyOf,
          System.Text.Json.JsonElement @default,
          ImmutableDictionary<string, ApiExtensions.V1Beta1.JSONSchemaProps> @definitions,
          ImmutableDictionary<string, Union<ApiExtensions.V1Beta1.JSONSchemaProps,ImmutableArray<string>>> @dependencies,
          string @description,
          ImmutableArray<System.Text.Json.JsonElement> @enum,
          System.Text.Json.JsonElement @example,
          bool @exclusiveMaximum,
          bool @exclusiveMinimum,
          ApiExtensions.V1Beta1.ExternalDocumentation @externalDocs,
          string @format,
          string @id,
          Union<ApiExtensions.V1Beta1.JSONSchemaProps,ImmutableArray<string>> @items,
          int @maxItems,
          int @maxLength,
          int @maxProperties,
          double @maximum,
          int @minItems,
          int @minLength,
          int @minProperties,
          double @minimum,
          double @multipleOf,
          ApiExtensions.V1Beta1.JSONSchemaProps @not,
          bool @nullable,
          ImmutableArray<ApiExtensions.V1Beta1.JSONSchemaProps> @oneOf,
          string @pattern,
          ImmutableDictionary<string, ApiExtensions.V1Beta1.JSONSchemaProps> @patternProperties,
          ImmutableDictionary<string, ApiExtensions.V1Beta1.JSONSchemaProps> @properties,
          ImmutableArray<string> @required,
          string @title,
          string @type,
          bool @uniqueItems,
          bool @x_kubernetes_embedded_resource,
          bool @x_kubernetes_int_or_string,
          ImmutableArray<string> @x_kubernetes_list_map_keys,
          string @x_kubernetes_list_type,
          string @x_kubernetes_map_type,
          bool @x_kubernetes_preserve_unknown_fields)
      {
          this.Ref = @ref;
          this.Schema = @schema;
          this.AdditionalItems = @additionalItems;
          this.AdditionalProperties = @additionalProperties;
          this.AllOf = @allOf;
          this.AnyOf = @anyOf;
          this.Default = @default;
          this.Definitions = @definitions;
          this.Dependencies = @dependencies;
          this.Description = @description;
          this.Enum = @enum;
          this.Example = @example;
          this.ExclusiveMaximum = @exclusiveMaximum;
          this.ExclusiveMinimum = @exclusiveMinimum;
          this.ExternalDocs = @externalDocs;
          this.Format = @format;
          this.Id = @id;
          this.Items = @items;
          this.MaxItems = @maxItems;
          this.MaxLength = @maxLength;
          this.MaxProperties = @maxProperties;
          this.Maximum = @maximum;
          this.MinItems = @minItems;
          this.MinLength = @minLength;
          this.MinProperties = @minProperties;
          this.Minimum = @minimum;
          this.MultipleOf = @multipleOf;
          this.Not = @not;
          this.Nullable = @nullable;
          this.OneOf = @oneOf;
          this.Pattern = @pattern;
          this.PatternProperties = @patternProperties;
          this.Properties = @properties;
          this.Required = @required;
          this.Title = @title;
          this.Type = @type;
          this.UniqueItems = @uniqueItems;
          this.X_kubernetes_embedded_resource = @x_kubernetes_embedded_resource;
          this.X_kubernetes_int_or_string = @x_kubernetes_int_or_string;
          this.X_kubernetes_list_map_keys = @x_kubernetes_list_map_keys;
          this.X_kubernetes_list_type = @x_kubernetes_list_type;
          this.X_kubernetes_map_type = @x_kubernetes_map_type;
          this.X_kubernetes_preserve_unknown_fields = @x_kubernetes_preserve_unknown_fields;
      }

    }
    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    [OutputType]
    public sealed class ServiceReference
    {
      /// <summary>
        /// name is the name of the service. Required
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// namespace is the namespace of the service. Required
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// path is an optional URL path at which the webhook will be contacted.
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// port is an optional service port at which the webhook will be contacted. `port` should
        /// be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.
        /// </summary>
      public readonly int Port;

      [OutputConstructor]
      private ServiceReference(
          string @name,
          string @namespace,
          string @path,
          int @port)
      {
          this.Name = @name;
          this.Namespace = @namespace;
          this.Path = @path;
          this.Port = @port;
      }

    }
    /// <summary>
    /// WebhookClientConfig contains the information to make a TLS connection with the webhook.
    /// </summary>
    [OutputType]
    public sealed class WebhookClientConfig
    {
      /// <summary>
        /// caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server
        /// certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
      public readonly string CaBundle;

      /// <summary>
        /// service is a reference to the service for this webhook. Either service or url must be
        /// specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
      public readonly ApiExtensions.V1Beta1.ServiceReference Service;

      /// <summary>
        /// url gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
        /// Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
      public readonly string Url;

      [OutputConstructor]
      private WebhookClientConfig(
          string @caBundle,
          ApiExtensions.V1Beta1.ServiceReference @service,
          string @url)
      {
          this.CaBundle = @caBundle;
          this.Service = @service;
          this.Url = @url;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.ApiRegistration
{
  namespace V1
  {
    /// <summary>
    /// APIService represents a server for a particular GroupVersion. Name must be "version.group".
    /// </summary>
    [OutputType]
    public sealed class APIService
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec contains information for locating and communicating with a server
        /// </summary>
      public readonly ApiRegistration.V1.APIServiceSpec Spec;

      /// <summary>
        /// Status contains derived information about an API server
        /// </summary>
      public readonly ApiRegistration.V1.APIServiceStatus Status;

      [OutputConstructor]
      private APIService(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ApiRegistration.V1.APIServiceSpec @spec,
          ApiRegistration.V1.APIServiceStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// APIServiceCondition describes the state of an APIService at a particular point
    /// </summary>
    [OutputType]
    public sealed class APIServiceCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type is the type of the condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private APIServiceCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// APIServiceList is a list of APIService objects.
    /// </summary>
    [OutputType]
    public sealed class APIServiceList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      
      public readonly ImmutableArray<ApiRegistration.V1.APIService> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private APIServiceList(
          string @apiVersion,
          ImmutableArray<ApiRegistration.V1.APIService> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// APIServiceSpec contains information for locating and communicating with a server. Only https
    /// is supported, though you are able to disable certificate verification.
    /// </summary>
    [OutputType]
    public sealed class APIServiceSpec
    {
      /// <summary>
        /// CABundle is a PEM encoded CA bundle which will be used to validate an API server's
        /// serving certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
      public readonly string CaBundle;

      /// <summary>
        /// Group is the API group name this server hosts
        /// </summary>
      public readonly string Group;

      /// <summary>
        /// GroupPriorityMininum is the priority this group should have at least. Higher priority
        /// means that the group is preferred by clients over lower priority ones. Note that other
        /// versions of this group might specify even higher GroupPriorityMininum values such that
        /// the whole group gets a higher priority. The primary sort is based on
        /// GroupPriorityMinimum, ordered highest number to lowest (20 before 10). The secondary
        /// sort is based on the alphabetical comparison of the name of the object.  (v1.bar before
        /// v1.foo) We'd recommend something like: *.k8s.io (except extensions) at 18000 and PaaSes
        /// (OpenShift, Deis) are recommended to be in the 2000s
        /// </summary>
      public readonly int GroupPriorityMinimum;

      /// <summary>
        /// InsecureSkipTLSVerify disables TLS certificate verification when communicating with this
        /// server. This is strongly discouraged.  You should use the CABundle instead.
        /// </summary>
      public readonly bool InsecureSkipTLSVerify;

      /// <summary>
        /// Service is a reference to the service for this API server.  It must communicate on port
        /// 443 If the Service is nil, that means the handling for the API groupversion is handled
        /// locally on this server. The call will simply delegate to the normal handler chain to be
        /// fulfilled.
        /// </summary>
      public readonly ApiRegistration.V1.ServiceReference Service;

      /// <summary>
        /// Version is the API version this server hosts.  For example, "v1"
        /// </summary>
      public readonly string Version;

      /// <summary>
        /// VersionPriority controls the ordering of this API version inside of its group.  Must be
        /// greater than zero. The primary sort is based on VersionPriority, ordered highest to
        /// lowest (20 before 10). Since it's inside of a group, the number can be small, probably
        /// in the 10s. In case of equal version priorities, the version string will be used to
        /// compute the order inside a group. If the version string is "kube-like", it will sort
        /// above non "kube-like" version strings, which are ordered lexicographically. "Kube-like"
        /// versions start with a "v", then are followed by a number (the major version), then
        /// optionally the string "alpha" or "beta" and another number (the minor version). These
        /// are sorted first by GA &amp;gt; beta &amp;gt; alpha (where GA is a version with no
        /// suffix such as beta or alpha), and then by comparing major version, then minor version.
        /// An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1,
        /// v11alpha2, foo1, foo10.
        /// </summary>
      public readonly int VersionPriority;

      [OutputConstructor]
      private APIServiceSpec(
          string @caBundle,
          string @group,
          int @groupPriorityMinimum,
          bool @insecureSkipTLSVerify,
          ApiRegistration.V1.ServiceReference @service,
          string @version,
          int @versionPriority)
      {
          this.CaBundle = @caBundle;
          this.Group = @group;
          this.GroupPriorityMinimum = @groupPriorityMinimum;
          this.InsecureSkipTLSVerify = @insecureSkipTLSVerify;
          this.Service = @service;
          this.Version = @version;
          this.VersionPriority = @versionPriority;
      }

    }
    /// <summary>
    /// APIServiceStatus contains derived information about an API server
    /// </summary>
    [OutputType]
    public sealed class APIServiceStatus
    {
      /// <summary>
        /// Current service state of apiService.
        /// </summary>
      public readonly ImmutableArray<ApiRegistration.V1.APIServiceCondition> Conditions;

      [OutputConstructor]
      private APIServiceStatus(
          ImmutableArray<ApiRegistration.V1.APIServiceCondition> @conditions)
      {
          this.Conditions = @conditions;
      }

    }
    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    [OutputType]
    public sealed class ServiceReference
    {
      /// <summary>
        /// Name is the name of the service
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace is the namespace of the service
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
      public readonly int Port;

      [OutputConstructor]
      private ServiceReference(
          string @name,
          string @namespace,
          int @port)
      {
          this.Name = @name;
          this.Namespace = @namespace;
          this.Port = @port;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// APIService represents a server for a particular GroupVersion. Name must be "version.group".
    /// </summary>
    [OutputType]
    public sealed class APIService
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec contains information for locating and communicating with a server
        /// </summary>
      public readonly ApiRegistration.V1Beta1.APIServiceSpec Spec;

      /// <summary>
        /// Status contains derived information about an API server
        /// </summary>
      public readonly ApiRegistration.V1Beta1.APIServiceStatus Status;

      [OutputConstructor]
      private APIService(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ApiRegistration.V1Beta1.APIServiceSpec @spec,
          ApiRegistration.V1Beta1.APIServiceStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// APIServiceCondition describes the state of an APIService at a particular point
    /// </summary>
    [OutputType]
    public sealed class APIServiceCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status is the status of the condition. Can be True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type is the type of the condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private APIServiceCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// APIServiceList is a list of APIService objects.
    /// </summary>
    [OutputType]
    public sealed class APIServiceList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      
      public readonly ImmutableArray<ApiRegistration.V1Beta1.APIService> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private APIServiceList(
          string @apiVersion,
          ImmutableArray<ApiRegistration.V1Beta1.APIService> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// APIServiceSpec contains information for locating and communicating with a server. Only https
    /// is supported, though you are able to disable certificate verification.
    /// </summary>
    [OutputType]
    public sealed class APIServiceSpec
    {
      /// <summary>
        /// CABundle is a PEM encoded CA bundle which will be used to validate an API server's
        /// serving certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
      public readonly string CaBundle;

      /// <summary>
        /// Group is the API group name this server hosts
        /// </summary>
      public readonly string Group;

      /// <summary>
        /// GroupPriorityMininum is the priority this group should have at least. Higher priority
        /// means that the group is preferred by clients over lower priority ones. Note that other
        /// versions of this group might specify even higher GroupPriorityMininum values such that
        /// the whole group gets a higher priority. The primary sort is based on
        /// GroupPriorityMinimum, ordered highest number to lowest (20 before 10). The secondary
        /// sort is based on the alphabetical comparison of the name of the object.  (v1.bar before
        /// v1.foo) We'd recommend something like: *.k8s.io (except extensions) at 18000 and PaaSes
        /// (OpenShift, Deis) are recommended to be in the 2000s
        /// </summary>
      public readonly int GroupPriorityMinimum;

      /// <summary>
        /// InsecureSkipTLSVerify disables TLS certificate verification when communicating with this
        /// server. This is strongly discouraged.  You should use the CABundle instead.
        /// </summary>
      public readonly bool InsecureSkipTLSVerify;

      /// <summary>
        /// Service is a reference to the service for this API server.  It must communicate on port
        /// 443 If the Service is nil, that means the handling for the API groupversion is handled
        /// locally on this server. The call will simply delegate to the normal handler chain to be
        /// fulfilled.
        /// </summary>
      public readonly ApiRegistration.V1Beta1.ServiceReference Service;

      /// <summary>
        /// Version is the API version this server hosts.  For example, "v1"
        /// </summary>
      public readonly string Version;

      /// <summary>
        /// VersionPriority controls the ordering of this API version inside of its group.  Must be
        /// greater than zero. The primary sort is based on VersionPriority, ordered highest to
        /// lowest (20 before 10). Since it's inside of a group, the number can be small, probably
        /// in the 10s. In case of equal version priorities, the version string will be used to
        /// compute the order inside a group. If the version string is "kube-like", it will sort
        /// above non "kube-like" version strings, which are ordered lexicographically. "Kube-like"
        /// versions start with a "v", then are followed by a number (the major version), then
        /// optionally the string "alpha" or "beta" and another number (the minor version). These
        /// are sorted first by GA &amp;gt; beta &amp;gt; alpha (where GA is a version with no
        /// suffix such as beta or alpha), and then by comparing major version, then minor version.
        /// An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1,
        /// v11alpha2, foo1, foo10.
        /// </summary>
      public readonly int VersionPriority;

      [OutputConstructor]
      private APIServiceSpec(
          string @caBundle,
          string @group,
          int @groupPriorityMinimum,
          bool @insecureSkipTLSVerify,
          ApiRegistration.V1Beta1.ServiceReference @service,
          string @version,
          int @versionPriority)
      {
          this.CaBundle = @caBundle;
          this.Group = @group;
          this.GroupPriorityMinimum = @groupPriorityMinimum;
          this.InsecureSkipTLSVerify = @insecureSkipTLSVerify;
          this.Service = @service;
          this.Version = @version;
          this.VersionPriority = @versionPriority;
      }

    }
    /// <summary>
    /// APIServiceStatus contains derived information about an API server
    /// </summary>
    [OutputType]
    public sealed class APIServiceStatus
    {
      /// <summary>
        /// Current service state of apiService.
        /// </summary>
      public readonly ImmutableArray<ApiRegistration.V1Beta1.APIServiceCondition> Conditions;

      [OutputConstructor]
      private APIServiceStatus(
          ImmutableArray<ApiRegistration.V1Beta1.APIServiceCondition> @conditions)
      {
          this.Conditions = @conditions;
      }

    }
    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    [OutputType]
    public sealed class ServiceReference
    {
      /// <summary>
        /// Name is the name of the service
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace is the namespace of the service
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
      public readonly int Port;

      [OutputConstructor]
      private ServiceReference(
          string @name,
          string @namespace,
          int @port)
      {
          this.Name = @name;
          this.Namespace = @namespace;
          this.Port = @port;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Apps
{
  namespace V1
  {
    /// <summary>
    /// ControllerRevision implements an immutable snapshot of state data. Clients are responsible
    /// for serializing and deserializing the objects that contain their internal state. Once a
    /// ControllerRevision has been successfully created, it can not be updated. The API Server will
    /// fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
    /// may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
    /// controllers for update and rollback, this object is beta. However, it may be subject to name
    /// and representation changes in future releases, and clients should not depend on its
    /// stability. It is primarily for internal use by controllers.
    /// </summary>
    [OutputType]
    public sealed class ControllerRevision
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Data is the serialized representation of the state.
        /// </summary>
      public readonly System.Text.Json.JsonElement Data;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Revision indicates the revision of the state represented by Data.
        /// </summary>
      public readonly int Revision;

      [OutputConstructor]
      private ControllerRevision(
          string @apiVersion,
          System.Text.Json.JsonElement @data,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          int @revision)
      {
          this.ApiVersion = @apiVersion;
          this.Data = @data;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Revision = @revision;
      }

    }
    /// <summary>
    /// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
    /// </summary>
    [OutputType]
    public sealed class ControllerRevisionList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of ControllerRevisions
        /// </summary>
      public readonly ImmutableArray<Apps.V1.ControllerRevision> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ControllerRevisionList(
          string @apiVersion,
          ImmutableArray<Apps.V1.ControllerRevision> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DaemonSet represents the configuration of a daemon set.
    /// </summary>
    [OutputType]
    public sealed class DaemonSet
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// The desired behavior of this daemon set. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Apps.V1.DaemonSetSpec Spec;

      /// <summary>
        /// The current status of this daemon set. This data may be out of date by some window of
        /// time. Populated by the system. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Apps.V1.DaemonSetStatus Status;

      [OutputConstructor]
      private DaemonSet(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1.DaemonSetSpec @spec,
          Apps.V1.DaemonSetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// DaemonSetCondition describes the state of a DaemonSet at a certain point.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of DaemonSet condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DaemonSetCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DaemonSetList is a collection of daemon sets.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// A list of daemon sets.
        /// </summary>
      public readonly ImmutableArray<Apps.V1.DaemonSet> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private DaemonSetList(
          string @apiVersion,
          ImmutableArray<Apps.V1.DaemonSet> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DaemonSetSpec is the specification of a daemon set.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetSpec
    {
      /// <summary>
        /// The minimum number of seconds for which a newly created DaemonSet pod should be ready
        /// without any of its container crashing, for it to be considered available. Defaults to 0
        /// (pod will be considered available as soon as it is ready).
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// The number of old history to retain to allow rollback. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 10.
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// A label query over pods that are managed by the daemon set. Must match in order to be
        /// controlled. It must match the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// An object that describes the pod that will be created. The DaemonSet will create exactly
        /// one copy of this pod on every node that matches the template's node selector (or on
        /// every node if no node selector is specified). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      /// <summary>
        /// An update strategy to replace existing DaemonSet pods with new pods.
        /// </summary>
      public readonly Apps.V1.DaemonSetUpdateStrategy UpdateStrategy;

      [OutputConstructor]
      private DaemonSetSpec(
          int @minReadySeconds,
          int @revisionHistoryLimit,
          Meta.V1.LabelSelector @selector,
          Core.V1.PodTemplateSpec @template,
          Apps.V1.DaemonSetUpdateStrategy @updateStrategy)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.Selector = @selector;
          this.Template = @template;
          this.UpdateStrategy = @updateStrategy;
      }

    }
    /// <summary>
    /// DaemonSetStatus represents the current status of a daemon set.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetStatus
    {
      /// <summary>
        /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as
        /// a collision avoidance mechanism when it needs to create the name for the newest
        /// ControllerRevision.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a DaemonSet's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1.DaemonSetCondition> Conditions;

      /// <summary>
        /// The number of nodes that are running at least 1 daemon pod and are supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
      public readonly int CurrentNumberScheduled;

      /// <summary>
        /// The total number of nodes that should be running the daemon pod (including nodes
        /// correctly running the daemon pod). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
      public readonly int DesiredNumberScheduled;

      /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
      public readonly int NumberAvailable;

      /// <summary>
        /// The number of nodes that are running the daemon pod, but are not supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
      public readonly int NumberMisscheduled;

      /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and ready.
        /// </summary>
      public readonly int NumberReady;

      /// <summary>
        /// The number of nodes that should be running the daemon pod and have none of the daemon
        /// pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
      public readonly int NumberUnavailable;

      /// <summary>
        /// The most recent generation observed by the daemon set controller.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// The total number of nodes that are running updated daemon pod
        /// </summary>
      public readonly int UpdatedNumberScheduled;

      [OutputConstructor]
      private DaemonSetStatus(
          int @collisionCount,
          ImmutableArray<Apps.V1.DaemonSetCondition> @conditions,
          int @currentNumberScheduled,
          int @desiredNumberScheduled,
          int @numberAvailable,
          int @numberMisscheduled,
          int @numberReady,
          int @numberUnavailable,
          int @observedGeneration,
          int @updatedNumberScheduled)
      {
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.CurrentNumberScheduled = @currentNumberScheduled;
          this.DesiredNumberScheduled = @desiredNumberScheduled;
          this.NumberAvailable = @numberAvailable;
          this.NumberMisscheduled = @numberMisscheduled;
          this.NumberReady = @numberReady;
          this.NumberUnavailable = @numberUnavailable;
          this.ObservedGeneration = @observedGeneration;
          this.UpdatedNumberScheduled = @updatedNumberScheduled;
      }

    }
    /// <summary>
    /// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetUpdateStrategy
    {
      /// <summary>
        /// Rolling update config params. Present only if type = "RollingUpdate".
        /// </summary>
      public readonly Apps.V1.RollingUpdateDaemonSet RollingUpdate;

      /// <summary>
        /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is
        /// RollingUpdate.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DaemonSetUpdateStrategy(
          Apps.V1.RollingUpdateDaemonSet @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
    /// <summary>
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    [OutputType]
    public sealed class Deployment
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
      public readonly Apps.V1.DeploymentSpec Spec;

      /// <summary>
        /// Most recently observed status of the Deployment.
        /// </summary>
      public readonly Apps.V1.DeploymentStatus Status;

      [OutputConstructor]
      private Deployment(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1.DeploymentSpec @spec,
          Apps.V1.DeploymentStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    [OutputType]
    public sealed class DeploymentCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// The last time this condition was updated.
        /// </summary>
      public readonly string LastUpdateTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of deployment condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DeploymentCondition(
          string @lastTransitionTime,
          string @lastUpdateTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.LastUpdateTime = @lastUpdateTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    [OutputType]
    public sealed class DeploymentList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
      public readonly ImmutableArray<Apps.V1.Deployment> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private DeploymentList(
          string @apiVersion,
          ImmutableArray<Apps.V1.Deployment> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentSpec
    {
      /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// Indicates that the deployment is paused.
        /// </summary>
      public readonly bool Paused;

      /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// Defaults to 600s.
        /// </summary>
      public readonly int ProgressDeadlineSeconds;

      /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. Defaults to 10.
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment. It must match the pod template's labels.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
      public readonly Apps.V1.DeploymentStrategy Strategy;

      /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      [OutputConstructor]
      private DeploymentSpec(
          int @minReadySeconds,
          bool @paused,
          int @progressDeadlineSeconds,
          int @replicas,
          int @revisionHistoryLimit,
          Meta.V1.LabelSelector @selector,
          Apps.V1.DeploymentStrategy @strategy,
          Core.V1.PodTemplateSpec @template)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.Paused = @paused;
          this.ProgressDeadlineSeconds = @progressDeadlineSeconds;
          this.Replicas = @replicas;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.Selector = @selector;
          this.Strategy = @strategy;
          this.Template = @template;
      }

    }
    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentStatus
    {
      /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
      public readonly int AvailableReplicas;

      /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1.DeploymentCondition> Conditions;

      /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
      public readonly int UnavailableReplicas;

      /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
      public readonly int UpdatedReplicas;

      [OutputConstructor]
      private DeploymentStatus(
          int @availableReplicas,
          int @collisionCount,
          ImmutableArray<Apps.V1.DeploymentCondition> @conditions,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas,
          int @unavailableReplicas,
          int @updatedReplicas)
      {
          this.AvailableReplicas = @availableReplicas;
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
          this.UnavailableReplicas = @unavailableReplicas;
          this.UpdatedReplicas = @updatedReplicas;
      }

    }
    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    [OutputType]
    public sealed class DeploymentStrategy
    {
      /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
      public readonly Apps.V1.RollingUpdateDeployment RollingUpdate;

      /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DeploymentStrategy(
          Apps.V1.RollingUpdateDeployment @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
    /// <summary>
    /// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSet
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
        /// that the ReplicaSet manages. Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the specification of the desired behavior of the ReplicaSet. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Apps.V1.ReplicaSetSpec Spec;

      /// <summary>
        /// Status is the most recently observed status of the ReplicaSet. This data may be out of
        /// date by some window of time. Populated by the system. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Apps.V1.ReplicaSetStatus Status;

      [OutputConstructor]
      private ReplicaSet(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1.ReplicaSetSpec @spec,
          Apps.V1.ReplicaSetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// ReplicaSetCondition describes the state of a replica set at a certain point.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetCondition
    {
      /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of replica set condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private ReplicaSetCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// ReplicaSetList is a collection of ReplicaSets.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of ReplicaSets. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
      public readonly ImmutableArray<Apps.V1.ReplicaSet> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ReplicaSetList(
          string @apiVersion,
          ImmutableArray<Apps.V1.ReplicaSet> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ReplicaSetSpec is the specification of a ReplicaSet.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetSpec
    {
      /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// Selector is a label query over pods that should match the replica count. Label keys and
        /// values that must match in order to be controlled by this replica set. It must match the
        /// pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      [OutputConstructor]
      private ReplicaSetSpec(
          int @minReadySeconds,
          int @replicas,
          Meta.V1.LabelSelector @selector,
          Core.V1.PodTemplateSpec @template)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.Replicas = @replicas;
          this.Selector = @selector;
          this.Template = @template;
      }

    }
    /// <summary>
    /// ReplicaSetStatus represents the current status of a ReplicaSet.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetStatus
    {
      /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this replica
        /// set.
        /// </summary>
      public readonly int AvailableReplicas;

      /// <summary>
        /// Represents the latest available observations of a replica set's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1.ReplicaSetCondition> Conditions;

      /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replicaset.
        /// </summary>
      public readonly int FullyLabeledReplicas;

      /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// The number of ready replicas for this replica set.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
      public readonly int Replicas;

      [OutputConstructor]
      private ReplicaSetStatus(
          int @availableReplicas,
          ImmutableArray<Apps.V1.ReplicaSetCondition> @conditions,
          int @fullyLabeledReplicas,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas)
      {
          this.AvailableReplicas = @availableReplicas;
          this.Conditions = @conditions;
          this.FullyLabeledReplicas = @fullyLabeledReplicas;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
      }

    }
    /// <summary>
    /// Spec to control the desired behavior of daemon set rolling update.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateDaemonSet
    {
      /// <summary>
        /// The maximum number of DaemonSet pods that can be unavailable during the update. Value
        /// can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at
        /// the start of the update (ex: 10%). Absolute number is calculated from percentage by
        /// rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at
        /// most 30% of the total number of nodes that should be running the daemon pod (i.e.
        /// status.desiredNumberScheduled) can have their pods stopped for an update at any given
        /// time. The update starts by stopping at most 30% of those DaemonSet pods and then brings
        /// up new DaemonSet pods in their place. Once the new pods are available, it then proceeds
        /// onto other DaemonSet pods, thus ensuring that at least 70% of original number of
        /// DaemonSet pods are available at all times during the update.
        /// </summary>
      public readonly Union<int,string> MaxUnavailable;

      [OutputConstructor]
      private RollingUpdateDaemonSet(
          Union<int,string> @maxUnavailable)
      {
          this.MaxUnavailable = @maxUnavailable;
      }

    }
    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateDeployment
    {
      /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can
        /// be scaled up immediately when the rolling update starts, such that the total number of
        /// old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new
        /// ReplicaSet can be scaled up further, ensuring that total number of pods running at any
        /// time during the update is at most 130% of desired pods.
        /// </summary>
      public readonly Union<int,string> MaxSurge;

      /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0.
        /// Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down
        /// to 70% of desired pods immediately when the rolling update starts. Once new pods are
        /// ready, old ReplicaSet can be scaled down further, followed by scaling up the new
        /// ReplicaSet, ensuring that the total number of pods available at all times during the
        /// update is at least 70% of desired pods.
        /// </summary>
      public readonly Union<int,string> MaxUnavailable;

      [OutputConstructor]
      private RollingUpdateDeployment(
          Union<int,string> @maxSurge,
          Union<int,string> @maxUnavailable)
      {
          this.MaxSurge = @maxSurge;
          this.MaxUnavailable = @maxUnavailable;
      }

    }
    /// <summary>
    /// RollingUpdateStatefulSetStrategy is used to communicate parameter for
    /// RollingUpdateStatefulSetStrategyType.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateStatefulSetStrategy
    {
      /// <summary>
        /// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default
        /// value is 0.
        /// </summary>
      public readonly int Partition;

      [OutputConstructor]
      private RollingUpdateStatefulSetStrategy(
          int @partition)
      {
          this.Partition = @partition;
      }

    }
    /// <summary>
    /// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
    ///  - Network: A single stable DNS and hostname.
    ///  - Storage: As many VolumeClaims as requested.
    /// The StatefulSet guarantees that a given network identity will always map to the same storage
    /// identity.
    /// </summary>
    [OutputType]
    public sealed class StatefulSet
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the desired identities of pods in this set.
        /// </summary>
      public readonly Apps.V1.StatefulSetSpec Spec;

      /// <summary>
        /// Status is the current status of Pods in this StatefulSet. This data may be out of date
        /// by some window of time.
        /// </summary>
      public readonly Apps.V1.StatefulSetStatus Status;

      [OutputConstructor]
      private StatefulSet(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1.StatefulSetSpec @spec,
          Apps.V1.StatefulSetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// StatefulSetCondition describes the state of a statefulset at a certain point.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of statefulset condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private StatefulSetCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// StatefulSetList is a collection of StatefulSets.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      
      public readonly ImmutableArray<Apps.V1.StatefulSet> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private StatefulSetList(
          string @apiVersion,
          ImmutableArray<Apps.V1.StatefulSet> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// A StatefulSetSpec is the specification of a StatefulSet.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetSpec
    {
      /// <summary>
        /// podManagementPolicy controls how pods are created during initial scale up, when
        /// replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`,
        /// where pods are created in increasing order (pod-0, then pod-1, etc) and the controller
        /// will wait until each pod is ready before continuing. When scaling down, the pods are
        /// removed in the opposite order. The alternative policy is `Parallel` which will create
        /// pods in parallel to match the desired scale without waiting, and on scale down will
        /// delete all pods at once.
        /// </summary>
      public readonly string PodManagementPolicy;

      /// <summary>
        /// replicas is the desired number of replicas of the given Template. These are replicas in
        /// the sense that they are instantiations of the same Template, but individual replicas
        /// also have a consistent identity. If unspecified, defaults to 1.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the
        /// StatefulSet's revision history. The revision history consists of all revisions not
        /// represented by a currently applied StatefulSetSpec version. The default value is 10.
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// selector is a label query over pods that should match the replica count. It must match
        /// the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// serviceName is the name of the service that governs this StatefulSet. This service must
        /// exist before the StatefulSet, and is responsible for the network identity of the set.
        /// Pods get DNS/hostnames that follow the pattern:
        /// pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
        /// managed by the StatefulSet controller.
        /// </summary>
      public readonly string ServiceName;

      /// <summary>
        /// template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. Each pod stamped out by the StatefulSet will fulfill this
        /// Template, but have a unique identity from the rest of the StatefulSet.
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      /// <summary>
        /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update
        /// Pods in the StatefulSet when a revision is made to Template.
        /// </summary>
      public readonly Apps.V1.StatefulSetUpdateStrategy UpdateStrategy;

      /// <summary>
        /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The
        /// StatefulSet controller is responsible for mapping network identities to claims in a way
        /// that maintains the identity of a pod. Every claim in this list must have at least one
        /// matching (by name) volumeMount in one container in the template. A claim in this list
        /// takes precedence over any volumes in the template, with the same name.
        /// </summary>
      public readonly ImmutableArray<Core.V1.PersistentVolumeClaim> VolumeClaimTemplates;

      [OutputConstructor]
      private StatefulSetSpec(
          string @podManagementPolicy,
          int @replicas,
          int @revisionHistoryLimit,
          Meta.V1.LabelSelector @selector,
          string @serviceName,
          Core.V1.PodTemplateSpec @template,
          Apps.V1.StatefulSetUpdateStrategy @updateStrategy,
          ImmutableArray<Core.V1.PersistentVolumeClaim> @volumeClaimTemplates)
      {
          this.PodManagementPolicy = @podManagementPolicy;
          this.Replicas = @replicas;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.Selector = @selector;
          this.ServiceName = @serviceName;
          this.Template = @template;
          this.UpdateStrategy = @updateStrategy;
          this.VolumeClaimTemplates = @volumeClaimTemplates;
      }

    }
    /// <summary>
    /// StatefulSetStatus represents the current state of a StatefulSet.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetStatus
    {
      /// <summary>
        /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet
        /// controller uses this field as a collision avoidance mechanism when it needs to create
        /// the name for the newest ControllerRevision.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a statefulset's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1.StatefulSetCondition> Conditions;

      /// <summary>
        /// currentReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by currentRevision.
        /// </summary>
      public readonly int CurrentReplicas;

      /// <summary>
        /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [0,currentReplicas).
        /// </summary>
      public readonly string CurrentRevision;

      /// <summary>
        /// observedGeneration is the most recent generation observed for this StatefulSet. It
        /// corresponds to the StatefulSet's generation, which is updated on mutation by the API
        /// Server.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// readyReplicas is the number of Pods created by the StatefulSet controller that have a
        /// Ready Condition.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// replicas is the number of Pods created by the StatefulSet controller.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [replicas-updatedReplicas,replicas)
        /// </summary>
      public readonly string UpdateRevision;

      /// <summary>
        /// updatedReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by updateRevision.
        /// </summary>
      public readonly int UpdatedReplicas;

      [OutputConstructor]
      private StatefulSetStatus(
          int @collisionCount,
          ImmutableArray<Apps.V1.StatefulSetCondition> @conditions,
          int @currentReplicas,
          string @currentRevision,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas,
          string @updateRevision,
          int @updatedReplicas)
      {
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.CurrentReplicas = @currentReplicas;
          this.CurrentRevision = @currentRevision;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
          this.UpdateRevision = @updateRevision;
          this.UpdatedReplicas = @updatedReplicas;
      }

    }
    /// <summary>
    /// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
    /// perform updates. It includes any additional parameters necessary to perform the update for
    /// the indicated strategy.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetUpdateStrategy
    {
      /// <summary>
        /// RollingUpdate is used to communicate parameters when Type is
        /// RollingUpdateStatefulSetStrategyType.
        /// </summary>
      public readonly Apps.V1.RollingUpdateStatefulSetStrategy RollingUpdate;

      /// <summary>
        /// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private StatefulSetUpdateStrategy(
          Apps.V1.RollingUpdateStatefulSetStrategy @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// DEPRECATED - apps/v1beta1/ControllerRevision is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/ControllerRevision instead.
    /// 
    /// ControllerRevision implements an immutable snapshot of state data. Clients are responsible
    /// for serializing and deserializing the objects that contain their internal state. Once a
    /// ControllerRevision has been successfully created, it can not be updated. The API Server will
    /// fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
    /// may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
    /// controllers for update and rollback, this object is beta. However, it may be subject to name
    /// and representation changes in future releases, and clients should not depend on its
    /// stability. It is primarily for internal use by controllers.
    /// </summary>
    [OutputType]
    public sealed class ControllerRevision
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Data is the serialized representation of the state.
        /// </summary>
      public readonly System.Text.Json.JsonElement Data;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Revision indicates the revision of the state represented by Data.
        /// </summary>
      public readonly int Revision;

      [OutputConstructor]
      private ControllerRevision(
          string @apiVersion,
          System.Text.Json.JsonElement @data,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          int @revision)
      {
          this.ApiVersion = @apiVersion;
          this.Data = @data;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Revision = @revision;
      }

    }
    /// <summary>
    /// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
    /// </summary>
    [OutputType]
    public sealed class ControllerRevisionList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of ControllerRevisions
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta1.ControllerRevision> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ControllerRevisionList(
          string @apiVersion,
          ImmutableArray<Apps.V1Beta1.ControllerRevision> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DEPRECATED - apps/v1beta1/Deployment is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/Deployment instead.
    /// 
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    [OutputType]
    public sealed class Deployment
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
      public readonly Apps.V1Beta1.DeploymentSpec Spec;

      /// <summary>
        /// Most recently observed status of the Deployment.
        /// </summary>
      public readonly Apps.V1Beta1.DeploymentStatus Status;

      [OutputConstructor]
      private Deployment(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1Beta1.DeploymentSpec @spec,
          Apps.V1Beta1.DeploymentStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    [OutputType]
    public sealed class DeploymentCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// The last time this condition was updated.
        /// </summary>
      public readonly string LastUpdateTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of deployment condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DeploymentCondition(
          string @lastTransitionTime,
          string @lastUpdateTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.LastUpdateTime = @lastUpdateTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    [OutputType]
    public sealed class DeploymentList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta1.Deployment> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private DeploymentList(
          string @apiVersion,
          ImmutableArray<Apps.V1Beta1.Deployment> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentRollback
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Required: This must match the Name of a deployment.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// The config of this deployment rollback.
        /// </summary>
      public readonly Apps.V1Beta1.RollbackConfig RollbackTo;

      /// <summary>
        /// The annotations to be updated to a deployment
        /// </summary>
      public readonly ImmutableDictionary<string, string> UpdatedAnnotations;

      [OutputConstructor]
      private DeploymentRollback(
          string @apiVersion,
          string @kind,
          string @name,
          Apps.V1Beta1.RollbackConfig @rollbackTo,
          ImmutableDictionary<string, string> @updatedAnnotations)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Name = @name;
          this.RollbackTo = @rollbackTo;
          this.UpdatedAnnotations = @updatedAnnotations;
      }

    }
    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentSpec
    {
      /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// Indicates that the deployment is paused.
        /// </summary>
      public readonly bool Paused;

      /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// Defaults to 600s.
        /// </summary>
      public readonly int ProgressDeadlineSeconds;

      /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. Defaults to 2.
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// DEPRECATED. The config this deployment is rolling back to. Will be cleared after
        /// rollback is done.
        /// </summary>
      public readonly Apps.V1Beta1.RollbackConfig RollbackTo;

      /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
      public readonly Apps.V1Beta1.DeploymentStrategy Strategy;

      /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      [OutputConstructor]
      private DeploymentSpec(
          int @minReadySeconds,
          bool @paused,
          int @progressDeadlineSeconds,
          int @replicas,
          int @revisionHistoryLimit,
          Apps.V1Beta1.RollbackConfig @rollbackTo,
          Meta.V1.LabelSelector @selector,
          Apps.V1Beta1.DeploymentStrategy @strategy,
          Core.V1.PodTemplateSpec @template)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.Paused = @paused;
          this.ProgressDeadlineSeconds = @progressDeadlineSeconds;
          this.Replicas = @replicas;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.RollbackTo = @rollbackTo;
          this.Selector = @selector;
          this.Strategy = @strategy;
          this.Template = @template;
      }

    }
    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentStatus
    {
      /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
      public readonly int AvailableReplicas;

      /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta1.DeploymentCondition> Conditions;

      /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
      public readonly int UnavailableReplicas;

      /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
      public readonly int UpdatedReplicas;

      [OutputConstructor]
      private DeploymentStatus(
          int @availableReplicas,
          int @collisionCount,
          ImmutableArray<Apps.V1Beta1.DeploymentCondition> @conditions,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas,
          int @unavailableReplicas,
          int @updatedReplicas)
      {
          this.AvailableReplicas = @availableReplicas;
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
          this.UnavailableReplicas = @unavailableReplicas;
          this.UpdatedReplicas = @updatedReplicas;
      }

    }
    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    [OutputType]
    public sealed class DeploymentStrategy
    {
      /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
      public readonly Apps.V1Beta1.RollingUpdateDeployment RollingUpdate;

      /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DeploymentStrategy(
          Apps.V1Beta1.RollingUpdateDeployment @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DEPRECATED.
    /// </summary>
    [OutputType]
    public sealed class RollbackConfig
    {
      /// <summary>
        /// The revision to rollback to. If set to 0, rollback to the last revision.
        /// </summary>
      public readonly int Revision;

      [OutputConstructor]
      private RollbackConfig(
          int @revision)
      {
          this.Revision = @revision;
      }

    }
    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateDeployment
    {
      /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can
        /// be scaled up immediately when the rolling update starts, such that the total number of
        /// old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new
        /// ReplicaSet can be scaled up further, ensuring that total number of pods running at any
        /// time during the update is at most 130% of desired pods.
        /// </summary>
      public readonly Union<int,string> MaxSurge;

      /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0.
        /// Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down
        /// to 70% of desired pods immediately when the rolling update starts. Once new pods are
        /// ready, old ReplicaSet can be scaled down further, followed by scaling up the new
        /// ReplicaSet, ensuring that the total number of pods available at all times during the
        /// update is at least 70% of desired pods.
        /// </summary>
      public readonly Union<int,string> MaxUnavailable;

      [OutputConstructor]
      private RollingUpdateDeployment(
          Union<int,string> @maxSurge,
          Union<int,string> @maxUnavailable)
      {
          this.MaxSurge = @maxSurge;
          this.MaxUnavailable = @maxUnavailable;
      }

    }
    /// <summary>
    /// RollingUpdateStatefulSetStrategy is used to communicate parameter for
    /// RollingUpdateStatefulSetStrategyType.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateStatefulSetStrategy
    {
      /// <summary>
        /// Partition indicates the ordinal at which the StatefulSet should be partitioned.
        /// </summary>
      public readonly int Partition;

      [OutputConstructor]
      private RollingUpdateStatefulSetStrategy(
          int @partition)
      {
          this.Partition = @partition;
      }

    }
    /// <summary>
    /// Scale represents a scaling request for a resource.
    /// </summary>
    [OutputType]
    public sealed class Scale
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
      public readonly Apps.V1Beta1.ScaleSpec Spec;

      /// <summary>
        /// current status of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// Read-only.
        /// </summary>
      public readonly Apps.V1Beta1.ScaleStatus Status;

      [OutputConstructor]
      private Scale(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1Beta1.ScaleSpec @spec,
          Apps.V1Beta1.ScaleStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// ScaleSpec describes the attributes of a scale subresource
    /// </summary>
    [OutputType]
    public sealed class ScaleSpec
    {
      /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
      public readonly int Replicas;

      [OutputConstructor]
      private ScaleSpec(
          int @replicas)
      {
          this.Replicas = @replicas;
      }

    }
    /// <summary>
    /// ScaleStatus represents the current status of a scale subresource.
    /// </summary>
    [OutputType]
    public sealed class ScaleStatus
    {
      /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// label query over pods that should match the replicas count. More info:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
      public readonly ImmutableDictionary<string, string> Selector;

      /// <summary>
        /// label selector for pods that should match the replicas count. This is a serializated
        /// version of both map-based and more expressive set-based selectors. This is done to avoid
        /// introspection in the clients. The string will be in the same format as the query-param
        /// syntax. If the target type only supports map-based selectors, both this field and
        /// map-based selector field are populated. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly string TargetSelector;

      [OutputConstructor]
      private ScaleStatus(
          int @replicas,
          ImmutableDictionary<string, string> @selector,
          string @targetSelector)
      {
          this.Replicas = @replicas;
          this.Selector = @selector;
          this.TargetSelector = @targetSelector;
      }

    }
    /// <summary>
    /// DEPRECATED - apps/v1beta1/StatefulSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/StatefulSet instead.
    /// 
    /// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
    ///  - Network: A single stable DNS and hostname.
    ///  - Storage: As many VolumeClaims as requested.
    /// The StatefulSet guarantees that a given network identity will always map to the same storage
    /// identity.
    /// </summary>
    [OutputType]
    public sealed class StatefulSet
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the desired identities of pods in this set.
        /// </summary>
      public readonly Apps.V1Beta1.StatefulSetSpec Spec;

      /// <summary>
        /// Status is the current status of Pods in this StatefulSet. This data may be out of date
        /// by some window of time.
        /// </summary>
      public readonly Apps.V1Beta1.StatefulSetStatus Status;

      [OutputConstructor]
      private StatefulSet(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1Beta1.StatefulSetSpec @spec,
          Apps.V1Beta1.StatefulSetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// StatefulSetCondition describes the state of a statefulset at a certain point.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of statefulset condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private StatefulSetCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// StatefulSetList is a collection of StatefulSets.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      
      public readonly ImmutableArray<Apps.V1Beta1.StatefulSet> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private StatefulSetList(
          string @apiVersion,
          ImmutableArray<Apps.V1Beta1.StatefulSet> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// A StatefulSetSpec is the specification of a StatefulSet.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetSpec
    {
      /// <summary>
        /// podManagementPolicy controls how pods are created during initial scale up, when
        /// replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`,
        /// where pods are created in increasing order (pod-0, then pod-1, etc) and the controller
        /// will wait until each pod is ready before continuing. When scaling down, the pods are
        /// removed in the opposite order. The alternative policy is `Parallel` which will create
        /// pods in parallel to match the desired scale without waiting, and on scale down will
        /// delete all pods at once.
        /// </summary>
      public readonly string PodManagementPolicy;

      /// <summary>
        /// replicas is the desired number of replicas of the given Template. These are replicas in
        /// the sense that they are instantiations of the same Template, but individual replicas
        /// also have a consistent identity. If unspecified, defaults to 1.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the
        /// StatefulSet's revision history. The revision history consists of all revisions not
        /// represented by a currently applied StatefulSetSpec version. The default value is 10.
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// selector is a label query over pods that should match the replica count. If empty,
        /// defaulted to labels on the pod template. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// serviceName is the name of the service that governs this StatefulSet. This service must
        /// exist before the StatefulSet, and is responsible for the network identity of the set.
        /// Pods get DNS/hostnames that follow the pattern:
        /// pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
        /// managed by the StatefulSet controller.
        /// </summary>
      public readonly string ServiceName;

      /// <summary>
        /// template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. Each pod stamped out by the StatefulSet will fulfill this
        /// Template, but have a unique identity from the rest of the StatefulSet.
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      /// <summary>
        /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update
        /// Pods in the StatefulSet when a revision is made to Template.
        /// </summary>
      public readonly Apps.V1Beta1.StatefulSetUpdateStrategy UpdateStrategy;

      /// <summary>
        /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The
        /// StatefulSet controller is responsible for mapping network identities to claims in a way
        /// that maintains the identity of a pod. Every claim in this list must have at least one
        /// matching (by name) volumeMount in one container in the template. A claim in this list
        /// takes precedence over any volumes in the template, with the same name.
        /// </summary>
      public readonly ImmutableArray<Core.V1.PersistentVolumeClaim> VolumeClaimTemplates;

      [OutputConstructor]
      private StatefulSetSpec(
          string @podManagementPolicy,
          int @replicas,
          int @revisionHistoryLimit,
          Meta.V1.LabelSelector @selector,
          string @serviceName,
          Core.V1.PodTemplateSpec @template,
          Apps.V1Beta1.StatefulSetUpdateStrategy @updateStrategy,
          ImmutableArray<Core.V1.PersistentVolumeClaim> @volumeClaimTemplates)
      {
          this.PodManagementPolicy = @podManagementPolicy;
          this.Replicas = @replicas;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.Selector = @selector;
          this.ServiceName = @serviceName;
          this.Template = @template;
          this.UpdateStrategy = @updateStrategy;
          this.VolumeClaimTemplates = @volumeClaimTemplates;
      }

    }
    /// <summary>
    /// StatefulSetStatus represents the current state of a StatefulSet.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetStatus
    {
      /// <summary>
        /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet
        /// controller uses this field as a collision avoidance mechanism when it needs to create
        /// the name for the newest ControllerRevision.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a statefulset's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta1.StatefulSetCondition> Conditions;

      /// <summary>
        /// currentReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by currentRevision.
        /// </summary>
      public readonly int CurrentReplicas;

      /// <summary>
        /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [0,currentReplicas).
        /// </summary>
      public readonly string CurrentRevision;

      /// <summary>
        /// observedGeneration is the most recent generation observed for this StatefulSet. It
        /// corresponds to the StatefulSet's generation, which is updated on mutation by the API
        /// Server.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// readyReplicas is the number of Pods created by the StatefulSet controller that have a
        /// Ready Condition.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// replicas is the number of Pods created by the StatefulSet controller.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [replicas-updatedReplicas,replicas)
        /// </summary>
      public readonly string UpdateRevision;

      /// <summary>
        /// updatedReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by updateRevision.
        /// </summary>
      public readonly int UpdatedReplicas;

      [OutputConstructor]
      private StatefulSetStatus(
          int @collisionCount,
          ImmutableArray<Apps.V1Beta1.StatefulSetCondition> @conditions,
          int @currentReplicas,
          string @currentRevision,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas,
          string @updateRevision,
          int @updatedReplicas)
      {
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.CurrentReplicas = @currentReplicas;
          this.CurrentRevision = @currentRevision;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
          this.UpdateRevision = @updateRevision;
          this.UpdatedReplicas = @updatedReplicas;
      }

    }
    /// <summary>
    /// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
    /// perform updates. It includes any additional parameters necessary to perform the update for
    /// the indicated strategy.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetUpdateStrategy
    {
      /// <summary>
        /// RollingUpdate is used to communicate parameters when Type is
        /// RollingUpdateStatefulSetStrategyType.
        /// </summary>
      public readonly Apps.V1Beta1.RollingUpdateStatefulSetStrategy RollingUpdate;

      /// <summary>
        /// Type indicates the type of the StatefulSetUpdateStrategy.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private StatefulSetUpdateStrategy(
          Apps.V1Beta1.RollingUpdateStatefulSetStrategy @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
  }

  namespace V1Beta2
  {
    /// <summary>
    /// DEPRECATED - apps/v1beta2/ControllerRevision is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/ControllerRevision instead.
    /// 
    /// ControllerRevision implements an immutable snapshot of state data. Clients are responsible
    /// for serializing and deserializing the objects that contain their internal state. Once a
    /// ControllerRevision has been successfully created, it can not be updated. The API Server will
    /// fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
    /// may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
    /// controllers for update and rollback, this object is beta. However, it may be subject to name
    /// and representation changes in future releases, and clients should not depend on its
    /// stability. It is primarily for internal use by controllers.
    /// </summary>
    [OutputType]
    public sealed class ControllerRevision
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Data is the serialized representation of the state.
        /// </summary>
      public readonly System.Text.Json.JsonElement Data;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Revision indicates the revision of the state represented by Data.
        /// </summary>
      public readonly int Revision;

      [OutputConstructor]
      private ControllerRevision(
          string @apiVersion,
          System.Text.Json.JsonElement @data,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          int @revision)
      {
          this.ApiVersion = @apiVersion;
          this.Data = @data;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Revision = @revision;
      }

    }
    /// <summary>
    /// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
    /// </summary>
    [OutputType]
    public sealed class ControllerRevisionList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of ControllerRevisions
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta2.ControllerRevision> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ControllerRevisionList(
          string @apiVersion,
          ImmutableArray<Apps.V1Beta2.ControllerRevision> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DEPRECATED - apps/v1beta2/DaemonSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/DaemonSet instead.
    /// 
    /// DaemonSet represents the configuration of a daemon set.
    /// </summary>
    [OutputType]
    public sealed class DaemonSet
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// The desired behavior of this daemon set. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Apps.V1Beta2.DaemonSetSpec Spec;

      /// <summary>
        /// The current status of this daemon set. This data may be out of date by some window of
        /// time. Populated by the system. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Apps.V1Beta2.DaemonSetStatus Status;

      [OutputConstructor]
      private DaemonSet(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1Beta2.DaemonSetSpec @spec,
          Apps.V1Beta2.DaemonSetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// DaemonSetCondition describes the state of a DaemonSet at a certain point.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of DaemonSet condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DaemonSetCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DaemonSetList is a collection of daemon sets.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// A list of daemon sets.
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta2.DaemonSet> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private DaemonSetList(
          string @apiVersion,
          ImmutableArray<Apps.V1Beta2.DaemonSet> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DaemonSetSpec is the specification of a daemon set.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetSpec
    {
      /// <summary>
        /// The minimum number of seconds for which a newly created DaemonSet pod should be ready
        /// without any of its container crashing, for it to be considered available. Defaults to 0
        /// (pod will be considered available as soon as it is ready).
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// The number of old history to retain to allow rollback. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 10.
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// A label query over pods that are managed by the daemon set. Must match in order to be
        /// controlled. It must match the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// An object that describes the pod that will be created. The DaemonSet will create exactly
        /// one copy of this pod on every node that matches the template's node selector (or on
        /// every node if no node selector is specified). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      /// <summary>
        /// An update strategy to replace existing DaemonSet pods with new pods.
        /// </summary>
      public readonly Apps.V1Beta2.DaemonSetUpdateStrategy UpdateStrategy;

      [OutputConstructor]
      private DaemonSetSpec(
          int @minReadySeconds,
          int @revisionHistoryLimit,
          Meta.V1.LabelSelector @selector,
          Core.V1.PodTemplateSpec @template,
          Apps.V1Beta2.DaemonSetUpdateStrategy @updateStrategy)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.Selector = @selector;
          this.Template = @template;
          this.UpdateStrategy = @updateStrategy;
      }

    }
    /// <summary>
    /// DaemonSetStatus represents the current status of a daemon set.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetStatus
    {
      /// <summary>
        /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as
        /// a collision avoidance mechanism when it needs to create the name for the newest
        /// ControllerRevision.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a DaemonSet's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta2.DaemonSetCondition> Conditions;

      /// <summary>
        /// The number of nodes that are running at least 1 daemon pod and are supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
      public readonly int CurrentNumberScheduled;

      /// <summary>
        /// The total number of nodes that should be running the daemon pod (including nodes
        /// correctly running the daemon pod). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
      public readonly int DesiredNumberScheduled;

      /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
      public readonly int NumberAvailable;

      /// <summary>
        /// The number of nodes that are running the daemon pod, but are not supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
      public readonly int NumberMisscheduled;

      /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and ready.
        /// </summary>
      public readonly int NumberReady;

      /// <summary>
        /// The number of nodes that should be running the daemon pod and have none of the daemon
        /// pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
      public readonly int NumberUnavailable;

      /// <summary>
        /// The most recent generation observed by the daemon set controller.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// The total number of nodes that are running updated daemon pod
        /// </summary>
      public readonly int UpdatedNumberScheduled;

      [OutputConstructor]
      private DaemonSetStatus(
          int @collisionCount,
          ImmutableArray<Apps.V1Beta2.DaemonSetCondition> @conditions,
          int @currentNumberScheduled,
          int @desiredNumberScheduled,
          int @numberAvailable,
          int @numberMisscheduled,
          int @numberReady,
          int @numberUnavailable,
          int @observedGeneration,
          int @updatedNumberScheduled)
      {
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.CurrentNumberScheduled = @currentNumberScheduled;
          this.DesiredNumberScheduled = @desiredNumberScheduled;
          this.NumberAvailable = @numberAvailable;
          this.NumberMisscheduled = @numberMisscheduled;
          this.NumberReady = @numberReady;
          this.NumberUnavailable = @numberUnavailable;
          this.ObservedGeneration = @observedGeneration;
          this.UpdatedNumberScheduled = @updatedNumberScheduled;
      }

    }
    /// <summary>
    /// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetUpdateStrategy
    {
      /// <summary>
        /// Rolling update config params. Present only if type = "RollingUpdate".
        /// </summary>
      public readonly Apps.V1Beta2.RollingUpdateDaemonSet RollingUpdate;

      /// <summary>
        /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is
        /// RollingUpdate.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DaemonSetUpdateStrategy(
          Apps.V1Beta2.RollingUpdateDaemonSet @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DEPRECATED - apps/v1beta2/Deployment is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/Deployment instead.
    /// 
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    [OutputType]
    public sealed class Deployment
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
      public readonly Apps.V1Beta2.DeploymentSpec Spec;

      /// <summary>
        /// Most recently observed status of the Deployment.
        /// </summary>
      public readonly Apps.V1Beta2.DeploymentStatus Status;

      [OutputConstructor]
      private Deployment(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1Beta2.DeploymentSpec @spec,
          Apps.V1Beta2.DeploymentStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    [OutputType]
    public sealed class DeploymentCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// The last time this condition was updated.
        /// </summary>
      public readonly string LastUpdateTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of deployment condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DeploymentCondition(
          string @lastTransitionTime,
          string @lastUpdateTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.LastUpdateTime = @lastUpdateTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    [OutputType]
    public sealed class DeploymentList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta2.Deployment> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private DeploymentList(
          string @apiVersion,
          ImmutableArray<Apps.V1Beta2.Deployment> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentSpec
    {
      /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// Indicates that the deployment is paused.
        /// </summary>
      public readonly bool Paused;

      /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// Defaults to 600s.
        /// </summary>
      public readonly int ProgressDeadlineSeconds;

      /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. Defaults to 10.
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment. It must match the pod template's labels.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
      public readonly Apps.V1Beta2.DeploymentStrategy Strategy;

      /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      [OutputConstructor]
      private DeploymentSpec(
          int @minReadySeconds,
          bool @paused,
          int @progressDeadlineSeconds,
          int @replicas,
          int @revisionHistoryLimit,
          Meta.V1.LabelSelector @selector,
          Apps.V1Beta2.DeploymentStrategy @strategy,
          Core.V1.PodTemplateSpec @template)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.Paused = @paused;
          this.ProgressDeadlineSeconds = @progressDeadlineSeconds;
          this.Replicas = @replicas;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.Selector = @selector;
          this.Strategy = @strategy;
          this.Template = @template;
      }

    }
    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentStatus
    {
      /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
      public readonly int AvailableReplicas;

      /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta2.DeploymentCondition> Conditions;

      /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
      public readonly int UnavailableReplicas;

      /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
      public readonly int UpdatedReplicas;

      [OutputConstructor]
      private DeploymentStatus(
          int @availableReplicas,
          int @collisionCount,
          ImmutableArray<Apps.V1Beta2.DeploymentCondition> @conditions,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas,
          int @unavailableReplicas,
          int @updatedReplicas)
      {
          this.AvailableReplicas = @availableReplicas;
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
          this.UnavailableReplicas = @unavailableReplicas;
          this.UpdatedReplicas = @updatedReplicas;
      }

    }
    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    [OutputType]
    public sealed class DeploymentStrategy
    {
      /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
      public readonly Apps.V1Beta2.RollingUpdateDeployment RollingUpdate;

      /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DeploymentStrategy(
          Apps.V1Beta2.RollingUpdateDeployment @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DEPRECATED - apps/v1beta2/ReplicaSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/ReplicaSet instead.
    /// 
    /// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSet
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
        /// that the ReplicaSet manages. Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the specification of the desired behavior of the ReplicaSet. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Apps.V1Beta2.ReplicaSetSpec Spec;

      /// <summary>
        /// Status is the most recently observed status of the ReplicaSet. This data may be out of
        /// date by some window of time. Populated by the system. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Apps.V1Beta2.ReplicaSetStatus Status;

      [OutputConstructor]
      private ReplicaSet(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1Beta2.ReplicaSetSpec @spec,
          Apps.V1Beta2.ReplicaSetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// ReplicaSetCondition describes the state of a replica set at a certain point.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetCondition
    {
      /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of replica set condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private ReplicaSetCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// ReplicaSetList is a collection of ReplicaSets.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of ReplicaSets. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta2.ReplicaSet> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ReplicaSetList(
          string @apiVersion,
          ImmutableArray<Apps.V1Beta2.ReplicaSet> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ReplicaSetSpec is the specification of a ReplicaSet.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetSpec
    {
      /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// Selector is a label query over pods that should match the replica count. Label keys and
        /// values that must match in order to be controlled by this replica set. It must match the
        /// pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      [OutputConstructor]
      private ReplicaSetSpec(
          int @minReadySeconds,
          int @replicas,
          Meta.V1.LabelSelector @selector,
          Core.V1.PodTemplateSpec @template)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.Replicas = @replicas;
          this.Selector = @selector;
          this.Template = @template;
      }

    }
    /// <summary>
    /// ReplicaSetStatus represents the current status of a ReplicaSet.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetStatus
    {
      /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this replica
        /// set.
        /// </summary>
      public readonly int AvailableReplicas;

      /// <summary>
        /// Represents the latest available observations of a replica set's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta2.ReplicaSetCondition> Conditions;

      /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replicaset.
        /// </summary>
      public readonly int FullyLabeledReplicas;

      /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// The number of ready replicas for this replica set.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
      public readonly int Replicas;

      [OutputConstructor]
      private ReplicaSetStatus(
          int @availableReplicas,
          ImmutableArray<Apps.V1Beta2.ReplicaSetCondition> @conditions,
          int @fullyLabeledReplicas,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas)
      {
          this.AvailableReplicas = @availableReplicas;
          this.Conditions = @conditions;
          this.FullyLabeledReplicas = @fullyLabeledReplicas;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
      }

    }
    /// <summary>
    /// Spec to control the desired behavior of daemon set rolling update.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateDaemonSet
    {
      /// <summary>
        /// The maximum number of DaemonSet pods that can be unavailable during the update. Value
        /// can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at
        /// the start of the update (ex: 10%). Absolute number is calculated from percentage by
        /// rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at
        /// most 30% of the total number of nodes that should be running the daemon pod (i.e.
        /// status.desiredNumberScheduled) can have their pods stopped for an update at any given
        /// time. The update starts by stopping at most 30% of those DaemonSet pods and then brings
        /// up new DaemonSet pods in their place. Once the new pods are available, it then proceeds
        /// onto other DaemonSet pods, thus ensuring that at least 70% of original number of
        /// DaemonSet pods are available at all times during the update.
        /// </summary>
      public readonly Union<int,string> MaxUnavailable;

      [OutputConstructor]
      private RollingUpdateDaemonSet(
          Union<int,string> @maxUnavailable)
      {
          this.MaxUnavailable = @maxUnavailable;
      }

    }
    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateDeployment
    {
      /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can
        /// be scaled up immediately when the rolling update starts, such that the total number of
        /// old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new
        /// ReplicaSet can be scaled up further, ensuring that total number of pods running at any
        /// time during the update is at most 130% of desired pods.
        /// </summary>
      public readonly Union<int,string> MaxSurge;

      /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0.
        /// Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down
        /// to 70% of desired pods immediately when the rolling update starts. Once new pods are
        /// ready, old ReplicaSet can be scaled down further, followed by scaling up the new
        /// ReplicaSet, ensuring that the total number of pods available at all times during the
        /// update is at least 70% of desired pods.
        /// </summary>
      public readonly Union<int,string> MaxUnavailable;

      [OutputConstructor]
      private RollingUpdateDeployment(
          Union<int,string> @maxSurge,
          Union<int,string> @maxUnavailable)
      {
          this.MaxSurge = @maxSurge;
          this.MaxUnavailable = @maxUnavailable;
      }

    }
    /// <summary>
    /// RollingUpdateStatefulSetStrategy is used to communicate parameter for
    /// RollingUpdateStatefulSetStrategyType.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateStatefulSetStrategy
    {
      /// <summary>
        /// Partition indicates the ordinal at which the StatefulSet should be partitioned. Default
        /// value is 0.
        /// </summary>
      public readonly int Partition;

      [OutputConstructor]
      private RollingUpdateStatefulSetStrategy(
          int @partition)
      {
          this.Partition = @partition;
      }

    }
    /// <summary>
    /// Scale represents a scaling request for a resource.
    /// </summary>
    [OutputType]
    public sealed class Scale
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
      public readonly Apps.V1Beta2.ScaleSpec Spec;

      /// <summary>
        /// current status of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// Read-only.
        /// </summary>
      public readonly Apps.V1Beta2.ScaleStatus Status;

      [OutputConstructor]
      private Scale(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1Beta2.ScaleSpec @spec,
          Apps.V1Beta2.ScaleStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// ScaleSpec describes the attributes of a scale subresource
    /// </summary>
    [OutputType]
    public sealed class ScaleSpec
    {
      /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
      public readonly int Replicas;

      [OutputConstructor]
      private ScaleSpec(
          int @replicas)
      {
          this.Replicas = @replicas;
      }

    }
    /// <summary>
    /// ScaleStatus represents the current status of a scale subresource.
    /// </summary>
    [OutputType]
    public sealed class ScaleStatus
    {
      /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// label query over pods that should match the replicas count. More info:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
      public readonly ImmutableDictionary<string, string> Selector;

      /// <summary>
        /// label selector for pods that should match the replicas count. This is a serializated
        /// version of both map-based and more expressive set-based selectors. This is done to avoid
        /// introspection in the clients. The string will be in the same format as the query-param
        /// syntax. If the target type only supports map-based selectors, both this field and
        /// map-based selector field are populated. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly string TargetSelector;

      [OutputConstructor]
      private ScaleStatus(
          int @replicas,
          ImmutableDictionary<string, string> @selector,
          string @targetSelector)
      {
          this.Replicas = @replicas;
          this.Selector = @selector;
          this.TargetSelector = @targetSelector;
      }

    }
    /// <summary>
    /// DEPRECATED - apps/v1beta2/StatefulSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/StatefulSet instead.
    /// 
    /// StatefulSet represents a set of pods with consistent identities. Identities are defined as:
    ///  - Network: A single stable DNS and hostname.
    ///  - Storage: As many VolumeClaims as requested.
    /// The StatefulSet guarantees that a given network identity will always map to the same storage
    /// identity.
    /// </summary>
    [OutputType]
    public sealed class StatefulSet
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the desired identities of pods in this set.
        /// </summary>
      public readonly Apps.V1Beta2.StatefulSetSpec Spec;

      /// <summary>
        /// Status is the current status of Pods in this StatefulSet. This data may be out of date
        /// by some window of time.
        /// </summary>
      public readonly Apps.V1Beta2.StatefulSetStatus Status;

      [OutputConstructor]
      private StatefulSet(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Apps.V1Beta2.StatefulSetSpec @spec,
          Apps.V1Beta2.StatefulSetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// StatefulSetCondition describes the state of a statefulset at a certain point.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of statefulset condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private StatefulSetCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// StatefulSetList is a collection of StatefulSets.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      
      public readonly ImmutableArray<Apps.V1Beta2.StatefulSet> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private StatefulSetList(
          string @apiVersion,
          ImmutableArray<Apps.V1Beta2.StatefulSet> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// A StatefulSetSpec is the specification of a StatefulSet.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetSpec
    {
      /// <summary>
        /// podManagementPolicy controls how pods are created during initial scale up, when
        /// replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`,
        /// where pods are created in increasing order (pod-0, then pod-1, etc) and the controller
        /// will wait until each pod is ready before continuing. When scaling down, the pods are
        /// removed in the opposite order. The alternative policy is `Parallel` which will create
        /// pods in parallel to match the desired scale without waiting, and on scale down will
        /// delete all pods at once.
        /// </summary>
      public readonly string PodManagementPolicy;

      /// <summary>
        /// replicas is the desired number of replicas of the given Template. These are replicas in
        /// the sense that they are instantiations of the same Template, but individual replicas
        /// also have a consistent identity. If unspecified, defaults to 1.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the
        /// StatefulSet's revision history. The revision history consists of all revisions not
        /// represented by a currently applied StatefulSetSpec version. The default value is 10.
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// selector is a label query over pods that should match the replica count. It must match
        /// the pod template's labels. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// serviceName is the name of the service that governs this StatefulSet. This service must
        /// exist before the StatefulSet, and is responsible for the network identity of the set.
        /// Pods get DNS/hostnames that follow the pattern:
        /// pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
        /// managed by the StatefulSet controller.
        /// </summary>
      public readonly string ServiceName;

      /// <summary>
        /// template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. Each pod stamped out by the StatefulSet will fulfill this
        /// Template, but have a unique identity from the rest of the StatefulSet.
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      /// <summary>
        /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update
        /// Pods in the StatefulSet when a revision is made to Template.
        /// </summary>
      public readonly Apps.V1Beta2.StatefulSetUpdateStrategy UpdateStrategy;

      /// <summary>
        /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The
        /// StatefulSet controller is responsible for mapping network identities to claims in a way
        /// that maintains the identity of a pod. Every claim in this list must have at least one
        /// matching (by name) volumeMount in one container in the template. A claim in this list
        /// takes precedence over any volumes in the template, with the same name.
        /// </summary>
      public readonly ImmutableArray<Core.V1.PersistentVolumeClaim> VolumeClaimTemplates;

      [OutputConstructor]
      private StatefulSetSpec(
          string @podManagementPolicy,
          int @replicas,
          int @revisionHistoryLimit,
          Meta.V1.LabelSelector @selector,
          string @serviceName,
          Core.V1.PodTemplateSpec @template,
          Apps.V1Beta2.StatefulSetUpdateStrategy @updateStrategy,
          ImmutableArray<Core.V1.PersistentVolumeClaim> @volumeClaimTemplates)
      {
          this.PodManagementPolicy = @podManagementPolicy;
          this.Replicas = @replicas;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.Selector = @selector;
          this.ServiceName = @serviceName;
          this.Template = @template;
          this.UpdateStrategy = @updateStrategy;
          this.VolumeClaimTemplates = @volumeClaimTemplates;
      }

    }
    /// <summary>
    /// StatefulSetStatus represents the current state of a StatefulSet.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetStatus
    {
      /// <summary>
        /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet
        /// controller uses this field as a collision avoidance mechanism when it needs to create
        /// the name for the newest ControllerRevision.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a statefulset's current state.
        /// </summary>
      public readonly ImmutableArray<Apps.V1Beta2.StatefulSetCondition> Conditions;

      /// <summary>
        /// currentReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by currentRevision.
        /// </summary>
      public readonly int CurrentReplicas;

      /// <summary>
        /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [0,currentReplicas).
        /// </summary>
      public readonly string CurrentRevision;

      /// <summary>
        /// observedGeneration is the most recent generation observed for this StatefulSet. It
        /// corresponds to the StatefulSet's generation, which is updated on mutation by the API
        /// Server.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// readyReplicas is the number of Pods created by the StatefulSet controller that have a
        /// Ready Condition.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// replicas is the number of Pods created by the StatefulSet controller.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate
        /// Pods in the sequence [replicas-updatedReplicas,replicas)
        /// </summary>
      public readonly string UpdateRevision;

      /// <summary>
        /// updatedReplicas is the number of Pods created by the StatefulSet controller from the
        /// StatefulSet version indicated by updateRevision.
        /// </summary>
      public readonly int UpdatedReplicas;

      [OutputConstructor]
      private StatefulSetStatus(
          int @collisionCount,
          ImmutableArray<Apps.V1Beta2.StatefulSetCondition> @conditions,
          int @currentReplicas,
          string @currentRevision,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas,
          string @updateRevision,
          int @updatedReplicas)
      {
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.CurrentReplicas = @currentReplicas;
          this.CurrentRevision = @currentRevision;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
          this.UpdateRevision = @updateRevision;
          this.UpdatedReplicas = @updatedReplicas;
      }

    }
    /// <summary>
    /// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
    /// perform updates. It includes any additional parameters necessary to perform the update for
    /// the indicated strategy.
    /// </summary>
    [OutputType]
    public sealed class StatefulSetUpdateStrategy
    {
      /// <summary>
        /// RollingUpdate is used to communicate parameters when Type is
        /// RollingUpdateStatefulSetStrategyType.
        /// </summary>
      public readonly Apps.V1Beta2.RollingUpdateStatefulSetStrategy RollingUpdate;

      /// <summary>
        /// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private StatefulSetUpdateStrategy(
          Apps.V1Beta2.RollingUpdateStatefulSetStrategy @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.AuditRegistraion
{
  namespace V1Alpha1
  {
    /// <summary>
    /// AuditSink represents a cluster level audit sink
    /// </summary>
    [OutputType]
    public sealed class AuditSink
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the audit configuration spec
        /// </summary>
      public readonly AuditRegistraion.V1Alpha1.AuditSinkSpec Spec;

      [OutputConstructor]
      private AuditSink(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          AuditRegistraion.V1Alpha1.AuditSinkSpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// AuditSinkList is a list of AuditSink items.
    /// </summary>
    [OutputType]
    public sealed class AuditSinkList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of audit configurations.
        /// </summary>
      public readonly ImmutableArray<AuditRegistraion.V1Alpha1.AuditSink> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private AuditSinkList(
          string @apiVersion,
          ImmutableArray<AuditRegistraion.V1Alpha1.AuditSink> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// AuditSinkSpec holds the spec for the audit sink
    /// </summary>
    [OutputType]
    public sealed class AuditSinkSpec
    {
      /// <summary>
        /// Policy defines the policy for selecting which events should be sent to the webhook
        /// required
        /// </summary>
      public readonly AuditRegistraion.V1Alpha1.Policy Policy;

      /// <summary>
        /// Webhook to send events required
        /// </summary>
      public readonly AuditRegistraion.V1Alpha1.Webhook Webhook;

      [OutputConstructor]
      private AuditSinkSpec(
          AuditRegistraion.V1Alpha1.Policy @policy,
          AuditRegistraion.V1Alpha1.Webhook @webhook)
      {
          this.Policy = @policy;
          this.Webhook = @webhook;
      }

    }
    /// <summary>
    /// Policy defines the configuration of how audit events are logged
    /// </summary>
    [OutputType]
    public sealed class Policy
    {
      /// <summary>
        /// The Level that all requests are recorded at. available options: None, Metadata, Request,
        /// RequestResponse required
        /// </summary>
      public readonly string Level;

      /// <summary>
        /// Stages is a list of stages for which events are created.
        /// </summary>
      public readonly ImmutableArray<string> Stages;

      [OutputConstructor]
      private Policy(
          string @level,
          ImmutableArray<string> @stages)
      {
          this.Level = @level;
          this.Stages = @stages;
      }

    }
    /// <summary>
    /// ServiceReference holds a reference to Service.legacy.k8s.io
    /// </summary>
    [OutputType]
    public sealed class ServiceReference
    {
      /// <summary>
        /// `name` is the name of the service. Required
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// `namespace` is the namespace of the service. Required
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// `path` is an optional URL path which will be sent in any request to this service.
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// If specified, the port on the service that hosting webhook. Default to 443 for backward
        /// compatibility. `port` should be a valid port number (1-65535, inclusive).
        /// </summary>
      public readonly int Port;

      [OutputConstructor]
      private ServiceReference(
          string @name,
          string @namespace,
          string @path,
          int @port)
      {
          this.Name = @name;
          this.Namespace = @namespace;
          this.Path = @path;
          this.Port = @port;
      }

    }
    /// <summary>
    /// Webhook holds the configuration of the webhook
    /// </summary>
    [OutputType]
    public sealed class Webhook
    {
      /// <summary>
        /// ClientConfig holds the connection parameters for the webhook required
        /// </summary>
      public readonly AuditRegistraion.V1Alpha1.WebhookClientConfig ClientConfig;

      /// <summary>
        /// Throttle holds the options for throttling the webhook
        /// </summary>
      public readonly AuditRegistraion.V1Alpha1.WebhookThrottleConfig Throttle;

      [OutputConstructor]
      private Webhook(
          AuditRegistraion.V1Alpha1.WebhookClientConfig @clientConfig,
          AuditRegistraion.V1Alpha1.WebhookThrottleConfig @throttle)
      {
          this.ClientConfig = @clientConfig;
          this.Throttle = @throttle;
      }

    }
    /// <summary>
    /// WebhookClientConfig contains the information to make a connection with the webhook
    /// </summary>
    [OutputType]
    public sealed class WebhookClientConfig
    {
      /// <summary>
        /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's
        /// server certificate. If unspecified, system trust roots on the apiserver are used.
        /// </summary>
      public readonly string CaBundle;

      /// <summary>
        /// `service` is a reference to the service for this webhook. Either `service` or `url` must
        /// be specified.
        /// 
        /// If the webhook is running within the cluster, then you should use `service`.
        /// </summary>
      public readonly AuditRegistraion.V1Alpha1.ServiceReference Service;

      /// <summary>
        /// `url` gives the location of the webhook, in standard URL form
        /// (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.
        /// 
        /// The `host` should not refer to a service running in the cluster; use the `service` field
        /// instead. The host might be resolved via external DNS in some apiservers (e.g.,
        /// `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
        /// `host` may also be an IP address.
        /// 
        /// Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
        /// great care to run this webhook on all hosts which run an apiserver which might need to
        /// make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy
        /// to turn up in a new cluster.
        /// 
        /// The scheme must be "https"; the URL must begin with "https://".
        /// 
        /// A path is optional, and if present may be any string permissible in a URL. You may use
        /// the path to pass an arbitrary string to the webhook, for example, a cluster identifier.
        /// 
        /// Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
        /// ("#...") and query parameters ("?...") are not allowed, either.
        /// </summary>
      public readonly string Url;

      [OutputConstructor]
      private WebhookClientConfig(
          string @caBundle,
          AuditRegistraion.V1Alpha1.ServiceReference @service,
          string @url)
      {
          this.CaBundle = @caBundle;
          this.Service = @service;
          this.Url = @url;
      }

    }
    /// <summary>
    /// WebhookThrottleConfig holds the configuration for throttling events
    /// </summary>
    [OutputType]
    public sealed class WebhookThrottleConfig
    {
      /// <summary>
        /// ThrottleBurst is the maximum number of events sent at the same moment default 15 QPS
        /// </summary>
      public readonly int Burst;

      /// <summary>
        /// ThrottleQPS maximum number of batches per second default 10 QPS
        /// </summary>
      public readonly int Qps;

      [OutputConstructor]
      private WebhookThrottleConfig(
          int @burst,
          int @qps)
      {
          this.Burst = @burst;
          this.Qps = @qps;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Authentication
{
  namespace V1
  {
    /// <summary>
    /// BoundObjectReference is a reference to an object that a token is bound to.
    /// </summary>
    [OutputType]
    public sealed class BoundObjectReference
    {
      /// <summary>
        /// API version of the referent.
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind of the referent. Valid kinds are 'Pod' and 'Secret'.
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name of the referent.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// UID of the referent.
        /// </summary>
      public readonly string Uid;

      [OutputConstructor]
      private BoundObjectReference(
          string @apiVersion,
          string @kind,
          string @name,
          string @uid)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Name = @name;
          this.Uid = @uid;
      }

    }
    /// <summary>
    /// TokenRequest requests a token for a given service account.
    /// </summary>
    [OutputType]
    public sealed class TokenRequest
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      
      public readonly Authentication.V1.TokenRequestSpec Spec;

      
      public readonly Authentication.V1.TokenRequestStatus Status;

      [OutputConstructor]
      private TokenRequest(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authentication.V1.TokenRequestSpec @spec,
          Authentication.V1.TokenRequestStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// TokenRequestSpec contains client provided parameters of a token request.
    /// </summary>
    [OutputType]
    public sealed class TokenRequestSpec
    {
      /// <summary>
        /// Audiences are the intendend audiences of the token. A recipient of a token must
        /// identitfy themself with an identifier in the list of audiences of the token, and
        /// otherwise should reject the token. A token issued for multiple audiences may be used to
        /// authenticate against any of the audiences listed but implies a high degree of trust
        /// between the target audiences.
        /// </summary>
      public readonly ImmutableArray<string> Audiences;

      /// <summary>
        /// BoundObjectRef is a reference to an object that the token will be bound to. The token
        /// will only be valid for as long as the bound object exists. NOTE: The API server's
        /// TokenReview endpoint will validate the BoundObjectRef, but other audiences may not. Keep
        /// ExpirationSeconds small if you want prompt revocation.
        /// </summary>
      public readonly Authentication.V1.BoundObjectReference BoundObjectRef;

      /// <summary>
        /// ExpirationSeconds is the requested duration of validity of the request. The token issuer
        /// may return a token with a different validity duration so a client needs to check the
        /// 'expiration' field in a response.
        /// </summary>
      public readonly int ExpirationSeconds;

      [OutputConstructor]
      private TokenRequestSpec(
          ImmutableArray<string> @audiences,
          Authentication.V1.BoundObjectReference @boundObjectRef,
          int @expirationSeconds)
      {
          this.Audiences = @audiences;
          this.BoundObjectRef = @boundObjectRef;
          this.ExpirationSeconds = @expirationSeconds;
      }

    }
    /// <summary>
    /// TokenRequestStatus is the result of a token request.
    /// </summary>
    [OutputType]
    public sealed class TokenRequestStatus
    {
      /// <summary>
        /// ExpirationTimestamp is the time of expiration of the returned token.
        /// </summary>
      public readonly string ExpirationTimestamp;

      /// <summary>
        /// Token is the opaque bearer token.
        /// </summary>
      public readonly string Token;

      [OutputConstructor]
      private TokenRequestStatus(
          string @expirationTimestamp,
          string @token)
      {
          this.ExpirationTimestamp = @expirationTimestamp;
          this.Token = @token;
      }

    }
    /// <summary>
    /// TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may
    /// be cached by the webhook token authenticator plugin in the kube-apiserver.
    /// </summary>
    [OutputType]
    public sealed class TokenReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
      public readonly Authentication.V1.TokenReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates whether the request can be
        /// authenticated.
        /// </summary>
      public readonly Authentication.V1.TokenReviewStatus Status;

      [OutputConstructor]
      private TokenReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authentication.V1.TokenReviewSpec @spec,
          Authentication.V1.TokenReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// TokenReviewSpec is a description of the token authentication request.
    /// </summary>
    [OutputType]
    public sealed class TokenReviewSpec
    {
      /// <summary>
        /// Audiences is a list of the identifiers that the resource server presented with the token
        /// identifies as. Audience-aware token authenticators will verify that the token was
        /// intended for at least one of the audiences in this list. If no audiences are provided,
        /// the audience will default to the audience of the Kubernetes apiserver.
        /// </summary>
      public readonly ImmutableArray<string> Audiences;

      /// <summary>
        /// Token is the opaque bearer token.
        /// </summary>
      public readonly string Token;

      [OutputConstructor]
      private TokenReviewSpec(
          ImmutableArray<string> @audiences,
          string @token)
      {
          this.Audiences = @audiences;
          this.Token = @token;
      }

    }
    /// <summary>
    /// TokenReviewStatus is the result of the token authentication request.
    /// </summary>
    [OutputType]
    public sealed class TokenReviewStatus
    {
      /// <summary>
        /// Audiences are audience identifiers chosen by the authenticator that are compatible with
        /// both the TokenReview and token. An identifier is any identifier in the intersection of
        /// the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API
        /// that sets the spec.audiences field should validate that a compatible audience identifier
        /// is returned in the status.audiences field to ensure that the TokenReview server is
        /// audience aware. If a TokenReview returns an empty status.audience field where
        /// status.authenticated is "true", the token is valid against the audience of the
        /// Kubernetes API server.
        /// </summary>
      public readonly ImmutableArray<string> Audiences;

      /// <summary>
        /// Authenticated indicates that the token was associated with a known user.
        /// </summary>
      public readonly bool Authenticated;

      /// <summary>
        /// Error indicates that the token couldn't be checked
        /// </summary>
      public readonly string Error;

      /// <summary>
        /// User is the UserInfo associated with the provided token.
        /// </summary>
      public readonly Authentication.V1.UserInfo User;

      [OutputConstructor]
      private TokenReviewStatus(
          ImmutableArray<string> @audiences,
          bool @authenticated,
          string @error,
          Authentication.V1.UserInfo @user)
      {
          this.Audiences = @audiences;
          this.Authenticated = @authenticated;
          this.Error = @error;
          this.User = @user;
      }

    }
    /// <summary>
    /// UserInfo holds the information about the user needed to implement the user.Info interface.
    /// </summary>
    [OutputType]
    public sealed class UserInfo
    {
      /// <summary>
        /// Any additional information provided by the authenticator.
        /// </summary>
      public readonly ImmutableDictionary<string, ImmutableArray<string>> Extra;

      /// <summary>
        /// The names of groups this user is a part of.
        /// </summary>
      public readonly ImmutableArray<string> Groups;

      /// <summary>
        /// A unique value that identifies this user across time. If this user is deleted and
        /// another user by the same name is added, they will have different UIDs.
        /// </summary>
      public readonly string Uid;

      /// <summary>
        /// The name that uniquely identifies this user among all active users.
        /// </summary>
      public readonly string Username;

      [OutputConstructor]
      private UserInfo(
          ImmutableDictionary<string, ImmutableArray<string>> @extra,
          ImmutableArray<string> @groups,
          string @uid,
          string @username)
      {
          this.Extra = @extra;
          this.Groups = @groups;
          this.Uid = @uid;
          this.Username = @username;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may
    /// be cached by the webhook token authenticator plugin in the kube-apiserver.
    /// </summary>
    [OutputType]
    public sealed class TokenReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
      public readonly Authentication.V1Beta1.TokenReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates whether the request can be
        /// authenticated.
        /// </summary>
      public readonly Authentication.V1Beta1.TokenReviewStatus Status;

      [OutputConstructor]
      private TokenReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authentication.V1Beta1.TokenReviewSpec @spec,
          Authentication.V1Beta1.TokenReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// TokenReviewSpec is a description of the token authentication request.
    /// </summary>
    [OutputType]
    public sealed class TokenReviewSpec
    {
      /// <summary>
        /// Audiences is a list of the identifiers that the resource server presented with the token
        /// identifies as. Audience-aware token authenticators will verify that the token was
        /// intended for at least one of the audiences in this list. If no audiences are provided,
        /// the audience will default to the audience of the Kubernetes apiserver.
        /// </summary>
      public readonly ImmutableArray<string> Audiences;

      /// <summary>
        /// Token is the opaque bearer token.
        /// </summary>
      public readonly string Token;

      [OutputConstructor]
      private TokenReviewSpec(
          ImmutableArray<string> @audiences,
          string @token)
      {
          this.Audiences = @audiences;
          this.Token = @token;
      }

    }
    /// <summary>
    /// TokenReviewStatus is the result of the token authentication request.
    /// </summary>
    [OutputType]
    public sealed class TokenReviewStatus
    {
      /// <summary>
        /// Audiences are audience identifiers chosen by the authenticator that are compatible with
        /// both the TokenReview and token. An identifier is any identifier in the intersection of
        /// the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API
        /// that sets the spec.audiences field should validate that a compatible audience identifier
        /// is returned in the status.audiences field to ensure that the TokenReview server is
        /// audience aware. If a TokenReview returns an empty status.audience field where
        /// status.authenticated is "true", the token is valid against the audience of the
        /// Kubernetes API server.
        /// </summary>
      public readonly ImmutableArray<string> Audiences;

      /// <summary>
        /// Authenticated indicates that the token was associated with a known user.
        /// </summary>
      public readonly bool Authenticated;

      /// <summary>
        /// Error indicates that the token couldn't be checked
        /// </summary>
      public readonly string Error;

      /// <summary>
        /// User is the UserInfo associated with the provided token.
        /// </summary>
      public readonly Authentication.V1Beta1.UserInfo User;

      [OutputConstructor]
      private TokenReviewStatus(
          ImmutableArray<string> @audiences,
          bool @authenticated,
          string @error,
          Authentication.V1Beta1.UserInfo @user)
      {
          this.Audiences = @audiences;
          this.Authenticated = @authenticated;
          this.Error = @error;
          this.User = @user;
      }

    }
    /// <summary>
    /// UserInfo holds the information about the user needed to implement the user.Info interface.
    /// </summary>
    [OutputType]
    public sealed class UserInfo
    {
      /// <summary>
        /// Any additional information provided by the authenticator.
        /// </summary>
      public readonly ImmutableDictionary<string, ImmutableArray<string>> Extra;

      /// <summary>
        /// The names of groups this user is a part of.
        /// </summary>
      public readonly ImmutableArray<string> Groups;

      /// <summary>
        /// A unique value that identifies this user across time. If this user is deleted and
        /// another user by the same name is added, they will have different UIDs.
        /// </summary>
      public readonly string Uid;

      /// <summary>
        /// The name that uniquely identifies this user among all active users.
        /// </summary>
      public readonly string Username;

      [OutputConstructor]
      private UserInfo(
          ImmutableDictionary<string, ImmutableArray<string>> @extra,
          ImmutableArray<string> @groups,
          string @uid,
          string @username)
      {
          this.Extra = @extra;
          this.Groups = @groups;
          this.Uid = @uid;
          this.Username = @username;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Authorization
{
  namespace V1
  {
    /// <summary>
    /// LocalSubjectAccessReview checks whether or not a user or group can perform an action in a
    /// given namespace. Having a namespace scoped resource makes it much easier to grant namespace
    /// scoped policy that includes permissions checking.
    /// </summary>
    [OutputType]
    public sealed class LocalSubjectAccessReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated.  spec.namespace must be equal
        /// to the namespace you made the request against.  If empty, it is defaulted.
        /// </summary>
      public readonly Authorization.V1.SubjectAccessReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates whether the request is allowed or not
        /// </summary>
      public readonly Authorization.V1.SubjectAccessReviewStatus Status;

      [OutputConstructor]
      private LocalSubjectAccessReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authorization.V1.SubjectAccessReviewSpec @spec,
          Authorization.V1.SubjectAccessReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// NonResourceAttributes includes the authorization attributes available for non-resource
    /// requests to the Authorizer interface
    /// </summary>
    [OutputType]
    public sealed class NonResourceAttributes
    {
      /// <summary>
        /// Path is the URL path of the request
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// Verb is the standard HTTP verb
        /// </summary>
      public readonly string Verb;

      [OutputConstructor]
      private NonResourceAttributes(
          string @path,
          string @verb)
      {
          this.Path = @path;
          this.Verb = @verb;
      }

    }
    /// <summary>
    /// NonResourceRule holds information that describes a rule for the non-resource
    /// </summary>
    [OutputType]
    public sealed class NonResourceRule
    {
      /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> NonResourceURLs;

      /// <summary>
        /// Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete,
        /// patch, head, options.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      [OutputConstructor]
      private NonResourceRule(
          ImmutableArray<string> @nonResourceURLs,
          ImmutableArray<string> @verbs)
      {
          this.NonResourceURLs = @nonResourceURLs;
          this.Verbs = @verbs;
      }

    }
    /// <summary>
    /// ResourceAttributes includes the authorization attributes available for resource requests to
    /// the Authorizer interface
    /// </summary>
    [OutputType]
    public sealed class ResourceAttributes
    {
      /// <summary>
        /// Group is the API Group of the Resource.  "*" means all.
        /// </summary>
      public readonly string Group;

      /// <summary>
        /// Name is the name of the resource being requested for a "get" or deleted for a "delete".
        /// "" (empty) means all.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace is the namespace of the action being requested.  Currently, there is no
        /// distinction between no namespace and all namespaces "" (empty) is defaulted for
        /// LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty)
        /// means "all" for namespace scoped resources from a SubjectAccessReview or
        /// SelfSubjectAccessReview
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// Resource is one of the existing resource types.  "*" means all.
        /// </summary>
      public readonly string Resource;

      /// <summary>
        /// Subresource is one of the existing resource types.  "" means none.
        /// </summary>
      public readonly string Subresource;

      /// <summary>
        /// Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete,
        /// proxy.  "*" means all.
        /// </summary>
      public readonly string Verb;

      /// <summary>
        /// Version is the API Version of the Resource.  "*" means all.
        /// </summary>
      public readonly string Version;

      [OutputConstructor]
      private ResourceAttributes(
          string @group,
          string @name,
          string @namespace,
          string @resource,
          string @subresource,
          string @verb,
          string @version)
      {
          this.Group = @group;
          this.Name = @name;
          this.Namespace = @namespace;
          this.Resource = @resource;
          this.Subresource = @subresource;
          this.Verb = @verb;
          this.Version = @version;
      }

    }
    /// <summary>
    /// ResourceRule is the list of actions the subject is allowed to perform on resources. The list
    /// ordering isn't significant, may contain duplicates, and possibly be incomplete.
    /// </summary>
    [OutputType]
    public sealed class ResourceRule
    {
      /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> ApiGroups;

      /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> ResourceNames;

      /// <summary>
        /// Resources is a list of resources this rule applies to.  "*" means all in the specified
        /// apiGroups.
        ///  "*/foo" represents the subresource 'foo' for all resources in the specified apiGroups.
        /// </summary>
      public readonly ImmutableArray<string> Resources;

      /// <summary>
        /// Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update,
        /// delete, proxy.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      [OutputConstructor]
      private ResourceRule(
          ImmutableArray<string> @apiGroups,
          ImmutableArray<string> @resourceNames,
          ImmutableArray<string> @resources,
          ImmutableArray<string> @verbs)
      {
          this.ApiGroups = @apiGroups;
          this.ResourceNames = @resourceNames;
          this.Resources = @resources;
          this.Verbs = @verbs;
      }

    }
    /// <summary>
    /// SelfSubjectAccessReview checks whether or the current user can perform an action.  Not
    /// filling in a spec.namespace means "in all namespaces".  Self is a special case, because
    /// users should always be able to check whether they can perform an action
    /// </summary>
    [OutputType]
    public sealed class SelfSubjectAccessReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated.  user and groups must be empty
        /// </summary>
      public readonly Authorization.V1.SelfSubjectAccessReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates whether the request is allowed or not
        /// </summary>
      public readonly Authorization.V1.SubjectAccessReviewStatus Status;

      [OutputConstructor]
      private SelfSubjectAccessReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authorization.V1.SelfSubjectAccessReviewSpec @spec,
          Authorization.V1.SubjectAccessReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    [OutputType]
    public sealed class SelfSubjectAccessReviewSpec
    {
      /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
      public readonly Authorization.V1.NonResourceAttributes NonResourceAttributes;

      /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
      public readonly Authorization.V1.ResourceAttributes ResourceAttributes;

      [OutputConstructor]
      private SelfSubjectAccessReviewSpec(
          Authorization.V1.NonResourceAttributes @nonResourceAttributes,
          Authorization.V1.ResourceAttributes @resourceAttributes)
      {
          this.NonResourceAttributes = @nonResourceAttributes;
          this.ResourceAttributes = @resourceAttributes;
      }

    }
    /// <summary>
    /// SelfSubjectRulesReview enumerates the set of actions the current user can perform within a
    /// namespace. The returned list of actions may be incomplete depending on the server's
    /// authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview
    /// should be used by UIs to show/hide actions, or to quickly let an end user reason about their
    /// permissions. It should NOT Be used by external systems to drive authorization decisions as
    /// this raises confused deputy, cache lifetime/revocation, and correctness concerns.
    /// SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization
    /// decisions to the API server.
    /// </summary>
    [OutputType]
    public sealed class SelfSubjectRulesReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated.
        /// </summary>
      public readonly Authorization.V1.SelfSubjectRulesReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates the set of actions a user can perform.
        /// </summary>
      public readonly Authorization.V1.SubjectRulesReviewStatus Status;

      [OutputConstructor]
      private SelfSubjectRulesReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authorization.V1.SelfSubjectRulesReviewSpec @spec,
          Authorization.V1.SubjectRulesReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// 
    /// </summary>
    [OutputType]
    public sealed class SelfSubjectRulesReviewSpec
    {
      /// <summary>
        /// Namespace to evaluate rules for. Required.
        /// </summary>
      public readonly string Namespace;

      [OutputConstructor]
      private SelfSubjectRulesReviewSpec(
          string @namespace)
      {
          this.Namespace = @namespace;
      }

    }
    /// <summary>
    /// SubjectAccessReview checks whether or not a user or group can perform an action.
    /// </summary>
    [OutputType]
    public sealed class SubjectAccessReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
      public readonly Authorization.V1.SubjectAccessReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates whether the request is allowed or not
        /// </summary>
      public readonly Authorization.V1.SubjectAccessReviewStatus Status;

      [OutputConstructor]
      private SubjectAccessReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authorization.V1.SubjectAccessReviewSpec @spec,
          Authorization.V1.SubjectAccessReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// SubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    [OutputType]
    public sealed class SubjectAccessReviewSpec
    {
      /// <summary>
        /// Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that
        /// is input to the authorizer it needs a reflection here.
        /// </summary>
      public readonly ImmutableDictionary<string, ImmutableArray<string>> Extra;

      /// <summary>
        /// Groups is the groups you're testing for.
        /// </summary>
      public readonly ImmutableArray<string> Groups;

      /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
      public readonly Authorization.V1.NonResourceAttributes NonResourceAttributes;

      /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
      public readonly Authorization.V1.ResourceAttributes ResourceAttributes;

      /// <summary>
        /// UID information about the requesting user.
        /// </summary>
      public readonly string Uid;

      /// <summary>
        /// User is the user you're testing for. If you specify "User" but not "Groups", then is it
        /// interpreted as "What if User were not a member of any groups
        /// </summary>
      public readonly string User;

      [OutputConstructor]
      private SubjectAccessReviewSpec(
          ImmutableDictionary<string, ImmutableArray<string>> @extra,
          ImmutableArray<string> @groups,
          Authorization.V1.NonResourceAttributes @nonResourceAttributes,
          Authorization.V1.ResourceAttributes @resourceAttributes,
          string @uid,
          string @user)
      {
          this.Extra = @extra;
          this.Groups = @groups;
          this.NonResourceAttributes = @nonResourceAttributes;
          this.ResourceAttributes = @resourceAttributes;
          this.Uid = @uid;
          this.User = @user;
      }

    }
    /// <summary>
    /// SubjectAccessReviewStatus
    /// </summary>
    [OutputType]
    public sealed class SubjectAccessReviewStatus
    {
      /// <summary>
        /// Allowed is required. True if the action would be allowed, false otherwise.
        /// </summary>
      public readonly bool Allowed;

      /// <summary>
        /// Denied is optional. True if the action would be denied, otherwise false. If both allowed
        /// is false and denied is false, then the authorizer has no opinion on whether to authorize
        /// the action. Denied may not be true if Allowed is true.
        /// </summary>
      public readonly bool Denied;

      /// <summary>
        /// EvaluationError is an indication that some error occurred during the authorization
        /// check. It is entirely possible to get an error and be able to continue determine
        /// authorization status in spite of it. For instance, RBAC can be missing a role, but
        /// enough roles are still present and bound to reason about the request.
        /// </summary>
      public readonly string EvaluationError;

      /// <summary>
        /// Reason is optional.  It indicates why a request was allowed or denied.
        /// </summary>
      public readonly string Reason;

      [OutputConstructor]
      private SubjectAccessReviewStatus(
          bool @allowed,
          bool @denied,
          string @evaluationError,
          string @reason)
      {
          this.Allowed = @allowed;
          this.Denied = @denied;
          this.EvaluationError = @evaluationError;
          this.Reason = @reason;
      }

    }
    /// <summary>
    /// SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete
    /// depending on the set of authorizers the server is configured with and any errors experienced
    /// during evaluation. Because authorization rules are additive, if a rule appears in a list
    /// it's safe to assume the subject has that permission, even if that list is incomplete.
    /// </summary>
    [OutputType]
    public sealed class SubjectRulesReviewStatus
    {
      /// <summary>
        /// EvaluationError can appear in combination with Rules. It indicates an error occurred
        /// during rule evaluation, such as an authorizer that doesn't support rule evaluation, and
        /// that ResourceRules and/or NonResourceRules may be incomplete.
        /// </summary>
      public readonly string EvaluationError;

      /// <summary>
        /// Incomplete is true when the rules returned by this call are incomplete. This is most
        /// commonly encountered when an authorizer, such as an external authorizer, doesn't support
        /// rules evaluation.
        /// </summary>
      public readonly bool Incomplete;

      /// <summary>
        /// NonResourceRules is the list of actions the subject is allowed to perform on
        /// non-resources. The list ordering isn't significant, may contain duplicates, and possibly
        /// be incomplete.
        /// </summary>
      public readonly ImmutableArray<Authorization.V1.NonResourceRule> NonResourceRules;

      /// <summary>
        /// ResourceRules is the list of actions the subject is allowed to perform on resources. The
        /// list ordering isn't significant, may contain duplicates, and possibly be incomplete.
        /// </summary>
      public readonly ImmutableArray<Authorization.V1.ResourceRule> ResourceRules;

      [OutputConstructor]
      private SubjectRulesReviewStatus(
          string @evaluationError,
          bool @incomplete,
          ImmutableArray<Authorization.V1.NonResourceRule> @nonResourceRules,
          ImmutableArray<Authorization.V1.ResourceRule> @resourceRules)
      {
          this.EvaluationError = @evaluationError;
          this.Incomplete = @incomplete;
          this.NonResourceRules = @nonResourceRules;
          this.ResourceRules = @resourceRules;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// LocalSubjectAccessReview checks whether or not a user or group can perform an action in a
    /// given namespace. Having a namespace scoped resource makes it much easier to grant namespace
    /// scoped policy that includes permissions checking.
    /// </summary>
    [OutputType]
    public sealed class LocalSubjectAccessReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated.  spec.namespace must be equal
        /// to the namespace you made the request against.  If empty, it is defaulted.
        /// </summary>
      public readonly Authorization.V1Beta1.SubjectAccessReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates whether the request is allowed or not
        /// </summary>
      public readonly Authorization.V1Beta1.SubjectAccessReviewStatus Status;

      [OutputConstructor]
      private LocalSubjectAccessReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authorization.V1Beta1.SubjectAccessReviewSpec @spec,
          Authorization.V1Beta1.SubjectAccessReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// NonResourceAttributes includes the authorization attributes available for non-resource
    /// requests to the Authorizer interface
    /// </summary>
    [OutputType]
    public sealed class NonResourceAttributes
    {
      /// <summary>
        /// Path is the URL path of the request
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// Verb is the standard HTTP verb
        /// </summary>
      public readonly string Verb;

      [OutputConstructor]
      private NonResourceAttributes(
          string @path,
          string @verb)
      {
          this.Path = @path;
          this.Verb = @verb;
      }

    }
    /// <summary>
    /// NonResourceRule holds information that describes a rule for the non-resource
    /// </summary>
    [OutputType]
    public sealed class NonResourceRule
    {
      /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> NonResourceURLs;

      /// <summary>
        /// Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete,
        /// patch, head, options.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      [OutputConstructor]
      private NonResourceRule(
          ImmutableArray<string> @nonResourceURLs,
          ImmutableArray<string> @verbs)
      {
          this.NonResourceURLs = @nonResourceURLs;
          this.Verbs = @verbs;
      }

    }
    /// <summary>
    /// ResourceAttributes includes the authorization attributes available for resource requests to
    /// the Authorizer interface
    /// </summary>
    [OutputType]
    public sealed class ResourceAttributes
    {
      /// <summary>
        /// Group is the API Group of the Resource.  "*" means all.
        /// </summary>
      public readonly string Group;

      /// <summary>
        /// Name is the name of the resource being requested for a "get" or deleted for a "delete".
        /// "" (empty) means all.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace is the namespace of the action being requested.  Currently, there is no
        /// distinction between no namespace and all namespaces "" (empty) is defaulted for
        /// LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty)
        /// means "all" for namespace scoped resources from a SubjectAccessReview or
        /// SelfSubjectAccessReview
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// Resource is one of the existing resource types.  "*" means all.
        /// </summary>
      public readonly string Resource;

      /// <summary>
        /// Subresource is one of the existing resource types.  "" means none.
        /// </summary>
      public readonly string Subresource;

      /// <summary>
        /// Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete,
        /// proxy.  "*" means all.
        /// </summary>
      public readonly string Verb;

      /// <summary>
        /// Version is the API Version of the Resource.  "*" means all.
        /// </summary>
      public readonly string Version;

      [OutputConstructor]
      private ResourceAttributes(
          string @group,
          string @name,
          string @namespace,
          string @resource,
          string @subresource,
          string @verb,
          string @version)
      {
          this.Group = @group;
          this.Name = @name;
          this.Namespace = @namespace;
          this.Resource = @resource;
          this.Subresource = @subresource;
          this.Verb = @verb;
          this.Version = @version;
      }

    }
    /// <summary>
    /// ResourceRule is the list of actions the subject is allowed to perform on resources. The list
    /// ordering isn't significant, may contain duplicates, and possibly be incomplete.
    /// </summary>
    [OutputType]
    public sealed class ResourceRule
    {
      /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> ApiGroups;

      /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> ResourceNames;

      /// <summary>
        /// Resources is a list of resources this rule applies to.  "*" means all in the specified
        /// apiGroups.
        ///  "*/foo" represents the subresource 'foo' for all resources in the specified apiGroups.
        /// </summary>
      public readonly ImmutableArray<string> Resources;

      /// <summary>
        /// Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update,
        /// delete, proxy.  "*" means all.
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      [OutputConstructor]
      private ResourceRule(
          ImmutableArray<string> @apiGroups,
          ImmutableArray<string> @resourceNames,
          ImmutableArray<string> @resources,
          ImmutableArray<string> @verbs)
      {
          this.ApiGroups = @apiGroups;
          this.ResourceNames = @resourceNames;
          this.Resources = @resources;
          this.Verbs = @verbs;
      }

    }
    /// <summary>
    /// SelfSubjectAccessReview checks whether or the current user can perform an action.  Not
    /// filling in a spec.namespace means "in all namespaces".  Self is a special case, because
    /// users should always be able to check whether they can perform an action
    /// </summary>
    [OutputType]
    public sealed class SelfSubjectAccessReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated.  user and groups must be empty
        /// </summary>
      public readonly Authorization.V1Beta1.SelfSubjectAccessReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates whether the request is allowed or not
        /// </summary>
      public readonly Authorization.V1Beta1.SubjectAccessReviewStatus Status;

      [OutputConstructor]
      private SelfSubjectAccessReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authorization.V1Beta1.SelfSubjectAccessReviewSpec @spec,
          Authorization.V1Beta1.SubjectAccessReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    [OutputType]
    public sealed class SelfSubjectAccessReviewSpec
    {
      /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
      public readonly Authorization.V1Beta1.NonResourceAttributes NonResourceAttributes;

      /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
      public readonly Authorization.V1Beta1.ResourceAttributes ResourceAttributes;

      [OutputConstructor]
      private SelfSubjectAccessReviewSpec(
          Authorization.V1Beta1.NonResourceAttributes @nonResourceAttributes,
          Authorization.V1Beta1.ResourceAttributes @resourceAttributes)
      {
          this.NonResourceAttributes = @nonResourceAttributes;
          this.ResourceAttributes = @resourceAttributes;
      }

    }
    /// <summary>
    /// SelfSubjectRulesReview enumerates the set of actions the current user can perform within a
    /// namespace. The returned list of actions may be incomplete depending on the server's
    /// authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview
    /// should be used by UIs to show/hide actions, or to quickly let an end user reason about their
    /// permissions. It should NOT Be used by external systems to drive authorization decisions as
    /// this raises confused deputy, cache lifetime/revocation, and correctness concerns.
    /// SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization
    /// decisions to the API server.
    /// </summary>
    [OutputType]
    public sealed class SelfSubjectRulesReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated.
        /// </summary>
      public readonly Authorization.V1Beta1.SelfSubjectRulesReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates the set of actions a user can perform.
        /// </summary>
      public readonly Authorization.V1Beta1.SubjectRulesReviewStatus Status;

      [OutputConstructor]
      private SelfSubjectRulesReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authorization.V1Beta1.SelfSubjectRulesReviewSpec @spec,
          Authorization.V1Beta1.SubjectRulesReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// 
    /// </summary>
    [OutputType]
    public sealed class SelfSubjectRulesReviewSpec
    {
      /// <summary>
        /// Namespace to evaluate rules for. Required.
        /// </summary>
      public readonly string Namespace;

      [OutputConstructor]
      private SelfSubjectRulesReviewSpec(
          string @namespace)
      {
          this.Namespace = @namespace;
      }

    }
    /// <summary>
    /// SubjectAccessReview checks whether or not a user or group can perform an action.
    /// </summary>
    [OutputType]
    public sealed class SubjectAccessReview
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec holds information about the request being evaluated
        /// </summary>
      public readonly Authorization.V1Beta1.SubjectAccessReviewSpec Spec;

      /// <summary>
        /// Status is filled in by the server and indicates whether the request is allowed or not
        /// </summary>
      public readonly Authorization.V1Beta1.SubjectAccessReviewStatus Status;

      [OutputConstructor]
      private SubjectAccessReview(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Authorization.V1Beta1.SubjectAccessReviewSpec @spec,
          Authorization.V1Beta1.SubjectAccessReviewStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// SubjectAccessReviewSpec is a description of the access request.  Exactly one of
    /// ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
    /// </summary>
    [OutputType]
    public sealed class SubjectAccessReviewSpec
    {
      /// <summary>
        /// Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that
        /// is input to the authorizer it needs a reflection here.
        /// </summary>
      public readonly ImmutableDictionary<string, ImmutableArray<string>> Extra;

      /// <summary>
        /// Groups is the groups you're testing for.
        /// </summary>
      public readonly ImmutableArray<string> Group;

      /// <summary>
        /// NonResourceAttributes describes information for a non-resource access request
        /// </summary>
      public readonly Authorization.V1Beta1.NonResourceAttributes NonResourceAttributes;

      /// <summary>
        /// ResourceAuthorizationAttributes describes information for a resource access request
        /// </summary>
      public readonly Authorization.V1Beta1.ResourceAttributes ResourceAttributes;

      /// <summary>
        /// UID information about the requesting user.
        /// </summary>
      public readonly string Uid;

      /// <summary>
        /// User is the user you're testing for. If you specify "User" but not "Group", then is it
        /// interpreted as "What if User were not a member of any groups
        /// </summary>
      public readonly string User;

      [OutputConstructor]
      private SubjectAccessReviewSpec(
          ImmutableDictionary<string, ImmutableArray<string>> @extra,
          ImmutableArray<string> @group,
          Authorization.V1Beta1.NonResourceAttributes @nonResourceAttributes,
          Authorization.V1Beta1.ResourceAttributes @resourceAttributes,
          string @uid,
          string @user)
      {
          this.Extra = @extra;
          this.Group = @group;
          this.NonResourceAttributes = @nonResourceAttributes;
          this.ResourceAttributes = @resourceAttributes;
          this.Uid = @uid;
          this.User = @user;
      }

    }
    /// <summary>
    /// SubjectAccessReviewStatus
    /// </summary>
    [OutputType]
    public sealed class SubjectAccessReviewStatus
    {
      /// <summary>
        /// Allowed is required. True if the action would be allowed, false otherwise.
        /// </summary>
      public readonly bool Allowed;

      /// <summary>
        /// Denied is optional. True if the action would be denied, otherwise false. If both allowed
        /// is false and denied is false, then the authorizer has no opinion on whether to authorize
        /// the action. Denied may not be true if Allowed is true.
        /// </summary>
      public readonly bool Denied;

      /// <summary>
        /// EvaluationError is an indication that some error occurred during the authorization
        /// check. It is entirely possible to get an error and be able to continue determine
        /// authorization status in spite of it. For instance, RBAC can be missing a role, but
        /// enough roles are still present and bound to reason about the request.
        /// </summary>
      public readonly string EvaluationError;

      /// <summary>
        /// Reason is optional.  It indicates why a request was allowed or denied.
        /// </summary>
      public readonly string Reason;

      [OutputConstructor]
      private SubjectAccessReviewStatus(
          bool @allowed,
          bool @denied,
          string @evaluationError,
          string @reason)
      {
          this.Allowed = @allowed;
          this.Denied = @denied;
          this.EvaluationError = @evaluationError;
          this.Reason = @reason;
      }

    }
    /// <summary>
    /// SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete
    /// depending on the set of authorizers the server is configured with and any errors experienced
    /// during evaluation. Because authorization rules are additive, if a rule appears in a list
    /// it's safe to assume the subject has that permission, even if that list is incomplete.
    /// </summary>
    [OutputType]
    public sealed class SubjectRulesReviewStatus
    {
      /// <summary>
        /// EvaluationError can appear in combination with Rules. It indicates an error occurred
        /// during rule evaluation, such as an authorizer that doesn't support rule evaluation, and
        /// that ResourceRules and/or NonResourceRules may be incomplete.
        /// </summary>
      public readonly string EvaluationError;

      /// <summary>
        /// Incomplete is true when the rules returned by this call are incomplete. This is most
        /// commonly encountered when an authorizer, such as an external authorizer, doesn't support
        /// rules evaluation.
        /// </summary>
      public readonly bool Incomplete;

      /// <summary>
        /// NonResourceRules is the list of actions the subject is allowed to perform on
        /// non-resources. The list ordering isn't significant, may contain duplicates, and possibly
        /// be incomplete.
        /// </summary>
      public readonly ImmutableArray<Authorization.V1Beta1.NonResourceRule> NonResourceRules;

      /// <summary>
        /// ResourceRules is the list of actions the subject is allowed to perform on resources. The
        /// list ordering isn't significant, may contain duplicates, and possibly be incomplete.
        /// </summary>
      public readonly ImmutableArray<Authorization.V1Beta1.ResourceRule> ResourceRules;

      [OutputConstructor]
      private SubjectRulesReviewStatus(
          string @evaluationError,
          bool @incomplete,
          ImmutableArray<Authorization.V1Beta1.NonResourceRule> @nonResourceRules,
          ImmutableArray<Authorization.V1Beta1.ResourceRule> @resourceRules)
      {
          this.EvaluationError = @evaluationError;
          this.Incomplete = @incomplete;
          this.NonResourceRules = @nonResourceRules;
          this.ResourceRules = @resourceRules;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Autoscaling
{
  namespace V1
  {
    /// <summary>
    /// CrossVersionObjectReference contains enough information to let you identify the referred
    /// resource.
    /// </summary>
    [OutputType]
    public sealed class CrossVersionObjectReference
    {
      /// <summary>
        /// API version of the referent
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind of the referent; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private CrossVersionObjectReference(
          string @apiVersion,
          string @kind,
          string @name)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Name = @name;
      }

    }
    /// <summary>
    /// configuration of a horizontal pod autoscaler.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscaler
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// behaviour of autoscaler. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
      public readonly Autoscaling.V1.HorizontalPodAutoscalerSpec Spec;

      /// <summary>
        /// current information about the autoscaler.
        /// </summary>
      public readonly Autoscaling.V1.HorizontalPodAutoscalerStatus Status;

      [OutputConstructor]
      private HorizontalPodAutoscaler(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Autoscaling.V1.HorizontalPodAutoscalerSpec @spec,
          Autoscaling.V1.HorizontalPodAutoscalerStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// list of horizontal pod autoscaler objects.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// list of horizontal pod autoscaler objects.
        /// </summary>
      public readonly ImmutableArray<Autoscaling.V1.HorizontalPodAutoscaler> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private HorizontalPodAutoscalerList(
          string @apiVersion,
          ImmutableArray<Autoscaling.V1.HorizontalPodAutoscaler> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// specification of a horizontal pod autoscaler.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerSpec
    {
      /// <summary>
        /// upper limit for the number of pods that can be set by the autoscaler; cannot be smaller
        /// than MinReplicas.
        /// </summary>
      public readonly int MaxReplicas;

      /// <summary>
        /// minReplicas is the lower limit for the number of replicas to which the autoscaler can
        /// scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature
        /// gate HPAScaleToZero is enabled and at least one Object or External metric is configured.
        /// Scaling is active as long as at least one metric value is available.
        /// </summary>
      public readonly int MinReplicas;

      /// <summary>
        /// reference to scaled resource; horizontal pod autoscaler will learn the current resource
        /// consumption and will set the desired number of pods by using its Scale subresource.
        /// </summary>
      public readonly Autoscaling.V1.CrossVersionObjectReference ScaleTargetRef;

      /// <summary>
        /// target average CPU utilization (represented as a percentage of requested CPU) over all
        /// the pods; if not specified the default autoscaling policy will be used.
        /// </summary>
      public readonly int TargetCPUUtilizationPercentage;

      [OutputConstructor]
      private HorizontalPodAutoscalerSpec(
          int @maxReplicas,
          int @minReplicas,
          Autoscaling.V1.CrossVersionObjectReference @scaleTargetRef,
          int @targetCPUUtilizationPercentage)
      {
          this.MaxReplicas = @maxReplicas;
          this.MinReplicas = @minReplicas;
          this.ScaleTargetRef = @scaleTargetRef;
          this.TargetCPUUtilizationPercentage = @targetCPUUtilizationPercentage;
      }

    }
    /// <summary>
    /// current status of a horizontal pod autoscaler
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerStatus
    {
      /// <summary>
        /// current average CPU utilization over all pods, represented as a percentage of requested
        /// CPU, e.g. 70 means that an average pod is using now 70% of its requested CPU.
        /// </summary>
      public readonly int CurrentCPUUtilizationPercentage;

      /// <summary>
        /// current number of replicas of pods managed by this autoscaler.
        /// </summary>
      public readonly int CurrentReplicas;

      /// <summary>
        /// desired number of replicas of pods managed by this autoscaler.
        /// </summary>
      public readonly int DesiredReplicas;

      /// <summary>
        /// last time the HorizontalPodAutoscaler scaled the number of pods; used by the autoscaler
        /// to control how often the number of pods is changed.
        /// </summary>
      public readonly string LastScaleTime;

      /// <summary>
        /// most recent generation observed by this autoscaler.
        /// </summary>
      public readonly int ObservedGeneration;

      [OutputConstructor]
      private HorizontalPodAutoscalerStatus(
          int @currentCPUUtilizationPercentage,
          int @currentReplicas,
          int @desiredReplicas,
          string @lastScaleTime,
          int @observedGeneration)
      {
          this.CurrentCPUUtilizationPercentage = @currentCPUUtilizationPercentage;
          this.CurrentReplicas = @currentReplicas;
          this.DesiredReplicas = @desiredReplicas;
          this.LastScaleTime = @lastScaleTime;
          this.ObservedGeneration = @observedGeneration;
      }

    }
    /// <summary>
    /// Scale represents a scaling request for a resource.
    /// </summary>
    [OutputType]
    public sealed class Scale
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
      public readonly Autoscaling.V1.ScaleSpec Spec;

      /// <summary>
        /// current status of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// Read-only.
        /// </summary>
      public readonly Autoscaling.V1.ScaleStatus Status;

      [OutputConstructor]
      private Scale(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Autoscaling.V1.ScaleSpec @spec,
          Autoscaling.V1.ScaleStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// ScaleSpec describes the attributes of a scale subresource.
    /// </summary>
    [OutputType]
    public sealed class ScaleSpec
    {
      /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
      public readonly int Replicas;

      [OutputConstructor]
      private ScaleSpec(
          int @replicas)
      {
          this.Replicas = @replicas;
      }

    }
    /// <summary>
    /// ScaleStatus represents the current status of a scale subresource.
    /// </summary>
    [OutputType]
    public sealed class ScaleStatus
    {
      /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// label query over pods that should match the replicas count. This is same as the label
        /// selector but in the string format to avoid introspection by clients. The string will be
        /// in the same format as the query-param syntax. More info about label selectors:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
      public readonly string Selector;

      [OutputConstructor]
      private ScaleStatus(
          int @replicas,
          string @selector)
      {
          this.Replicas = @replicas;
          this.Selector = @selector;
      }

    }
  }

  namespace V2Beta1
  {
    /// <summary>
    /// CrossVersionObjectReference contains enough information to let you identify the referred
    /// resource.
    /// </summary>
    [OutputType]
    public sealed class CrossVersionObjectReference
    {
      /// <summary>
        /// API version of the referent
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind of the referent; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private CrossVersionObjectReference(
          string @apiVersion,
          string @kind,
          string @name)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Name = @name;
      }

    }
    /// <summary>
    /// ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes
    /// object (for example length of queue in cloud messaging service, or QPS from loadbalancer
    /// running outside of cluster). Exactly one "target" type should be set.
    /// </summary>
    [OutputType]
    public sealed class ExternalMetricSource
    {
      /// <summary>
        /// metricName is the name of the metric in question.
        /// </summary>
      public readonly string MetricName;

      /// <summary>
        /// metricSelector is used to identify a specific time series within a given metric.
        /// </summary>
      public readonly Meta.V1.LabelSelector MetricSelector;

      /// <summary>
        /// targetAverageValue is the target per-pod value of global metric (as a quantity).
        /// Mutually exclusive with TargetValue.
        /// </summary>
      public readonly string TargetAverageValue;

      /// <summary>
        /// targetValue is the target value of the metric (as a quantity). Mutually exclusive with
        /// TargetAverageValue.
        /// </summary>
      public readonly string TargetValue;

      [OutputConstructor]
      private ExternalMetricSource(
          string @metricName,
          Meta.V1.LabelSelector @metricSelector,
          string @targetAverageValue,
          string @targetValue)
      {
          this.MetricName = @metricName;
          this.MetricSelector = @metricSelector;
          this.TargetAverageValue = @targetAverageValue;
          this.TargetValue = @targetValue;
      }

    }
    /// <summary>
    /// ExternalMetricStatus indicates the current value of a global metric not associated with any
    /// Kubernetes object.
    /// </summary>
    [OutputType]
    public sealed class ExternalMetricStatus
    {
      /// <summary>
        /// currentAverageValue is the current value of metric averaged over autoscaled pods.
        /// </summary>
      public readonly string CurrentAverageValue;

      /// <summary>
        /// currentValue is the current value of the metric (as a quantity)
        /// </summary>
      public readonly string CurrentValue;

      /// <summary>
        /// metricName is the name of a metric used for autoscaling in metric system.
        /// </summary>
      public readonly string MetricName;

      /// <summary>
        /// metricSelector is used to identify a specific time series within a given metric.
        /// </summary>
      public readonly Meta.V1.LabelSelector MetricSelector;

      [OutputConstructor]
      private ExternalMetricStatus(
          string @currentAverageValue,
          string @currentValue,
          string @metricName,
          Meta.V1.LabelSelector @metricSelector)
      {
          this.CurrentAverageValue = @currentAverageValue;
          this.CurrentValue = @currentValue;
          this.MetricName = @metricName;
          this.MetricSelector = @metricSelector;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which
    /// automatically manages the replica count of any resource implementing the scale subresource
    /// based on the metrics specified.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscaler
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// metadata is the standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// spec is the specification for the behaviour of the autoscaler. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
      public readonly Autoscaling.V2Beta1.HorizontalPodAutoscalerSpec Spec;

      /// <summary>
        /// status is the current information about the autoscaler.
        /// </summary>
      public readonly Autoscaling.V2Beta1.HorizontalPodAutoscalerStatus Status;

      [OutputConstructor]
      private HorizontalPodAutoscaler(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Autoscaling.V2Beta1.HorizontalPodAutoscalerSpec @spec,
          Autoscaling.V2Beta1.HorizontalPodAutoscalerStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a
    /// certain point.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerCondition
    {
      /// <summary>
        /// lastTransitionTime is the last time the condition transitioned from one status to
        /// another
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// message is a human-readable explanation containing details about the transition
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// reason is the reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// status is the status of the condition (True, False, Unknown)
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// type describes the current condition
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private HorizontalPodAutoscalerCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of horizontal pod autoscaler objects.
        /// </summary>
      public readonly ImmutableArray<Autoscaling.V2Beta1.HorizontalPodAutoscaler> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// metadata is the standard list metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private HorizontalPodAutoscalerList(
          string @apiVersion,
          ImmutableArray<Autoscaling.V2Beta1.HorizontalPodAutoscaler> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscalerSpec describes the desired functionality of the
    /// HorizontalPodAutoscaler.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerSpec
    {
      /// <summary>
        /// maxReplicas is the upper limit for the number of replicas to which the autoscaler can
        /// scale up. It cannot be less that minReplicas.
        /// </summary>
      public readonly int MaxReplicas;

      /// <summary>
        /// metrics contains the specifications for which to use to calculate the desired replica
        /// count (the maximum replica count across all metrics will be used).  The desired replica
        /// count is calculated multiplying the ratio between the target value and the current value
        /// by the current number of pods.  Ergo, metrics used must decrease as the pod count is
        /// increased, and vice-versa.  See the individual metric source types for more information
        /// about how each type of metric must respond.
        /// </summary>
      public readonly ImmutableArray<Autoscaling.V2Beta1.MetricSpec> Metrics;

      /// <summary>
        /// minReplicas is the lower limit for the number of replicas to which the autoscaler can
        /// scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature
        /// gate HPAScaleToZero is enabled and at least one Object or External metric is configured.
        /// Scaling is active as long as at least one metric value is available.
        /// </summary>
      public readonly int MinReplicas;

      /// <summary>
        /// scaleTargetRef points to the target resource to scale, and is used to the pods for which
        /// metrics should be collected, as well as to actually change the replica count.
        /// </summary>
      public readonly Autoscaling.V2Beta1.CrossVersionObjectReference ScaleTargetRef;

      [OutputConstructor]
      private HorizontalPodAutoscalerSpec(
          int @maxReplicas,
          ImmutableArray<Autoscaling.V2Beta1.MetricSpec> @metrics,
          int @minReplicas,
          Autoscaling.V2Beta1.CrossVersionObjectReference @scaleTargetRef)
      {
          this.MaxReplicas = @maxReplicas;
          this.Metrics = @metrics;
          this.MinReplicas = @minReplicas;
          this.ScaleTargetRef = @scaleTargetRef;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerStatus
    {
      /// <summary>
        /// conditions is the set of conditions required for this autoscaler to scale its target,
        /// and indicates whether or not those conditions are met.
        /// </summary>
      public readonly ImmutableArray<Autoscaling.V2Beta1.HorizontalPodAutoscalerCondition> Conditions;

      /// <summary>
        /// currentMetrics is the last read state of the metrics used by this autoscaler.
        /// </summary>
      public readonly ImmutableArray<Autoscaling.V2Beta1.MetricStatus> CurrentMetrics;

      /// <summary>
        /// currentReplicas is current number of replicas of pods managed by this autoscaler, as
        /// last seen by the autoscaler.
        /// </summary>
      public readonly int CurrentReplicas;

      /// <summary>
        /// desiredReplicas is the desired number of replicas of pods managed by this autoscaler, as
        /// last calculated by the autoscaler.
        /// </summary>
      public readonly int DesiredReplicas;

      /// <summary>
        /// lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods,
        /// used by the autoscaler to control how often the number of pods is changed.
        /// </summary>
      public readonly string LastScaleTime;

      /// <summary>
        /// observedGeneration is the most recent generation observed by this autoscaler.
        /// </summary>
      public readonly int ObservedGeneration;

      [OutputConstructor]
      private HorizontalPodAutoscalerStatus(
          ImmutableArray<Autoscaling.V2Beta1.HorizontalPodAutoscalerCondition> @conditions,
          ImmutableArray<Autoscaling.V2Beta1.MetricStatus> @currentMetrics,
          int @currentReplicas,
          int @desiredReplicas,
          string @lastScaleTime,
          int @observedGeneration)
      {
          this.Conditions = @conditions;
          this.CurrentMetrics = @currentMetrics;
          this.CurrentReplicas = @currentReplicas;
          this.DesiredReplicas = @desiredReplicas;
          this.LastScaleTime = @lastScaleTime;
          this.ObservedGeneration = @observedGeneration;
      }

    }
    /// <summary>
    /// MetricSpec specifies how to scale based on a single metric (only `type` and one other
    /// matching field should be set at once).
    /// </summary>
    [OutputType]
    public sealed class MetricSpec
    {
      /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
      public readonly Autoscaling.V2Beta1.ExternalMetricSource External;

      /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
      public readonly Autoscaling.V2Beta1.ObjectMetricSource Object;

      /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
      public readonly Autoscaling.V2Beta1.PodsMetricSource Pods;

      /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
      public readonly Autoscaling.V2Beta1.ResourceMetricSource Resource;

      /// <summary>
        /// type is the type of metric source.  It should be one of "Object", "Pods" or "Resource",
        /// each mapping to a matching field in the object.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private MetricSpec(
          Autoscaling.V2Beta1.ExternalMetricSource @external,
          Autoscaling.V2Beta1.ObjectMetricSource @object,
          Autoscaling.V2Beta1.PodsMetricSource @pods,
          Autoscaling.V2Beta1.ResourceMetricSource @resource,
          string @type)
      {
          this.External = @external;
          this.Object = @object;
          this.Pods = @pods;
          this.Resource = @resource;
          this.Type = @type;
      }

    }
    /// <summary>
    /// MetricStatus describes the last-read state of a single metric.
    /// </summary>
    [OutputType]
    public sealed class MetricStatus
    {
      /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
      public readonly Autoscaling.V2Beta1.ExternalMetricStatus External;

      /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
      public readonly Autoscaling.V2Beta1.ObjectMetricStatus Object;

      /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
      public readonly Autoscaling.V2Beta1.PodsMetricStatus Pods;

      /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
      public readonly Autoscaling.V2Beta1.ResourceMetricStatus Resource;

      /// <summary>
        /// type is the type of metric source.  It will be one of "Object", "Pods" or "Resource",
        /// each corresponds to a matching field in the object.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private MetricStatus(
          Autoscaling.V2Beta1.ExternalMetricStatus @external,
          Autoscaling.V2Beta1.ObjectMetricStatus @object,
          Autoscaling.V2Beta1.PodsMetricStatus @pods,
          Autoscaling.V2Beta1.ResourceMetricStatus @resource,
          string @type)
      {
          this.External = @external;
          this.Object = @object;
          this.Pods = @pods;
          this.Resource = @resource;
          this.Type = @type;
      }

    }
    /// <summary>
    /// ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for
    /// example, hits-per-second on an Ingress object).
    /// </summary>
    [OutputType]
    public sealed class ObjectMetricSource
    {
      /// <summary>
        /// averageValue is the target value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
      public readonly string AverageValue;

      /// <summary>
        /// metricName is the name of the metric in question.
        /// </summary>
      public readonly string MetricName;

      /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set, it is passed as an additional parameter to the metrics server for
        /// more specific metrics scoping When unset, just the metricName will be used to gather
        /// metrics.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// target is the described Kubernetes object.
        /// </summary>
      public readonly Autoscaling.V2Beta1.CrossVersionObjectReference Target;

      /// <summary>
        /// targetValue is the target value of the metric (as a quantity).
        /// </summary>
      public readonly string TargetValue;

      [OutputConstructor]
      private ObjectMetricSource(
          string @averageValue,
          string @metricName,
          Meta.V1.LabelSelector @selector,
          Autoscaling.V2Beta1.CrossVersionObjectReference @target,
          string @targetValue)
      {
          this.AverageValue = @averageValue;
          this.MetricName = @metricName;
          this.Selector = @selector;
          this.Target = @target;
          this.TargetValue = @targetValue;
      }

    }
    /// <summary>
    /// ObjectMetricStatus indicates the current value of a metric describing a kubernetes object
    /// (for example, hits-per-second on an Ingress object).
    /// </summary>
    [OutputType]
    public sealed class ObjectMetricStatus
    {
      /// <summary>
        /// averageValue is the current value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
      public readonly string AverageValue;

      /// <summary>
        /// currentValue is the current value of the metric (as a quantity).
        /// </summary>
      public readonly string CurrentValue;

      /// <summary>
        /// metricName is the name of the metric in question.
        /// </summary>
      public readonly string MetricName;

      /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set in the ObjectMetricSource, it is passed as an additional parameter
        /// to the metrics server for more specific metrics scoping. When unset, just the metricName
        /// will be used to gather metrics.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// target is the described Kubernetes object.
        /// </summary>
      public readonly Autoscaling.V2Beta1.CrossVersionObjectReference Target;

      [OutputConstructor]
      private ObjectMetricStatus(
          string @averageValue,
          string @currentValue,
          string @metricName,
          Meta.V1.LabelSelector @selector,
          Autoscaling.V2Beta1.CrossVersionObjectReference @target)
      {
          this.AverageValue = @averageValue;
          this.CurrentValue = @currentValue;
          this.MetricName = @metricName;
          this.Selector = @selector;
          this.Target = @target;
      }

    }
    /// <summary>
    /// PodsMetricSource indicates how to scale on a metric describing each pod in the current scale
    /// target (for example, transactions-processed-per-second). The values will be averaged
    /// together before being compared to the target value.
    /// </summary>
    [OutputType]
    public sealed class PodsMetricSource
    {
      /// <summary>
        /// metricName is the name of the metric in question
        /// </summary>
      public readonly string MetricName;

      /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set, it is passed as an additional parameter to the metrics server for
        /// more specific metrics scoping When unset, just the metricName will be used to gather
        /// metrics.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// targetAverageValue is the target value of the average of the metric across all relevant
        /// pods (as a quantity)
        /// </summary>
      public readonly string TargetAverageValue;

      [OutputConstructor]
      private PodsMetricSource(
          string @metricName,
          Meta.V1.LabelSelector @selector,
          string @targetAverageValue)
      {
          this.MetricName = @metricName;
          this.Selector = @selector;
          this.TargetAverageValue = @targetAverageValue;
      }

    }
    /// <summary>
    /// PodsMetricStatus indicates the current value of a metric describing each pod in the current
    /// scale target (for example, transactions-processed-per-second).
    /// </summary>
    [OutputType]
    public sealed class PodsMetricStatus
    {
      /// <summary>
        /// currentAverageValue is the current value of the average of the metric across all
        /// relevant pods (as a quantity)
        /// </summary>
      public readonly string CurrentAverageValue;

      /// <summary>
        /// metricName is the name of the metric in question
        /// </summary>
      public readonly string MetricName;

      /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set in the PodsMetricSource, it is passed as an additional parameter
        /// to the metrics server for more specific metrics scoping. When unset, just the metricName
        /// will be used to gather metrics.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      [OutputConstructor]
      private PodsMetricStatus(
          string @currentAverageValue,
          string @metricName,
          Meta.V1.LabelSelector @selector)
      {
          this.CurrentAverageValue = @currentAverageValue;
          this.MetricName = @metricName;
          this.Selector = @selector;
      }

    }
    /// <summary>
    /// ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as
    /// specified in requests and limits, describing each pod in the current scale target (e.g. CPU
    /// or memory).  The values will be averaged together before being compared to the target.  Such
    /// metrics are built in to Kubernetes, and have special scaling options on top of those
    /// available to normal per-pod metrics using the "pods" source.  Only one "target" type should
    /// be set.
    /// </summary>
    [OutputType]
    public sealed class ResourceMetricSource
    {
      /// <summary>
        /// name is the name of the resource in question.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// targetAverageUtilization is the target value of the average of the resource metric
        /// across all relevant pods, represented as a percentage of the requested value of the
        /// resource for the pods.
        /// </summary>
      public readonly int TargetAverageUtilization;

      /// <summary>
        /// targetAverageValue is the target value of the average of the resource metric across all
        /// relevant pods, as a raw value (instead of as a percentage of the request), similar to
        /// the "pods" metric source type.
        /// </summary>
      public readonly string TargetAverageValue;

      [OutputConstructor]
      private ResourceMetricSource(
          string @name,
          int @targetAverageUtilization,
          string @targetAverageValue)
      {
          this.Name = @name;
          this.TargetAverageUtilization = @targetAverageUtilization;
          this.TargetAverageValue = @targetAverageValue;
      }

    }
    /// <summary>
    /// ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes,
    /// as specified in requests and limits, describing each pod in the current scale target (e.g.
    /// CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options
    /// on top of those available to normal per-pod metrics using the "pods" source.
    /// </summary>
    [OutputType]
    public sealed class ResourceMetricStatus
    {
      /// <summary>
        /// currentAverageUtilization is the current value of the average of the resource metric
        /// across all relevant pods, represented as a percentage of the requested value of the
        /// resource for the pods.  It will only be present if `targetAverageValue` was set in the
        /// corresponding metric specification.
        /// </summary>
      public readonly int CurrentAverageUtilization;

      /// <summary>
        /// currentAverageValue is the current value of the average of the resource metric across
        /// all relevant pods, as a raw value (instead of as a percentage of the request), similar
        /// to the "pods" metric source type. It will always be set, regardless of the corresponding
        /// metric specification.
        /// </summary>
      public readonly string CurrentAverageValue;

      /// <summary>
        /// name is the name of the resource in question.
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private ResourceMetricStatus(
          int @currentAverageUtilization,
          string @currentAverageValue,
          string @name)
      {
          this.CurrentAverageUtilization = @currentAverageUtilization;
          this.CurrentAverageValue = @currentAverageValue;
          this.Name = @name;
      }

    }
  }

  namespace V2Beta2
  {
    /// <summary>
    /// CrossVersionObjectReference contains enough information to let you identify the referred
    /// resource.
    /// </summary>
    [OutputType]
    public sealed class CrossVersionObjectReference
    {
      /// <summary>
        /// API version of the referent
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind of the referent; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private CrossVersionObjectReference(
          string @apiVersion,
          string @kind,
          string @name)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Name = @name;
      }

    }
    /// <summary>
    /// ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes
    /// object (for example length of queue in cloud messaging service, or QPS from loadbalancer
    /// running outside of cluster).
    /// </summary>
    [OutputType]
    public sealed class ExternalMetricSource
    {
      /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricIdentifier Metric;

      /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricTarget Target;

      [OutputConstructor]
      private ExternalMetricSource(
          Autoscaling.V2Beta2.MetricIdentifier @metric,
          Autoscaling.V2Beta2.MetricTarget @target)
      {
          this.Metric = @metric;
          this.Target = @target;
      }

    }
    /// <summary>
    /// ExternalMetricStatus indicates the current value of a global metric not associated with any
    /// Kubernetes object.
    /// </summary>
    [OutputType]
    public sealed class ExternalMetricStatus
    {
      /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricValueStatus Current;

      /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricIdentifier Metric;

      [OutputConstructor]
      private ExternalMetricStatus(
          Autoscaling.V2Beta2.MetricValueStatus @current,
          Autoscaling.V2Beta2.MetricIdentifier @metric)
      {
          this.Current = @current;
          this.Metric = @metric;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which
    /// automatically manages the replica count of any resource implementing the scale subresource
    /// based on the metrics specified.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscaler
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// metadata is the standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// spec is the specification for the behaviour of the autoscaler. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
      public readonly Autoscaling.V2Beta2.HorizontalPodAutoscalerSpec Spec;

      /// <summary>
        /// status is the current information about the autoscaler.
        /// </summary>
      public readonly Autoscaling.V2Beta2.HorizontalPodAutoscalerStatus Status;

      [OutputConstructor]
      private HorizontalPodAutoscaler(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Autoscaling.V2Beta2.HorizontalPodAutoscalerSpec @spec,
          Autoscaling.V2Beta2.HorizontalPodAutoscalerStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a
    /// certain point.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerCondition
    {
      /// <summary>
        /// lastTransitionTime is the last time the condition transitioned from one status to
        /// another
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// message is a human-readable explanation containing details about the transition
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// reason is the reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// status is the status of the condition (True, False, Unknown)
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// type describes the current condition
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private HorizontalPodAutoscalerCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of horizontal pod autoscaler objects.
        /// </summary>
      public readonly ImmutableArray<Autoscaling.V2Beta2.HorizontalPodAutoscaler> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// metadata is the standard list metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private HorizontalPodAutoscalerList(
          string @apiVersion,
          ImmutableArray<Autoscaling.V2Beta2.HorizontalPodAutoscaler> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscalerSpec describes the desired functionality of the
    /// HorizontalPodAutoscaler.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerSpec
    {
      /// <summary>
        /// maxReplicas is the upper limit for the number of replicas to which the autoscaler can
        /// scale up. It cannot be less that minReplicas.
        /// </summary>
      public readonly int MaxReplicas;

      /// <summary>
        /// metrics contains the specifications for which to use to calculate the desired replica
        /// count (the maximum replica count across all metrics will be used).  The desired replica
        /// count is calculated multiplying the ratio between the target value and the current value
        /// by the current number of pods.  Ergo, metrics used must decrease as the pod count is
        /// increased, and vice-versa.  See the individual metric source types for more information
        /// about how each type of metric must respond. If not set, the default metric will be set
        /// to 80% average CPU utilization.
        /// </summary>
      public readonly ImmutableArray<Autoscaling.V2Beta2.MetricSpec> Metrics;

      /// <summary>
        /// minReplicas is the lower limit for the number of replicas to which the autoscaler can
        /// scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature
        /// gate HPAScaleToZero is enabled and at least one Object or External metric is configured.
        /// Scaling is active as long as at least one metric value is available.
        /// </summary>
      public readonly int MinReplicas;

      /// <summary>
        /// scaleTargetRef points to the target resource to scale, and is used to the pods for which
        /// metrics should be collected, as well as to actually change the replica count.
        /// </summary>
      public readonly Autoscaling.V2Beta2.CrossVersionObjectReference ScaleTargetRef;

      [OutputConstructor]
      private HorizontalPodAutoscalerSpec(
          int @maxReplicas,
          ImmutableArray<Autoscaling.V2Beta2.MetricSpec> @metrics,
          int @minReplicas,
          Autoscaling.V2Beta2.CrossVersionObjectReference @scaleTargetRef)
      {
          this.MaxReplicas = @maxReplicas;
          this.Metrics = @metrics;
          this.MinReplicas = @minReplicas;
          this.ScaleTargetRef = @scaleTargetRef;
      }

    }
    /// <summary>
    /// HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.
    /// </summary>
    [OutputType]
    public sealed class HorizontalPodAutoscalerStatus
    {
      /// <summary>
        /// conditions is the set of conditions required for this autoscaler to scale its target,
        /// and indicates whether or not those conditions are met.
        /// </summary>
      public readonly ImmutableArray<Autoscaling.V2Beta2.HorizontalPodAutoscalerCondition> Conditions;

      /// <summary>
        /// currentMetrics is the last read state of the metrics used by this autoscaler.
        /// </summary>
      public readonly ImmutableArray<Autoscaling.V2Beta2.MetricStatus> CurrentMetrics;

      /// <summary>
        /// currentReplicas is current number of replicas of pods managed by this autoscaler, as
        /// last seen by the autoscaler.
        /// </summary>
      public readonly int CurrentReplicas;

      /// <summary>
        /// desiredReplicas is the desired number of replicas of pods managed by this autoscaler, as
        /// last calculated by the autoscaler.
        /// </summary>
      public readonly int DesiredReplicas;

      /// <summary>
        /// lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods,
        /// used by the autoscaler to control how often the number of pods is changed.
        /// </summary>
      public readonly string LastScaleTime;

      /// <summary>
        /// observedGeneration is the most recent generation observed by this autoscaler.
        /// </summary>
      public readonly int ObservedGeneration;

      [OutputConstructor]
      private HorizontalPodAutoscalerStatus(
          ImmutableArray<Autoscaling.V2Beta2.HorizontalPodAutoscalerCondition> @conditions,
          ImmutableArray<Autoscaling.V2Beta2.MetricStatus> @currentMetrics,
          int @currentReplicas,
          int @desiredReplicas,
          string @lastScaleTime,
          int @observedGeneration)
      {
          this.Conditions = @conditions;
          this.CurrentMetrics = @currentMetrics;
          this.CurrentReplicas = @currentReplicas;
          this.DesiredReplicas = @desiredReplicas;
          this.LastScaleTime = @lastScaleTime;
          this.ObservedGeneration = @observedGeneration;
      }

    }
    /// <summary>
    /// MetricIdentifier defines the name and optionally selector for a metric
    /// </summary>
    [OutputType]
    public sealed class MetricIdentifier
    {
      /// <summary>
        /// name is the name of the given metric
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// selector is the string-encoded form of a standard kubernetes label selector for the
        /// given metric When set, it is passed as an additional parameter to the metrics server for
        /// more specific metrics scoping. When unset, just the metricName will be used to gather
        /// metrics.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      [OutputConstructor]
      private MetricIdentifier(
          string @name,
          Meta.V1.LabelSelector @selector)
      {
          this.Name = @name;
          this.Selector = @selector;
      }

    }
    /// <summary>
    /// MetricSpec specifies how to scale based on a single metric (only `type` and one other
    /// matching field should be set at once).
    /// </summary>
    [OutputType]
    public sealed class MetricSpec
    {
      /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
      public readonly Autoscaling.V2Beta2.ExternalMetricSource External;

      /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
      public readonly Autoscaling.V2Beta2.ObjectMetricSource Object;

      /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
      public readonly Autoscaling.V2Beta2.PodsMetricSource Pods;

      /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
      public readonly Autoscaling.V2Beta2.ResourceMetricSource Resource;

      /// <summary>
        /// type is the type of metric source.  It should be one of "Object", "Pods" or "Resource",
        /// each mapping to a matching field in the object.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private MetricSpec(
          Autoscaling.V2Beta2.ExternalMetricSource @external,
          Autoscaling.V2Beta2.ObjectMetricSource @object,
          Autoscaling.V2Beta2.PodsMetricSource @pods,
          Autoscaling.V2Beta2.ResourceMetricSource @resource,
          string @type)
      {
          this.External = @external;
          this.Object = @object;
          this.Pods = @pods;
          this.Resource = @resource;
          this.Type = @type;
      }

    }
    /// <summary>
    /// MetricStatus describes the last-read state of a single metric.
    /// </summary>
    [OutputType]
    public sealed class MetricStatus
    {
      /// <summary>
        /// external refers to a global metric that is not associated with any Kubernetes object. It
        /// allows autoscaling based on information coming from components running outside of
        /// cluster (for example length of queue in cloud messaging service, or QPS from
        /// loadbalancer running outside of cluster).
        /// </summary>
      public readonly Autoscaling.V2Beta2.ExternalMetricStatus External;

      /// <summary>
        /// object refers to a metric describing a single kubernetes object (for example,
        /// hits-per-second on an Ingress object).
        /// </summary>
      public readonly Autoscaling.V2Beta2.ObjectMetricStatus Object;

      /// <summary>
        /// pods refers to a metric describing each pod in the current scale target (for example,
        /// transactions-processed-per-second).  The values will be averaged together before being
        /// compared to the target value.
        /// </summary>
      public readonly Autoscaling.V2Beta2.PodsMetricStatus Pods;

      /// <summary>
        /// resource refers to a resource metric (such as those specified in requests and limits)
        /// known to Kubernetes describing each pod in the current scale target (e.g. CPU or
        /// memory). Such metrics are built in to Kubernetes, and have special scaling options on
        /// top of those available to normal per-pod metrics using the "pods" source.
        /// </summary>
      public readonly Autoscaling.V2Beta2.ResourceMetricStatus Resource;

      /// <summary>
        /// type is the type of metric source.  It will be one of "Object", "Pods" or "Resource",
        /// each corresponds to a matching field in the object.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private MetricStatus(
          Autoscaling.V2Beta2.ExternalMetricStatus @external,
          Autoscaling.V2Beta2.ObjectMetricStatus @object,
          Autoscaling.V2Beta2.PodsMetricStatus @pods,
          Autoscaling.V2Beta2.ResourceMetricStatus @resource,
          string @type)
      {
          this.External = @external;
          this.Object = @object;
          this.Pods = @pods;
          this.Resource = @resource;
          this.Type = @type;
      }

    }
    /// <summary>
    /// MetricTarget defines the target value, average value, or average utilization of a specific
    /// metric
    /// </summary>
    [OutputType]
    public sealed class MetricTarget
    {
      /// <summary>
        /// averageUtilization is the target value of the average of the resource metric across all
        /// relevant pods, represented as a percentage of the requested value of the resource for
        /// the pods. Currently only valid for Resource metric source type
        /// </summary>
      public readonly int AverageUtilization;

      /// <summary>
        /// averageValue is the target value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
      public readonly string AverageValue;

      /// <summary>
        /// type represents whether the metric type is Utilization, Value, or AverageValue
        /// </summary>
      public readonly string Type;

      /// <summary>
        /// value is the target value of the metric (as a quantity).
        /// </summary>
      public readonly string Value;

      [OutputConstructor]
      private MetricTarget(
          int @averageUtilization,
          string @averageValue,
          string @type,
          string @value)
      {
          this.AverageUtilization = @averageUtilization;
          this.AverageValue = @averageValue;
          this.Type = @type;
          this.Value = @value;
      }

    }
    /// <summary>
    /// MetricValueStatus holds the current value for a metric
    /// </summary>
    [OutputType]
    public sealed class MetricValueStatus
    {
      /// <summary>
        /// currentAverageUtilization is the current value of the average of the resource metric
        /// across all relevant pods, represented as a percentage of the requested value of the
        /// resource for the pods.
        /// </summary>
      public readonly int AverageUtilization;

      /// <summary>
        /// averageValue is the current value of the average of the metric across all relevant pods
        /// (as a quantity)
        /// </summary>
      public readonly string AverageValue;

      /// <summary>
        /// value is the current value of the metric (as a quantity).
        /// </summary>
      public readonly string Value;

      [OutputConstructor]
      private MetricValueStatus(
          int @averageUtilization,
          string @averageValue,
          string @value)
      {
          this.AverageUtilization = @averageUtilization;
          this.AverageValue = @averageValue;
          this.Value = @value;
      }

    }
    /// <summary>
    /// ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for
    /// example, hits-per-second on an Ingress object).
    /// </summary>
    [OutputType]
    public sealed class ObjectMetricSource
    {
      
      public readonly Autoscaling.V2Beta2.CrossVersionObjectReference DescribedObject;

      /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricIdentifier Metric;

      /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricTarget Target;

      [OutputConstructor]
      private ObjectMetricSource(
          Autoscaling.V2Beta2.CrossVersionObjectReference @describedObject,
          Autoscaling.V2Beta2.MetricIdentifier @metric,
          Autoscaling.V2Beta2.MetricTarget @target)
      {
          this.DescribedObject = @describedObject;
          this.Metric = @metric;
          this.Target = @target;
      }

    }
    /// <summary>
    /// ObjectMetricStatus indicates the current value of a metric describing a kubernetes object
    /// (for example, hits-per-second on an Ingress object).
    /// </summary>
    [OutputType]
    public sealed class ObjectMetricStatus
    {
      /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricValueStatus Current;

      
      public readonly Autoscaling.V2Beta2.CrossVersionObjectReference DescribedObject;

      /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricIdentifier Metric;

      [OutputConstructor]
      private ObjectMetricStatus(
          Autoscaling.V2Beta2.MetricValueStatus @current,
          Autoscaling.V2Beta2.CrossVersionObjectReference @describedObject,
          Autoscaling.V2Beta2.MetricIdentifier @metric)
      {
          this.Current = @current;
          this.DescribedObject = @describedObject;
          this.Metric = @metric;
      }

    }
    /// <summary>
    /// PodsMetricSource indicates how to scale on a metric describing each pod in the current scale
    /// target (for example, transactions-processed-per-second). The values will be averaged
    /// together before being compared to the target value.
    /// </summary>
    [OutputType]
    public sealed class PodsMetricSource
    {
      /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricIdentifier Metric;

      /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricTarget Target;

      [OutputConstructor]
      private PodsMetricSource(
          Autoscaling.V2Beta2.MetricIdentifier @metric,
          Autoscaling.V2Beta2.MetricTarget @target)
      {
          this.Metric = @metric;
          this.Target = @target;
      }

    }
    /// <summary>
    /// PodsMetricStatus indicates the current value of a metric describing each pod in the current
    /// scale target (for example, transactions-processed-per-second).
    /// </summary>
    [OutputType]
    public sealed class PodsMetricStatus
    {
      /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricValueStatus Current;

      /// <summary>
        /// metric identifies the target metric by name and selector
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricIdentifier Metric;

      [OutputConstructor]
      private PodsMetricStatus(
          Autoscaling.V2Beta2.MetricValueStatus @current,
          Autoscaling.V2Beta2.MetricIdentifier @metric)
      {
          this.Current = @current;
          this.Metric = @metric;
      }

    }
    /// <summary>
    /// ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as
    /// specified in requests and limits, describing each pod in the current scale target (e.g. CPU
    /// or memory).  The values will be averaged together before being compared to the target.  Such
    /// metrics are built in to Kubernetes, and have special scaling options on top of those
    /// available to normal per-pod metrics using the "pods" source.  Only one "target" type should
    /// be set.
    /// </summary>
    [OutputType]
    public sealed class ResourceMetricSource
    {
      /// <summary>
        /// name is the name of the resource in question.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// target specifies the target value for the given metric
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricTarget Target;

      [OutputConstructor]
      private ResourceMetricSource(
          string @name,
          Autoscaling.V2Beta2.MetricTarget @target)
      {
          this.Name = @name;
          this.Target = @target;
      }

    }
    /// <summary>
    /// ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes,
    /// as specified in requests and limits, describing each pod in the current scale target (e.g.
    /// CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options
    /// on top of those available to normal per-pod metrics using the "pods" source.
    /// </summary>
    [OutputType]
    public sealed class ResourceMetricStatus
    {
      /// <summary>
        /// current contains the current value for the given metric
        /// </summary>
      public readonly Autoscaling.V2Beta2.MetricValueStatus Current;

      /// <summary>
        /// Name is the name of the resource in question.
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private ResourceMetricStatus(
          Autoscaling.V2Beta2.MetricValueStatus @current,
          string @name)
      {
          this.Current = @current;
          this.Name = @name;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Batch
{
  namespace V1
  {
    /// <summary>
    /// Job represents the configuration of a single job.
    /// </summary>
    [OutputType]
    public sealed class Job
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of a job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Batch.V1.JobSpec Spec;

      /// <summary>
        /// Current status of a job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Batch.V1.JobStatus Status;

      [OutputConstructor]
      private Job(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Batch.V1.JobSpec @spec,
          Batch.V1.JobStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// JobCondition describes current state of a job.
    /// </summary>
    [OutputType]
    public sealed class JobCondition
    {
      /// <summary>
        /// Last time the condition was checked.
        /// </summary>
      public readonly string LastProbeTime;

      /// <summary>
        /// Last time the condition transit from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// Human readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// (brief) reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of job condition, Complete or Failed.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private JobCondition(
          string @lastProbeTime,
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastProbeTime = @lastProbeTime;
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// JobList is a collection of jobs.
    /// </summary>
    [OutputType]
    public sealed class JobList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of Jobs.
        /// </summary>
      public readonly ImmutableArray<Batch.V1.Job> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private JobList(
          string @apiVersion,
          ImmutableArray<Batch.V1.Job> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// JobSpec describes how the job execution will look like.
    /// </summary>
    [OutputType]
    public sealed class JobSpec
    {
      /// <summary>
        /// Specifies the duration in seconds relative to the startTime that the job may be active
        /// before the system tries to terminate it; value must be positive integer
        /// </summary>
      public readonly int ActiveDeadlineSeconds;

      /// <summary>
        /// Specifies the number of retries before marking this job failed. Defaults to 6
        /// </summary>
      public readonly int BackoffLimit;

      /// <summary>
        /// Specifies the desired number of successfully finished pods the job should be run with.
        /// Setting to nil means that the success of any pod signals the success of all pods, and
        /// allows parallelism to have any positive value.  Setting to 1 means that parallelism is
        /// limited to 1 and the success of that pod signals the success of the job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
      public readonly int Completions;

      /// <summary>
        /// manualSelector controls generation of pod labels and pod selectors. Leave
        /// `manualSelector` unset unless you are certain what you are doing. When false or unset,
        /// the system pick labels unique to this job and appends those labels to the pod template.
        /// When true, the user is responsible for picking unique labels and specifying the
        /// selector.  Failure to pick a unique label may cause this and other jobs to not function
        /// correctly.  However, You may see `manualSelector=true` in jobs that were created with
        /// the old `extensions/v1beta1` API. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
        /// </summary>
      public readonly bool ManualSelector;

      /// <summary>
        /// Specifies the maximum desired number of pods the job should run at any given time. The
        /// actual number of pods running in steady state will be less than this number when
        /// ((.spec.completions - .status.successful) &amp;lt; .spec.parallelism), i.e. when the
        /// work left to do is less than max parallelism. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
      public readonly int Parallelism;

      /// <summary>
        /// A label query over pods that should match the pod count. Normally, the system sets this
        /// field for you. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// Describes the pod that will be created when executing a job. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      /// <summary>
        /// ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either
        /// Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job
        /// finishes, it is eligible to be automatically deleted. When the Job is being deleted, its
        /// lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job
        /// won't be automatically deleted. If this field is set to zero, the Job becomes eligible
        /// to be deleted immediately after it finishes. This field is alpha-level and is only
        /// honored by servers that enable the TTLAfterFinished feature.
        /// </summary>
      public readonly int TtlSecondsAfterFinished;

      [OutputConstructor]
      private JobSpec(
          int @activeDeadlineSeconds,
          int @backoffLimit,
          int @completions,
          bool @manualSelector,
          int @parallelism,
          Meta.V1.LabelSelector @selector,
          Core.V1.PodTemplateSpec @template,
          int @ttlSecondsAfterFinished)
      {
          this.ActiveDeadlineSeconds = @activeDeadlineSeconds;
          this.BackoffLimit = @backoffLimit;
          this.Completions = @completions;
          this.ManualSelector = @manualSelector;
          this.Parallelism = @parallelism;
          this.Selector = @selector;
          this.Template = @template;
          this.TtlSecondsAfterFinished = @ttlSecondsAfterFinished;
      }

    }
    /// <summary>
    /// JobStatus represents the current state of a Job.
    /// </summary>
    [OutputType]
    public sealed class JobStatus
    {
      /// <summary>
        /// The number of actively running pods.
        /// </summary>
      public readonly int Active;

      /// <summary>
        /// Represents time when the job was completed. It is not guaranteed to be set in
        /// happens-before order across separate operations. It is represented in RFC3339 form and
        /// is in UTC.
        /// </summary>
      public readonly string CompletionTime;

      /// <summary>
        /// The latest available observations of an object's current state. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        /// </summary>
      public readonly ImmutableArray<Batch.V1.JobCondition> Conditions;

      /// <summary>
        /// The number of pods which reached phase Failed.
        /// </summary>
      public readonly int Failed;

      /// <summary>
        /// Represents time when the job was acknowledged by the job controller. It is not
        /// guaranteed to be set in happens-before order across separate operations. It is
        /// represented in RFC3339 form and is in UTC.
        /// </summary>
      public readonly string StartTime;

      /// <summary>
        /// The number of pods which reached phase Succeeded.
        /// </summary>
      public readonly int Succeeded;

      [OutputConstructor]
      private JobStatus(
          int @active,
          string @completionTime,
          ImmutableArray<Batch.V1.JobCondition> @conditions,
          int @failed,
          string @startTime,
          int @succeeded)
      {
          this.Active = @active;
          this.CompletionTime = @completionTime;
          this.Conditions = @conditions;
          this.Failed = @failed;
          this.StartTime = @startTime;
          this.Succeeded = @succeeded;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// CronJob represents the configuration of a single cron job.
    /// </summary>
    [OutputType]
    public sealed class CronJob
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of a cron job, including the schedule. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Batch.V1Beta1.CronJobSpec Spec;

      /// <summary>
        /// Current status of a cron job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Batch.V1Beta1.CronJobStatus Status;

      [OutputConstructor]
      private CronJob(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Batch.V1Beta1.CronJobSpec @spec,
          Batch.V1Beta1.CronJobStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// CronJobList is a collection of cron jobs.
    /// </summary>
    [OutputType]
    public sealed class CronJobList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of CronJobs.
        /// </summary>
      public readonly ImmutableArray<Batch.V1Beta1.CronJob> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private CronJobList(
          string @apiVersion,
          ImmutableArray<Batch.V1Beta1.CronJob> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// CronJobSpec describes how the job execution will look like and when it will actually run.
    /// </summary>
    [OutputType]
    public sealed class CronJobSpec
    {
      /// <summary>
        /// Specifies how to treat concurrent executions of a Job. Valid values are: - "Allow"
        /// (default): allows CronJobs to run concurrently; - "Forbid": forbids concurrent runs,
        /// skipping next run if previous run hasn't finished yet; - "Replace": cancels currently
        /// running job and replaces it with a new one
        /// </summary>
      public readonly string ConcurrencyPolicy;

      /// <summary>
        /// The number of failed finished jobs to retain. This is a pointer to distinguish between
        /// explicit zero and not specified. Defaults to 1.
        /// </summary>
      public readonly int FailedJobsHistoryLimit;

      /// <summary>
        /// Specifies the job that will be created when executing a CronJob.
        /// </summary>
      public readonly Batch.V1Beta1.JobTemplateSpec JobTemplate;

      /// <summary>
        /// The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
        /// </summary>
      public readonly string Schedule;

      /// <summary>
        /// Optional deadline in seconds for starting the job if it misses scheduled time for any
        /// reason.  Missed jobs executions will be counted as failed ones.
        /// </summary>
      public readonly int StartingDeadlineSeconds;

      /// <summary>
        /// The number of successful finished jobs to retain. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 3.
        /// </summary>
      public readonly int SuccessfulJobsHistoryLimit;

      /// <summary>
        /// This flag tells the controller to suspend subsequent executions, it does not apply to
        /// already started executions.  Defaults to false.
        /// </summary>
      public readonly bool Suspend;

      [OutputConstructor]
      private CronJobSpec(
          string @concurrencyPolicy,
          int @failedJobsHistoryLimit,
          Batch.V1Beta1.JobTemplateSpec @jobTemplate,
          string @schedule,
          int @startingDeadlineSeconds,
          int @successfulJobsHistoryLimit,
          bool @suspend)
      {
          this.ConcurrencyPolicy = @concurrencyPolicy;
          this.FailedJobsHistoryLimit = @failedJobsHistoryLimit;
          this.JobTemplate = @jobTemplate;
          this.Schedule = @schedule;
          this.StartingDeadlineSeconds = @startingDeadlineSeconds;
          this.SuccessfulJobsHistoryLimit = @successfulJobsHistoryLimit;
          this.Suspend = @suspend;
      }

    }
    /// <summary>
    /// CronJobStatus represents the current state of a cron job.
    /// </summary>
    [OutputType]
    public sealed class CronJobStatus
    {
      /// <summary>
        /// A list of pointers to currently running jobs.
        /// </summary>
      public readonly ImmutableArray<Core.V1.ObjectReference> Active;

      /// <summary>
        /// Information when was the last time the job was successfully scheduled.
        /// </summary>
      public readonly string LastScheduleTime;

      [OutputConstructor]
      private CronJobStatus(
          ImmutableArray<Core.V1.ObjectReference> @active,
          string @lastScheduleTime)
      {
          this.Active = @active;
          this.LastScheduleTime = @lastScheduleTime;
      }

    }
    /// <summary>
    /// JobTemplateSpec describes the data a Job should have when created from a template
    /// </summary>
    [OutputType]
    public sealed class JobTemplateSpec
    {
      /// <summary>
        /// Standard object's metadata of the jobs created from this template. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of the job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Batch.V1.JobSpec Spec;

      [OutputConstructor]
      private JobTemplateSpec(
          Meta.V1.ObjectMeta @metadata,
          Batch.V1.JobSpec @spec)
      {
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
  }

  namespace V2Alpha1
  {
    /// <summary>
    /// CronJob represents the configuration of a single cron job.
    /// </summary>
    [OutputType]
    public sealed class CronJob
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of a cron job, including the schedule. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Batch.V2Alpha1.CronJobSpec Spec;

      /// <summary>
        /// Current status of a cron job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Batch.V2Alpha1.CronJobStatus Status;

      [OutputConstructor]
      private CronJob(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Batch.V2Alpha1.CronJobSpec @spec,
          Batch.V2Alpha1.CronJobStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// CronJobList is a collection of cron jobs.
    /// </summary>
    [OutputType]
    public sealed class CronJobList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of CronJobs.
        /// </summary>
      public readonly ImmutableArray<Batch.V2Alpha1.CronJob> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private CronJobList(
          string @apiVersion,
          ImmutableArray<Batch.V2Alpha1.CronJob> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// CronJobSpec describes how the job execution will look like and when it will actually run.
    /// </summary>
    [OutputType]
    public sealed class CronJobSpec
    {
      /// <summary>
        /// Specifies how to treat concurrent executions of a Job. Valid values are: - "Allow"
        /// (default): allows CronJobs to run concurrently; - "Forbid": forbids concurrent runs,
        /// skipping next run if previous run hasn't finished yet; - "Replace": cancels currently
        /// running job and replaces it with a new one
        /// </summary>
      public readonly string ConcurrencyPolicy;

      /// <summary>
        /// The number of failed finished jobs to retain. This is a pointer to distinguish between
        /// explicit zero and not specified.
        /// </summary>
      public readonly int FailedJobsHistoryLimit;

      /// <summary>
        /// Specifies the job that will be created when executing a CronJob.
        /// </summary>
      public readonly Batch.V2Alpha1.JobTemplateSpec JobTemplate;

      /// <summary>
        /// The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
        /// </summary>
      public readonly string Schedule;

      /// <summary>
        /// Optional deadline in seconds for starting the job if it misses scheduled time for any
        /// reason.  Missed jobs executions will be counted as failed ones.
        /// </summary>
      public readonly int StartingDeadlineSeconds;

      /// <summary>
        /// The number of successful finished jobs to retain. This is a pointer to distinguish
        /// between explicit zero and not specified.
        /// </summary>
      public readonly int SuccessfulJobsHistoryLimit;

      /// <summary>
        /// This flag tells the controller to suspend subsequent executions, it does not apply to
        /// already started executions.  Defaults to false.
        /// </summary>
      public readonly bool Suspend;

      [OutputConstructor]
      private CronJobSpec(
          string @concurrencyPolicy,
          int @failedJobsHistoryLimit,
          Batch.V2Alpha1.JobTemplateSpec @jobTemplate,
          string @schedule,
          int @startingDeadlineSeconds,
          int @successfulJobsHistoryLimit,
          bool @suspend)
      {
          this.ConcurrencyPolicy = @concurrencyPolicy;
          this.FailedJobsHistoryLimit = @failedJobsHistoryLimit;
          this.JobTemplate = @jobTemplate;
          this.Schedule = @schedule;
          this.StartingDeadlineSeconds = @startingDeadlineSeconds;
          this.SuccessfulJobsHistoryLimit = @successfulJobsHistoryLimit;
          this.Suspend = @suspend;
      }

    }
    /// <summary>
    /// CronJobStatus represents the current state of a cron job.
    /// </summary>
    [OutputType]
    public sealed class CronJobStatus
    {
      /// <summary>
        /// A list of pointers to currently running jobs.
        /// </summary>
      public readonly ImmutableArray<Core.V1.ObjectReference> Active;

      /// <summary>
        /// Information when was the last time the job was successfully scheduled.
        /// </summary>
      public readonly string LastScheduleTime;

      [OutputConstructor]
      private CronJobStatus(
          ImmutableArray<Core.V1.ObjectReference> @active,
          string @lastScheduleTime)
      {
          this.Active = @active;
          this.LastScheduleTime = @lastScheduleTime;
      }

    }
    /// <summary>
    /// JobTemplateSpec describes the data a Job should have when created from a template
    /// </summary>
    [OutputType]
    public sealed class JobTemplateSpec
    {
      /// <summary>
        /// Standard object's metadata of the jobs created from this template. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of the job. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Batch.V1.JobSpec Spec;

      [OutputConstructor]
      private JobTemplateSpec(
          Meta.V1.ObjectMeta @metadata,
          Batch.V1.JobSpec @spec)
      {
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Certificates
{
  namespace V1Beta1
  {
    /// <summary>
    /// Describes a certificate signing request
    /// </summary>
    [OutputType]
    public sealed class CertificateSigningRequest
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// The certificate request itself and any additional information.
        /// </summary>
      public readonly Certificates.V1Beta1.CertificateSigningRequestSpec Spec;

      /// <summary>
        /// Derived information about the request.
        /// </summary>
      public readonly Certificates.V1Beta1.CertificateSigningRequestStatus Status;

      [OutputConstructor]
      private CertificateSigningRequest(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Certificates.V1Beta1.CertificateSigningRequestSpec @spec,
          Certificates.V1Beta1.CertificateSigningRequestStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// 
    /// </summary>
    [OutputType]
    public sealed class CertificateSigningRequestCondition
    {
      /// <summary>
        /// timestamp for the last update to this condition
        /// </summary>
      public readonly string LastUpdateTime;

      /// <summary>
        /// human readable message with details about the request state
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// brief reason for the request state
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// request approval state, currently Approved or Denied.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private CertificateSigningRequestCondition(
          string @lastUpdateTime,
          string @message,
          string @reason,
          string @type)
      {
          this.LastUpdateTime = @lastUpdateTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Type = @type;
      }

    }
    /// <summary>
    /// 
    /// </summary>
    [OutputType]
    public sealed class CertificateSigningRequestList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      
      public readonly ImmutableArray<Certificates.V1Beta1.CertificateSigningRequest> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private CertificateSigningRequestList(
          string @apiVersion,
          ImmutableArray<Certificates.V1Beta1.CertificateSigningRequest> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// This information is immutable after the request is created. Only the Request and Usages
    /// fields can be set on creation, other fields are derived by Kubernetes and cannot be modified
    /// by users.
    /// </summary>
    [OutputType]
    public sealed class CertificateSigningRequestSpec
    {
      /// <summary>
        /// Extra information about the requesting user. See user.Info interface for details.
        /// </summary>
      public readonly ImmutableDictionary<string, ImmutableArray<string>> Extra;

      /// <summary>
        /// Group information about the requesting user. See user.Info interface for details.
        /// </summary>
      public readonly ImmutableArray<string> Groups;

      /// <summary>
        /// Base64-encoded PKCS#10 CSR data
        /// </summary>
      public readonly string Request;

      /// <summary>
        /// UID information about the requesting user. See user.Info interface for details.
        /// </summary>
      public readonly string Uid;

      /// <summary>
        /// allowedUsages specifies a set of usage contexts the key will be valid for. See:
        /// https://tools.ietf.org/html/rfc5280#section-4.2.1.3
        ///      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
        /// </summary>
      public readonly ImmutableArray<string> Usages;

      /// <summary>
        /// Information about the requesting user. See user.Info interface for details.
        /// </summary>
      public readonly string Username;

      [OutputConstructor]
      private CertificateSigningRequestSpec(
          ImmutableDictionary<string, ImmutableArray<string>> @extra,
          ImmutableArray<string> @groups,
          string @request,
          string @uid,
          ImmutableArray<string> @usages,
          string @username)
      {
          this.Extra = @extra;
          this.Groups = @groups;
          this.Request = @request;
          this.Uid = @uid;
          this.Usages = @usages;
          this.Username = @username;
      }

    }
    /// <summary>
    /// 
    /// </summary>
    [OutputType]
    public sealed class CertificateSigningRequestStatus
    {
      /// <summary>
        /// If request was approved, the controller will place the issued certificate here.
        /// </summary>
      public readonly string Certificate;

      /// <summary>
        /// Conditions applied to the request, such as approval or denial.
        /// </summary>
      public readonly ImmutableArray<Certificates.V1Beta1.CertificateSigningRequestCondition> Conditions;

      [OutputConstructor]
      private CertificateSigningRequestStatus(
          string @certificate,
          ImmutableArray<Certificates.V1Beta1.CertificateSigningRequestCondition> @conditions)
      {
          this.Certificate = @certificate;
          this.Conditions = @conditions;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Coordination
{
  namespace V1
  {
    /// <summary>
    /// Lease defines a lease concept.
    /// </summary>
    [OutputType]
    public sealed class Lease
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the Lease. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Coordination.V1.LeaseSpec Spec;

      [OutputConstructor]
      private Lease(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Coordination.V1.LeaseSpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// LeaseList is a list of Lease objects.
    /// </summary>
    [OutputType]
    public sealed class LeaseList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Coordination.V1.Lease> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private LeaseList(
          string @apiVersion,
          ImmutableArray<Coordination.V1.Lease> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// LeaseSpec is a specification of a Lease.
    /// </summary>
    [OutputType]
    public sealed class LeaseSpec
    {
      /// <summary>
        /// acquireTime is a time when the current lease was acquired.
        /// </summary>
      public readonly string AcquireTime;

      /// <summary>
        /// holderIdentity contains the identity of the holder of a current lease.
        /// </summary>
      public readonly string HolderIdentity;

      /// <summary>
        /// leaseDurationSeconds is a duration that candidates for a lease need to wait to force
        /// acquire it. This is measure against time of last observed RenewTime.
        /// </summary>
      public readonly int LeaseDurationSeconds;

      /// <summary>
        /// leaseTransitions is the number of transitions of a lease between holders.
        /// </summary>
      public readonly int LeaseTransitions;

      /// <summary>
        /// renewTime is a time when the current holder of a lease has last updated the lease.
        /// </summary>
      public readonly string RenewTime;

      [OutputConstructor]
      private LeaseSpec(
          string @acquireTime,
          string @holderIdentity,
          int @leaseDurationSeconds,
          int @leaseTransitions,
          string @renewTime)
      {
          this.AcquireTime = @acquireTime;
          this.HolderIdentity = @holderIdentity;
          this.LeaseDurationSeconds = @leaseDurationSeconds;
          this.LeaseTransitions = @leaseTransitions;
          this.RenewTime = @renewTime;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// Lease defines a lease concept.
    /// </summary>
    [OutputType]
    public sealed class Lease
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the Lease. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Coordination.V1Beta1.LeaseSpec Spec;

      [OutputConstructor]
      private Lease(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Coordination.V1Beta1.LeaseSpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// LeaseList is a list of Lease objects.
    /// </summary>
    [OutputType]
    public sealed class LeaseList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Coordination.V1Beta1.Lease> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private LeaseList(
          string @apiVersion,
          ImmutableArray<Coordination.V1Beta1.Lease> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// LeaseSpec is a specification of a Lease.
    /// </summary>
    [OutputType]
    public sealed class LeaseSpec
    {
      /// <summary>
        /// acquireTime is a time when the current lease was acquired.
        /// </summary>
      public readonly string AcquireTime;

      /// <summary>
        /// holderIdentity contains the identity of the holder of a current lease.
        /// </summary>
      public readonly string HolderIdentity;

      /// <summary>
        /// leaseDurationSeconds is a duration that candidates for a lease need to wait to force
        /// acquire it. This is measure against time of last observed RenewTime.
        /// </summary>
      public readonly int LeaseDurationSeconds;

      /// <summary>
        /// leaseTransitions is the number of transitions of a lease between holders.
        /// </summary>
      public readonly int LeaseTransitions;

      /// <summary>
        /// renewTime is a time when the current holder of a lease has last updated the lease.
        /// </summary>
      public readonly string RenewTime;

      [OutputConstructor]
      private LeaseSpec(
          string @acquireTime,
          string @holderIdentity,
          int @leaseDurationSeconds,
          int @leaseTransitions,
          string @renewTime)
      {
          this.AcquireTime = @acquireTime;
          this.HolderIdentity = @holderIdentity;
          this.LeaseDurationSeconds = @leaseDurationSeconds;
          this.LeaseTransitions = @leaseTransitions;
          this.RenewTime = @renewTime;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Core
{
  namespace V1
  {
    /// <summary>
    /// Represents a Persistent Disk resource in AWS.
    /// 
    /// An AWS EBS disk must exist before mounting to a container. The disk must also be in the same
    /// AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS
    /// volumes support ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class AWSElasticBlockStoreVolumeSource
    {
      /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// The partition in the volume that you want to mount. If omitted, the default is to mount
        /// by volume name. Examples: For volume /dev/sda1, you specify the partition as "1".
        /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property
        /// empty).
        /// </summary>
      public readonly int Partition;

      /// <summary>
        /// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If
        /// omitted, the default is "false". More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
      public readonly string VolumeID;

      [OutputConstructor]
      private AWSElasticBlockStoreVolumeSource(
          string @fsType,
          int @partition,
          bool @readOnly,
          string @volumeID)
      {
          this.FsType = @fsType;
          this.Partition = @partition;
          this.ReadOnly = @readOnly;
          this.VolumeID = @volumeID;
      }

    }
    /// <summary>
    /// Affinity is a group of affinity scheduling rules.
    /// </summary>
    [OutputType]
    public sealed class Affinity
    {
      /// <summary>
        /// Describes node affinity scheduling rules for the pod.
        /// </summary>
      public readonly Core.V1.NodeAffinity NodeAffinity;

      /// <summary>
        /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
        /// etc. as some other pod(s)).
        /// </summary>
      public readonly Core.V1.PodAffinity PodAffinity;

      /// <summary>
        /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same
        /// node, zone, etc. as some other pod(s)).
        /// </summary>
      public readonly Core.V1.PodAntiAffinity PodAntiAffinity;

      [OutputConstructor]
      private Affinity(
          Core.V1.NodeAffinity @nodeAffinity,
          Core.V1.PodAffinity @podAffinity,
          Core.V1.PodAntiAffinity @podAntiAffinity)
      {
          this.NodeAffinity = @nodeAffinity;
          this.PodAffinity = @podAffinity;
          this.PodAntiAffinity = @podAntiAffinity;
      }

    }
    /// <summary>
    /// AttachedVolume describes a volume attached to a node
    /// </summary>
    [OutputType]
    public sealed class AttachedVolume
    {
      /// <summary>
        /// DevicePath represents the device path where the volume should be available
        /// </summary>
      public readonly string DevicePath;

      /// <summary>
        /// Name of the attached volume
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private AttachedVolume(
          string @devicePath,
          string @name)
      {
          this.DevicePath = @devicePath;
          this.Name = @name;
      }

    }
    /// <summary>
    /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// </summary>
    [OutputType]
    public sealed class AzureDiskVolumeSource
    {
      /// <summary>
        /// Host Caching mode: None, Read Only, Read Write.
        /// </summary>
      public readonly string CachingMode;

      /// <summary>
        /// The Name of the data disk in the blob storage
        /// </summary>
      public readonly string DiskName;

      /// <summary>
        /// The URI the data disk in the blob storage
        /// </summary>
      public readonly string DiskURI;

      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob
        /// disk per storage account  Managed: azure managed data disk (only in managed availability
        /// set). defaults to shared
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      [OutputConstructor]
      private AzureDiskVolumeSource(
          string @cachingMode,
          string @diskName,
          string @diskURI,
          string @fsType,
          string @kind,
          bool @readOnly)
      {
          this.CachingMode = @cachingMode;
          this.DiskName = @diskName;
          this.DiskURI = @diskURI;
          this.FsType = @fsType;
          this.Kind = @kind;
          this.ReadOnly = @readOnly;
      }

    }
    /// <summary>
    /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// </summary>
    [OutputType]
    public sealed class AzureFilePersistentVolumeSource
    {
      /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// the name of secret that contains Azure Storage Account Name and Key
        /// </summary>
      public readonly string SecretName;

      /// <summary>
        /// the namespace of the secret that contains Azure Storage Account Name and Key default is
        /// the same as the Pod
        /// </summary>
      public readonly string SecretNamespace;

      /// <summary>
        /// Share Name
        /// </summary>
      public readonly string ShareName;

      [OutputConstructor]
      private AzureFilePersistentVolumeSource(
          bool @readOnly,
          string @secretName,
          string @secretNamespace,
          string @shareName)
      {
          this.ReadOnly = @readOnly;
          this.SecretName = @secretName;
          this.SecretNamespace = @secretNamespace;
          this.ShareName = @shareName;
      }

    }
    /// <summary>
    /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// </summary>
    [OutputType]
    public sealed class AzureFileVolumeSource
    {
      /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// the name of secret that contains Azure Storage Account Name and Key
        /// </summary>
      public readonly string SecretName;

      /// <summary>
        /// Share Name
        /// </summary>
      public readonly string ShareName;

      [OutputConstructor]
      private AzureFileVolumeSource(
          bool @readOnly,
          string @secretName,
          string @shareName)
      {
          this.ReadOnly = @readOnly;
          this.SecretName = @secretName;
          this.ShareName = @shareName;
      }

    }
    /// <summary>
    /// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
    /// Deprecated in 1.7, please use the bindings subresource of pods instead.
    /// </summary>
    [OutputType]
    public sealed class Binding
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// The target object that you want to bind to the standard object.
        /// </summary>
      public readonly Core.V1.ObjectReference Target;

      [OutputConstructor]
      private Binding(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.ObjectReference @target)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Target = @target;
      }

    }
    /// <summary>
    /// Represents storage that is managed by an external CSI volume driver (Beta feature)
    /// </summary>
    [OutputType]
    public sealed class CSIPersistentVolumeSource
    {
      /// <summary>
        /// ControllerExpandSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI ControllerExpandVolume call.
        /// This is an alpha field and requires enabling ExpandCSIVolumes feature gate. This field
        /// is optional, and may be empty if no secret is required. If the secret object contains
        /// more than one secret, all secrets are passed.
        /// </summary>
      public readonly Core.V1.SecretReference ControllerExpandSecretRef;

      /// <summary>
        /// ControllerPublishSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI ControllerPublishVolume and
        /// ControllerUnpublishVolume calls. This field is optional, and may be empty if no secret
        /// is required. If the secret object contains more than one secret, all secrets are passed.
        /// </summary>
      public readonly Core.V1.SecretReference ControllerPublishSecretRef;

      /// <summary>
        /// Driver is the name of the driver to use for this volume. Required.
        /// </summary>
      public readonly string Driver;

      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs".
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// NodePublishSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI NodePublishVolume and
        /// NodeUnpublishVolume calls. This field is optional, and may be empty if no secret is
        /// required. If the secret object contains more than one secret, all secrets are passed.
        /// </summary>
      public readonly Core.V1.SecretReference NodePublishSecretRef;

      /// <summary>
        /// NodeStageSecretRef is a reference to the secret object containing sensitive information
        /// to pass to the CSI driver to complete the CSI NodeStageVolume and NodeStageVolume and
        /// NodeUnstageVolume calls. This field is optional, and may be empty if no secret is
        /// required. If the secret object contains more than one secret, all secrets are passed.
        /// </summary>
      public readonly Core.V1.SecretReference NodeStageSecretRef;

      /// <summary>
        /// Optional: The value to pass to ControllerPublishVolumeRequest. Defaults to false
        /// (read/write).
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Attributes of the volume to publish.
        /// </summary>
      public readonly ImmutableDictionary<string, string> VolumeAttributes;

      /// <summary>
        /// VolumeHandle is the unique volume name returned by the CSI volume plugin’s
        /// CreateVolume to refer to the volume on all subsequent calls. Required.
        /// </summary>
      public readonly string VolumeHandle;

      [OutputConstructor]
      private CSIPersistentVolumeSource(
          Core.V1.SecretReference @controllerExpandSecretRef,
          Core.V1.SecretReference @controllerPublishSecretRef,
          string @driver,
          string @fsType,
          Core.V1.SecretReference @nodePublishSecretRef,
          Core.V1.SecretReference @nodeStageSecretRef,
          bool @readOnly,
          ImmutableDictionary<string, string> @volumeAttributes,
          string @volumeHandle)
      {
          this.ControllerExpandSecretRef = @controllerExpandSecretRef;
          this.ControllerPublishSecretRef = @controllerPublishSecretRef;
          this.Driver = @driver;
          this.FsType = @fsType;
          this.NodePublishSecretRef = @nodePublishSecretRef;
          this.NodeStageSecretRef = @nodeStageSecretRef;
          this.ReadOnly = @readOnly;
          this.VolumeAttributes = @volumeAttributes;
          this.VolumeHandle = @volumeHandle;
      }

    }
    /// <summary>
    /// Represents a source location of a volume to mount, managed by an external CSI driver
    /// </summary>
    [OutputType]
    public sealed class CSIVolumeSource
    {
      /// <summary>
        /// Driver is the name of the CSI driver that handles this volume. Consult with your admin
        /// for the correct name as registered in the cluster.
        /// </summary>
      public readonly string Driver;

      /// <summary>
        /// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is
        /// passed to the associated CSI driver which will determine the default filesystem to
        /// apply.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// NodePublishSecretRef is a reference to the secret object containing sensitive
        /// information to pass to the CSI driver to complete the CSI NodePublishVolume and
        /// NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is
        /// required. If the secret object contains more than one secret, all secret references are
        /// passed.
        /// </summary>
      public readonly Core.V1.LocalObjectReference NodePublishSecretRef;

      /// <summary>
        /// Specifies a read-only configuration for the volume. Defaults to false (read/write).
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// VolumeAttributes stores driver-specific properties that are passed to the CSI driver.
        /// Consult your driver's documentation for supported values.
        /// </summary>
      public readonly ImmutableDictionary<string, string> VolumeAttributes;

      [OutputConstructor]
      private CSIVolumeSource(
          string @driver,
          string @fsType,
          Core.V1.LocalObjectReference @nodePublishSecretRef,
          bool @readOnly,
          ImmutableDictionary<string, string> @volumeAttributes)
      {
          this.Driver = @driver;
          this.FsType = @fsType;
          this.NodePublishSecretRef = @nodePublishSecretRef;
          this.ReadOnly = @readOnly;
          this.VolumeAttributes = @volumeAttributes;
      }

    }
    /// <summary>
    /// Adds and removes POSIX capabilities from running containers.
    /// </summary>
    [OutputType]
    public sealed class Capabilities
    {
      /// <summary>
        /// Added capabilities
        /// </summary>
      public readonly ImmutableArray<string> Add;

      /// <summary>
        /// Removed capabilities
        /// </summary>
      public readonly ImmutableArray<string> Drop;

      [OutputConstructor]
      private Capabilities(
          ImmutableArray<string> @add,
          ImmutableArray<string> @drop)
      {
          this.Add = @add;
          this.Drop = @drop;
      }

    }
    /// <summary>
    /// Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class CephFSPersistentVolumeSource
    {
      /// <summary>
        /// Required: Monitors is a collection of Ceph monitors More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly ImmutableArray<string> Monitors;

      /// <summary>
        /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly string SecretFile;

      /// <summary>
        /// Optional: SecretRef is reference to the authentication secret for User, default is
        /// empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly Core.V1.SecretReference SecretRef;

      /// <summary>
        /// Optional: User is the rados user name, default is admin More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly string User;

      [OutputConstructor]
      private CephFSPersistentVolumeSource(
          ImmutableArray<string> @monitors,
          string @path,
          bool @readOnly,
          string @secretFile,
          Core.V1.SecretReference @secretRef,
          string @user)
      {
          this.Monitors = @monitors;
          this.Path = @path;
          this.ReadOnly = @readOnly;
          this.SecretFile = @secretFile;
          this.SecretRef = @secretRef;
          this.User = @user;
      }

    }
    /// <summary>
    /// Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class CephFSVolumeSource
    {
      /// <summary>
        /// Required: Monitors is a collection of Ceph monitors More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly ImmutableArray<string> Monitors;

      /// <summary>
        /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly string SecretFile;

      /// <summary>
        /// Optional: SecretRef is reference to the authentication secret for User, default is
        /// empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly Core.V1.LocalObjectReference SecretRef;

      /// <summary>
        /// Optional: User is the rados user name, default is admin More info:
        /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
      public readonly string User;

      [OutputConstructor]
      private CephFSVolumeSource(
          ImmutableArray<string> @monitors,
          string @path,
          bool @readOnly,
          string @secretFile,
          Core.V1.LocalObjectReference @secretRef,
          string @user)
      {
          this.Monitors = @monitors;
          this.Path = @path;
          this.ReadOnly = @readOnly;
          this.SecretFile = @secretFile;
          this.SecretRef = @secretRef;
          this.User = @user;
      }

    }
    /// <summary>
    /// Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting
    /// to a container. The volume must also be in the same region as the kubelet. Cinder volumes
    /// support ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class CinderPersistentVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
        /// unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Optional: points to a secret object containing parameters used to connect to OpenStack.
        /// </summary>
      public readonly Core.V1.SecretReference SecretRef;

      /// <summary>
        /// volume id used to identify the volume in cinder. More info:
        /// https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
      public readonly string VolumeID;

      [OutputConstructor]
      private CinderPersistentVolumeSource(
          string @fsType,
          bool @readOnly,
          Core.V1.SecretReference @secretRef,
          string @volumeID)
      {
          this.FsType = @fsType;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.VolumeID = @volumeID;
      }

    }
    /// <summary>
    /// Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting
    /// to a container. The volume must also be in the same region as the kubelet. Cinder volumes
    /// support ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class CinderVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if
        /// unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Optional: points to a secret object containing parameters used to connect to OpenStack.
        /// </summary>
      public readonly Core.V1.LocalObjectReference SecretRef;

      /// <summary>
        /// volume id used to identify the volume in cinder. More info:
        /// https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
      public readonly string VolumeID;

      [OutputConstructor]
      private CinderVolumeSource(
          string @fsType,
          bool @readOnly,
          Core.V1.LocalObjectReference @secretRef,
          string @volumeID)
      {
          this.FsType = @fsType;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.VolumeID = @volumeID;
      }

    }
    /// <summary>
    /// ClientIPConfig represents the configurations of Client IP based session affinity.
    /// </summary>
    [OutputType]
    public sealed class ClientIPConfig
    {
      /// <summary>
        /// timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value
        /// must be &amp;gt;0 &amp;&amp; &amp;lt;=86400(for 1 day) if ServiceAffinity == "ClientIP".
        /// Default value is 10800(for 3 hours).
        /// </summary>
      public readonly int TimeoutSeconds;

      [OutputConstructor]
      private ClientIPConfig(
          int @timeoutSeconds)
      {
          this.TimeoutSeconds = @timeoutSeconds;
      }

    }
    /// <summary>
    /// Information about the condition of a component.
    /// </summary>
    [OutputType]
    public sealed class ComponentCondition
    {
      /// <summary>
        /// Condition error code for a component. For example, a health check error code.
        /// </summary>
      public readonly string Error;

      /// <summary>
        /// Message about the condition for a component. For example, information about a health
        /// check.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Status of the condition for a component. Valid values for "Healthy": "True", "False", or
        /// "Unknown".
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of condition for a component. Valid value: "Healthy"
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private ComponentCondition(
          string @error,
          string @message,
          string @status,
          string @type)
      {
          this.Error = @error;
          this.Message = @message;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
    /// </summary>
    [OutputType]
    public sealed class ComponentStatus
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of component conditions observed
        /// </summary>
      public readonly ImmutableArray<Core.V1.ComponentCondition> Conditions;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      [OutputConstructor]
      private ComponentStatus(
          string @apiVersion,
          ImmutableArray<Core.V1.ComponentCondition> @conditions,
          string @kind,
          Meta.V1.ObjectMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Conditions = @conditions;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// Status of all the conditions for the component as a list of ComponentStatus objects.
    /// </summary>
    [OutputType]
    public sealed class ComponentStatusList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of ComponentStatus objects.
        /// </summary>
      public readonly ImmutableArray<Core.V1.ComponentStatus> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ComponentStatusList(
          string @apiVersion,
          ImmutableArray<Core.V1.ComponentStatus> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ConfigMap holds configuration data for pods to consume.
    /// </summary>
    [OutputType]
    public sealed class ConfigMap
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// BinaryData contains the binary data. Each key must consist of alphanumeric characters,
        /// '-', '_' or '.'. BinaryData can contain byte sequences that are not in the UTF-8 range.
        /// The keys stored in BinaryData must not overlap with the ones in the Data field, this is
        /// enforced during validation process. Using this field will require 1.10+ apiserver and
        /// kubelet.
        /// </summary>
      public readonly ImmutableDictionary<string, string> BinaryData;

      /// <summary>
        /// Data contains the configuration data. Each key must consist of alphanumeric characters,
        /// '-', '_' or '.'. Values with non-UTF-8 byte sequences must use the BinaryData field. The
        /// keys stored in Data must not overlap with the keys in the BinaryData field, this is
        /// enforced during validation process.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Data;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      [OutputConstructor]
      private ConfigMap(
          string @apiVersion,
          ImmutableDictionary<string, string> @binaryData,
          ImmutableDictionary<string, string> @data,
          string @kind,
          Meta.V1.ObjectMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.BinaryData = @binaryData;
          this.Data = @data;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.
    /// 
    /// The contents of the target ConfigMap's Data field will represent the key-value pairs as
    /// environment variables.
    /// </summary>
    [OutputType]
    public sealed class ConfigMapEnvSource
    {
      /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Specify whether the ConfigMap must be defined
        /// </summary>
      public readonly bool Optional;

      [OutputConstructor]
      private ConfigMapEnvSource(
          string @name,
          bool @optional)
      {
          this.Name = @name;
          this.Optional = @optional;
      }

    }
    /// <summary>
    /// Selects a key from a ConfigMap.
    /// </summary>
    [OutputType]
    public sealed class ConfigMapKeySelector
    {
      /// <summary>
        /// The key to select.
        /// </summary>
      public readonly string Key;

      /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Specify whether the ConfigMap or its key must be defined
        /// </summary>
      public readonly bool Optional;

      [OutputConstructor]
      private ConfigMapKeySelector(
          string @key,
          string @name,
          bool @optional)
      {
          this.Key = @key;
          this.Name = @name;
          this.Optional = @optional;
      }

    }
    /// <summary>
    /// ConfigMapList is a resource containing a list of ConfigMap objects.
    /// </summary>
    [OutputType]
    public sealed class ConfigMapList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of ConfigMaps.
        /// </summary>
      public readonly ImmutableArray<Core.V1.ConfigMap> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ConfigMapList(
          string @apiVersion,
          ImmutableArray<Core.V1.ConfigMap> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config
    /// source for the Node.
    /// </summary>
    [OutputType]
    public sealed class ConfigMapNodeConfigSource
    {
      /// <summary>
        /// KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the
        /// KubeletConfiguration structure This field is required in all cases.
        /// </summary>
      public readonly string KubeletConfigKey;

      /// <summary>
        /// Name is the metadata.name of the referenced ConfigMap. This field is required in all
        /// cases.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace is the metadata.namespace of the referenced ConfigMap. This field is required
        /// in all cases.
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap. This field
        /// is forbidden in Node.Spec, and required in Node.Status.
        /// </summary>
      public readonly string ResourceVersion;

      /// <summary>
        /// UID is the metadata.UID of the referenced ConfigMap. This field is forbidden in
        /// Node.Spec, and required in Node.Status.
        /// </summary>
      public readonly string Uid;

      [OutputConstructor]
      private ConfigMapNodeConfigSource(
          string @kubeletConfigKey,
          string @name,
          string @namespace,
          string @resourceVersion,
          string @uid)
      {
          this.KubeletConfigKey = @kubeletConfigKey;
          this.Name = @name;
          this.Namespace = @namespace;
          this.ResourceVersion = @resourceVersion;
          this.Uid = @uid;
      }

    }
    /// <summary>
    /// Adapts a ConfigMap into a projected volume.
    /// 
    /// The contents of the target ConfigMap's Data field will be presented in a projected volume as
    /// files using the keys in the Data field as the file names, unless the items element is
    /// populated with specific mappings of keys to paths. Note that this is identical to a
    /// configmap volume source without the default mode.
    /// </summary>
    [OutputType]
    public sealed class ConfigMapProjection
    {
      /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will
        /// be projected into the volume as a file whose name is the key and content is the value.
        /// If specified, the listed keys will be projected into the specified paths, and unlisted
        /// keys will not be present. If a key is specified which is not present in the ConfigMap,
        /// the volume setup will error unless it is marked optional. Paths must be relative and may
        /// not contain the '..' path or start with '..'.
        /// </summary>
      public readonly ImmutableArray<Core.V1.KeyToPath> Items;

      /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Specify whether the ConfigMap or its keys must be defined
        /// </summary>
      public readonly bool Optional;

      [OutputConstructor]
      private ConfigMapProjection(
          ImmutableArray<Core.V1.KeyToPath> @items,
          string @name,
          bool @optional)
      {
          this.Items = @items;
          this.Name = @name;
          this.Optional = @optional;
      }

    }
    /// <summary>
    /// Adapts a ConfigMap into a volume.
    /// 
    /// The contents of the target ConfigMap's Data field will be presented in a volume as files
    /// using the keys in the Data field as the file names, unless the items element is populated
    /// with specific mappings of keys to paths. ConfigMap volumes support ownership management and
    /// SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class ConfigMapVolumeSource
    {
      /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a value between 0 and
        /// 0777. Defaults to 0644. Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file mode, like fsGroup,
        /// and the result can be other mode bits set.
        /// </summary>
      public readonly int DefaultMode;

      /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will
        /// be projected into the volume as a file whose name is the key and content is the value.
        /// If specified, the listed keys will be projected into the specified paths, and unlisted
        /// keys will not be present. If a key is specified which is not present in the ConfigMap,
        /// the volume setup will error unless it is marked optional. Paths must be relative and may
        /// not contain the '..' path or start with '..'.
        /// </summary>
      public readonly ImmutableArray<Core.V1.KeyToPath> Items;

      /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Specify whether the ConfigMap or its keys must be defined
        /// </summary>
      public readonly bool Optional;

      [OutputConstructor]
      private ConfigMapVolumeSource(
          int @defaultMode,
          ImmutableArray<Core.V1.KeyToPath> @items,
          string @name,
          bool @optional)
      {
          this.DefaultMode = @defaultMode;
          this.Items = @items;
          this.Name = @name;
          this.Optional = @optional;
      }

    }
    /// <summary>
    /// A single application container that you want to run within a pod.
    /// </summary>
    [OutputType]
    public sealed class Container
    {
      /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a
        /// variable cannot be resolved, the reference in the input string will be unchanged. The
        /// $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references
        /// will never be expanded, regardless of whether the variable exists or not. Cannot be
        /// updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
      public readonly ImmutableArray<string> Args;

      /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if
        /// this is not provided. Variable references $(VAR_NAME) are expanded using the container's
        /// environment. If a variable cannot be resolved, the reference in the input string will be
        /// unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
        /// Escaped references will never be expanded, regardless of whether the variable exists or
        /// not. Cannot be updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
      public readonly ImmutableArray<string> Command;

      /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EnvVar> Env;

      /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined
        /// within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event
        /// when the container is starting. When a key exists in multiple sources, the value
        /// associated with the last source will take precedence. Values defined by an Env with a
        /// duplicate key will take precedence. Cannot be updated.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EnvFromSource> EnvFrom;

      /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This
        /// field is optional to allow higher level config management to default or override
        /// container images in workload controllers like Deployments and StatefulSets.
        /// </summary>
      public readonly string Image;

      /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag
        /// is specified, or IfNotPresent otherwise. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
      public readonly string ImagePullPolicy;

      /// <summary>
        /// Actions that the management system should take in response to container lifecycle
        /// events. Cannot be updated.
        /// </summary>
      public readonly Core.V1.Lifecycle Lifecycle;

      /// <summary>
        /// Periodic probe of container liveness. Container will be restarted if the probe fails.
        /// Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
      public readonly Core.V1.Probe LivenessProbe;

      /// <summary>
        /// Name of the container specified as a DNS_LABEL. Each container in a pod must have a
        /// unique name (DNS_LABEL). Cannot be updated.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// List of ports to expose from the container. Exposing a port here gives the system
        /// additional information about the network connections a container uses, but is primarily
        /// informational. Not specifying a port here DOES NOT prevent that port from being exposed.
        /// Any port which is listening on the default "0.0.0.0" address inside a container will be
        /// accessible from the network. Cannot be updated.
        /// </summary>
      public readonly ImmutableArray<Core.V1.ContainerPort> Ports;

      /// <summary>
        /// Periodic probe of container service readiness. Container will be removed from service
        /// endpoints if the probe fails. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
      public readonly Core.V1.Probe ReadinessProbe;

      /// <summary>
        /// Compute Resources required by this container. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
      public readonly Core.V1.ResourceRequirements Resources;

      /// <summary>
        /// Security options the pod should run with. More info:
        /// https://kubernetes.io/docs/concepts/policy/security-context/ More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
      public readonly Core.V1.SecurityContext SecurityContext;

      /// <summary>
        /// StartupProbe indicates that the Pod has successfully initialized. If specified, no other
        /// probes are executed until this completes successfully. If this probe fails, the Pod will
        /// be restarted, just as if the livenessProbe failed. This can be used to provide different
        /// probe parameters at the beginning of a Pod's lifecycle, when it might take a long time
        /// to load data or warm a cache, than during steady-state operation. This cannot be
        /// updated. This is an alpha feature enabled by the StartupProbe feature flag. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
      public readonly Core.V1.Probe StartupProbe;

      /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If
        /// this is not set, reads from stdin in the container will always result in EOF. Default is
        /// false.
        /// </summary>
      public readonly bool Stdin;

      /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by
        /// a single attach. When stdin is true the stdin stream will remain open across multiple
        /// attach sessions. If stdinOnce is set to true, stdin is opened on container start, is
        /// empty until the first client attaches to stdin, and then remains open and accepts data
        /// until the client disconnects, at which time stdin is closed and remains closed until the
        /// container is restarted. If this flag is false, a container processes that reads from
        /// stdin will never receive an EOF. Default is false
        /// </summary>
      public readonly bool StdinOnce;

      /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be
        /// written is mounted into the container's filesystem. Message written is intended to be
        /// brief final status, such as an assertion failure message. Will be truncated by the node
        /// if greater than 4096 bytes. The total message length across all containers will be
        /// limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
      public readonly string TerminationMessagePath;

      /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of
        /// terminationMessagePath to populate the container status message on both success and
        /// failure. FallbackToLogsOnError will use the last chunk of container log output if the
        /// termination message file is empty and the container exited with an error. The log output
        /// is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be
        /// updated.
        /// </summary>
      public readonly string TerminationMessagePolicy;

      /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be
        /// true. Default is false.
        /// </summary>
      public readonly bool Tty;

      /// <summary>
        /// volumeDevices is the list of block devices to be used by the container. This is a beta
        /// feature.
        /// </summary>
      public readonly ImmutableArray<Core.V1.VolumeDevice> VolumeDevices;

      /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
      public readonly ImmutableArray<Core.V1.VolumeMount> VolumeMounts;

      /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be
        /// used, which might be configured in the container image. Cannot be updated.
        /// </summary>
      public readonly string WorkingDir;

      [OutputConstructor]
      private Container(
          ImmutableArray<string> @args,
          ImmutableArray<string> @command,
          ImmutableArray<Core.V1.EnvVar> @env,
          ImmutableArray<Core.V1.EnvFromSource> @envFrom,
          string @image,
          string @imagePullPolicy,
          Core.V1.Lifecycle @lifecycle,
          Core.V1.Probe @livenessProbe,
          string @name,
          ImmutableArray<Core.V1.ContainerPort> @ports,
          Core.V1.Probe @readinessProbe,
          Core.V1.ResourceRequirements @resources,
          Core.V1.SecurityContext @securityContext,
          Core.V1.Probe @startupProbe,
          bool @stdin,
          bool @stdinOnce,
          string @terminationMessagePath,
          string @terminationMessagePolicy,
          bool @tty,
          ImmutableArray<Core.V1.VolumeDevice> @volumeDevices,
          ImmutableArray<Core.V1.VolumeMount> @volumeMounts,
          string @workingDir)
      {
          this.Args = @args;
          this.Command = @command;
          this.Env = @env;
          this.EnvFrom = @envFrom;
          this.Image = @image;
          this.ImagePullPolicy = @imagePullPolicy;
          this.Lifecycle = @lifecycle;
          this.LivenessProbe = @livenessProbe;
          this.Name = @name;
          this.Ports = @ports;
          this.ReadinessProbe = @readinessProbe;
          this.Resources = @resources;
          this.SecurityContext = @securityContext;
          this.StartupProbe = @startupProbe;
          this.Stdin = @stdin;
          this.StdinOnce = @stdinOnce;
          this.TerminationMessagePath = @terminationMessagePath;
          this.TerminationMessagePolicy = @terminationMessagePolicy;
          this.Tty = @tty;
          this.VolumeDevices = @volumeDevices;
          this.VolumeMounts = @volumeMounts;
          this.WorkingDir = @workingDir;
      }

    }
    /// <summary>
    /// Describe a container image
    /// </summary>
    [OutputType]
    public sealed class ContainerImage
    {
      /// <summary>
        /// Names by which this image is known. e.g. ["k8s.gcr.io/hyperkube:v1.0.7",
        /// "dockerhub.io/google_containers/hyperkube:v1.0.7"]
        /// </summary>
      public readonly ImmutableArray<string> Names;

      /// <summary>
        /// The size of the image in bytes.
        /// </summary>
      public readonly int SizeBytes;

      [OutputConstructor]
      private ContainerImage(
          ImmutableArray<string> @names,
          int @sizeBytes)
      {
          this.Names = @names;
          this.SizeBytes = @sizeBytes;
      }

    }
    /// <summary>
    /// ContainerPort represents a network port in a single container.
    /// </summary>
    [OutputType]
    public sealed class ContainerPort
    {
      /// <summary>
        /// Number of port to expose on the pod's IP address. This must be a valid port number, 0
        /// &amp;lt; x &amp;lt; 65536.
        /// </summary>
      public readonly int ContainerPortValue;

      /// <summary>
        /// What host IP to bind the external port to.
        /// </summary>
      public readonly string HostIP;

      /// <summary>
        /// Number of port to expose on the host. If specified, this must be a valid port number, 0
        /// &amp;lt; x &amp;lt; 65536. If HostNetwork is specified, this must match ContainerPort.
        /// Most containers do not need this.
        /// </summary>
      public readonly int HostPort;

      /// <summary>
        /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port
        /// in a pod must have a unique name. Name for the port that can be referred to by services.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
        /// </summary>
      public readonly string Protocol;

      [OutputConstructor]
      private ContainerPort(
          int @containerPort,
          string @hostIP,
          int @hostPort,
          string @name,
          string @protocol)
      {
          this.ContainerPortValue = @containerPort;
          this.HostIP = @hostIP;
          this.HostPort = @hostPort;
          this.Name = @name;
          this.Protocol = @protocol;
      }

    }
    /// <summary>
    /// ContainerState holds a possible state of container. Only one of its members may be
    /// specified. If none of them is specified, the default one is ContainerStateWaiting.
    /// </summary>
    [OutputType]
    public sealed class ContainerState
    {
      /// <summary>
        /// Details about a running container
        /// </summary>
      public readonly Core.V1.ContainerStateRunning Running;

      /// <summary>
        /// Details about a terminated container
        /// </summary>
      public readonly Core.V1.ContainerStateTerminated Terminated;

      /// <summary>
        /// Details about a waiting container
        /// </summary>
      public readonly Core.V1.ContainerStateWaiting Waiting;

      [OutputConstructor]
      private ContainerState(
          Core.V1.ContainerStateRunning @running,
          Core.V1.ContainerStateTerminated @terminated,
          Core.V1.ContainerStateWaiting @waiting)
      {
          this.Running = @running;
          this.Terminated = @terminated;
          this.Waiting = @waiting;
      }

    }
    /// <summary>
    /// ContainerStateRunning is a running state of a container.
    /// </summary>
    [OutputType]
    public sealed class ContainerStateRunning
    {
      /// <summary>
        /// Time at which the container was last (re-)started
        /// </summary>
      public readonly string StartedAt;

      [OutputConstructor]
      private ContainerStateRunning(
          string @startedAt)
      {
          this.StartedAt = @startedAt;
      }

    }
    /// <summary>
    /// ContainerStateTerminated is a terminated state of a container.
    /// </summary>
    [OutputType]
    public sealed class ContainerStateTerminated
    {
      /// <summary>
        /// Container's ID in the format 'docker://&amp;lt;container_id&amp;gt;'
        /// </summary>
      public readonly string ContainerID;

      /// <summary>
        /// Exit status from the last termination of the container
        /// </summary>
      public readonly int ExitCode;

      /// <summary>
        /// Time at which the container last terminated
        /// </summary>
      public readonly string FinishedAt;

      /// <summary>
        /// Message regarding the last termination of the container
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// (brief) reason from the last termination of the container
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Signal from the last termination of the container
        /// </summary>
      public readonly int Signal;

      /// <summary>
        /// Time at which previous execution of the container started
        /// </summary>
      public readonly string StartedAt;

      [OutputConstructor]
      private ContainerStateTerminated(
          string @containerID,
          int @exitCode,
          string @finishedAt,
          string @message,
          string @reason,
          int @signal,
          string @startedAt)
      {
          this.ContainerID = @containerID;
          this.ExitCode = @exitCode;
          this.FinishedAt = @finishedAt;
          this.Message = @message;
          this.Reason = @reason;
          this.Signal = @signal;
          this.StartedAt = @startedAt;
      }

    }
    /// <summary>
    /// ContainerStateWaiting is a waiting state of a container.
    /// </summary>
    [OutputType]
    public sealed class ContainerStateWaiting
    {
      /// <summary>
        /// Message regarding why the container is not yet running.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// (brief) reason the container is not yet running.
        /// </summary>
      public readonly string Reason;

      [OutputConstructor]
      private ContainerStateWaiting(
          string @message,
          string @reason)
      {
          this.Message = @message;
          this.Reason = @reason;
      }

    }
    /// <summary>
    /// ContainerStatus contains details for the current status of this container.
    /// </summary>
    [OutputType]
    public sealed class ContainerStatus
    {
      /// <summary>
        /// Container's ID in the format 'docker://&amp;lt;container_id&amp;gt;'.
        /// </summary>
      public readonly string ContainerID;

      /// <summary>
        /// The image the container is running. More info:
        /// https://kubernetes.io/docs/concepts/containers/images
        /// </summary>
      public readonly string Image;

      /// <summary>
        /// ImageID of the container's image.
        /// </summary>
      public readonly string ImageID;

      /// <summary>
        /// Details about the container's last termination condition.
        /// </summary>
      public readonly Core.V1.ContainerState LastState;

      /// <summary>
        /// This must be a DNS_LABEL. Each container in a pod must have a unique name. Cannot be
        /// updated.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Specifies whether the container has passed its readiness probe.
        /// </summary>
      public readonly bool Ready;

      /// <summary>
        /// The number of times the container has been restarted, currently based on the number of
        /// dead containers that have not yet been removed. Note that this is calculated from dead
        /// containers. But those containers are subject to garbage collection. This value will get
        /// capped at 5 by GC.
        /// </summary>
      public readonly int RestartCount;

      /// <summary>
        /// Specifies whether the container has passed its startup probe. Initialized as false,
        /// becomes true after startupProbe is considered successful. Resets to false when the
        /// container is restarted, or if kubelet loses state temporarily. Is always true when no
        /// startupProbe is defined.
        /// </summary>
      public readonly bool Started;

      /// <summary>
        /// Details about the container's current condition.
        /// </summary>
      public readonly Core.V1.ContainerState State;

      [OutputConstructor]
      private ContainerStatus(
          string @containerID,
          string @image,
          string @imageID,
          Core.V1.ContainerState @lastState,
          string @name,
          bool @ready,
          int @restartCount,
          bool @started,
          Core.V1.ContainerState @state)
      {
          this.ContainerID = @containerID;
          this.Image = @image;
          this.ImageID = @imageID;
          this.LastState = @lastState;
          this.Name = @name;
          this.Ready = @ready;
          this.RestartCount = @restartCount;
          this.Started = @started;
          this.State = @state;
      }

    }
    /// <summary>
    /// DaemonEndpoint contains information about a single Daemon endpoint.
    /// </summary>
    [OutputType]
    public sealed class DaemonEndpoint
    {
      /// <summary>
        /// Port number of the given endpoint.
        /// </summary>
      public readonly int Port;

      [OutputConstructor]
      private DaemonEndpoint(
          int @Port)
      {
          this.Port = @Port;
      }

    }
    /// <summary>
    /// Represents downward API info for projecting into a projected volume. Note that this is
    /// identical to a downwardAPI volume source without the default mode.
    /// </summary>
    [OutputType]
    public sealed class DownwardAPIProjection
    {
      /// <summary>
        /// Items is a list of DownwardAPIVolume file
        /// </summary>
      public readonly ImmutableArray<Core.V1.DownwardAPIVolumeFile> Items;

      [OutputConstructor]
      private DownwardAPIProjection(
          ImmutableArray<Core.V1.DownwardAPIVolumeFile> @items)
      {
          this.Items = @items;
      }

    }
    /// <summary>
    /// DownwardAPIVolumeFile represents information to create the file containing the pod field
    /// </summary>
    [OutputType]
    public sealed class DownwardAPIVolumeFile
    {
      /// <summary>
        /// Required: Selects a field of the pod: only annotations, labels, name and namespace are
        /// supported.
        /// </summary>
      public readonly Core.V1.ObjectFieldSelector FieldRef;

      /// <summary>
        /// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not
        /// specified, the volume defaultMode will be used. This might be in conflict with other
        /// options that affect the file mode, like fsGroup, and the result can be other mode bits
        /// set.
        /// </summary>
      public readonly int Mode;

      /// <summary>
        /// Required: Path is  the relative path name of the file to be created. Must not be
        /// absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative
        /// path must not start with '..'
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// Selects a resource of the container: only resources limits and requests (limits.cpu,
        /// limits.memory, requests.cpu and requests.memory) are currently supported.
        /// </summary>
      public readonly Core.V1.ResourceFieldSelector ResourceFieldRef;

      [OutputConstructor]
      private DownwardAPIVolumeFile(
          Core.V1.ObjectFieldSelector @fieldRef,
          int @mode,
          string @path,
          Core.V1.ResourceFieldSelector @resourceFieldRef)
      {
          this.FieldRef = @fieldRef;
          this.Mode = @mode;
          this.Path = @path;
          this.ResourceFieldRef = @resourceFieldRef;
      }

    }
    /// <summary>
    /// DownwardAPIVolumeSource represents a volume containing downward API info. Downward API
    /// volumes support ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class DownwardAPIVolumeSource
    {
      /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a value between 0 and
        /// 0777. Defaults to 0644. Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file mode, like fsGroup,
        /// and the result can be other mode bits set.
        /// </summary>
      public readonly int DefaultMode;

      /// <summary>
        /// Items is a list of downward API volume file
        /// </summary>
      public readonly ImmutableArray<Core.V1.DownwardAPIVolumeFile> Items;

      [OutputConstructor]
      private DownwardAPIVolumeSource(
          int @defaultMode,
          ImmutableArray<Core.V1.DownwardAPIVolumeFile> @items)
      {
          this.DefaultMode = @defaultMode;
          this.Items = @items;
      }

    }
    /// <summary>
    /// Represents an empty directory for a pod. Empty directory volumes support ownership
    /// management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class EmptyDirVolumeSource
    {
      /// <summary>
        /// What type of storage medium should back this directory. The default is "" which means to
        /// use the node's default medium. Must be an empty string (default) or Memory. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        /// </summary>
      public readonly string Medium;

      /// <summary>
        /// Total amount of local storage required for this EmptyDir volume. The size limit is also
        /// applicable for memory medium. The maximum usage on memory medium EmptyDir would be the
        /// minimum value between the SizeLimit specified here and the sum of memory limits of all
        /// containers in a pod. The default is nil which means that the limit is undefined. More
        /// info: http://kubernetes.io/docs/user-guide/volumes#emptydir
        /// </summary>
      public readonly string SizeLimit;

      [OutputConstructor]
      private EmptyDirVolumeSource(
          string @medium,
          string @sizeLimit)
      {
          this.Medium = @medium;
          this.SizeLimit = @sizeLimit;
      }

    }
    /// <summary>
    /// EndpointAddress is a tuple that describes single IP address.
    /// </summary>
    [OutputType]
    public sealed class EndpointAddress
    {
      /// <summary>
        /// The Hostname of this endpoint
        /// </summary>
      public readonly string Hostname;

      /// <summary>
        /// The IP of this endpoint. May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
        /// or link-local multicast ((224.0.0.0/24). IPv6 is also accepted but not fully supported
        /// on all platforms. Also, certain kubernetes components, like kube-proxy, are not IPv6
        /// ready.
        /// </summary>
      public readonly string Ip;

      /// <summary>
        /// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a
        /// node.
        /// </summary>
      public readonly string NodeName;

      /// <summary>
        /// Reference to object providing the endpoint.
        /// </summary>
      public readonly Core.V1.ObjectReference TargetRef;

      [OutputConstructor]
      private EndpointAddress(
          string @hostname,
          string @ip,
          string @nodeName,
          Core.V1.ObjectReference @targetRef)
      {
          this.Hostname = @hostname;
          this.Ip = @ip;
          this.NodeName = @nodeName;
          this.TargetRef = @targetRef;
      }

    }
    /// <summary>
    /// EndpointPort is a tuple that describes a single port.
    /// </summary>
    [OutputType]
    public sealed class EndpointPort
    {
      /// <summary>
        /// The name of this port.  This must match the 'name' field in the corresponding
        /// ServicePort. Must be a DNS_LABEL. Optional only if one port is defined.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// The port number of the endpoint.
        /// </summary>
      public readonly int Port;

      /// <summary>
        /// The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
        /// </summary>
      public readonly string Protocol;

      [OutputConstructor]
      private EndpointPort(
          string @name,
          int @port,
          string @protocol)
      {
          this.Name = @name;
          this.Port = @port;
          this.Protocol = @protocol;
      }

    }
    /// <summary>
    /// EndpointSubset is a group of addresses with a common set of ports. The expanded set of
    /// endpoints is the Cartesian product of Addresses x Ports. For example, given:
    ///   {
    ///     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
    ///     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
    ///   }
    /// The resulting set of endpoints can be viewed as:
    ///     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
    ///     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
    /// </summary>
    [OutputType]
    public sealed class EndpointSubset
    {
      /// <summary>
        /// IP addresses which offer the related ports that are marked as ready. These endpoints
        /// should be considered safe for load balancers and clients to utilize.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EndpointAddress> Addresses;

      /// <summary>
        /// IP addresses which offer the related ports but are not currently marked as ready because
        /// they have not yet finished starting, have recently failed a readiness check, or have
        /// recently failed a liveness check.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EndpointAddress> NotReadyAddresses;

      /// <summary>
        /// Port numbers available on the related IP addresses.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EndpointPort> Ports;

      [OutputConstructor]
      private EndpointSubset(
          ImmutableArray<Core.V1.EndpointAddress> @addresses,
          ImmutableArray<Core.V1.EndpointAddress> @notReadyAddresses,
          ImmutableArray<Core.V1.EndpointPort> @ports)
      {
          this.Addresses = @addresses;
          this.NotReadyAddresses = @notReadyAddresses;
          this.Ports = @ports;
      }

    }
    /// <summary>
    /// Endpoints is a collection of endpoints that implement the actual service. Example:
    ///   Name: "mysvc",
    ///   Subsets: [
    ///     {
    ///       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
    ///       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
    ///     },
    ///     {
    ///       Addresses: [{"ip": "10.10.3.3"}],
    ///       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
    ///     },
    ///  ]
    /// </summary>
    [OutputType]
    public sealed class Endpoints
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// The set of all endpoints is the union of all subsets. Addresses are placed into subsets
        /// according to the IPs they share. A single address with multiple ports, some of which are
        /// ready and some of which are not (because they come from different containers) will
        /// result in the address being displayed in different subsets for the different ports. No
        /// address will appear in both Addresses and NotReadyAddresses in the same subset. Sets of
        /// addresses and ports that comprise a service.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EndpointSubset> Subsets;

      [OutputConstructor]
      private Endpoints(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<Core.V1.EndpointSubset> @subsets)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Subsets = @subsets;
      }

    }
    /// <summary>
    /// EndpointsList is a list of endpoints.
    /// </summary>
    [OutputType]
    public sealed class EndpointsList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of endpoints.
        /// </summary>
      public readonly ImmutableArray<Core.V1.Endpoints> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private EndpointsList(
          string @apiVersion,
          ImmutableArray<Core.V1.Endpoints> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// EnvFromSource represents the source of a set of ConfigMaps
    /// </summary>
    [OutputType]
    public sealed class EnvFromSource
    {
      /// <summary>
        /// The ConfigMap to select from
        /// </summary>
      public readonly Core.V1.ConfigMapEnvSource ConfigMapRef;

      /// <summary>
        /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        /// </summary>
      public readonly string Prefix;

      /// <summary>
        /// The Secret to select from
        /// </summary>
      public readonly Core.V1.SecretEnvSource SecretRef;

      [OutputConstructor]
      private EnvFromSource(
          Core.V1.ConfigMapEnvSource @configMapRef,
          string @prefix,
          Core.V1.SecretEnvSource @secretRef)
      {
          this.ConfigMapRef = @configMapRef;
          this.Prefix = @prefix;
          this.SecretRef = @secretRef;
      }

    }
    /// <summary>
    /// EnvVar represents an environment variable present in a Container.
    /// </summary>
    [OutputType]
    public sealed class EnvVar
    {
      /// <summary>
        /// Name of the environment variable. Must be a C_IDENTIFIER.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Variable references $(VAR_NAME) are expanded using the previous defined environment
        /// variables in the container and any service environment variables. If a variable cannot
        /// be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
        /// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be
        /// expanded, regardless of whether the variable exists or not. Defaults to "".
        /// </summary>
      public readonly string Value;

      /// <summary>
        /// Source for the environment variable's value. Cannot be used if value is not empty.
        /// </summary>
      public readonly Core.V1.EnvVarSource ValueFrom;

      [OutputConstructor]
      private EnvVar(
          string @name,
          string @value,
          Core.V1.EnvVarSource @valueFrom)
      {
          this.Name = @name;
          this.Value = @value;
          this.ValueFrom = @valueFrom;
      }

    }
    /// <summary>
    /// EnvVarSource represents a source for the value of an EnvVar.
    /// </summary>
    [OutputType]
    public sealed class EnvVarSource
    {
      /// <summary>
        /// Selects a key of a ConfigMap.
        /// </summary>
      public readonly Core.V1.ConfigMapKeySelector ConfigMapKeyRef;

      /// <summary>
        /// Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels,
        /// metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP,
        /// status.podIP, status.podIPs.
        /// </summary>
      public readonly Core.V1.ObjectFieldSelector FieldRef;

      /// <summary>
        /// Selects a resource of the container: only resources limits and requests (limits.cpu,
        /// limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and
        /// requests.ephemeral-storage) are currently supported.
        /// </summary>
      public readonly Core.V1.ResourceFieldSelector ResourceFieldRef;

      /// <summary>
        /// Selects a key of a secret in the pod's namespace
        /// </summary>
      public readonly Core.V1.SecretKeySelector SecretKeyRef;

      [OutputConstructor]
      private EnvVarSource(
          Core.V1.ConfigMapKeySelector @configMapKeyRef,
          Core.V1.ObjectFieldSelector @fieldRef,
          Core.V1.ResourceFieldSelector @resourceFieldRef,
          Core.V1.SecretKeySelector @secretKeyRef)
      {
          this.ConfigMapKeyRef = @configMapKeyRef;
          this.FieldRef = @fieldRef;
          this.ResourceFieldRef = @resourceFieldRef;
          this.SecretKeyRef = @secretKeyRef;
      }

    }
    /// <summary>
    /// An EphemeralContainer is a container that may be added temporarily to an existing pod for
    /// user-initiated activities such as debugging. Ephemeral containers have no resource or
    /// scheduling guarantees, and they will not be restarted when they exit or when a pod is
    /// removed or restarted. If an ephemeral container causes a pod to exceed its resource
    /// allocation, the pod may be evicted. Ephemeral containers may not be added by directly
    /// updating the pod spec. They must be added via the pod's ephemeralcontainers subresource, and
    /// they will appear in the pod spec once added. This is an alpha feature enabled by the
    /// EphemeralContainers feature flag.
    /// </summary>
    [OutputType]
    public sealed class EphemeralContainer
    {
      /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a
        /// variable cannot be resolved, the reference in the input string will be unchanged. The
        /// $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references
        /// will never be expanded, regardless of whether the variable exists or not. Cannot be
        /// updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
      public readonly ImmutableArray<string> Args;

      /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if
        /// this is not provided. Variable references $(VAR_NAME) are expanded using the container's
        /// environment. If a variable cannot be resolved, the reference in the input string will be
        /// unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
        /// Escaped references will never be expanded, regardless of whether the variable exists or
        /// not. Cannot be updated. More info:
        /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
      public readonly ImmutableArray<string> Command;

      /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EnvVar> Env;

      /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined
        /// within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event
        /// when the container is starting. When a key exists in multiple sources, the value
        /// associated with the last source will take precedence. Values defined by an Env with a
        /// duplicate key will take precedence. Cannot be updated.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EnvFromSource> EnvFrom;

      /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
        /// </summary>
      public readonly string Image;

      /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag
        /// is specified, or IfNotPresent otherwise. Cannot be updated. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
      public readonly string ImagePullPolicy;

      /// <summary>
        /// Lifecycle is not allowed for ephemeral containers.
        /// </summary>
      public readonly Core.V1.Lifecycle Lifecycle;

      /// <summary>
        /// Probes are not allowed for ephemeral containers.
        /// </summary>
      public readonly Core.V1.Probe LivenessProbe;

      /// <summary>
        /// Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among
        /// all containers, init containers and ephemeral containers.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Ports are not allowed for ephemeral containers.
        /// </summary>
      public readonly ImmutableArray<Core.V1.ContainerPort> Ports;

      /// <summary>
        /// Probes are not allowed for ephemeral containers.
        /// </summary>
      public readonly Core.V1.Probe ReadinessProbe;

      /// <summary>
        /// Resources are not allowed for ephemeral containers. Ephemeral containers use spare
        /// resources already allocated to the pod.
        /// </summary>
      public readonly Core.V1.ResourceRequirements Resources;

      /// <summary>
        /// SecurityContext is not allowed for ephemeral containers.
        /// </summary>
      public readonly Core.V1.SecurityContext SecurityContext;

      /// <summary>
        /// Probes are not allowed for ephemeral containers.
        /// </summary>
      public readonly Core.V1.Probe StartupProbe;

      /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If
        /// this is not set, reads from stdin in the container will always result in EOF. Default is
        /// false.
        /// </summary>
      public readonly bool Stdin;

      /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by
        /// a single attach. When stdin is true the stdin stream will remain open across multiple
        /// attach sessions. If stdinOnce is set to true, stdin is opened on container start, is
        /// empty until the first client attaches to stdin, and then remains open and accepts data
        /// until the client disconnects, at which time stdin is closed and remains closed until the
        /// container is restarted. If this flag is false, a container processes that reads from
        /// stdin will never receive an EOF. Default is false
        /// </summary>
      public readonly bool StdinOnce;

      /// <summary>
        /// If set, the name of the container from PodSpec that this ephemeral container targets.
        /// The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
        /// If not set then the ephemeral container is run in whatever namespaces are shared for the
        /// pod. Note that the container runtime must support this feature.
        /// </summary>
      public readonly string TargetContainerName;

      /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be
        /// written is mounted into the container's filesystem. Message written is intended to be
        /// brief final status, such as an assertion failure message. Will be truncated by the node
        /// if greater than 4096 bytes. The total message length across all containers will be
        /// limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
      public readonly string TerminationMessagePath;

      /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of
        /// terminationMessagePath to populate the container status message on both success and
        /// failure. FallbackToLogsOnError will use the last chunk of container log output if the
        /// termination message file is empty and the container exited with an error. The log output
        /// is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be
        /// updated.
        /// </summary>
      public readonly string TerminationMessagePolicy;

      /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be
        /// true. Default is false.
        /// </summary>
      public readonly bool Tty;

      /// <summary>
        /// volumeDevices is the list of block devices to be used by the container. This is a beta
        /// feature.
        /// </summary>
      public readonly ImmutableArray<Core.V1.VolumeDevice> VolumeDevices;

      /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
      public readonly ImmutableArray<Core.V1.VolumeMount> VolumeMounts;

      /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be
        /// used, which might be configured in the container image. Cannot be updated.
        /// </summary>
      public readonly string WorkingDir;

      [OutputConstructor]
      private EphemeralContainer(
          ImmutableArray<string> @args,
          ImmutableArray<string> @command,
          ImmutableArray<Core.V1.EnvVar> @env,
          ImmutableArray<Core.V1.EnvFromSource> @envFrom,
          string @image,
          string @imagePullPolicy,
          Core.V1.Lifecycle @lifecycle,
          Core.V1.Probe @livenessProbe,
          string @name,
          ImmutableArray<Core.V1.ContainerPort> @ports,
          Core.V1.Probe @readinessProbe,
          Core.V1.ResourceRequirements @resources,
          Core.V1.SecurityContext @securityContext,
          Core.V1.Probe @startupProbe,
          bool @stdin,
          bool @stdinOnce,
          string @targetContainerName,
          string @terminationMessagePath,
          string @terminationMessagePolicy,
          bool @tty,
          ImmutableArray<Core.V1.VolumeDevice> @volumeDevices,
          ImmutableArray<Core.V1.VolumeMount> @volumeMounts,
          string @workingDir)
      {
          this.Args = @args;
          this.Command = @command;
          this.Env = @env;
          this.EnvFrom = @envFrom;
          this.Image = @image;
          this.ImagePullPolicy = @imagePullPolicy;
          this.Lifecycle = @lifecycle;
          this.LivenessProbe = @livenessProbe;
          this.Name = @name;
          this.Ports = @ports;
          this.ReadinessProbe = @readinessProbe;
          this.Resources = @resources;
          this.SecurityContext = @securityContext;
          this.StartupProbe = @startupProbe;
          this.Stdin = @stdin;
          this.StdinOnce = @stdinOnce;
          this.TargetContainerName = @targetContainerName;
          this.TerminationMessagePath = @terminationMessagePath;
          this.TerminationMessagePolicy = @terminationMessagePolicy;
          this.Tty = @tty;
          this.VolumeDevices = @volumeDevices;
          this.VolumeMounts = @volumeMounts;
          this.WorkingDir = @workingDir;
      }

    }
    /// <summary>
    /// Event is a report of an event somewhere in the cluster.
    /// </summary>
    [OutputType]
    public sealed class Event
    {
      /// <summary>
        /// What action was taken/failed regarding to the Regarding object.
        /// </summary>
      public readonly string Action;

      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// The number of times this event has occurred.
        /// </summary>
      public readonly int Count;

      /// <summary>
        /// Time when this Event was first observed.
        /// </summary>
      public readonly string EventTime;

      /// <summary>
        /// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
        /// </summary>
      public readonly string FirstTimestamp;

      /// <summary>
        /// The object that this event is about.
        /// </summary>
      public readonly Core.V1.ObjectReference InvolvedObject;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// The time at which the most recent occurrence of this event was recorded.
        /// </summary>
      public readonly string LastTimestamp;

      /// <summary>
        /// A human-readable description of the status of this operation.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// This should be a short, machine understandable string that gives the reason for the
        /// transition into the object's current status.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Optional secondary object for more complex actions.
        /// </summary>
      public readonly Core.V1.ObjectReference Related;

      /// <summary>
        /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
        /// </summary>
      public readonly string ReportingComponent;

      /// <summary>
        /// ID of the controller instance, e.g. `kubelet-xyzf`.
        /// </summary>
      public readonly string ReportingInstance;

      /// <summary>
        /// Data about the Event series this event represents or nil if it's a singleton Event.
        /// </summary>
      public readonly Core.V1.EventSeries Series;

      /// <summary>
        /// The component reporting this event. Should be a short machine understandable string.
        /// </summary>
      public readonly Core.V1.EventSource Source;

      /// <summary>
        /// Type of this event (Normal, Warning), new types could be added in the future
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private Event(
          string @action,
          string @apiVersion,
          int @count,
          string @eventTime,
          string @firstTimestamp,
          Core.V1.ObjectReference @involvedObject,
          string @kind,
          string @lastTimestamp,
          string @message,
          Meta.V1.ObjectMeta @metadata,
          string @reason,
          Core.V1.ObjectReference @related,
          string @reportingComponent,
          string @reportingInstance,
          Core.V1.EventSeries @series,
          Core.V1.EventSource @source,
          string @type)
      {
          this.Action = @action;
          this.ApiVersion = @apiVersion;
          this.Count = @count;
          this.EventTime = @eventTime;
          this.FirstTimestamp = @firstTimestamp;
          this.InvolvedObject = @involvedObject;
          this.Kind = @kind;
          this.LastTimestamp = @lastTimestamp;
          this.Message = @message;
          this.Metadata = @metadata;
          this.Reason = @reason;
          this.Related = @related;
          this.ReportingComponent = @reportingComponent;
          this.ReportingInstance = @reportingInstance;
          this.Series = @series;
          this.Source = @source;
          this.Type = @type;
      }

    }
    /// <summary>
    /// EventList is a list of events.
    /// </summary>
    [OutputType]
    public sealed class EventList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of events
        /// </summary>
      public readonly ImmutableArray<Core.V1.Event> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private EventList(
          string @apiVersion,
          ImmutableArray<Core.V1.Event> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// EventSeries contain information on series of events, i.e. thing that was/is happening
    /// continuously for some time.
    /// </summary>
    [OutputType]
    public sealed class EventSeries
    {
      /// <summary>
        /// Number of occurrences in this series up to the last heartbeat time
        /// </summary>
      public readonly int Count;

      /// <summary>
        /// Time of the last occurrence observed
        /// </summary>
      public readonly string LastObservedTime;

      /// <summary>
        /// State of this Series: Ongoing or Finished Deprecated. Planned removal for 1.18
        /// </summary>
      public readonly string State;

      [OutputConstructor]
      private EventSeries(
          int @count,
          string @lastObservedTime,
          string @state)
      {
          this.Count = @count;
          this.LastObservedTime = @lastObservedTime;
          this.State = @state;
      }

    }
    /// <summary>
    /// EventSource contains information for an event.
    /// </summary>
    [OutputType]
    public sealed class EventSource
    {
      /// <summary>
        /// Component from which the event is generated.
        /// </summary>
      public readonly string Component;

      /// <summary>
        /// Node name on which the event is generated.
        /// </summary>
      public readonly string Host;

      [OutputConstructor]
      private EventSource(
          string @component,
          string @host)
      {
          this.Component = @component;
          this.Host = @host;
      }

    }
    /// <summary>
    /// ExecAction describes a "run in container" action.
    /// </summary>
    [OutputType]
    public sealed class ExecAction
    {
      /// <summary>
        /// Command is the command line to execute inside the container, the working directory for
        /// the command  is root ('/') in the container's filesystem. The command is simply exec'd,
        /// it is not run inside a shell, so traditional shell instructions ('|', etc) won't work.
        /// To use a shell, you need to explicitly call out to that shell. Exit status of 0 is
        /// treated as live/healthy and non-zero is unhealthy.
        /// </summary>
      public readonly ImmutableArray<string> Command;

      [OutputConstructor]
      private ExecAction(
          ImmutableArray<string> @command)
      {
          this.Command = @command;
      }

    }
    /// <summary>
    /// Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write
    /// once. Fibre Channel volumes support ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class FCVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Optional: FC target lun number
        /// </summary>
      public readonly int Lun;

      /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Optional: FC target worldwide names (WWNs)
        /// </summary>
      public readonly ImmutableArray<string> TargetWWNs;

      /// <summary>
        /// Optional: FC volume world wide identifiers (wwids) Either wwids or combination of
        /// targetWWNs and lun must be set, but not both simultaneously.
        /// </summary>
      public readonly ImmutableArray<string> Wwids;

      [OutputConstructor]
      private FCVolumeSource(
          string @fsType,
          int @lun,
          bool @readOnly,
          ImmutableArray<string> @targetWWNs,
          ImmutableArray<string> @wwids)
      {
          this.FsType = @fsType;
          this.Lun = @lun;
          this.ReadOnly = @readOnly;
          this.TargetWWNs = @targetWWNs;
          this.Wwids = @wwids;
      }

    }
    /// <summary>
    /// FlexPersistentVolumeSource represents a generic persistent volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// </summary>
    [OutputType]
    public sealed class FlexPersistentVolumeSource
    {
      /// <summary>
        /// Driver is the name of the driver to use for this volume.
        /// </summary>
      public readonly string Driver;

      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Optional: Extra command options if any.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Options;

      /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Optional: SecretRef is reference to the secret object containing sensitive information
        /// to pass to the plugin scripts. This may be empty if no secret object is specified. If
        /// the secret object contains more than one secret, all secrets are passed to the plugin
        /// scripts.
        /// </summary>
      public readonly Core.V1.SecretReference SecretRef;

      [OutputConstructor]
      private FlexPersistentVolumeSource(
          string @driver,
          string @fsType,
          ImmutableDictionary<string, string> @options,
          bool @readOnly,
          Core.V1.SecretReference @secretRef)
      {
          this.Driver = @driver;
          this.FsType = @fsType;
          this.Options = @options;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
      }

    }
    /// <summary>
    /// FlexVolume represents a generic volume resource that is provisioned/attached using an exec
    /// based plugin.
    /// </summary>
    [OutputType]
    public sealed class FlexVolumeSource
    {
      /// <summary>
        /// Driver is the name of the driver to use for this volume.
        /// </summary>
      public readonly string Driver;

      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Optional: Extra command options if any.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Options;

      /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
        /// in VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Optional: SecretRef is reference to the secret object containing sensitive information
        /// to pass to the plugin scripts. This may be empty if no secret object is specified. If
        /// the secret object contains more than one secret, all secrets are passed to the plugin
        /// scripts.
        /// </summary>
      public readonly Core.V1.LocalObjectReference SecretRef;

      [OutputConstructor]
      private FlexVolumeSource(
          string @driver,
          string @fsType,
          ImmutableDictionary<string, string> @options,
          bool @readOnly,
          Core.V1.LocalObjectReference @secretRef)
      {
          this.Driver = @driver;
          this.FsType = @fsType;
          this.Options = @options;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
      }

    }
    /// <summary>
    /// Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName
    /// and datasetUUID should be set. Flocker volumes do not support ownership management or
    /// SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class FlockerVolumeSource
    {
      /// <summary>
        /// Name of the dataset stored as metadata -&amp;gt; name on the dataset for Flocker should
        /// be considered as deprecated
        /// </summary>
      public readonly string DatasetName;

      /// <summary>
        /// UUID of the dataset. This is unique identifier of a Flocker dataset
        /// </summary>
      public readonly string DatasetUUID;

      [OutputConstructor]
      private FlockerVolumeSource(
          string @datasetName,
          string @datasetUUID)
      {
          this.DatasetName = @datasetName;
          this.DatasetUUID = @datasetUUID;
      }

    }
    /// <summary>
    /// Represents a Persistent Disk resource in Google Compute Engine.
    /// 
    /// A GCE PD must exist before mounting to a container. The disk must also be in the same GCE
    /// project and zone as the kubelet. A GCE PD can only be mounted as read/write once or
    /// read-only many times. GCE PDs support ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class GCEPersistentDiskVolumeSource
    {
      /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// The partition in the volume that you want to mount. If omitted, the default is to mount
        /// by volume name. Examples: For volume /dev/sda1, you specify the partition as "1".
        /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property
        /// empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
      public readonly int Partition;

      /// <summary>
        /// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
      public readonly string PdName;

      /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
        /// info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
      public readonly bool ReadOnly;

      [OutputConstructor]
      private GCEPersistentDiskVolumeSource(
          string @fsType,
          int @partition,
          string @pdName,
          bool @readOnly)
      {
          this.FsType = @fsType;
          this.Partition = @partition;
          this.PdName = @pdName;
          this.ReadOnly = @readOnly;
      }

    }
    /// <summary>
    /// Represents a volume that is populated with the contents of a git repository. Git repo
    /// volumes do not support ownership management. Git repo volumes support SELinux relabeling.
    /// 
    /// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into
    /// the Pod's container.
    /// </summary>
    [OutputType]
    public sealed class GitRepoVolumeSource
    {
      /// <summary>
        /// Target directory name. Must not contain or start with '..'.  If '.' is supplied, the
        /// volume directory will be the git repository.  Otherwise, if specified, the volume will
        /// contain the git repository in the subdirectory with the given name.
        /// </summary>
      public readonly string Directory;

      /// <summary>
        /// Repository URL
        /// </summary>
      public readonly string Repository;

      /// <summary>
        /// Commit hash for the specified revision.
        /// </summary>
      public readonly string Revision;

      [OutputConstructor]
      private GitRepoVolumeSource(
          string @directory,
          string @repository,
          string @revision)
      {
          this.Directory = @directory;
          this.Repository = @repository;
          this.Revision = @revision;
      }

    }
    /// <summary>
    /// Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class GlusterfsPersistentVolumeSource
    {
      /// <summary>
        /// EndpointsName is the endpoint name that details Glusterfs topology. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
      public readonly string Endpoints;

      /// <summary>
        /// EndpointsNamespace is the namespace that contains Glusterfs endpoint. If this field is
        /// empty, the EndpointNamespace defaults to the same namespace as the bound PVC. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
      public readonly string EndpointsNamespace;

      /// <summary>
        /// Path is the Glusterfs volume path. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
        /// Defaults to false. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
      public readonly bool ReadOnly;

      [OutputConstructor]
      private GlusterfsPersistentVolumeSource(
          string @endpoints,
          string @endpointsNamespace,
          string @path,
          bool @readOnly)
      {
          this.Endpoints = @endpoints;
          this.EndpointsNamespace = @endpointsNamespace;
          this.Path = @path;
          this.ReadOnly = @readOnly;
      }

    }
    /// <summary>
    /// Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not
    /// support ownership management or SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class GlusterfsVolumeSource
    {
      /// <summary>
        /// EndpointsName is the endpoint name that details Glusterfs topology. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
      public readonly string Endpoints;

      /// <summary>
        /// Path is the Glusterfs volume path. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
        /// Defaults to false. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
      public readonly bool ReadOnly;

      [OutputConstructor]
      private GlusterfsVolumeSource(
          string @endpoints,
          string @path,
          bool @readOnly)
      {
          this.Endpoints = @endpoints;
          this.Path = @path;
          this.ReadOnly = @readOnly;
      }

    }
    /// <summary>
    /// HTTPGetAction describes an action based on HTTP Get requests.
    /// </summary>
    [OutputType]
    public sealed class HTTPGetAction
    {
      /// <summary>
        /// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in
        /// httpHeaders instead.
        /// </summary>
      public readonly string Host;

      /// <summary>
        /// Custom headers to set in the request. HTTP allows repeated headers.
        /// </summary>
      public readonly ImmutableArray<Core.V1.HTTPHeader> HttpHeaders;

      /// <summary>
        /// Path to access on the HTTP server.
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// Name or number of the port to access on the container. Number must be in the range 1 to
        /// 65535. Name must be an IANA_SVC_NAME.
        /// </summary>
      public readonly Union<int,string> Port;

      /// <summary>
        /// Scheme to use for connecting to the host. Defaults to HTTP.
        /// </summary>
      public readonly string Scheme;

      [OutputConstructor]
      private HTTPGetAction(
          string @host,
          ImmutableArray<Core.V1.HTTPHeader> @httpHeaders,
          string @path,
          Union<int,string> @port,
          string @scheme)
      {
          this.Host = @host;
          this.HttpHeaders = @httpHeaders;
          this.Path = @path;
          this.Port = @port;
          this.Scheme = @scheme;
      }

    }
    /// <summary>
    /// HTTPHeader describes a custom header to be used in HTTP probes
    /// </summary>
    [OutputType]
    public sealed class HTTPHeader
    {
      /// <summary>
        /// The header field name
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// The header field value
        /// </summary>
      public readonly string Value;

      [OutputConstructor]
      private HTTPHeader(
          string @name,
          string @value)
      {
          this.Name = @name;
          this.Value = @value;
      }

    }
    /// <summary>
    /// Handler defines a specific action that should be taken
    /// </summary>
    [OutputType]
    public sealed class Handler
    {
      /// <summary>
        /// One and only one of the following should be specified. Exec specifies the action to
        /// take.
        /// </summary>
      public readonly Core.V1.ExecAction Exec;

      /// <summary>
        /// HTTPGet specifies the http request to perform.
        /// </summary>
      public readonly Core.V1.HTTPGetAction HttpGet;

      /// <summary>
        /// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        /// </summary>
      public readonly Core.V1.TCPSocketAction TcpSocket;

      [OutputConstructor]
      private Handler(
          Core.V1.ExecAction @exec,
          Core.V1.HTTPGetAction @httpGet,
          Core.V1.TCPSocketAction @tcpSocket)
      {
          this.Exec = @exec;
          this.HttpGet = @httpGet;
          this.TcpSocket = @tcpSocket;
      }

    }
    /// <summary>
    /// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in
    /// the pod's hosts file.
    /// </summary>
    [OutputType]
    public sealed class HostAlias
    {
      /// <summary>
        /// Hostnames for the above IP address.
        /// </summary>
      public readonly ImmutableArray<string> Hostnames;

      /// <summary>
        /// IP address of the host file entry.
        /// </summary>
      public readonly string Ip;

      [OutputConstructor]
      private HostAlias(
          ImmutableArray<string> @hostnames,
          string @ip)
      {
          this.Hostnames = @hostnames;
          this.Ip = @ip;
      }

    }
    /// <summary>
    /// Represents a host path mapped into a pod. Host path volumes do not support ownership
    /// management or SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class HostPathVolumeSource
    {
      /// <summary>
        /// Path of the directory on the host. If the path is a symlink, it will follow the link to
        /// the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// Type for HostPath Volume Defaults to "" More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private HostPathVolumeSource(
          string @path,
          string @type)
      {
          this.Path = @path;
          this.Type = @type;
      }

    }
    /// <summary>
    /// ISCSIPersistentVolumeSource represents an ISCSI disk. ISCSI volumes can only be mounted as
    /// read/write once. ISCSI volumes support ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class ISCSIPersistentVolumeSource
    {
      /// <summary>
        /// whether support iSCSI Discovery CHAP authentication
        /// </summary>
      public readonly bool ChapAuthDiscovery;

      /// <summary>
        /// whether support iSCSI Session CHAP authentication
        /// </summary>
      public readonly bool ChapAuthSession;

      /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
        /// simultaneously, new iSCSI interface &amp;lt;target portal&amp;gt;:&amp;lt;volume
        /// name&amp;gt; will be created for the connection.
        /// </summary>
      public readonly string InitiatorName;

      /// <summary>
        /// Target iSCSI Qualified Name.
        /// </summary>
      public readonly string Iqn;

      /// <summary>
        /// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
        /// </summary>
      public readonly string IscsiInterface;

      /// <summary>
        /// iSCSI Target Lun number.
        /// </summary>
      public readonly int Lun;

      /// <summary>
        /// iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port is
        /// other than default (typically TCP ports 860 and 3260).
        /// </summary>
      public readonly ImmutableArray<string> Portals;

      /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// CHAP Secret for iSCSI target and initiator authentication
        /// </summary>
      public readonly Core.V1.SecretReference SecretRef;

      /// <summary>
        /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other
        /// than default (typically TCP ports 860 and 3260).
        /// </summary>
      public readonly string TargetPortal;

      [OutputConstructor]
      private ISCSIPersistentVolumeSource(
          bool @chapAuthDiscovery,
          bool @chapAuthSession,
          string @fsType,
          string @initiatorName,
          string @iqn,
          string @iscsiInterface,
          int @lun,
          ImmutableArray<string> @portals,
          bool @readOnly,
          Core.V1.SecretReference @secretRef,
          string @targetPortal)
      {
          this.ChapAuthDiscovery = @chapAuthDiscovery;
          this.ChapAuthSession = @chapAuthSession;
          this.FsType = @fsType;
          this.InitiatorName = @initiatorName;
          this.Iqn = @iqn;
          this.IscsiInterface = @iscsiInterface;
          this.Lun = @lun;
          this.Portals = @portals;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.TargetPortal = @targetPortal;
      }

    }
    /// <summary>
    /// Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI
    /// volumes support ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class ISCSIVolumeSource
    {
      /// <summary>
        /// whether support iSCSI Discovery CHAP authentication
        /// </summary>
      public readonly bool ChapAuthDiscovery;

      /// <summary>
        /// whether support iSCSI Session CHAP authentication
        /// </summary>
      public readonly bool ChapAuthSession;

      /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
        /// simultaneously, new iSCSI interface &amp;lt;target portal&amp;gt;:&amp;lt;volume
        /// name&amp;gt; will be created for the connection.
        /// </summary>
      public readonly string InitiatorName;

      /// <summary>
        /// Target iSCSI Qualified Name.
        /// </summary>
      public readonly string Iqn;

      /// <summary>
        /// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
        /// </summary>
      public readonly string IscsiInterface;

      /// <summary>
        /// iSCSI Target Lun number.
        /// </summary>
      public readonly int Lun;

      /// <summary>
        /// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is
        /// other than default (typically TCP ports 860 and 3260).
        /// </summary>
      public readonly ImmutableArray<string> Portals;

      /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// CHAP Secret for iSCSI target and initiator authentication
        /// </summary>
      public readonly Core.V1.LocalObjectReference SecretRef;

      /// <summary>
        /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other
        /// than default (typically TCP ports 860 and 3260).
        /// </summary>
      public readonly string TargetPortal;

      [OutputConstructor]
      private ISCSIVolumeSource(
          bool @chapAuthDiscovery,
          bool @chapAuthSession,
          string @fsType,
          string @initiatorName,
          string @iqn,
          string @iscsiInterface,
          int @lun,
          ImmutableArray<string> @portals,
          bool @readOnly,
          Core.V1.LocalObjectReference @secretRef,
          string @targetPortal)
      {
          this.ChapAuthDiscovery = @chapAuthDiscovery;
          this.ChapAuthSession = @chapAuthSession;
          this.FsType = @fsType;
          this.InitiatorName = @initiatorName;
          this.Iqn = @iqn;
          this.IscsiInterface = @iscsiInterface;
          this.Lun = @lun;
          this.Portals = @portals;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.TargetPortal = @targetPortal;
      }

    }
    /// <summary>
    /// Maps a string key to a path within a volume.
    /// </summary>
    [OutputType]
    public sealed class KeyToPath
    {
      /// <summary>
        /// The key to project.
        /// </summary>
      public readonly string Key;

      /// <summary>
        /// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not
        /// specified, the volume defaultMode will be used. This might be in conflict with other
        /// options that affect the file mode, like fsGroup, and the result can be other mode bits
        /// set.
        /// </summary>
      public readonly int Mode;

      /// <summary>
        /// The relative path of the file to map the key to. May not be an absolute path. May not
        /// contain the path element '..'. May not start with the string '..'.
        /// </summary>
      public readonly string Path;

      [OutputConstructor]
      private KeyToPath(
          string @key,
          int @mode,
          string @path)
      {
          this.Key = @key;
          this.Mode = @mode;
          this.Path = @path;
      }

    }
    /// <summary>
    /// Lifecycle describes actions that the management system should take in response to container
    /// lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the
    /// container blocks until the action is complete, unless the container process fails, in which
    /// case the handler is aborted.
    /// </summary>
    [OutputType]
    public sealed class Lifecycle
    {
      /// <summary>
        /// PostStart is called immediately after a container is created. If the handler fails, the
        /// container is terminated and restarted according to its restart policy. Other management
        /// of the container blocks until the hook completes. More info:
        /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        /// </summary>
      public readonly Core.V1.Handler PostStart;

      /// <summary>
        /// PreStop is called immediately before a container is terminated due to an API request or
        /// management event such as liveness/startup probe failure, preemption, resource
        /// contention, etc. The handler is not called if the container crashes or exits. The reason
        /// for termination is passed to the handler. The Pod's termination grace period countdown
        /// begins before the PreStop hooked is executed. Regardless of the outcome of the handler,
        /// the container will eventually terminate within the Pod's termination grace period. Other
        /// management of the container blocks until the hook completes or until the termination
        /// grace period is reached. More info:
        /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        /// </summary>
      public readonly Core.V1.Handler PreStop;

      [OutputConstructor]
      private Lifecycle(
          Core.V1.Handler @postStart,
          Core.V1.Handler @preStop)
      {
          this.PostStart = @postStart;
          this.PreStop = @preStop;
      }

    }
    /// <summary>
    /// LimitRange sets resource usage limits for each kind of resource in a Namespace.
    /// </summary>
    [OutputType]
    public sealed class LimitRange
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the limits enforced. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.LimitRangeSpec Spec;

      [OutputConstructor]
      private LimitRange(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.LimitRangeSpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
    /// </summary>
    [OutputType]
    public sealed class LimitRangeItem
    {
      /// <summary>
        /// Default resource requirement limit value by resource name if resource limit is omitted.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Default;

      /// <summary>
        /// DefaultRequest is the default resource requirement request value by resource name if
        /// resource request is omitted.
        /// </summary>
      public readonly ImmutableDictionary<string, string> DefaultRequest;

      /// <summary>
        /// Max usage constraints on this kind by resource name.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Max;

      /// <summary>
        /// MaxLimitRequestRatio if specified, the named resource must have a request and limit that
        /// are both non-zero where limit divided by request is less than or equal to the enumerated
        /// value; this represents the max burst for the named resource.
        /// </summary>
      public readonly ImmutableDictionary<string, string> MaxLimitRequestRatio;

      /// <summary>
        /// Min usage constraints on this kind by resource name.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Min;

      /// <summary>
        /// Type of resource that this limit applies to.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private LimitRangeItem(
          ImmutableDictionary<string, string> @default,
          ImmutableDictionary<string, string> @defaultRequest,
          ImmutableDictionary<string, string> @max,
          ImmutableDictionary<string, string> @maxLimitRequestRatio,
          ImmutableDictionary<string, string> @min,
          string @type)
      {
          this.Default = @default;
          this.DefaultRequest = @defaultRequest;
          this.Max = @max;
          this.MaxLimitRequestRatio = @maxLimitRequestRatio;
          this.Min = @min;
          this.Type = @type;
      }

    }
    /// <summary>
    /// LimitRangeList is a list of LimitRange items.
    /// </summary>
    [OutputType]
    public sealed class LimitRangeList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of LimitRange objects. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
      public readonly ImmutableArray<Core.V1.LimitRange> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private LimitRangeList(
          string @apiVersion,
          ImmutableArray<Core.V1.LimitRange> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// LimitRangeSpec defines a min/max usage limit for resources that match on kind.
    /// </summary>
    [OutputType]
    public sealed class LimitRangeSpec
    {
      /// <summary>
        /// Limits is the list of LimitRangeItem objects that are enforced.
        /// </summary>
      public readonly ImmutableArray<Core.V1.LimitRangeItem> Limits;

      [OutputConstructor]
      private LimitRangeSpec(
          ImmutableArray<Core.V1.LimitRangeItem> @limits)
      {
          this.Limits = @limits;
      }

    }
    /// <summary>
    /// LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended
    /// for the service should be sent to an ingress point.
    /// </summary>
    [OutputType]
    public sealed class LoadBalancerIngress
    {
      /// <summary>
        /// Hostname is set for load-balancer ingress points that are DNS based (typically AWS
        /// load-balancers)
        /// </summary>
      public readonly string Hostname;

      /// <summary>
        /// IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack
        /// load-balancers)
        /// </summary>
      public readonly string Ip;

      [OutputConstructor]
      private LoadBalancerIngress(
          string @hostname,
          string @ip)
      {
          this.Hostname = @hostname;
          this.Ip = @ip;
      }

    }
    /// <summary>
    /// LoadBalancerStatus represents the status of a load-balancer.
    /// </summary>
    [OutputType]
    public sealed class LoadBalancerStatus
    {
      /// <summary>
        /// Ingress is a list containing ingress points for the load-balancer. Traffic intended for
        /// the service should be sent to these ingress points.
        /// </summary>
      public readonly ImmutableArray<Core.V1.LoadBalancerIngress> Ingress;

      [OutputConstructor]
      private LoadBalancerStatus(
          ImmutableArray<Core.V1.LoadBalancerIngress> @ingress)
      {
          this.Ingress = @ingress;
      }

    }
    /// <summary>
    /// LocalObjectReference contains enough information to let you locate the referenced object
    /// inside the same namespace.
    /// </summary>
    [OutputType]
    public sealed class LocalObjectReference
    {
      /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private LocalObjectReference(
          string @name)
      {
          this.Name = @name;
      }

    }
    /// <summary>
    /// Local represents directly-attached storage with node affinity (Beta feature)
    /// </summary>
    [OutputType]
    public sealed class LocalVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. It applies only when the Path is a block device. Must be a
        /// filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The
        /// default value is to auto-select a fileystem if unspecified.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// The full path to the volume on the node. It can be either a directory or block device
        /// (disk, partition, ...).
        /// </summary>
      public readonly string Path;

      [OutputConstructor]
      private LocalVolumeSource(
          string @fsType,
          string @path)
      {
          this.FsType = @fsType;
          this.Path = @path;
      }

    }
    /// <summary>
    /// Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support
    /// ownership management or SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class NFSVolumeSource
    {
      /// <summary>
        /// Path that is exported by the NFS server. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
      public readonly string Path;

      /// <summary>
        /// ReadOnly here will force the NFS export to be mounted with read-only permissions.
        /// Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Server is the hostname or IP address of the NFS server. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
      public readonly string Server;

      [OutputConstructor]
      private NFSVolumeSource(
          string @path,
          bool @readOnly,
          string @server)
      {
          this.Path = @path;
          this.ReadOnly = @readOnly;
          this.Server = @server;
      }

    }
    /// <summary>
    /// Namespace provides a scope for Names. Use of multiple namespaces is optional.
    /// </summary>
    [OutputType]
    public sealed class Namespace
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the behavior of the Namespace. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.NamespaceSpec Spec;

      /// <summary>
        /// Status describes the current status of a Namespace. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.NamespaceStatus Status;

      [OutputConstructor]
      private Namespace(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.NamespaceSpec @spec,
          Core.V1.NamespaceStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// NamespaceCondition contains details about state of namespace.
    /// </summary>
    [OutputType]
    public sealed class NamespaceCondition
    {
      
      public readonly string LastTransitionTime;

      
      public readonly string Message;

      
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of namespace controller condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private NamespaceCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// NamespaceList is a list of Namespaces.
    /// </summary>
    [OutputType]
    public sealed class NamespaceList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of Namespace objects in the list. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        /// </summary>
      public readonly ImmutableArray<Core.V1.Namespace> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private NamespaceList(
          string @apiVersion,
          ImmutableArray<Core.V1.Namespace> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// NamespaceSpec describes the attributes on a Namespace.
    /// </summary>
    [OutputType]
    public sealed class NamespaceSpec
    {
      /// <summary>
        /// Finalizers is an opaque list of values that must be empty to permanently remove object
        /// from storage. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
        /// </summary>
      public readonly ImmutableArray<string> Finalizers;

      [OutputConstructor]
      private NamespaceSpec(
          ImmutableArray<string> @finalizers)
      {
          this.Finalizers = @finalizers;
      }

    }
    /// <summary>
    /// NamespaceStatus is information about the current status of a Namespace.
    /// </summary>
    [OutputType]
    public sealed class NamespaceStatus
    {
      /// <summary>
        /// Represents the latest available observations of a namespace's current state.
        /// </summary>
      public readonly ImmutableArray<Core.V1.NamespaceCondition> Conditions;

      /// <summary>
        /// Phase is the current lifecycle phase of the namespace. More info:
        /// https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
        /// </summary>
      public readonly string Phase;

      [OutputConstructor]
      private NamespaceStatus(
          ImmutableArray<Core.V1.NamespaceCondition> @conditions,
          string @phase)
      {
          this.Conditions = @conditions;
          this.Phase = @phase;
      }

    }
    /// <summary>
    /// Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache
    /// (i.e. in etcd).
    /// </summary>
    [OutputType]
    public sealed class Node
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the behavior of a node.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.NodeSpec Spec;

      /// <summary>
        /// Most recently observed status of the node. Populated by the system. Read-only. More
        /// info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.NodeStatus Status;

      [OutputConstructor]
      private Node(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.NodeSpec @spec,
          Core.V1.NodeStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// NodeAddress contains information for the node's address.
    /// </summary>
    [OutputType]
    public sealed class NodeAddress
    {
      /// <summary>
        /// The node address.
        /// </summary>
      public readonly string Address;

      /// <summary>
        /// Node address type, one of Hostname, ExternalIP or InternalIP.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private NodeAddress(
          string @address,
          string @type)
      {
          this.Address = @address;
          this.Type = @type;
      }

    }
    /// <summary>
    /// Node affinity is a group of node affinity scheduling rules.
    /// </summary>
    [OutputType]
    public sealed class NodeAffinity
    {
      /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity
        /// expressions specified by this field, but it may choose a node that violates one or more
        /// of the expressions. The node that is most preferred is the one with the greatest sum of
        /// weights, i.e. for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling affinity expressions, etc.), compute a sum by
        /// iterating through the elements of this field and adding "weight" to the sum if the node
        /// matches the corresponding matchExpressions; the node(s) with the highest sum are the
        /// most preferred.
        /// </summary>
      public readonly ImmutableArray<Core.V1.PreferredSchedulingTerm> PreferredDuringSchedulingIgnoredDuringExecution;

      /// <summary>
        /// If the affinity requirements specified by this field are not met at scheduling time, the
        /// pod will not be scheduled onto the node. If the affinity requirements specified by this
        /// field cease to be met at some point during pod execution (e.g. due to an update), the
        /// system may or may not try to eventually evict the pod from its node.
        /// </summary>
      public readonly Core.V1.NodeSelector RequiredDuringSchedulingIgnoredDuringExecution;

      [OutputConstructor]
      private NodeAffinity(
          ImmutableArray<Core.V1.PreferredSchedulingTerm> @preferredDuringSchedulingIgnoredDuringExecution,
          Core.V1.NodeSelector @requiredDuringSchedulingIgnoredDuringExecution)
      {
          this.PreferredDuringSchedulingIgnoredDuringExecution = @preferredDuringSchedulingIgnoredDuringExecution;
          this.RequiredDuringSchedulingIgnoredDuringExecution = @requiredDuringSchedulingIgnoredDuringExecution;
      }

    }
    /// <summary>
    /// NodeCondition contains condition information for a node.
    /// </summary>
    [OutputType]
    public sealed class NodeCondition
    {
      /// <summary>
        /// Last time we got an update on a given condition.
        /// </summary>
      public readonly string LastHeartbeatTime;

      /// <summary>
        /// Last time the condition transit from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// Human readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// (brief) reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of node condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private NodeCondition(
          string @lastHeartbeatTime,
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastHeartbeatTime = @lastHeartbeatTime;
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding
    /// metadata) must be non-nil.
    /// </summary>
    [OutputType]
    public sealed class NodeConfigSource
    {
      /// <summary>
        /// ConfigMap is a reference to a Node's ConfigMap
        /// </summary>
      public readonly Core.V1.ConfigMapNodeConfigSource ConfigMap;

      [OutputConstructor]
      private NodeConfigSource(
          Core.V1.ConfigMapNodeConfigSource @configMap)
      {
          this.ConfigMap = @configMap;
      }

    }
    /// <summary>
    /// NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
    /// </summary>
    [OutputType]
    public sealed class NodeConfigStatus
    {
      /// <summary>
        /// Active reports the checkpointed config the node is actively using. Active will represent
        /// either the current version of the Assigned config, or the current LastKnownGood config,
        /// depending on whether attempting to use the Assigned config results in an error.
        /// </summary>
      public readonly Core.V1.NodeConfigSource Active;

      /// <summary>
        /// Assigned reports the checkpointed config the node will try to use. When
        /// Node.Spec.ConfigSource is updated, the node checkpoints the associated config payload to
        /// local disk, along with a record indicating intended config. The node refers to this
        /// record to choose its config checkpoint, and reports this record in Assigned. Assigned
        /// only updates in the status after the record has been checkpointed to disk. When the
        /// Kubelet is restarted, it tries to make the Assigned config the Active config by loading
        /// and validating the checkpointed payload identified by Assigned.
        /// </summary>
      public readonly Core.V1.NodeConfigSource Assigned;

      /// <summary>
        /// Error describes any problems reconciling the Spec.ConfigSource to the Active config.
        /// Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local
        /// Assigned record, attempting to checkpoint the payload associated with Spec.ConfigSource,
        /// attempting to load or validate the Assigned config, etc. Errors may occur at different
        /// points while syncing config. Earlier errors (e.g. download or checkpointing errors) will
        /// not result in a rollback to LastKnownGood, and may resolve across Kubelet retries. Later
        /// errors (e.g. loading or validating a checkpointed config) will result in a rollback to
        /// LastKnownGood. In the latter case, it is usually possible to resolve the error by fixing
        /// the config assigned in Spec.ConfigSource. You can find additional information for
        /// debugging by searching the error message in the Kubelet log. Error is a human-readable
        /// description of the error state; machines can check whether or not Error is empty, but
        /// should not rely on the stability of the Error text across Kubelet versions.
        /// </summary>
      public readonly string Error;

      /// <summary>
        /// LastKnownGood reports the checkpointed config the node will fall back to when it
        /// encounters an error attempting to use the Assigned config. The Assigned config becomes
        /// the LastKnownGood config when the node determines that the Assigned config is stable and
        /// correct. This is currently implemented as a 10-minute soak period starting when the
        /// local record of Assigned config is updated. If the Assigned config is Active at the end
        /// of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is reset to
        /// nil (use local defaults), the LastKnownGood is also immediately reset to nil, because
        /// the local default config is always assumed good. You should not make assumptions about
        /// the node's method of determining config stability and correctness, as this may change or
        /// become configurable in the future.
        /// </summary>
      public readonly Core.V1.NodeConfigSource LastKnownGood;

      [OutputConstructor]
      private NodeConfigStatus(
          Core.V1.NodeConfigSource @active,
          Core.V1.NodeConfigSource @assigned,
          string @error,
          Core.V1.NodeConfigSource @lastKnownGood)
      {
          this.Active = @active;
          this.Assigned = @assigned;
          this.Error = @error;
          this.LastKnownGood = @lastKnownGood;
      }

    }
    /// <summary>
    /// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
    /// </summary>
    [OutputType]
    public sealed class NodeDaemonEndpoints
    {
      /// <summary>
        /// Endpoint on which Kubelet is listening.
        /// </summary>
      public readonly Core.V1.DaemonEndpoint KubeletEndpoint;

      [OutputConstructor]
      private NodeDaemonEndpoints(
          Core.V1.DaemonEndpoint @kubeletEndpoint)
      {
          this.KubeletEndpoint = @kubeletEndpoint;
      }

    }
    /// <summary>
    /// NodeList is the whole list of all Nodes which have been registered with master.
    /// </summary>
    [OutputType]
    public sealed class NodeList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of nodes
        /// </summary>
      public readonly ImmutableArray<Core.V1.Node> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private NodeList(
          string @apiVersion,
          ImmutableArray<Core.V1.Node> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// A node selector represents the union of the results of one or more label queries over a set
    /// of nodes; that is, it represents the OR of the selectors represented by the node selector
    /// terms.
    /// </summary>
    [OutputType]
    public sealed class NodeSelector
    {
      /// <summary>
        /// Required. A list of node selector terms. The terms are ORed.
        /// </summary>
      public readonly ImmutableArray<Core.V1.NodeSelectorTerm> NodeSelectorTerms;

      [OutputConstructor]
      private NodeSelector(
          ImmutableArray<Core.V1.NodeSelectorTerm> @nodeSelectorTerms)
      {
          this.NodeSelectorTerms = @nodeSelectorTerms;
      }

    }
    /// <summary>
    /// A node selector requirement is a selector that contains values, a key, and an operator that
    /// relates the key and values.
    /// </summary>
    [OutputType]
    public sealed class NodeSelectorRequirement
    {
      /// <summary>
        /// The label key that the selector applies to.
        /// </summary>
      public readonly string Key;

      /// <summary>
        /// Represents a key's relationship to a set of values. Valid operators are In, NotIn,
        /// Exists, DoesNotExist. Gt, and Lt.
        /// </summary>
      public readonly string Operator;

      /// <summary>
        /// An array of string values. If the operator is In or NotIn, the values array must be
        /// non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If
        /// the operator is Gt or Lt, the values array must have a single element, which will be
        /// interpreted as an integer. This array is replaced during a strategic merge patch.
        /// </summary>
      public readonly ImmutableArray<string> Values;

      [OutputConstructor]
      private NodeSelectorRequirement(
          string @key,
          string @operator,
          ImmutableArray<string> @values)
      {
          this.Key = @key;
          this.Operator = @operator;
          this.Values = @values;
      }

    }
    /// <summary>
    /// A null or empty node selector term matches no objects. The requirements of them are ANDed.
    /// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
    /// </summary>
    [OutputType]
    public sealed class NodeSelectorTerm
    {
      /// <summary>
        /// A list of node selector requirements by node's labels.
        /// </summary>
      public readonly ImmutableArray<Core.V1.NodeSelectorRequirement> MatchExpressions;

      /// <summary>
        /// A list of node selector requirements by node's fields.
        /// </summary>
      public readonly ImmutableArray<Core.V1.NodeSelectorRequirement> MatchFields;

      [OutputConstructor]
      private NodeSelectorTerm(
          ImmutableArray<Core.V1.NodeSelectorRequirement> @matchExpressions,
          ImmutableArray<Core.V1.NodeSelectorRequirement> @matchFields)
      {
          this.MatchExpressions = @matchExpressions;
          this.MatchFields = @matchFields;
      }

    }
    /// <summary>
    /// NodeSpec describes the attributes that a node is created with.
    /// </summary>
    [OutputType]
    public sealed class NodeSpec
    {
      /// <summary>
        /// If specified, the source to get node configuration from The DynamicKubeletConfig feature
        /// gate must be enabled for the Kubelet to use this field
        /// </summary>
      public readonly Core.V1.NodeConfigSource ConfigSource;

      /// <summary>
        /// Deprecated. Not all kubelets will set this field. Remove field after 1.13. see:
        /// https://issues.k8s.io/61966
        /// </summary>
      public readonly string ExternalID;

      /// <summary>
        /// PodCIDR represents the pod IP range assigned to the node.
        /// </summary>
      public readonly string PodCIDR;

      /// <summary>
        /// podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node.
        /// If this field is specified, the 0th entry must match the podCIDR field. It may contain
        /// at most 1 value for each of IPv4 and IPv6.
        /// </summary>
      public readonly ImmutableArray<string> PodCIDRs;

      /// <summary>
        /// ID of the node assigned by the cloud provider in the format:
        /// &amp;lt;ProviderName&amp;gt;://&amp;lt;ProviderSpecificNodeID&amp;gt;
        /// </summary>
      public readonly string ProviderID;

      /// <summary>
        /// If specified, the node's taints.
        /// </summary>
      public readonly ImmutableArray<Core.V1.Taint> Taints;

      /// <summary>
        /// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
        /// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
        /// </summary>
      public readonly bool Unschedulable;

      [OutputConstructor]
      private NodeSpec(
          Core.V1.NodeConfigSource @configSource,
          string @externalID,
          string @podCIDR,
          ImmutableArray<string> @podCIDRs,
          string @providerID,
          ImmutableArray<Core.V1.Taint> @taints,
          bool @unschedulable)
      {
          this.ConfigSource = @configSource;
          this.ExternalID = @externalID;
          this.PodCIDR = @podCIDR;
          this.PodCIDRs = @podCIDRs;
          this.ProviderID = @providerID;
          this.Taints = @taints;
          this.Unschedulable = @unschedulable;
      }

    }
    /// <summary>
    /// NodeStatus is information about the current status of a node.
    /// </summary>
    [OutputType]
    public sealed class NodeStatus
    {
      /// <summary>
        /// List of addresses reachable to the node. Queried from cloud provider, if available. More
        /// info: https://kubernetes.io/docs/concepts/nodes/node/#addresses Note: This field is
        /// declared as mergeable, but the merge key is not sufficiently unique, which can cause
        /// data corruption when it is merged. Callers should instead use a full-replacement patch.
        /// See http://pr.k8s.io/79391 for an example.
        /// </summary>
      public readonly ImmutableArray<Core.V1.NodeAddress> Addresses;

      /// <summary>
        /// Allocatable represents the resources of a node that are available for scheduling.
        /// Defaults to Capacity.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Allocatable;

      /// <summary>
        /// Capacity represents the total resources of a node. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </summary>
      public readonly ImmutableDictionary<string, string> Capacity;

      /// <summary>
        /// Conditions is an array of current observed node conditions. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#condition
        /// </summary>
      public readonly ImmutableArray<Core.V1.NodeCondition> Conditions;

      /// <summary>
        /// Status of the config assigned to the node via the dynamic Kubelet config feature.
        /// </summary>
      public readonly Core.V1.NodeConfigStatus Config;

      /// <summary>
        /// Endpoints of daemons running on the Node.
        /// </summary>
      public readonly Core.V1.NodeDaemonEndpoints DaemonEndpoints;

      /// <summary>
        /// List of container images on this node
        /// </summary>
      public readonly ImmutableArray<Core.V1.ContainerImage> Images;

      /// <summary>
        /// Set of ids/uuids to uniquely identify the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#info
        /// </summary>
      public readonly Core.V1.NodeSystemInfo NodeInfo;

      /// <summary>
        /// NodePhase is the recently observed lifecycle phase of the node. More info:
        /// https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and
        /// now is deprecated.
        /// </summary>
      public readonly string Phase;

      /// <summary>
        /// List of volumes that are attached to the node.
        /// </summary>
      public readonly ImmutableArray<Core.V1.AttachedVolume> VolumesAttached;

      /// <summary>
        /// List of attachable volumes in use (mounted) by the node.
        /// </summary>
      public readonly ImmutableArray<string> VolumesInUse;

      [OutputConstructor]
      private NodeStatus(
          ImmutableArray<Core.V1.NodeAddress> @addresses,
          ImmutableDictionary<string, string> @allocatable,
          ImmutableDictionary<string, string> @capacity,
          ImmutableArray<Core.V1.NodeCondition> @conditions,
          Core.V1.NodeConfigStatus @config,
          Core.V1.NodeDaemonEndpoints @daemonEndpoints,
          ImmutableArray<Core.V1.ContainerImage> @images,
          Core.V1.NodeSystemInfo @nodeInfo,
          string @phase,
          ImmutableArray<Core.V1.AttachedVolume> @volumesAttached,
          ImmutableArray<string> @volumesInUse)
      {
          this.Addresses = @addresses;
          this.Allocatable = @allocatable;
          this.Capacity = @capacity;
          this.Conditions = @conditions;
          this.Config = @config;
          this.DaemonEndpoints = @daemonEndpoints;
          this.Images = @images;
          this.NodeInfo = @nodeInfo;
          this.Phase = @phase;
          this.VolumesAttached = @volumesAttached;
          this.VolumesInUse = @volumesInUse;
      }

    }
    /// <summary>
    /// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
    /// </summary>
    [OutputType]
    public sealed class NodeSystemInfo
    {
      /// <summary>
        /// The Architecture reported by the node
        /// </summary>
      public readonly string Architecture;

      /// <summary>
        /// Boot ID reported by the node.
        /// </summary>
      public readonly string BootID;

      /// <summary>
        /// ContainerRuntime Version reported by the node through runtime remote API (e.g.
        /// docker://1.5.0).
        /// </summary>
      public readonly string ContainerRuntimeVersion;

      /// <summary>
        /// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
        /// </summary>
      public readonly string KernelVersion;

      /// <summary>
        /// KubeProxy Version reported by the node.
        /// </summary>
      public readonly string KubeProxyVersion;

      /// <summary>
        /// Kubelet Version reported by the node.
        /// </summary>
      public readonly string KubeletVersion;

      /// <summary>
        /// MachineID reported by the node. For unique machine identification in the cluster this
        /// field is preferred. Learn more from man(5) machine-id:
        /// http://man7.org/linux/man-pages/man5/machine-id.5.html
        /// </summary>
      public readonly string MachineID;

      /// <summary>
        /// The Operating System reported by the node
        /// </summary>
      public readonly string OperatingSystem;

      /// <summary>
        /// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
        /// </summary>
      public readonly string OsImage;

      /// <summary>
        /// SystemUUID reported by the node. For unique machine identification MachineID is
        /// preferred. This field is specific to Red Hat hosts
        /// https://access.redhat.com/documentation/en-US/Red_Hat_Subscription_Management/1/html/RHSM/getting-system-uuid.html
        /// </summary>
      public readonly string SystemUUID;

      [OutputConstructor]
      private NodeSystemInfo(
          string @architecture,
          string @bootID,
          string @containerRuntimeVersion,
          string @kernelVersion,
          string @kubeProxyVersion,
          string @kubeletVersion,
          string @machineID,
          string @operatingSystem,
          string @osImage,
          string @systemUUID)
      {
          this.Architecture = @architecture;
          this.BootID = @bootID;
          this.ContainerRuntimeVersion = @containerRuntimeVersion;
          this.KernelVersion = @kernelVersion;
          this.KubeProxyVersion = @kubeProxyVersion;
          this.KubeletVersion = @kubeletVersion;
          this.MachineID = @machineID;
          this.OperatingSystem = @operatingSystem;
          this.OsImage = @osImage;
          this.SystemUUID = @systemUUID;
      }

    }
    /// <summary>
    /// ObjectFieldSelector selects an APIVersioned field of an object.
    /// </summary>
    [OutputType]
    public sealed class ObjectFieldSelector
    {
      /// <summary>
        /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Path of the field to select in the specified API version.
        /// </summary>
      public readonly string FieldPath;

      [OutputConstructor]
      private ObjectFieldSelector(
          string @apiVersion,
          string @fieldPath)
      {
          this.ApiVersion = @apiVersion;
          this.FieldPath = @fieldPath;
      }

    }
    /// <summary>
    /// ObjectReference contains enough information to let you inspect or modify the referred
    /// object.
    /// </summary>
    [OutputType]
    public sealed class ObjectReference
    {
      /// <summary>
        /// API version of the referent.
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// If referring to a piece of an object instead of an entire object, this string should
        /// contain a valid JSON/Go field access statement, such as
        /// desiredState.manifest.containers[2]. For example, if the object reference is to a
        /// container within a pod, this would take on a value like: "spec.containers{name}" (where
        /// "name" refers to the name of the container that triggered the event) or if no container
        /// name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax
        /// is chosen only to have some well-defined way of referencing a part of an object.
        /// </summary>
      public readonly string FieldPath;

      /// <summary>
        /// Kind of the referent. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// Specific resourceVersion to which this reference is made, if any. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
      public readonly string ResourceVersion;

      /// <summary>
        /// UID of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        /// </summary>
      public readonly string Uid;

      [OutputConstructor]
      private ObjectReference(
          string @apiVersion,
          string @fieldPath,
          string @kind,
          string @name,
          string @namespace,
          string @resourceVersion,
          string @uid)
      {
          this.ApiVersion = @apiVersion;
          this.FieldPath = @fieldPath;
          this.Kind = @kind;
          this.Name = @name;
          this.Namespace = @namespace;
          this.ResourceVersion = @resourceVersion;
          this.Uid = @uid;
      }

    }
    /// <summary>
    /// PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous
    /// to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
    /// </summary>
    [OutputType]
    public sealed class PersistentVolume
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines a specification of a persistent volume owned by the cluster. Provisioned by
        /// an administrator. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
        /// </summary>
      public readonly Core.V1.PersistentVolumeSpec Spec;

      /// <summary>
        /// Status represents the current information/status for the persistent volume. Populated by
        /// the system. Read-only. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
        /// </summary>
      public readonly Core.V1.PersistentVolumeStatus Status;

      [OutputConstructor]
      private PersistentVolume(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.PersistentVolumeSpec @spec,
          Core.V1.PersistentVolumeStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// PersistentVolumeClaim is a user's request for and claim to a persistent volume
    /// </summary>
    [OutputType]
    public sealed class PersistentVolumeClaim
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the desired characteristics of a volume requested by a pod author. More
        /// info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
      public readonly Core.V1.PersistentVolumeClaimSpec Spec;

      /// <summary>
        /// Status represents the current information/status of a persistent volume claim.
        /// Read-only. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
      public readonly Core.V1.PersistentVolumeClaimStatus Status;

      [OutputConstructor]
      private PersistentVolumeClaim(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.PersistentVolumeClaimSpec @spec,
          Core.V1.PersistentVolumeClaimStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// PersistentVolumeClaimCondition contails details about state of pvc
    /// </summary>
    [OutputType]
    public sealed class PersistentVolumeClaimCondition
    {
      /// <summary>
        /// Last time we probed the condition.
        /// </summary>
      public readonly string LastProbeTime;

      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Unique, this should be a short, machine understandable string that gives the reason for
        /// condition's last transition. If it reports "ResizeStarted" that means the underlying
        /// persistent volume is being resized.
        /// </summary>
      public readonly string Reason;

      
      public readonly string Status;

      
      public readonly string Type;

      [OutputConstructor]
      private PersistentVolumeClaimCondition(
          string @lastProbeTime,
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastProbeTime = @lastProbeTime;
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
    /// </summary>
    [OutputType]
    public sealed class PersistentVolumeClaimList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// A list of persistent volume claims. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
      public readonly ImmutableArray<Core.V1.PersistentVolumeClaim> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PersistentVolumeClaimList(
          string @apiVersion,
          ImmutableArray<Core.V1.PersistentVolumeClaim> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a
    /// Source for provider-specific attributes
    /// </summary>
    [OutputType]
    public sealed class PersistentVolumeClaimSpec
    {
      /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
      public readonly ImmutableArray<string> AccessModes;

      /// <summary>
        /// This field requires the VolumeSnapshotDataSource alpha feature gate to be enabled and
        /// currently VolumeSnapshot is the only supported data source. If the provisioner can
        /// support VolumeSnapshot data source, it will create a new volume and data will be
        /// restored to the volume at the same time. If the provisioner does not support
        /// VolumeSnapshot data source, volume will not be created and the failure will be reported
        /// as an event. In the future, we plan to support more data source types and the behavior
        /// of the provisioner may change.
        /// </summary>
      public readonly Core.V1.TypedLocalObjectReference DataSource;

      /// <summary>
        /// Resources represents the minimum resources the volume should have. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        /// </summary>
      public readonly Core.V1.ResourceRequirements Resources;

      /// <summary>
        /// A label query over volumes to consider for binding.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// Name of the StorageClass required by the claim. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
      public readonly string StorageClassName;

      /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is
        /// implied when not included in claim spec. This is a beta feature.
        /// </summary>
      public readonly string VolumeMode;

      /// <summary>
        /// VolumeName is the binding reference to the PersistentVolume backing this claim.
        /// </summary>
      public readonly string VolumeName;

      [OutputConstructor]
      private PersistentVolumeClaimSpec(
          ImmutableArray<string> @accessModes,
          Core.V1.TypedLocalObjectReference @dataSource,
          Core.V1.ResourceRequirements @resources,
          Meta.V1.LabelSelector @selector,
          string @storageClassName,
          string @volumeMode,
          string @volumeName)
      {
          this.AccessModes = @accessModes;
          this.DataSource = @dataSource;
          this.Resources = @resources;
          this.Selector = @selector;
          this.StorageClassName = @storageClassName;
          this.VolumeMode = @volumeMode;
          this.VolumeName = @volumeName;
      }

    }
    /// <summary>
    /// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
    /// </summary>
    [OutputType]
    public sealed class PersistentVolumeClaimStatus
    {
      /// <summary>
        /// AccessModes contains the actual access modes the volume backing the PVC has. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
      public readonly ImmutableArray<string> AccessModes;

      /// <summary>
        /// Represents the actual resources of the underlying volume.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Capacity;

      /// <summary>
        /// Current Condition of persistent volume claim. If underlying persistent volume is being
        /// resized then the Condition will be set to 'ResizeStarted'.
        /// </summary>
      public readonly ImmutableArray<Core.V1.PersistentVolumeClaimCondition> Conditions;

      /// <summary>
        /// Phase represents the current phase of PersistentVolumeClaim.
        /// </summary>
      public readonly string Phase;

      [OutputConstructor]
      private PersistentVolumeClaimStatus(
          ImmutableArray<string> @accessModes,
          ImmutableDictionary<string, string> @capacity,
          ImmutableArray<Core.V1.PersistentVolumeClaimCondition> @conditions,
          string @phase)
      {
          this.AccessModes = @accessModes;
          this.Capacity = @capacity;
          this.Conditions = @conditions;
          this.Phase = @phase;
      }

    }
    /// <summary>
    /// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This
    /// volume finds the bound PV and mounts that volume for the pod. A
    /// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume
    /// that is owned by someone else (the system).
    /// </summary>
    [OutputType]
    public sealed class PersistentVolumeClaimVolumeSource
    {
      /// <summary>
        /// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using
        /// this volume. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
      public readonly string ClaimName;

      /// <summary>
        /// Will force the ReadOnly setting in VolumeMounts. Default false.
        /// </summary>
      public readonly bool ReadOnly;

      [OutputConstructor]
      private PersistentVolumeClaimVolumeSource(
          string @claimName,
          bool @readOnly)
      {
          this.ClaimName = @claimName;
          this.ReadOnly = @readOnly;
      }

    }
    /// <summary>
    /// PersistentVolumeList is a list of PersistentVolume items.
    /// </summary>
    [OutputType]
    public sealed class PersistentVolumeList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of persistent volumes. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes
        /// </summary>
      public readonly ImmutableArray<Core.V1.PersistentVolume> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PersistentVolumeList(
          string @apiVersion,
          ImmutableArray<Core.V1.PersistentVolume> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PersistentVolumeSpec is the specification of a persistent volume.
    /// </summary>
    [OutputType]
    public sealed class PersistentVolumeSpec
    {
      /// <summary>
        /// AccessModes contains all ways the volume can be mounted. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
        /// </summary>
      public readonly ImmutableArray<string> AccessModes;

      /// <summary>
        /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's
        /// host machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
      public readonly Core.V1.AWSElasticBlockStoreVolumeSource AwsElasticBlockStore;

      /// <summary>
        /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
        /// </summary>
      public readonly Core.V1.AzureDiskVolumeSource AzureDisk;

      /// <summary>
        /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
        /// </summary>
      public readonly Core.V1.AzureFilePersistentVolumeSource AzureFile;

      /// <summary>
        /// A description of the persistent volume's resources and capacity. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
        /// </summary>
      public readonly ImmutableDictionary<string, string> Capacity;

      /// <summary>
        /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
        /// </summary>
      public readonly Core.V1.CephFSPersistentVolumeSource Cephfs;

      /// <summary>
        /// Cinder represents a cinder volume attached and mounted on kubelets host machine. More
        /// info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
      public readonly Core.V1.CinderPersistentVolumeSource Cinder;

      /// <summary>
        /// ClaimRef is part of a bi-directional binding between PersistentVolume and
        /// PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the
        /// authoritative bind between PV and PVC. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
        /// </summary>
      public readonly Core.V1.ObjectReference ClaimRef;

      /// <summary>
        /// CSI represents storage that is handled by an external CSI driver (Beta feature).
        /// </summary>
      public readonly Core.V1.CSIPersistentVolumeSource Csi;

      /// <summary>
        /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and
        /// then exposed to the pod.
        /// </summary>
      public readonly Core.V1.FCVolumeSource Fc;

      /// <summary>
        /// FlexVolume represents a generic volume resource that is provisioned/attached using an
        /// exec based plugin.
        /// </summary>
      public readonly Core.V1.FlexPersistentVolumeSource FlexVolume;

      /// <summary>
        /// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to
        /// the pod for its usage. This depends on the Flocker control service being running
        /// </summary>
      public readonly Core.V1.FlockerVolumeSource Flocker;

      /// <summary>
        /// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host
        /// machine and then exposed to the pod. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
      public readonly Core.V1.GCEPersistentDiskVolumeSource GcePersistentDisk;

      /// <summary>
        /// Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the
        /// pod. Provisioned by an admin. More info:
        /// https://examples.k8s.io/volumes/glusterfs/README.md
        /// </summary>
      public readonly Core.V1.GlusterfsPersistentVolumeSource Glusterfs;

      /// <summary>
        /// HostPath represents a directory on the host. Provisioned by a developer or tester. This
        /// is useful for single-node development and testing only! On-host storage is not supported
        /// in any way and WILL NOT WORK in a multi-node cluster. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
      public readonly Core.V1.HostPathVolumeSource HostPath;

      /// <summary>
        /// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and
        /// then exposed to the pod. Provisioned by an admin.
        /// </summary>
      public readonly Core.V1.ISCSIPersistentVolumeSource Iscsi;

      /// <summary>
        /// Local represents directly-attached storage with node affinity
        /// </summary>
      public readonly Core.V1.LocalVolumeSource Local;

      /// <summary>
        /// A list of mount options, e.g. ["ro", "soft"]. Not validated - mount will simply fail if
        /// one is invalid. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
        /// </summary>
      public readonly ImmutableArray<string> MountOptions;

      /// <summary>
        /// NFS represents an NFS mount on the host. Provisioned by an admin. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
      public readonly Core.V1.NFSVolumeSource Nfs;

      /// <summary>
        /// NodeAffinity defines constraints that limit what nodes this volume can be accessed from.
        /// This field influences the scheduling of pods that use this volume.
        /// </summary>
      public readonly Core.V1.VolumeNodeAffinity NodeAffinity;

      /// <summary>
        /// What happens to a persistent volume when released from its claim. Valid options are
        /// Retain (default for manually created PersistentVolumes), Delete (default for dynamically
        /// provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by
        /// the volume plugin underlying this PersistentVolume. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
        /// </summary>
      public readonly string PersistentVolumeReclaimPolicy;

      /// <summary>
        /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted
        /// on kubelets host machine
        /// </summary>
      public readonly Core.V1.PhotonPersistentDiskVolumeSource PhotonPersistentDisk;

      /// <summary>
        /// PortworxVolume represents a portworx volume attached and mounted on kubelets host
        /// machine
        /// </summary>
      public readonly Core.V1.PortworxVolumeSource PortworxVolume;

      /// <summary>
        /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        /// </summary>
      public readonly Core.V1.QuobyteVolumeSource Quobyte;

      /// <summary>
        /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md
        /// </summary>
      public readonly Core.V1.RBDPersistentVolumeSource Rbd;

      /// <summary>
        /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
        /// </summary>
      public readonly Core.V1.ScaleIOPersistentVolumeSource ScaleIO;

      /// <summary>
        /// Name of StorageClass to which this persistent volume belongs. Empty value means that
        /// this volume does not belong to any StorageClass.
        /// </summary>
      public readonly string StorageClassName;

      /// <summary>
        /// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine
        /// and mounted into the pod More info: https://examples.k8s.io/volumes/storageos/README.md
        /// </summary>
      public readonly Core.V1.StorageOSPersistentVolumeSource Storageos;

      /// <summary>
        /// volumeMode defines if a volume is intended to be used with a formatted filesystem or to
        /// remain in raw block state. Value of Filesystem is implied when not included in spec.
        /// This is a beta feature.
        /// </summary>
      public readonly string VolumeMode;

      /// <summary>
        /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
        /// </summary>
      public readonly Core.V1.VsphereVirtualDiskVolumeSource VsphereVolume;

      [OutputConstructor]
      private PersistentVolumeSpec(
          ImmutableArray<string> @accessModes,
          Core.V1.AWSElasticBlockStoreVolumeSource @awsElasticBlockStore,
          Core.V1.AzureDiskVolumeSource @azureDisk,
          Core.V1.AzureFilePersistentVolumeSource @azureFile,
          ImmutableDictionary<string, string> @capacity,
          Core.V1.CephFSPersistentVolumeSource @cephfs,
          Core.V1.CinderPersistentVolumeSource @cinder,
          Core.V1.ObjectReference @claimRef,
          Core.V1.CSIPersistentVolumeSource @csi,
          Core.V1.FCVolumeSource @fc,
          Core.V1.FlexPersistentVolumeSource @flexVolume,
          Core.V1.FlockerVolumeSource @flocker,
          Core.V1.GCEPersistentDiskVolumeSource @gcePersistentDisk,
          Core.V1.GlusterfsPersistentVolumeSource @glusterfs,
          Core.V1.HostPathVolumeSource @hostPath,
          Core.V1.ISCSIPersistentVolumeSource @iscsi,
          Core.V1.LocalVolumeSource @local,
          ImmutableArray<string> @mountOptions,
          Core.V1.NFSVolumeSource @nfs,
          Core.V1.VolumeNodeAffinity @nodeAffinity,
          string @persistentVolumeReclaimPolicy,
          Core.V1.PhotonPersistentDiskVolumeSource @photonPersistentDisk,
          Core.V1.PortworxVolumeSource @portworxVolume,
          Core.V1.QuobyteVolumeSource @quobyte,
          Core.V1.RBDPersistentVolumeSource @rbd,
          Core.V1.ScaleIOPersistentVolumeSource @scaleIO,
          string @storageClassName,
          Core.V1.StorageOSPersistentVolumeSource @storageos,
          string @volumeMode,
          Core.V1.VsphereVirtualDiskVolumeSource @vsphereVolume)
      {
          this.AccessModes = @accessModes;
          this.AwsElasticBlockStore = @awsElasticBlockStore;
          this.AzureDisk = @azureDisk;
          this.AzureFile = @azureFile;
          this.Capacity = @capacity;
          this.Cephfs = @cephfs;
          this.Cinder = @cinder;
          this.ClaimRef = @claimRef;
          this.Csi = @csi;
          this.Fc = @fc;
          this.FlexVolume = @flexVolume;
          this.Flocker = @flocker;
          this.GcePersistentDisk = @gcePersistentDisk;
          this.Glusterfs = @glusterfs;
          this.HostPath = @hostPath;
          this.Iscsi = @iscsi;
          this.Local = @local;
          this.MountOptions = @mountOptions;
          this.Nfs = @nfs;
          this.NodeAffinity = @nodeAffinity;
          this.PersistentVolumeReclaimPolicy = @persistentVolumeReclaimPolicy;
          this.PhotonPersistentDisk = @photonPersistentDisk;
          this.PortworxVolume = @portworxVolume;
          this.Quobyte = @quobyte;
          this.Rbd = @rbd;
          this.ScaleIO = @scaleIO;
          this.StorageClassName = @storageClassName;
          this.Storageos = @storageos;
          this.VolumeMode = @volumeMode;
          this.VsphereVolume = @vsphereVolume;
      }

    }
    /// <summary>
    /// PersistentVolumeStatus is the current status of a persistent volume.
    /// </summary>
    [OutputType]
    public sealed class PersistentVolumeStatus
    {
      /// <summary>
        /// A human-readable message indicating details about why the volume is in this state.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Phase indicates if a volume is available, bound to a claim, or released by a claim. More
        /// info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
        /// </summary>
      public readonly string Phase;

      /// <summary>
        /// Reason is a brief CamelCase string that describes any failure and is meant for machine
        /// parsing and tidy display in the CLI.
        /// </summary>
      public readonly string Reason;

      [OutputConstructor]
      private PersistentVolumeStatus(
          string @message,
          string @phase,
          string @reason)
      {
          this.Message = @message;
          this.Phase = @phase;
          this.Reason = @reason;
      }

    }
    /// <summary>
    /// Represents a Photon Controller persistent disk resource.
    /// </summary>
    [OutputType]
    public sealed class PhotonPersistentDiskVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// ID that identifies Photon Controller persistent disk
        /// </summary>
      public readonly string PdID;

      [OutputConstructor]
      private PhotonPersistentDiskVolumeSource(
          string @fsType,
          string @pdID)
      {
          this.FsType = @fsType;
          this.PdID = @pdID;
      }

    }
    /// <summary>
    /// Pod is a collection of containers that can run on a host. This resource is created by
    /// clients and scheduled onto hosts.
    /// </summary>
    [OutputType]
    public sealed class Pod
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of the pod. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.PodSpec Spec;

      /// <summary>
        /// Most recently observed status of the pod. This data may not be up to date. Populated by
        /// the system. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.PodStatus Status;

      [OutputConstructor]
      private Pod(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.PodSpec @spec,
          Core.V1.PodStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// Pod affinity is a group of inter pod affinity scheduling rules.
    /// </summary>
    [OutputType]
    public sealed class PodAffinity
    {
      /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity
        /// expressions specified by this field, but it may choose a node that violates one or more
        /// of the expressions. The node that is most preferred is the one with the greatest sum of
        /// weights, i.e. for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling affinity expressions, etc.), compute a sum by
        /// iterating through the elements of this field and adding "weight" to the sum if the node
        /// has pods which matches the corresponding podAffinityTerm; the node(s) with the highest
        /// sum are the most preferred.
        /// </summary>
      public readonly ImmutableArray<Core.V1.WeightedPodAffinityTerm> PreferredDuringSchedulingIgnoredDuringExecution;

      /// <summary>
        /// If the affinity requirements specified by this field are not met at scheduling time, the
        /// pod will not be scheduled onto the node. If the affinity requirements specified by this
        /// field cease to be met at some point during pod execution (e.g. due to a pod label
        /// update), the system may or may not try to eventually evict the pod from its node. When
        /// there are multiple elements, the lists of nodes corresponding to each podAffinityTerm
        /// are intersected, i.e. all terms must be satisfied.
        /// </summary>
      public readonly ImmutableArray<Core.V1.PodAffinityTerm> RequiredDuringSchedulingIgnoredDuringExecution;

      [OutputConstructor]
      private PodAffinity(
          ImmutableArray<Core.V1.WeightedPodAffinityTerm> @preferredDuringSchedulingIgnoredDuringExecution,
          ImmutableArray<Core.V1.PodAffinityTerm> @requiredDuringSchedulingIgnoredDuringExecution)
      {
          this.PreferredDuringSchedulingIgnoredDuringExecution = @preferredDuringSchedulingIgnoredDuringExecution;
          this.RequiredDuringSchedulingIgnoredDuringExecution = @requiredDuringSchedulingIgnoredDuringExecution;
      }

    }
    /// <summary>
    /// Defines a set of pods (namely those matching the labelSelector relative to the given
    /// namespace(s)) that this pod should be co-located (affinity) or not co-located
    /// (anti-affinity) with, where co-located is defined as running on a node whose value of the
    /// label with key &amp;lt;topologyKey&amp;gt; matches that of any node on which a pod of the
    /// set of pods is running
    /// </summary>
    [OutputType]
    public sealed class PodAffinityTerm
    {
      /// <summary>
        /// A label query over a set of resources, in this case pods.
        /// </summary>
      public readonly Meta.V1.LabelSelector LabelSelector;

      /// <summary>
        /// namespaces specifies which namespaces the labelSelector applies to (matches against);
        /// null or empty list means "this pod's namespace"
        /// </summary>
      public readonly ImmutableArray<string> Namespaces;

      /// <summary>
        /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods
        /// matching the labelSelector in the specified namespaces, where co-located is defined as
        /// running on a node whose value of the label with key topologyKey matches that of any node
        /// on which any of the selected pods is running. Empty topologyKey is not allowed.
        /// </summary>
      public readonly string TopologyKey;

      [OutputConstructor]
      private PodAffinityTerm(
          Meta.V1.LabelSelector @labelSelector,
          ImmutableArray<string> @namespaces,
          string @topologyKey)
      {
          this.LabelSelector = @labelSelector;
          this.Namespaces = @namespaces;
          this.TopologyKey = @topologyKey;
      }

    }
    /// <summary>
    /// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
    /// </summary>
    [OutputType]
    public sealed class PodAntiAffinity
    {
      /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity
        /// expressions specified by this field, but it may choose a node that violates one or more
        /// of the expressions. The node that is most preferred is the one with the greatest sum of
        /// weights, i.e. for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by
        /// iterating through the elements of this field and adding "weight" to the sum if the node
        /// has pods which matches the corresponding podAffinityTerm; the node(s) with the highest
        /// sum are the most preferred.
        /// </summary>
      public readonly ImmutableArray<Core.V1.WeightedPodAffinityTerm> PreferredDuringSchedulingIgnoredDuringExecution;

      /// <summary>
        /// If the anti-affinity requirements specified by this field are not met at scheduling
        /// time, the pod will not be scheduled onto the node. If the anti-affinity requirements
        /// specified by this field cease to be met at some point during pod execution (e.g. due to
        /// a pod label update), the system may or may not try to eventually evict the pod from its
        /// node. When there are multiple elements, the lists of nodes corresponding to each
        /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
        /// </summary>
      public readonly ImmutableArray<Core.V1.PodAffinityTerm> RequiredDuringSchedulingIgnoredDuringExecution;

      [OutputConstructor]
      private PodAntiAffinity(
          ImmutableArray<Core.V1.WeightedPodAffinityTerm> @preferredDuringSchedulingIgnoredDuringExecution,
          ImmutableArray<Core.V1.PodAffinityTerm> @requiredDuringSchedulingIgnoredDuringExecution)
      {
          this.PreferredDuringSchedulingIgnoredDuringExecution = @preferredDuringSchedulingIgnoredDuringExecution;
          this.RequiredDuringSchedulingIgnoredDuringExecution = @requiredDuringSchedulingIgnoredDuringExecution;
      }

    }
    /// <summary>
    /// PodCondition contains details for the current condition of this pod.
    /// </summary>
    [OutputType]
    public sealed class PodCondition
    {
      /// <summary>
        /// Last time we probed the condition.
        /// </summary>
      public readonly string LastProbeTime;

      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status is the status of the condition. Can be True, False, Unknown. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type is the type of the condition. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private PodCondition(
          string @lastProbeTime,
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastProbeTime = @lastProbeTime;
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// PodDNSConfig defines the DNS parameters of a pod in addition to those generated from
    /// DNSPolicy.
    /// </summary>
    [OutputType]
    public sealed class PodDNSConfig
    {
      /// <summary>
        /// A list of DNS name server IP addresses. This will be appended to the base nameservers
        /// generated from DNSPolicy. Duplicated nameservers will be removed.
        /// </summary>
      public readonly ImmutableArray<string> Nameservers;

      /// <summary>
        /// A list of DNS resolver options. This will be merged with the base options generated from
        /// DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will
        /// override those that appear in the base DNSPolicy.
        /// </summary>
      public readonly ImmutableArray<Core.V1.PodDNSConfigOption> Options;

      /// <summary>
        /// A list of DNS search domains for host-name lookup. This will be appended to the base
        /// search paths generated from DNSPolicy. Duplicated search paths will be removed.
        /// </summary>
      public readonly ImmutableArray<string> Searches;

      [OutputConstructor]
      private PodDNSConfig(
          ImmutableArray<string> @nameservers,
          ImmutableArray<Core.V1.PodDNSConfigOption> @options,
          ImmutableArray<string> @searches)
      {
          this.Nameservers = @nameservers;
          this.Options = @options;
          this.Searches = @searches;
      }

    }
    /// <summary>
    /// PodDNSConfigOption defines DNS resolver options of a pod.
    /// </summary>
    [OutputType]
    public sealed class PodDNSConfigOption
    {
      /// <summary>
        /// Required.
        /// </summary>
      public readonly string Name;

      
      public readonly string Value;

      [OutputConstructor]
      private PodDNSConfigOption(
          string @name,
          string @value)
      {
          this.Name = @name;
          this.Value = @value;
      }

    }
    /// <summary>
    /// IP address information for entries in the (plural) PodIPs field. Each entry includes:
    ///    IP: An IP address allocated to the pod. Routable at least within the cluster.
    /// </summary>
    [OutputType]
    public sealed class PodIP
    {
      /// <summary>
        /// ip is an IP address (IPv4 or IPv6) assigned to the pod
        /// </summary>
      public readonly string Ip;

      [OutputConstructor]
      private PodIP(
          string @ip)
      {
          this.Ip = @ip;
      }

    }
    /// <summary>
    /// PodList is a list of Pods.
    /// </summary>
    [OutputType]
    public sealed class PodList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of pods. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
        /// </summary>
      public readonly ImmutableArray<Core.V1.Pod> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PodList(
          string @apiVersion,
          ImmutableArray<Core.V1.Pod> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PodReadinessGate contains the reference to a pod condition
    /// </summary>
    [OutputType]
    public sealed class PodReadinessGate
    {
      /// <summary>
        /// ConditionType refers to a condition in the pod's condition list with matching type.
        /// </summary>
      public readonly string ConditionType;

      [OutputConstructor]
      private PodReadinessGate(
          string @conditionType)
      {
          this.ConditionType = @conditionType;
      }

    }
    /// <summary>
    /// PodSecurityContext holds pod-level security attributes and common container settings. Some
    /// fields are also present in container.securityContext.  Field values of
    /// container.securityContext take precedence over field values of PodSecurityContext.
    /// </summary>
    [OutputType]
    public sealed class PodSecurityContext
    {
      /// <summary>
        /// A special supplemental group that applies to all containers in a pod. Some volume types
        /// allow the Kubelet to change the ownership of that volume to be owned by the pod:
        /// 
        /// 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the
        /// volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
        /// 
        /// If unset, the Kubelet will not modify the ownership and permissions of any volume.
        /// </summary>
      public readonly int FsGroup;

      /// <summary>
        /// The GID to run the entrypoint of the container process. Uses runtime default if unset.
        /// May also be set in SecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence for that
        /// container.
        /// </summary>
      public readonly int RunAsGroup;

      /// <summary>
        /// Indicates that the container must run as a non-root user. If true, the Kubelet will
        /// validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to
        /// start the container if it does. If unset or false, no such validation will be performed.
        /// May also be set in SecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
      public readonly bool RunAsNonRoot;

      /// <summary>
        /// The UID to run the entrypoint of the container process. Defaults to user specified in
        /// image metadata if unspecified. May also be set in SecurityContext.  If set in both
        /// SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
        /// precedence for that container.
        /// </summary>
      public readonly int RunAsUser;

      /// <summary>
        /// The SELinux context to be applied to all containers. If unspecified, the container
        /// runtime will allocate a random SELinux context for each container.  May also be set in
        /// SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value
        /// specified in SecurityContext takes precedence for that container.
        /// </summary>
      public readonly Core.V1.SELinuxOptions SeLinuxOptions;

      /// <summary>
        /// A list of groups applied to the first process run in each container, in addition to the
        /// container's primary GID.  If unspecified, no groups will be added to any container.
        /// </summary>
      public readonly ImmutableArray<int> SupplementalGroups;

      /// <summary>
        /// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
        /// sysctls (by the container runtime) might fail to launch.
        /// </summary>
      public readonly ImmutableArray<Core.V1.Sysctl> Sysctls;

      /// <summary>
        /// The Windows specific settings applied to all containers. If unspecified, the options
        /// within a container's SecurityContext will be used. If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
      public readonly Core.V1.WindowsSecurityContextOptions WindowsOptions;

      [OutputConstructor]
      private PodSecurityContext(
          int @fsGroup,
          int @runAsGroup,
          bool @runAsNonRoot,
          int @runAsUser,
          Core.V1.SELinuxOptions @seLinuxOptions,
          ImmutableArray<int> @supplementalGroups,
          ImmutableArray<Core.V1.Sysctl> @sysctls,
          Core.V1.WindowsSecurityContextOptions @windowsOptions)
      {
          this.FsGroup = @fsGroup;
          this.RunAsGroup = @runAsGroup;
          this.RunAsNonRoot = @runAsNonRoot;
          this.RunAsUser = @runAsUser;
          this.SeLinuxOptions = @seLinuxOptions;
          this.SupplementalGroups = @supplementalGroups;
          this.Sysctls = @sysctls;
          this.WindowsOptions = @windowsOptions;
      }

    }
    /// <summary>
    /// PodSpec is a description of a pod.
    /// </summary>
    [OutputType]
    public sealed class PodSpec
    {
      /// <summary>
        /// Optional duration in seconds the pod may be active on the node relative to StartTime
        /// before the system will actively try to mark it failed and kill associated containers.
        /// Value must be a positive integer.
        /// </summary>
      public readonly int ActiveDeadlineSeconds;

      /// <summary>
        /// If specified, the pod's scheduling constraints
        /// </summary>
      public readonly Core.V1.Affinity Affinity;

      /// <summary>
        /// AutomountServiceAccountToken indicates whether a service account token should be
        /// automatically mounted.
        /// </summary>
      public readonly bool AutomountServiceAccountToken;

      /// <summary>
        /// List of containers belonging to the pod. Containers cannot currently be added or
        /// removed. There must be at least one container in a Pod. Cannot be updated.
        /// </summary>
      public readonly ImmutableArray<Core.V1.Container> Containers;

      /// <summary>
        /// Specifies the DNS parameters of a pod. Parameters specified here will be merged to the
        /// generated DNS configuration based on DNSPolicy.
        /// </summary>
      public readonly Core.V1.PodDNSConfig DnsConfig;

      /// <summary>
        /// Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are
        /// 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in
        /// DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options
        /// set along with hostNetwork, you have to specify DNS policy explicitly to
        /// 'ClusterFirstWithHostNet'.
        /// </summary>
      public readonly string DnsPolicy;

      /// <summary>
        /// EnableServiceLinks indicates whether information about services should be injected into
        /// pod's environment variables, matching the syntax of Docker links. Optional: Defaults to
        /// true.
        /// </summary>
      public readonly bool EnableServiceLinks;

      /// <summary>
        /// List of ephemeral containers run in this pod. Ephemeral containers may be run in an
        /// existing pod to perform user-initiated actions such as debugging. This list cannot be
        /// specified when creating a pod, and it cannot be modified by updating the pod spec. In
        /// order to add an ephemeral container to an existing pod, use the pod's
        /// ephemeralcontainers subresource. This field is alpha-level and is only honored by
        /// servers that enable the EphemeralContainers feature.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EphemeralContainer> EphemeralContainers;

      /// <summary>
        /// HostAliases is an optional list of hosts and IPs that will be injected into the pod's
        /// hosts file if specified. This is only valid for non-hostNetwork pods.
        /// </summary>
      public readonly ImmutableArray<Core.V1.HostAlias> HostAliases;

      /// <summary>
        /// Use the host's ipc namespace. Optional: Default to false.
        /// </summary>
      public readonly bool HostIPC;

      /// <summary>
        /// Host networking requested for this pod. Use the host's network namespace. If this option
        /// is set, the ports that will be used must be specified. Default to false.
        /// </summary>
      public readonly bool HostNetwork;

      /// <summary>
        /// Use the host's pid namespace. Optional: Default to false.
        /// </summary>
      public readonly bool HostPID;

      /// <summary>
        /// Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a
        /// system-defined value.
        /// </summary>
      public readonly string Hostname;

      /// <summary>
        /// ImagePullSecrets is an optional list of references to secrets in the same namespace to
        /// use for pulling any of the images used by this PodSpec. If specified, these secrets will
        /// be passed to individual puller implementations for them to use. For example, in the case
        /// of docker, only DockerConfig type secrets are honored. More info:
        /// https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
        /// </summary>
      public readonly ImmutableArray<Core.V1.LocalObjectReference> ImagePullSecrets;

      /// <summary>
        /// List of initialization containers belonging to the pod. Init containers are executed in
        /// order prior to containers being started. If any init container fails, the pod is
        /// considered to have failed and is handled according to its restartPolicy. The name for an
        /// init container or normal container must be unique among all containers. Init containers
        /// may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
        /// The resourceRequirements of an init container are taken into account during scheduling
        /// by finding the highest request/limit for each resource type, and then using the max of
        /// of that value or the sum of the normal containers. Limits are applied to init containers
        /// in a similar fashion. Init containers cannot currently be added or removed. Cannot be
        /// updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        /// </summary>
      public readonly ImmutableArray<Core.V1.Container> InitContainers;

      /// <summary>
        /// NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the
        /// scheduler simply schedules this pod onto that node, assuming that it fits resource
        /// requirements.
        /// </summary>
      public readonly string NodeName;

      /// <summary>
        /// NodeSelector is a selector which must be true for the pod to fit on a node. Selector
        /// which must match a node's labels for the pod to be scheduled on that node. More info:
        /// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        /// </summary>
      public readonly ImmutableDictionary<string, string> NodeSelector;

      /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a given
        /// RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass
        /// admission controller. If the RuntimeClass admission controller is enabled, overhead must
        /// not be set in Pod create requests. The RuntimeClass admission controller will reject Pod
        /// create requests which have the overhead already set. If RuntimeClass is configured and
        /// selected in the PodSpec, Overhead will be set to the value defined in the corresponding
        /// RuntimeClass, otherwise it will remain unset and treated as zero. More info:
        /// https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
        /// alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the
        /// PodOverhead feature.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Overhead;

      /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
      public readonly string PreemptionPolicy;

      /// <summary>
        /// The priority value. Various system components use this field to find the priority of the
        /// pod. When Priority Admission Controller is enabled, it prevents users from setting this
        /// field. The admission controller populates this field from PriorityClassName. The higher
        /// the value, the higher the priority.
        /// </summary>
      public readonly int Priority;

      /// <summary>
        /// If specified, indicates the pod's priority. "system-node-critical" and
        /// "system-cluster-critical" are two special keywords which indicate the highest priorities
        /// with the former being the highest priority. Any other name must be defined by creating a
        /// PriorityClass object with that name. If not specified, the pod priority will be default
        /// or zero if there is no default.
        /// </summary>
      public readonly string PriorityClassName;

      /// <summary>
        /// If specified, all readiness gates will be evaluated for pod readiness. A pod is ready
        /// when all its containers are ready AND all conditions specified in the readiness gates
        /// have status equal to "True" More info:
        /// https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        /// </summary>
      public readonly ImmutableArray<Core.V1.PodReadinessGate> ReadinessGates;

      /// <summary>
        /// Restart policy for all containers within the pod. One of Always, OnFailure, Never.
        /// Default to Always. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
        /// </summary>
      public readonly string RestartPolicy;

      /// <summary>
        /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should
        /// be used to run this pod.  If no RuntimeClass resource matches the named class, the pod
        /// will not be run. If unset or empty, the "legacy" RuntimeClass will be used, which is an
        /// implicit class with an empty definition that uses the default runtime handler. More
        /// info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md This is a beta
        /// feature as of Kubernetes v1.14.
        /// </summary>
      public readonly string RuntimeClassName;

      /// <summary>
        /// If specified, the pod will be dispatched by specified scheduler. If not specified, the
        /// pod will be dispatched by default scheduler.
        /// </summary>
      public readonly string SchedulerName;

      /// <summary>
        /// SecurityContext holds pod-level security attributes and common container settings.
        /// Optional: Defaults to empty.  See type description for default values of each field.
        /// </summary>
      public readonly Core.V1.PodSecurityContext SecurityContext;

      /// <summary>
        /// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use
        /// serviceAccountName instead.
        /// </summary>
      public readonly string ServiceAccount;

      /// <summary>
        /// ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        /// </summary>
      public readonly string ServiceAccountName;

      /// <summary>
        /// Share a single process namespace between all of the containers in a pod. When this is
        /// set containers will be able to view and signal processes from other containers in the
        /// same pod, and the first process in each container will not be assigned PID 1. HostPID
        /// and ShareProcessNamespace cannot both be set. Optional: Default to false.
        /// </summary>
      public readonly bool ShareProcessNamespace;

      /// <summary>
        /// If specified, the fully qualified Pod hostname will be
        /// "&amp;lt;hostname&amp;gt;.&amp;lt;subdomain&amp;gt;.&amp;lt;pod
        /// namespace&amp;gt;.svc.&amp;lt;cluster domain&amp;gt;". If not specified, the pod will
        /// not have a domainname at all.
        /// </summary>
      public readonly string Subdomain;

      /// <summary>
        /// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in
        /// delete request. Value must be non-negative integer. The value zero indicates delete
        /// immediately. If this value is nil, the default grace period will be used instead. The
        /// grace period is the duration in seconds after the processes running in the pod are sent
        /// a termination signal and the time when the processes are forcibly halted with a kill
        /// signal. Set this value longer than the expected cleanup time for your process. Defaults
        /// to 30 seconds.
        /// </summary>
      public readonly int TerminationGracePeriodSeconds;

      /// <summary>
        /// If specified, the pod's tolerations.
        /// </summary>
      public readonly ImmutableArray<Core.V1.Toleration> Tolerations;

      /// <summary>
        /// TopologySpreadConstraints describes how a group of pods ought to spread across topology
        /// domains. Scheduler will schedule pods in a way which abides by the constraints. This
        /// field is alpha-level and is only honored by clusters that enables the EvenPodsSpread
        /// feature. All topologySpreadConstraints are ANDed.
        /// </summary>
      public readonly ImmutableArray<Core.V1.TopologySpreadConstraint> TopologySpreadConstraints;

      /// <summary>
        /// List of volumes that can be mounted by containers belonging to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes
        /// </summary>
      public readonly ImmutableArray<Core.V1.Volume> Volumes;

      [OutputConstructor]
      private PodSpec(
          int @activeDeadlineSeconds,
          Core.V1.Affinity @affinity,
          bool @automountServiceAccountToken,
          ImmutableArray<Core.V1.Container> @containers,
          Core.V1.PodDNSConfig @dnsConfig,
          string @dnsPolicy,
          bool @enableServiceLinks,
          ImmutableArray<Core.V1.EphemeralContainer> @ephemeralContainers,
          ImmutableArray<Core.V1.HostAlias> @hostAliases,
          bool @hostIPC,
          bool @hostNetwork,
          bool @hostPID,
          string @hostname,
          ImmutableArray<Core.V1.LocalObjectReference> @imagePullSecrets,
          ImmutableArray<Core.V1.Container> @initContainers,
          string @nodeName,
          ImmutableDictionary<string, string> @nodeSelector,
          ImmutableDictionary<string, string> @overhead,
          string @preemptionPolicy,
          int @priority,
          string @priorityClassName,
          ImmutableArray<Core.V1.PodReadinessGate> @readinessGates,
          string @restartPolicy,
          string @runtimeClassName,
          string @schedulerName,
          Core.V1.PodSecurityContext @securityContext,
          string @serviceAccount,
          string @serviceAccountName,
          bool @shareProcessNamespace,
          string @subdomain,
          int @terminationGracePeriodSeconds,
          ImmutableArray<Core.V1.Toleration> @tolerations,
          ImmutableArray<Core.V1.TopologySpreadConstraint> @topologySpreadConstraints,
          ImmutableArray<Core.V1.Volume> @volumes)
      {
          this.ActiveDeadlineSeconds = @activeDeadlineSeconds;
          this.Affinity = @affinity;
          this.AutomountServiceAccountToken = @automountServiceAccountToken;
          this.Containers = @containers;
          this.DnsConfig = @dnsConfig;
          this.DnsPolicy = @dnsPolicy;
          this.EnableServiceLinks = @enableServiceLinks;
          this.EphemeralContainers = @ephemeralContainers;
          this.HostAliases = @hostAliases;
          this.HostIPC = @hostIPC;
          this.HostNetwork = @hostNetwork;
          this.HostPID = @hostPID;
          this.Hostname = @hostname;
          this.ImagePullSecrets = @imagePullSecrets;
          this.InitContainers = @initContainers;
          this.NodeName = @nodeName;
          this.NodeSelector = @nodeSelector;
          this.Overhead = @overhead;
          this.PreemptionPolicy = @preemptionPolicy;
          this.Priority = @priority;
          this.PriorityClassName = @priorityClassName;
          this.ReadinessGates = @readinessGates;
          this.RestartPolicy = @restartPolicy;
          this.RuntimeClassName = @runtimeClassName;
          this.SchedulerName = @schedulerName;
          this.SecurityContext = @securityContext;
          this.ServiceAccount = @serviceAccount;
          this.ServiceAccountName = @serviceAccountName;
          this.ShareProcessNamespace = @shareProcessNamespace;
          this.Subdomain = @subdomain;
          this.TerminationGracePeriodSeconds = @terminationGracePeriodSeconds;
          this.Tolerations = @tolerations;
          this.TopologySpreadConstraints = @topologySpreadConstraints;
          this.Volumes = @volumes;
      }

    }
    /// <summary>
    /// PodStatus represents information about the status of a pod. Status may trail the actual
    /// state of a system, especially if the node that hosts the pod cannot contact the control
    /// plane.
    /// </summary>
    [OutputType]
    public sealed class PodStatus
    {
      /// <summary>
        /// Current service state of pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
        /// </summary>
      public readonly ImmutableArray<Core.V1.PodCondition> Conditions;

      /// <summary>
        /// The list has one entry per container in the manifest. Each entry is currently the output
        /// of `docker inspect`. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
        /// </summary>
      public readonly ImmutableArray<Core.V1.ContainerStatus> ContainerStatuses;

      /// <summary>
        /// Status for any ephemeral containers that have run in this pod. This field is alpha-level
        /// and is only populated by servers that enable the EphemeralContainers feature.
        /// </summary>
      public readonly ImmutableArray<Core.V1.ContainerStatus> EphemeralContainerStatuses;

      /// <summary>
        /// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
        /// </summary>
      public readonly string HostIP;

      /// <summary>
        /// The list has one entry per init container in the manifest. The most recent successful
        /// init container will have ready = true, the most recently started container will have
        /// startTime set. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
        /// </summary>
      public readonly ImmutableArray<Core.V1.ContainerStatus> InitContainerStatuses;

      /// <summary>
        /// A human readable message indicating details about why the pod is in this condition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// nominatedNodeName is set only when this pod preempts other pods on the node, but it
        /// cannot be scheduled right away as preemption victims receive their graceful termination
        /// periods. This field does not guarantee that the pod will be scheduled on this node.
        /// Scheduler may decide to place the pod elsewhere if other nodes become available sooner.
        /// Scheduler may also decide to give the resources on this node to a higher priority pod
        /// that is created after preemption. As a result, this field may be different than
        /// PodSpec.nodeName when the pod is scheduled.
        /// </summary>
      public readonly string NominatedNodeName;

      /// <summary>
        /// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
        /// The conditions array, the reason and message fields, and the individual container status
        /// arrays contain more detail about the pod's status. There are five possible phase values:
        /// 
        /// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
        /// container images has not been created. This includes time before being scheduled as well
        /// as time spent downloading images over the network, which could take a while. Running:
        /// The pod has been bound to a node, and all of the containers have been created. At least
        /// one container is still running, or is in the process of starting or restarting.
        /// Succeeded: All containers in the pod have terminated in success, and will not be
        /// restarted. Failed: All containers in the pod have terminated, and at least one container
        /// has terminated in failure. The container either exited with non-zero status or was
        /// terminated by the system. Unknown: For some reason the state of the pod could not be
        /// obtained, typically due to an error in communicating with the host of the pod.
        /// 
        /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
        /// </summary>
      public readonly string Phase;

      /// <summary>
        /// IP address allocated to the pod. Routable at least within the cluster. Empty if not yet
        /// allocated.
        /// </summary>
      public readonly string PodIP;

      /// <summary>
        /// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th
        /// entry must match the podIP field. Pods may be allocated at most 1 value for each of IPv4
        /// and IPv6. This list is empty if no IPs have been allocated yet.
        /// </summary>
      public readonly ImmutableArray<Core.V1.PodIP> PodIPs;

      /// <summary>
        /// The Quality of Service (QOS) classification assigned to the pod based on resource
        /// requirements See PodQOSClass type for available QOS classes More info:
        /// https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
        /// </summary>
      public readonly string QosClass;

      /// <summary>
        /// A brief CamelCase message indicating details about why the pod is in this state. e.g.
        /// 'Evicted'
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// RFC 3339 date and time at which the object was acknowledged by the Kubelet. This is
        /// before the Kubelet pulled the container image(s) for the pod.
        /// </summary>
      public readonly string StartTime;

      [OutputConstructor]
      private PodStatus(
          ImmutableArray<Core.V1.PodCondition> @conditions,
          ImmutableArray<Core.V1.ContainerStatus> @containerStatuses,
          ImmutableArray<Core.V1.ContainerStatus> @ephemeralContainerStatuses,
          string @hostIP,
          ImmutableArray<Core.V1.ContainerStatus> @initContainerStatuses,
          string @message,
          string @nominatedNodeName,
          string @phase,
          string @podIP,
          ImmutableArray<Core.V1.PodIP> @podIPs,
          string @qosClass,
          string @reason,
          string @startTime)
      {
          this.Conditions = @conditions;
          this.ContainerStatuses = @containerStatuses;
          this.EphemeralContainerStatuses = @ephemeralContainerStatuses;
          this.HostIP = @hostIP;
          this.InitContainerStatuses = @initContainerStatuses;
          this.Message = @message;
          this.NominatedNodeName = @nominatedNodeName;
          this.Phase = @phase;
          this.PodIP = @podIP;
          this.PodIPs = @podIPs;
          this.QosClass = @qosClass;
          this.Reason = @reason;
          this.StartTime = @startTime;
      }

    }
    /// <summary>
    /// PodTemplate describes a template for creating copies of a predefined pod.
    /// </summary>
    [OutputType]
    public sealed class PodTemplate
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Template defines the pods that will be created from this pod template.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      [OutputConstructor]
      private PodTemplate(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.PodTemplateSpec @template)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Template = @template;
      }

    }
    /// <summary>
    /// PodTemplateList is a list of PodTemplates.
    /// </summary>
    [OutputType]
    public sealed class PodTemplateList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of pod templates
        /// </summary>
      public readonly ImmutableArray<Core.V1.PodTemplate> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PodTemplateList(
          string @apiVersion,
          ImmutableArray<Core.V1.PodTemplate> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PodTemplateSpec describes the data a pod should have when created from a template
    /// </summary>
    [OutputType]
    public sealed class PodTemplateSpec
    {
      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of the pod. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.PodSpec Spec;

      [OutputConstructor]
      private PodTemplateSpec(
          Meta.V1.ObjectMeta @metadata,
          Core.V1.PodSpec @spec)
      {
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// PortworxVolumeSource represents a Portworx volume resource.
    /// </summary>
    [OutputType]
    public sealed class PortworxVolumeSource
    {
      /// <summary>
        /// FSType represents the filesystem type to mount Must be a filesystem type supported by
        /// the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if
        /// unspecified.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// VolumeID uniquely identifies a Portworx volume
        /// </summary>
      public readonly string VolumeID;

      [OutputConstructor]
      private PortworxVolumeSource(
          string @fsType,
          bool @readOnly,
          string @volumeID)
      {
          this.FsType = @fsType;
          this.ReadOnly = @readOnly;
          this.VolumeID = @volumeID;
      }

    }
    /// <summary>
    /// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a
    /// no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
    /// </summary>
    [OutputType]
    public sealed class PreferredSchedulingTerm
    {
      /// <summary>
        /// A node selector term, associated with the corresponding weight.
        /// </summary>
      public readonly Core.V1.NodeSelectorTerm Preference;

      /// <summary>
        /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        /// </summary>
      public readonly int Weight;

      [OutputConstructor]
      private PreferredSchedulingTerm(
          Core.V1.NodeSelectorTerm @preference,
          int @weight)
      {
          this.Preference = @preference;
          this.Weight = @weight;
      }

    }
    /// <summary>
    /// Probe describes a health check to be performed against a container to determine whether it
    /// is alive or ready to receive traffic.
    /// </summary>
    [OutputType]
    public sealed class Probe
    {
      /// <summary>
        /// One and only one of the following should be specified. Exec specifies the action to
        /// take.
        /// </summary>
      public readonly Core.V1.ExecAction Exec;

      /// <summary>
        /// Minimum consecutive failures for the probe to be considered failed after having
        /// succeeded. Defaults to 3. Minimum value is 1.
        /// </summary>
      public readonly int FailureThreshold;

      /// <summary>
        /// HTTPGet specifies the http request to perform.
        /// </summary>
      public readonly Core.V1.HTTPGetAction HttpGet;

      /// <summary>
        /// Number of seconds after the container has started before liveness probes are initiated.
        /// More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
      public readonly int InitialDelaySeconds;

      /// <summary>
        /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        /// </summary>
      public readonly int PeriodSeconds;

      /// <summary>
        /// Minimum consecutive successes for the probe to be considered successful after having
        /// failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
        /// </summary>
      public readonly int SuccessThreshold;

      /// <summary>
        /// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        /// </summary>
      public readonly Core.V1.TCPSocketAction TcpSocket;

      /// <summary>
        /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value
        /// is 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
      public readonly int TimeoutSeconds;

      [OutputConstructor]
      private Probe(
          Core.V1.ExecAction @exec,
          int @failureThreshold,
          Core.V1.HTTPGetAction @httpGet,
          int @initialDelaySeconds,
          int @periodSeconds,
          int @successThreshold,
          Core.V1.TCPSocketAction @tcpSocket,
          int @timeoutSeconds)
      {
          this.Exec = @exec;
          this.FailureThreshold = @failureThreshold;
          this.HttpGet = @httpGet;
          this.InitialDelaySeconds = @initialDelaySeconds;
          this.PeriodSeconds = @periodSeconds;
          this.SuccessThreshold = @successThreshold;
          this.TcpSocket = @tcpSocket;
          this.TimeoutSeconds = @timeoutSeconds;
      }

    }
    /// <summary>
    /// Represents a projected volume source
    /// </summary>
    [OutputType]
    public sealed class ProjectedVolumeSource
    {
      /// <summary>
        /// Mode bits to use on created files by default. Must be a value between 0 and 0777.
        /// Directories within the path are not affected by this setting. This might be in conflict
        /// with other options that affect the file mode, like fsGroup, and the result can be other
        /// mode bits set.
        /// </summary>
      public readonly int DefaultMode;

      /// <summary>
        /// list of volume projections
        /// </summary>
      public readonly ImmutableArray<Core.V1.VolumeProjection> Sources;

      [OutputConstructor]
      private ProjectedVolumeSource(
          int @defaultMode,
          ImmutableArray<Core.V1.VolumeProjection> @sources)
      {
          this.DefaultMode = @defaultMode;
          this.Sources = @sources;
      }

    }
    /// <summary>
    /// Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support
    /// ownership management or SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class QuobyteVolumeSource
    {
      /// <summary>
        /// Group to map volume access to Default is no group
        /// </summary>
      public readonly string Group;

      /// <summary>
        /// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
        /// Defaults to false.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Registry represents a single or multiple Quobyte Registry services specified as a string
        /// as host:port pair (multiple entries are separated with commas) which acts as the central
        /// registry for volumes
        /// </summary>
      public readonly string Registry;

      /// <summary>
        /// Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned
        /// Quobyte volumes, value is set by the plugin
        /// </summary>
      public readonly string Tenant;

      /// <summary>
        /// User to map volume access to Defaults to serivceaccount user
        /// </summary>
      public readonly string User;

      /// <summary>
        /// Volume is a string that references an already created Quobyte volume by name.
        /// </summary>
      public readonly string Volume;

      [OutputConstructor]
      private QuobyteVolumeSource(
          string @group,
          bool @readOnly,
          string @registry,
          string @tenant,
          string @user,
          string @volume)
      {
          this.Group = @group;
          this.ReadOnly = @readOnly;
          this.Registry = @registry;
          this.Tenant = @tenant;
          this.User = @user;
          this.Volume = @volume;
      }

    }
    /// <summary>
    /// Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support
    /// ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class RBDPersistentVolumeSource
    {
      /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#rbd
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// The rados image name. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly string Image;

      /// <summary>
        /// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly string Keyring;

      /// <summary>
        /// A collection of Ceph monitors. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly ImmutableArray<string> Monitors;

      /// <summary>
        /// The rados pool name. Default is rbd. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly string Pool;

      /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// SecretRef is name of the authentication secret for RBDUser. If provided overrides
        /// keyring. Default is nil. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly Core.V1.SecretReference SecretRef;

      /// <summary>
        /// The rados user name. Default is admin. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly string User;

      [OutputConstructor]
      private RBDPersistentVolumeSource(
          string @fsType,
          string @image,
          string @keyring,
          ImmutableArray<string> @monitors,
          string @pool,
          bool @readOnly,
          Core.V1.SecretReference @secretRef,
          string @user)
      {
          this.FsType = @fsType;
          this.Image = @image;
          this.Keyring = @keyring;
          this.Monitors = @monitors;
          this.Pool = @pool;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.User = @user;
      }

    }
    /// <summary>
    /// Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support
    /// ownership management and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class RBDVolumeSource
    {
      /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
        /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs".
        /// Implicitly inferred to be "ext4" if unspecified. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#rbd
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// The rados image name. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly string Image;

      /// <summary>
        /// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly string Keyring;

      /// <summary>
        /// A collection of Ceph monitors. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly ImmutableArray<string> Monitors;

      /// <summary>
        /// The rados pool name. Default is rbd. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly string Pool;

      /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// SecretRef is name of the authentication secret for RBDUser. If provided overrides
        /// keyring. Default is nil. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly Core.V1.LocalObjectReference SecretRef;

      /// <summary>
        /// The rados user name. Default is admin. More info:
        /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
      public readonly string User;

      [OutputConstructor]
      private RBDVolumeSource(
          string @fsType,
          string @image,
          string @keyring,
          ImmutableArray<string> @monitors,
          string @pool,
          bool @readOnly,
          Core.V1.LocalObjectReference @secretRef,
          string @user)
      {
          this.FsType = @fsType;
          this.Image = @image;
          this.Keyring = @keyring;
          this.Monitors = @monitors;
          this.Pool = @pool;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.User = @user;
      }

    }
    /// <summary>
    /// ReplicationController represents the configuration of a replication controller.
    /// </summary>
    [OutputType]
    public sealed class ReplicationController
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// If the Labels of a ReplicationController are empty, they are defaulted to be the same as
        /// the Pod(s) that the replication controller manages. Standard object's metadata. More
        /// info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the specification of the desired behavior of the replication controller.
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.ReplicationControllerSpec Spec;

      /// <summary>
        /// Status is the most recently observed status of the replication controller. This data may
        /// be out of date by some window of time. Populated by the system. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.ReplicationControllerStatus Status;

      [OutputConstructor]
      private ReplicationController(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.ReplicationControllerSpec @spec,
          Core.V1.ReplicationControllerStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// ReplicationControllerCondition describes the state of a replication controller at a certain
    /// point.
    /// </summary>
    [OutputType]
    public sealed class ReplicationControllerCondition
    {
      /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of replication controller condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private ReplicationControllerCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// ReplicationControllerList is a collection of replication controllers.
    /// </summary>
    [OutputType]
    public sealed class ReplicationControllerList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of replication controllers. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
      public readonly ImmutableArray<Core.V1.ReplicationController> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ReplicationControllerList(
          string @apiVersion,
          ImmutableArray<Core.V1.ReplicationController> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ReplicationControllerSpec is the specification of a replication controller.
    /// </summary>
    [OutputType]
    public sealed class ReplicationControllerSpec
    {
      /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// Selector is a label query over pods that should match the Replicas count. If Selector is
        /// empty, it is defaulted to the labels present on the Pod template. Label keys and values
        /// that must match in order to be controlled by this replication controller, if empty
        /// defaulted to labels on Pod template. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly ImmutableDictionary<string, string> Selector;

      /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. This takes precedence over a TemplateRef. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      [OutputConstructor]
      private ReplicationControllerSpec(
          int @minReadySeconds,
          int @replicas,
          ImmutableDictionary<string, string> @selector,
          Core.V1.PodTemplateSpec @template)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.Replicas = @replicas;
          this.Selector = @selector;
          this.Template = @template;
      }

    }
    /// <summary>
    /// ReplicationControllerStatus represents the current status of a replication controller.
    /// </summary>
    [OutputType]
    public sealed class ReplicationControllerStatus
    {
      /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this
        /// replication controller.
        /// </summary>
      public readonly int AvailableReplicas;

      /// <summary>
        /// Represents the latest available observations of a replication controller's current
        /// state.
        /// </summary>
      public readonly ImmutableArray<Core.V1.ReplicationControllerCondition> Conditions;

      /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replication controller.
        /// </summary>
      public readonly int FullyLabeledReplicas;

      /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed replication
        /// controller.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// The number of ready replicas for this replication controller.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
        /// </summary>
      public readonly int Replicas;

      [OutputConstructor]
      private ReplicationControllerStatus(
          int @availableReplicas,
          ImmutableArray<Core.V1.ReplicationControllerCondition> @conditions,
          int @fullyLabeledReplicas,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas)
      {
          this.AvailableReplicas = @availableReplicas;
          this.Conditions = @conditions;
          this.FullyLabeledReplicas = @fullyLabeledReplicas;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
      }

    }
    /// <summary>
    /// ResourceFieldSelector represents container resources (cpu, memory) and their output format
    /// </summary>
    [OutputType]
    public sealed class ResourceFieldSelector
    {
      /// <summary>
        /// Container name: required for volumes, optional for env vars
        /// </summary>
      public readonly string ContainerName;

      /// <summary>
        /// Specifies the output format of the exposed resources, defaults to "1"
        /// </summary>
      public readonly string Divisor;

      /// <summary>
        /// Required: resource to select
        /// </summary>
      public readonly string Resource;

      [OutputConstructor]
      private ResourceFieldSelector(
          string @containerName,
          string @divisor,
          string @resource)
      {
          this.ContainerName = @containerName;
          this.Divisor = @divisor;
          this.Resource = @resource;
      }

    }
    /// <summary>
    /// ResourceQuota sets aggregate quota restrictions enforced per namespace
    /// </summary>
    [OutputType]
    public sealed class ResourceQuota
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the desired quota.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.ResourceQuotaSpec Spec;

      /// <summary>
        /// Status defines the actual enforced quota and its current usage.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.ResourceQuotaStatus Status;

      [OutputConstructor]
      private ResourceQuota(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.ResourceQuotaSpec @spec,
          Core.V1.ResourceQuotaStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// ResourceQuotaList is a list of ResourceQuota items.
    /// </summary>
    [OutputType]
    public sealed class ResourceQuotaList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of ResourceQuota objects. More info:
        /// https://kubernetes.io/docs/concepts/policy/resource-quotas/
        /// </summary>
      public readonly ImmutableArray<Core.V1.ResourceQuota> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ResourceQuotaList(
          string @apiVersion,
          ImmutableArray<Core.V1.ResourceQuota> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
    /// </summary>
    [OutputType]
    public sealed class ResourceQuotaSpec
    {
      /// <summary>
        /// hard is the set of desired hard limits for each named resource. More info:
        /// https://kubernetes.io/docs/concepts/policy/resource-quotas/
        /// </summary>
      public readonly ImmutableDictionary<string, string> Hard;

      /// <summary>
        /// scopeSelector is also a collection of filters like scopes that must match each object
        /// tracked by a quota but expressed using ScopeSelectorOperator in combination with
        /// possible values. For a resource to match, both scopes AND scopeSelector (if specified in
        /// spec), must be matched.
        /// </summary>
      public readonly Core.V1.ScopeSelector ScopeSelector;

      /// <summary>
        /// A collection of filters that must match each object tracked by a quota. If not
        /// specified, the quota matches all objects.
        /// </summary>
      public readonly ImmutableArray<string> Scopes;

      [OutputConstructor]
      private ResourceQuotaSpec(
          ImmutableDictionary<string, string> @hard,
          Core.V1.ScopeSelector @scopeSelector,
          ImmutableArray<string> @scopes)
      {
          this.Hard = @hard;
          this.ScopeSelector = @scopeSelector;
          this.Scopes = @scopes;
      }

    }
    /// <summary>
    /// ResourceQuotaStatus defines the enforced hard limits and observed use.
    /// </summary>
    [OutputType]
    public sealed class ResourceQuotaStatus
    {
      /// <summary>
        /// Hard is the set of enforced hard limits for each named resource. More info:
        /// https://kubernetes.io/docs/concepts/policy/resource-quotas/
        /// </summary>
      public readonly ImmutableDictionary<string, string> Hard;

      /// <summary>
        /// Used is the current observed total usage of the resource in the namespace.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Used;

      [OutputConstructor]
      private ResourceQuotaStatus(
          ImmutableDictionary<string, string> @hard,
          ImmutableDictionary<string, string> @used)
      {
          this.Hard = @hard;
          this.Used = @used;
      }

    }
    /// <summary>
    /// ResourceRequirements describes the compute resource requirements.
    /// </summary>
    [OutputType]
    public sealed class ResourceRequirements
    {
      /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
      public readonly ImmutableDictionary<string, string> Limits;

      /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is
        /// omitted for a container, it defaults to Limits if that is explicitly specified,
        /// otherwise to an implementation-defined value. More info:
        /// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        /// </summary>
      public readonly ImmutableDictionary<string, string> Requests;

      [OutputConstructor]
      private ResourceRequirements(
          ImmutableDictionary<string, string> @limits,
          ImmutableDictionary<string, string> @requests)
      {
          this.Limits = @limits;
          this.Requests = @requests;
      }

    }
    /// <summary>
    /// SELinuxOptions are the labels to be applied to the container
    /// </summary>
    [OutputType]
    public sealed class SELinuxOptions
    {
      /// <summary>
        /// Level is SELinux level label that applies to the container.
        /// </summary>
      public readonly string Level;

      /// <summary>
        /// Role is a SELinux role label that applies to the container.
        /// </summary>
      public readonly string Role;

      /// <summary>
        /// Type is a SELinux type label that applies to the container.
        /// </summary>
      public readonly string Type;

      /// <summary>
        /// User is a SELinux user label that applies to the container.
        /// </summary>
      public readonly string User;

      [OutputConstructor]
      private SELinuxOptions(
          string @level,
          string @role,
          string @type,
          string @user)
      {
          this.Level = @level;
          this.Role = @role;
          this.Type = @type;
          this.User = @user;
      }

    }
    /// <summary>
    /// ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
    /// </summary>
    [OutputType]
    public sealed class ScaleIOPersistentVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Default is "xfs"
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// The host address of the ScaleIO API Gateway.
        /// </summary>
      public readonly string Gateway;

      /// <summary>
        /// The name of the ScaleIO Protection Domain for the configured storage.
        /// </summary>
      public readonly string ProtectionDomain;

      /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// SecretRef references to the secret for ScaleIO user and other sensitive information. If
        /// this is not provided, Login operation will fail.
        /// </summary>
      public readonly Core.V1.SecretReference SecretRef;

      /// <summary>
        /// Flag to enable/disable SSL communication with Gateway, default false
        /// </summary>
      public readonly bool SslEnabled;

      /// <summary>
        /// Indicates whether the storage for a volume should be ThickProvisioned or
        /// ThinProvisioned. Default is ThinProvisioned.
        /// </summary>
      public readonly string StorageMode;

      /// <summary>
        /// The ScaleIO Storage Pool associated with the protection domain.
        /// </summary>
      public readonly string StoragePool;

      /// <summary>
        /// The name of the storage system as configured in ScaleIO.
        /// </summary>
      public readonly string System;

      /// <summary>
        /// The name of a volume already created in the ScaleIO system that is associated with this
        /// volume source.
        /// </summary>
      public readonly string VolumeName;

      [OutputConstructor]
      private ScaleIOPersistentVolumeSource(
          string @fsType,
          string @gateway,
          string @protectionDomain,
          bool @readOnly,
          Core.V1.SecretReference @secretRef,
          bool @sslEnabled,
          string @storageMode,
          string @storagePool,
          string @system,
          string @volumeName)
      {
          this.FsType = @fsType;
          this.Gateway = @gateway;
          this.ProtectionDomain = @protectionDomain;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.SslEnabled = @sslEnabled;
          this.StorageMode = @storageMode;
          this.StoragePool = @storagePool;
          this.System = @system;
          this.VolumeName = @volumeName;
      }

    }
    /// <summary>
    /// ScaleIOVolumeSource represents a persistent ScaleIO volume
    /// </summary>
    [OutputType]
    public sealed class ScaleIOVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// The host address of the ScaleIO API Gateway.
        /// </summary>
      public readonly string Gateway;

      /// <summary>
        /// The name of the ScaleIO Protection Domain for the configured storage.
        /// </summary>
      public readonly string ProtectionDomain;

      /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// SecretRef references to the secret for ScaleIO user and other sensitive information. If
        /// this is not provided, Login operation will fail.
        /// </summary>
      public readonly Core.V1.LocalObjectReference SecretRef;

      /// <summary>
        /// Flag to enable/disable SSL communication with Gateway, default false
        /// </summary>
      public readonly bool SslEnabled;

      /// <summary>
        /// Indicates whether the storage for a volume should be ThickProvisioned or
        /// ThinProvisioned. Default is ThinProvisioned.
        /// </summary>
      public readonly string StorageMode;

      /// <summary>
        /// The ScaleIO Storage Pool associated with the protection domain.
        /// </summary>
      public readonly string StoragePool;

      /// <summary>
        /// The name of the storage system as configured in ScaleIO.
        /// </summary>
      public readonly string System;

      /// <summary>
        /// The name of a volume already created in the ScaleIO system that is associated with this
        /// volume source.
        /// </summary>
      public readonly string VolumeName;

      [OutputConstructor]
      private ScaleIOVolumeSource(
          string @fsType,
          string @gateway,
          string @protectionDomain,
          bool @readOnly,
          Core.V1.LocalObjectReference @secretRef,
          bool @sslEnabled,
          string @storageMode,
          string @storagePool,
          string @system,
          string @volumeName)
      {
          this.FsType = @fsType;
          this.Gateway = @gateway;
          this.ProtectionDomain = @protectionDomain;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.SslEnabled = @sslEnabled;
          this.StorageMode = @storageMode;
          this.StoragePool = @storagePool;
          this.System = @system;
          this.VolumeName = @volumeName;
      }

    }
    /// <summary>
    /// A scope selector represents the AND of the selectors represented by the scoped-resource
    /// selector requirements.
    /// </summary>
    [OutputType]
    public sealed class ScopeSelector
    {
      /// <summary>
        /// A list of scope selector requirements by scope of the resources.
        /// </summary>
      public readonly ImmutableArray<Core.V1.ScopedResourceSelectorRequirement> MatchExpressions;

      [OutputConstructor]
      private ScopeSelector(
          ImmutableArray<Core.V1.ScopedResourceSelectorRequirement> @matchExpressions)
      {
          this.MatchExpressions = @matchExpressions;
      }

    }
    /// <summary>
    /// A scoped-resource selector requirement is a selector that contains values, a scope name, and
    /// an operator that relates the scope name and values.
    /// </summary>
    [OutputType]
    public sealed class ScopedResourceSelectorRequirement
    {
      /// <summary>
        /// Represents a scope's relationship to a set of values. Valid operators are In, NotIn,
        /// Exists, DoesNotExist.
        /// </summary>
      public readonly string Operator;

      /// <summary>
        /// The name of the scope that the selector applies to.
        /// </summary>
      public readonly string ScopeName;

      /// <summary>
        /// An array of string values. If the operator is In or NotIn, the values array must be
        /// non-empty. If the operator is Exists or DoesNotExist, the values array must be empty.
        /// This array is replaced during a strategic merge patch.
        /// </summary>
      public readonly ImmutableArray<string> Values;

      [OutputConstructor]
      private ScopedResourceSelectorRequirement(
          string @operator,
          string @scopeName,
          ImmutableArray<string> @values)
      {
          this.Operator = @operator;
          this.ScopeName = @scopeName;
          this.Values = @values;
      }

    }
    /// <summary>
    /// Secret holds secret data of a certain type. The total bytes of the values in the Data field
    /// must be less than MaxSecretSize bytes.
    /// </summary>
    [OutputType]
    public sealed class Secret
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Data contains the secret data. Each key must consist of alphanumeric characters, '-',
        /// '_' or '.'. The serialized form of the secret data is a base64 encoded string,
        /// representing the arbitrary (possibly non-string) data value here. Described in
        /// https://tools.ietf.org/html/rfc4648#section-4
        /// </summary>
      public readonly ImmutableDictionary<string, string> Data;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// stringData allows specifying non-binary secret data in string form. It is provided as a
        /// write-only convenience method. All keys and values are merged into the data field on
        /// write, overwriting any existing values. It is never output when reading from the API.
        /// </summary>
      public readonly ImmutableDictionary<string, string> StringData;

      /// <summary>
        /// Used to facilitate programmatic handling of secret data.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private Secret(
          string @apiVersion,
          ImmutableDictionary<string, string> @data,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableDictionary<string, string> @stringData,
          string @type)
      {
          this.ApiVersion = @apiVersion;
          this.Data = @data;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.StringData = @stringData;
          this.Type = @type;
      }

    }
    /// <summary>
    /// SecretEnvSource selects a Secret to populate the environment variables with.
    /// 
    /// The contents of the target Secret's Data field will represent the key-value pairs as
    /// environment variables.
    /// </summary>
    [OutputType]
    public sealed class SecretEnvSource
    {
      /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Specify whether the Secret must be defined
        /// </summary>
      public readonly bool Optional;

      [OutputConstructor]
      private SecretEnvSource(
          string @name,
          bool @optional)
      {
          this.Name = @name;
          this.Optional = @optional;
      }

    }
    /// <summary>
    /// SecretKeySelector selects a key of a Secret.
    /// </summary>
    [OutputType]
    public sealed class SecretKeySelector
    {
      /// <summary>
        /// The key of the secret to select from.  Must be a valid secret key.
        /// </summary>
      public readonly string Key;

      /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Specify whether the Secret or its key must be defined
        /// </summary>
      public readonly bool Optional;

      [OutputConstructor]
      private SecretKeySelector(
          string @key,
          string @name,
          bool @optional)
      {
          this.Key = @key;
          this.Name = @name;
          this.Optional = @optional;
      }

    }
    /// <summary>
    /// SecretList is a list of Secret.
    /// </summary>
    [OutputType]
    public sealed class SecretList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of secret objects. More info:
        /// https://kubernetes.io/docs/concepts/configuration/secret
        /// </summary>
      public readonly ImmutableArray<Core.V1.Secret> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private SecretList(
          string @apiVersion,
          ImmutableArray<Core.V1.Secret> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// Adapts a secret into a projected volume.
    /// 
    /// The contents of the target Secret's Data field will be presented in a projected volume as
    /// files using the keys in the Data field as the file names. Note that this is identical to a
    /// secret volume source without the default mode.
    /// </summary>
    [OutputType]
    public sealed class SecretProjection
    {
      /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced Secret will be
        /// projected into the volume as a file whose name is the key and content is the value. If
        /// specified, the listed keys will be projected into the specified paths, and unlisted keys
        /// will not be present. If a key is specified which is not present in the Secret, the
        /// volume setup will error unless it is marked optional. Paths must be relative and may not
        /// contain the '..' path or start with '..'.
        /// </summary>
      public readonly ImmutableArray<Core.V1.KeyToPath> Items;

      /// <summary>
        /// Name of the referent. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Specify whether the Secret or its key must be defined
        /// </summary>
      public readonly bool Optional;

      [OutputConstructor]
      private SecretProjection(
          ImmutableArray<Core.V1.KeyToPath> @items,
          string @name,
          bool @optional)
      {
          this.Items = @items;
          this.Name = @name;
          this.Optional = @optional;
      }

    }
    /// <summary>
    /// SecretReference represents a Secret Reference. It has enough information to retrieve secret
    /// in any namespace
    /// </summary>
    [OutputType]
    public sealed class SecretReference
    {
      /// <summary>
        /// Name is unique within a namespace to reference a secret resource.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace defines the space within which the secret name must be unique.
        /// </summary>
      public readonly string Namespace;

      [OutputConstructor]
      private SecretReference(
          string @name,
          string @namespace)
      {
          this.Name = @name;
          this.Namespace = @namespace;
      }

    }
    /// <summary>
    /// Adapts a Secret into a volume.
    /// 
    /// The contents of the target Secret's Data field will be presented in a volume as files using
    /// the keys in the Data field as the file names. Secret volumes support ownership management
    /// and SELinux relabeling.
    /// </summary>
    [OutputType]
    public sealed class SecretVolumeSource
    {
      /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a value between 0 and
        /// 0777. Defaults to 0644. Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file mode, like fsGroup,
        /// and the result can be other mode bits set.
        /// </summary>
      public readonly int DefaultMode;

      /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced Secret will be
        /// projected into the volume as a file whose name is the key and content is the value. If
        /// specified, the listed keys will be projected into the specified paths, and unlisted keys
        /// will not be present. If a key is specified which is not present in the Secret, the
        /// volume setup will error unless it is marked optional. Paths must be relative and may not
        /// contain the '..' path or start with '..'.
        /// </summary>
      public readonly ImmutableArray<Core.V1.KeyToPath> Items;

      /// <summary>
        /// Specify whether the Secret or its keys must be defined
        /// </summary>
      public readonly bool Optional;

      /// <summary>
        /// Name of the secret in the pod's namespace to use. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#secret
        /// </summary>
      public readonly string SecretName;

      [OutputConstructor]
      private SecretVolumeSource(
          int @defaultMode,
          ImmutableArray<Core.V1.KeyToPath> @items,
          bool @optional,
          string @secretName)
      {
          this.DefaultMode = @defaultMode;
          this.Items = @items;
          this.Optional = @optional;
          this.SecretName = @secretName;
      }

    }
    /// <summary>
    /// SecurityContext holds security configuration that will be applied to a container. Some
    /// fields are present in both SecurityContext and PodSecurityContext.  When both are set, the
    /// values in SecurityContext take precedence.
    /// </summary>
    [OutputType]
    public sealed class SecurityContext
    {
      /// <summary>
        /// AllowPrivilegeEscalation controls whether a process can gain more privileges than its
        /// parent process. This bool directly controls if the no_new_privs flag will be set on the
        /// container process. AllowPrivilegeEscalation is true always when the container is: 1) run
        /// as Privileged 2) has CAP_SYS_ADMIN
        /// </summary>
      public readonly bool AllowPrivilegeEscalation;

      /// <summary>
        /// The capabilities to add/drop when running containers. Defaults to the default set of
        /// capabilities granted by the container runtime.
        /// </summary>
      public readonly Core.V1.Capabilities Capabilities;

      /// <summary>
        /// Run container in privileged mode. Processes in privileged containers are essentially
        /// equivalent to root on the host. Defaults to false.
        /// </summary>
      public readonly bool Privileged;

      /// <summary>
        /// procMount denotes the type of proc mount to use for the containers. The default is
        /// DefaultProcMount which uses the container runtime defaults for readonly paths and masked
        /// paths. This requires the ProcMountType feature flag to be enabled.
        /// </summary>
      public readonly string ProcMount;

      /// <summary>
        /// Whether this container has a read-only root filesystem. Default is false.
        /// </summary>
      public readonly bool ReadOnlyRootFilesystem;

      /// <summary>
        /// The GID to run the entrypoint of the container process. Uses runtime default if unset.
        /// May also be set in PodSecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
      public readonly int RunAsGroup;

      /// <summary>
        /// Indicates that the container must run as a non-root user. If true, the Kubelet will
        /// validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to
        /// start the container if it does. If unset or false, no such validation will be performed.
        /// May also be set in PodSecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
      public readonly bool RunAsNonRoot;

      /// <summary>
        /// The UID to run the entrypoint of the container process. Defaults to user specified in
        /// image metadata if unspecified. May also be set in PodSecurityContext.  If set in both
        /// SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
        /// precedence.
        /// </summary>
      public readonly int RunAsUser;

      /// <summary>
        /// The SELinux context to be applied to the container. If unspecified, the container
        /// runtime will allocate a random SELinux context for each container.  May also be set in
        /// PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value
        /// specified in SecurityContext takes precedence.
        /// </summary>
      public readonly Core.V1.SELinuxOptions SeLinuxOptions;

      /// <summary>
        /// The Windows specific settings applied to all containers. If unspecified, the options
        /// from the PodSecurityContext will be used. If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
      public readonly Core.V1.WindowsSecurityContextOptions WindowsOptions;

      [OutputConstructor]
      private SecurityContext(
          bool @allowPrivilegeEscalation,
          Core.V1.Capabilities @capabilities,
          bool @privileged,
          string @procMount,
          bool @readOnlyRootFilesystem,
          int @runAsGroup,
          bool @runAsNonRoot,
          int @runAsUser,
          Core.V1.SELinuxOptions @seLinuxOptions,
          Core.V1.WindowsSecurityContextOptions @windowsOptions)
      {
          this.AllowPrivilegeEscalation = @allowPrivilegeEscalation;
          this.Capabilities = @capabilities;
          this.Privileged = @privileged;
          this.ProcMount = @procMount;
          this.ReadOnlyRootFilesystem = @readOnlyRootFilesystem;
          this.RunAsGroup = @runAsGroup;
          this.RunAsNonRoot = @runAsNonRoot;
          this.RunAsUser = @runAsUser;
          this.SeLinuxOptions = @seLinuxOptions;
          this.WindowsOptions = @windowsOptions;
      }

    }
    /// <summary>
    /// Service is a named abstraction of software service (for example, mysql) consisting of local
    /// port (for example 3306) that the proxy listens on, and the selector that determines which
    /// pods will answer requests sent through the proxy.
    /// </summary>
    [OutputType]
    public sealed class Service
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the behavior of a service.
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.ServiceSpec Spec;

      /// <summary>
        /// Most recently observed status of the service. Populated by the system. Read-only. More
        /// info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Core.V1.ServiceStatus Status;

      [OutputConstructor]
      private Service(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Core.V1.ServiceSpec @spec,
          Core.V1.ServiceStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral
    /// systems, for an identity * a principal that can be authenticated and authorized * a set of
    /// secrets
    /// </summary>
    [OutputType]
    public sealed class ServiceAccount
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// AutomountServiceAccountToken indicates whether pods running as this service account
        /// should have an API token automatically mounted. Can be overridden at the pod level.
        /// </summary>
      public readonly bool AutomountServiceAccountToken;

      /// <summary>
        /// ImagePullSecrets is a list of references to secrets in the same namespace to use for
        /// pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are
        /// distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets
        /// are only accessed by the kubelet. More info:
        /// https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        /// </summary>
      public readonly ImmutableArray<Core.V1.LocalObjectReference> ImagePullSecrets;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Secrets is the list of secrets allowed to be used by pods running using this
        /// ServiceAccount. More info: https://kubernetes.io/docs/concepts/configuration/secret
        /// </summary>
      public readonly ImmutableArray<Core.V1.ObjectReference> Secrets;

      [OutputConstructor]
      private ServiceAccount(
          string @apiVersion,
          bool @automountServiceAccountToken,
          ImmutableArray<Core.V1.LocalObjectReference> @imagePullSecrets,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<Core.V1.ObjectReference> @secrets)
      {
          this.ApiVersion = @apiVersion;
          this.AutomountServiceAccountToken = @automountServiceAccountToken;
          this.ImagePullSecrets = @imagePullSecrets;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Secrets = @secrets;
      }

    }
    /// <summary>
    /// ServiceAccountList is a list of ServiceAccount objects
    /// </summary>
    [OutputType]
    public sealed class ServiceAccountList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of ServiceAccounts. More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        /// </summary>
      public readonly ImmutableArray<Core.V1.ServiceAccount> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ServiceAccountList(
          string @apiVersion,
          ImmutableArray<Core.V1.ServiceAccount> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ServiceAccountTokenProjection represents a projected service account token volume. This
    /// projection can be used to insert a service account token into the pods runtime filesystem
    /// for use against APIs (Kubernetes API Server or otherwise).
    /// </summary>
    [OutputType]
    public sealed class ServiceAccountTokenProjection
    {
      /// <summary>
        /// Audience is the intended audience of the token. A recipient of a token must identify
        /// itself with an identifier specified in the audience of the token, and otherwise should
        /// reject the token. The audience defaults to the identifier of the apiserver.
        /// </summary>
      public readonly string Audience;

      /// <summary>
        /// ExpirationSeconds is the requested duration of validity of the service account token. As
        /// the token approaches expiration, the kubelet volume plugin will proactively rotate the
        /// service account token. The kubelet will start trying to rotate the token if the token is
        /// older than 80 percent of its time to live or if the token is older than 24
        /// hours.Defaults to 1 hour and must be at least 10 minutes.
        /// </summary>
      public readonly int ExpirationSeconds;

      /// <summary>
        /// Path is the path relative to the mount point of the file to project the token into.
        /// </summary>
      public readonly string Path;

      [OutputConstructor]
      private ServiceAccountTokenProjection(
          string @audience,
          int @expirationSeconds,
          string @path)
      {
          this.Audience = @audience;
          this.ExpirationSeconds = @expirationSeconds;
          this.Path = @path;
      }

    }
    /// <summary>
    /// ServiceList holds a list of services.
    /// </summary>
    [OutputType]
    public sealed class ServiceList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of services
        /// </summary>
      public readonly ImmutableArray<Core.V1.Service> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ServiceList(
          string @apiVersion,
          ImmutableArray<Core.V1.Service> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ServicePort contains information on service's port.
    /// </summary>
    [OutputType]
    public sealed class ServicePort
    {
      /// <summary>
        /// The name of this port within the service. This must be a DNS_LABEL. All ports within a
        /// ServiceSpec must have unique names. When considering the endpoints for a Service, this
        /// must match the 'name' field in the EndpointPort. Optional if only one ServicePort is
        /// defined on this service.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// The port on each node on which this service is exposed when type=NodePort or
        /// LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the
        /// service if unused or else creation of the service will fail. Default is to auto-allocate
        /// a port if the ServiceType of this Service requires one. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
        /// </summary>
      public readonly int NodePort;

      /// <summary>
        /// The port that will be exposed by this service.
        /// </summary>
      public readonly int Port;

      /// <summary>
        /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
        /// </summary>
      public readonly string Protocol;

      /// <summary>
        /// Number or name of the port to access on the pods targeted by the service. Number must be
        /// in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be
        /// looked up as a named port in the target Pod's container ports. If this is not specified,
        /// the value of the 'port' field is used (an identity map). This field is ignored for
        /// services with clusterIP=None, and should be omitted or set equal to the 'port' field.
        /// More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
        /// </summary>
      public readonly Union<int,string> TargetPort;

      [OutputConstructor]
      private ServicePort(
          string @name,
          int @nodePort,
          int @port,
          string @protocol,
          Union<int,string> @targetPort)
      {
          this.Name = @name;
          this.NodePort = @nodePort;
          this.Port = @port;
          this.Protocol = @protocol;
          this.TargetPort = @targetPort;
      }

    }
    /// <summary>
    /// ServiceSpec describes the attributes that a user creates on a service.
    /// </summary>
    [OutputType]
    public sealed class ServiceSpec
    {
      /// <summary>
        /// clusterIP is the IP address of the service and is usually assigned randomly by the
        /// master. If an address is specified manually and is not in use by others, it will be
        /// allocated to the service; otherwise, creation of the service will fail. This field can
        /// not be changed through updates. Valid values are "None", empty string (""), or a valid
        /// IP address. "None" can be specified for headless services when proxying is not required.
        /// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is
        /// ExternalName. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
      public readonly string ClusterIP;

      /// <summary>
        /// externalIPs is a list of IP addresses for which nodes in the cluster will also accept
        /// traffic for this service.  These IPs are not managed by Kubernetes.  The user is
        /// responsible for ensuring that traffic arrives at a node with this IP.  A common example
        /// is external load-balancers that are not part of the Kubernetes system.
        /// </summary>
      public readonly ImmutableArray<string> ExternalIPs;

      /// <summary>
        /// externalName is the external reference that kubedns or equivalent will return as a CNAME
        /// record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname
        /// (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
        /// </summary>
      public readonly string ExternalName;

      /// <summary>
        /// externalTrafficPolicy denotes if this Service desires to route external traffic to
        /// node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids
        /// a second hop for LoadBalancer and Nodeport type services, but risks potentially
        /// imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a
        /// second hop to another node, but should have good overall load-spreading.
        /// </summary>
      public readonly string ExternalTrafficPolicy;

      /// <summary>
        /// healthCheckNodePort specifies the healthcheck nodePort for the service. If not
        /// specified, HealthCheckNodePort is created by the service api backend with the allocated
        /// nodePort. Will use user-specified nodePort value if specified by the client. Only
        /// effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
        /// </summary>
      public readonly int HealthCheckNodePort;

      /// <summary>
        /// ipFamily specifies whether this Service has a preference for a particular IP family
        /// (e.g. IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be
        /// allocated from that family, if it is available in the cluster.  If no IP family is
        /// requested, the cluster's primary IP family will be used. Other IP fields
        /// (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which allocate
        /// external load-balancers should use the same IP family.  Endpoints for this Service will
        /// be of this family.  This field is immutable after creation. Assigning a ServiceIPFamily
        /// not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and
        /// will fail during clusterIP assignment.
        /// </summary>
      public readonly string IpFamily;

      /// <summary>
        /// Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP
        /// specified in this field. This feature depends on whether the underlying cloud-provider
        /// supports specifying the loadBalancerIP when a load balancer is created. This field will
        /// be ignored if the cloud-provider does not support the feature.
        /// </summary>
      public readonly string LoadBalancerIP;

      /// <summary>
        /// If specified and supported by the platform, this will restrict traffic through the
        /// cloud-provider load-balancer will be restricted to the specified client IPs. This field
        /// will be ignored if the cloud-provider does not support the feature." More info:
        /// https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
        /// </summary>
      public readonly ImmutableArray<string> LoadBalancerSourceRanges;

      /// <summary>
        /// The list of ports that are exposed by this service. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
      public readonly ImmutableArray<Core.V1.ServicePort> Ports;

      /// <summary>
        /// publishNotReadyAddresses, when set to true, indicates that DNS implementations must
        /// publish the notReadyAddresses of subsets for the Endpoints associated with the Service.
        /// The default value is false. The primary use case for setting this field is to use a
        /// StatefulSet's Headless Service to propagate SRV records for its Pods without respect to
        /// their readiness for purpose of peer discovery.
        /// </summary>
      public readonly bool PublishNotReadyAddresses;

      /// <summary>
        /// Route service traffic to pods with label keys and values matching this selector. If
        /// empty or not present, the service is assumed to have an external process managing its
        /// endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort,
        /// and LoadBalancer. Ignored if type is ExternalName. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/
        /// </summary>
      public readonly ImmutableDictionary<string, string> Selector;

      /// <summary>
        /// Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP
        /// based session affinity. Must be ClientIP or None. Defaults to None. More info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// </summary>
      public readonly string SessionAffinity;

      /// <summary>
        /// sessionAffinityConfig contains the configurations of session affinity.
        /// </summary>
      public readonly Core.V1.SessionAffinityConfig SessionAffinityConfig;

      /// <summary>
        /// topologyKeys is a preference-order list of topology keys which implementations of
        /// services should use to preferentially sort endpoints when accessing this Service, it can
        /// not be used at the same time as externalTrafficPolicy=Local. Topology keys must be valid
        /// label keys and at most 16 keys may be specified. Endpoints are chosen based on the first
        /// topology key with available backends. If this field is specified and all entries have no
        /// backends that match the topology of the client, the service has no backends for that
        /// client and connections should fail. The special value "*" may be used to mean "any
        /// topology". This catch-all value, if used, only makes sense as the last value in the
        /// list. If this is not specified or empty, no topology constraints will be applied.
        /// </summary>
      public readonly ImmutableArray<string> TopologyKeys;

      /// <summary>
        /// type determines how the Service is exposed. Defaults to ClusterIP. Valid options are
        /// ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the
        /// specified externalName. "ClusterIP" allocates a cluster-internal IP address for
        /// load-balancing to endpoints. Endpoints are determined by the selector or if that is not
        /// specified, by manual construction of an Endpoints object. If clusterIP is "None", no
        /// virtual IP is allocated and the endpoints are published as a set of endpoints rather
        /// than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node
        /// which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external
        /// load-balancer (if supported in the current cloud) which routes to the clusterIP. More
        /// info:
        /// https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private ServiceSpec(
          string @clusterIP,
          ImmutableArray<string> @externalIPs,
          string @externalName,
          string @externalTrafficPolicy,
          int @healthCheckNodePort,
          string @ipFamily,
          string @loadBalancerIP,
          ImmutableArray<string> @loadBalancerSourceRanges,
          ImmutableArray<Core.V1.ServicePort> @ports,
          bool @publishNotReadyAddresses,
          ImmutableDictionary<string, string> @selector,
          string @sessionAffinity,
          Core.V1.SessionAffinityConfig @sessionAffinityConfig,
          ImmutableArray<string> @topologyKeys,
          string @type)
      {
          this.ClusterIP = @clusterIP;
          this.ExternalIPs = @externalIPs;
          this.ExternalName = @externalName;
          this.ExternalTrafficPolicy = @externalTrafficPolicy;
          this.HealthCheckNodePort = @healthCheckNodePort;
          this.IpFamily = @ipFamily;
          this.LoadBalancerIP = @loadBalancerIP;
          this.LoadBalancerSourceRanges = @loadBalancerSourceRanges;
          this.Ports = @ports;
          this.PublishNotReadyAddresses = @publishNotReadyAddresses;
          this.Selector = @selector;
          this.SessionAffinity = @sessionAffinity;
          this.SessionAffinityConfig = @sessionAffinityConfig;
          this.TopologyKeys = @topologyKeys;
          this.Type = @type;
      }

    }
    /// <summary>
    /// ServiceStatus represents the current status of a service.
    /// </summary>
    [OutputType]
    public sealed class ServiceStatus
    {
      /// <summary>
        /// LoadBalancer contains the current status of the load-balancer, if one is present.
        /// </summary>
      public readonly Core.V1.LoadBalancerStatus LoadBalancer;

      [OutputConstructor]
      private ServiceStatus(
          Core.V1.LoadBalancerStatus @loadBalancer)
      {
          this.LoadBalancer = @loadBalancer;
      }

    }
    /// <summary>
    /// SessionAffinityConfig represents the configurations of session affinity.
    /// </summary>
    [OutputType]
    public sealed class SessionAffinityConfig
    {
      /// <summary>
        /// clientIP contains the configurations of Client IP based session affinity.
        /// </summary>
      public readonly Core.V1.ClientIPConfig ClientIP;

      [OutputConstructor]
      private SessionAffinityConfig(
          Core.V1.ClientIPConfig @clientIP)
      {
          this.ClientIP = @clientIP;
      }

    }
    /// <summary>
    /// Represents a StorageOS persistent volume resource.
    /// </summary>
    [OutputType]
    public sealed class StorageOSPersistentVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If
        /// not specified, default values will be attempted.
        /// </summary>
      public readonly Core.V1.ObjectReference SecretRef;

      /// <summary>
        /// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only
        /// unique within a namespace.
        /// </summary>
      public readonly string VolumeName;

      /// <summary>
        /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is
        /// specified then the Pod's namespace will be used.  This allows the Kubernetes name
        /// scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any
        /// name to override the default behaviour. Set to "default" if you are not using namespaces
        /// within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
        /// </summary>
      public readonly string VolumeNamespace;

      [OutputConstructor]
      private StorageOSPersistentVolumeSource(
          string @fsType,
          bool @readOnly,
          Core.V1.ObjectReference @secretRef,
          string @volumeName,
          string @volumeNamespace)
      {
          this.FsType = @fsType;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.VolumeName = @volumeName;
          this.VolumeNamespace = @volumeNamespace;
      }

    }
    /// <summary>
    /// Represents a StorageOS persistent volume resource.
    /// </summary>
    [OutputType]
    public sealed class StorageOSVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
        /// VolumeMounts.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If
        /// not specified, default values will be attempted.
        /// </summary>
      public readonly Core.V1.LocalObjectReference SecretRef;

      /// <summary>
        /// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only
        /// unique within a namespace.
        /// </summary>
      public readonly string VolumeName;

      /// <summary>
        /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is
        /// specified then the Pod's namespace will be used.  This allows the Kubernetes name
        /// scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any
        /// name to override the default behaviour. Set to "default" if you are not using namespaces
        /// within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
        /// </summary>
      public readonly string VolumeNamespace;

      [OutputConstructor]
      private StorageOSVolumeSource(
          string @fsType,
          bool @readOnly,
          Core.V1.LocalObjectReference @secretRef,
          string @volumeName,
          string @volumeNamespace)
      {
          this.FsType = @fsType;
          this.ReadOnly = @readOnly;
          this.SecretRef = @secretRef;
          this.VolumeName = @volumeName;
          this.VolumeNamespace = @volumeNamespace;
      }

    }
    /// <summary>
    /// Sysctl defines a kernel parameter to be set
    /// </summary>
    [OutputType]
    public sealed class Sysctl
    {
      /// <summary>
        /// Name of a property to set
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Value of a property to set
        /// </summary>
      public readonly string Value;

      [OutputConstructor]
      private Sysctl(
          string @name,
          string @value)
      {
          this.Name = @name;
          this.Value = @value;
      }

    }
    /// <summary>
    /// TCPSocketAction describes an action based on opening a socket
    /// </summary>
    [OutputType]
    public sealed class TCPSocketAction
    {
      /// <summary>
        /// Optional: Host name to connect to, defaults to the pod IP.
        /// </summary>
      public readonly string Host;

      /// <summary>
        /// Number or name of the port to access on the container. Number must be in the range 1 to
        /// 65535. Name must be an IANA_SVC_NAME.
        /// </summary>
      public readonly Union<int,string> Port;

      [OutputConstructor]
      private TCPSocketAction(
          string @host,
          Union<int,string> @port)
      {
          this.Host = @host;
          this.Port = @port;
      }

    }
    /// <summary>
    /// The node this Taint is attached to has the "effect" on any pod that does not tolerate the
    /// Taint.
    /// </summary>
    [OutputType]
    public sealed class Taint
    {
      /// <summary>
        /// Required. The effect of the taint on pods that do not tolerate the taint. Valid effects
        /// are NoSchedule, PreferNoSchedule and NoExecute.
        /// </summary>
      public readonly string Effect;

      /// <summary>
        /// Required. The taint key to be applied to a node.
        /// </summary>
      public readonly string Key;

      /// <summary>
        /// TimeAdded represents the time at which the taint was added. It is only written for
        /// NoExecute taints.
        /// </summary>
      public readonly string TimeAdded;

      /// <summary>
        /// Required. The taint value corresponding to the taint key.
        /// </summary>
      public readonly string Value;

      [OutputConstructor]
      private Taint(
          string @effect,
          string @key,
          string @timeAdded,
          string @value)
      {
          this.Effect = @effect;
          this.Key = @key;
          this.TimeAdded = @timeAdded;
          this.Value = @value;
      }

    }
    /// <summary>
    /// The pod this Toleration is attached to tolerates any taint that matches the triple
    /// &amp;lt;key,value,effect&amp;gt; using the matching operator &amp;lt;operator&amp;gt;.
    /// </summary>
    [OutputType]
    public sealed class Toleration
    {
      /// <summary>
        /// Effect indicates the taint effect to match. Empty means match all taint effects. When
        /// specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        /// </summary>
      public readonly string Effect;

      /// <summary>
        /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
        /// If the key is empty, operator must be Exists; this combination means to match all values
        /// and all keys.
        /// </summary>
      public readonly string Key;

      /// <summary>
        /// Operator represents a key's relationship to the value. Valid operators are Exists and
        /// Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can
        /// tolerate all taints of a particular category.
        /// </summary>
      public readonly string Operator;

      /// <summary>
        /// TolerationSeconds represents the period of time the toleration (which must be of effect
        /// NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not
        /// set, which means tolerate the taint forever (do not evict). Zero and negative values
        /// will be treated as 0 (evict immediately) by the system.
        /// </summary>
      public readonly int TolerationSeconds;

      /// <summary>
        /// Value is the taint value the toleration matches to. If the operator is Exists, the value
        /// should be empty, otherwise just a regular string.
        /// </summary>
      public readonly string Value;

      [OutputConstructor]
      private Toleration(
          string @effect,
          string @key,
          string @operator,
          int @tolerationSeconds,
          string @value)
      {
          this.Effect = @effect;
          this.Key = @key;
          this.Operator = @operator;
          this.TolerationSeconds = @tolerationSeconds;
          this.Value = @value;
      }

    }
    /// <summary>
    /// A topology selector requirement is a selector that matches given label. This is an alpha
    /// feature and may change in the future.
    /// </summary>
    [OutputType]
    public sealed class TopologySelectorLabelRequirement
    {
      /// <summary>
        /// The label key that the selector applies to.
        /// </summary>
      public readonly string Key;

      /// <summary>
        /// An array of string values. One value must match the label to be selected. Each entry in
        /// Values is ORed.
        /// </summary>
      public readonly ImmutableArray<string> Values;

      [OutputConstructor]
      private TopologySelectorLabelRequirement(
          string @key,
          ImmutableArray<string> @values)
      {
          this.Key = @key;
          this.Values = @values;
      }

    }
    /// <summary>
    /// A topology selector term represents the result of label queries. A null or empty topology
    /// selector term matches no objects. The requirements of them are ANDed. It provides a subset
    /// of functionality as NodeSelectorTerm. This is an alpha feature and may change in the future.
    /// </summary>
    [OutputType]
    public sealed class TopologySelectorTerm
    {
      /// <summary>
        /// A list of topology selector requirements by labels.
        /// </summary>
      public readonly ImmutableArray<Core.V1.TopologySelectorLabelRequirement> MatchLabelExpressions;

      [OutputConstructor]
      private TopologySelectorTerm(
          ImmutableArray<Core.V1.TopologySelectorLabelRequirement> @matchLabelExpressions)
      {
          this.MatchLabelExpressions = @matchLabelExpressions;
      }

    }
    /// <summary>
    /// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
    /// </summary>
    [OutputType]
    public sealed class TopologySpreadConstraint
    {
      /// <summary>
        /// LabelSelector is used to find matching pods. Pods that match this label selector are
        /// counted to determine the number of pods in their corresponding topology domain.
        /// </summary>
      public readonly Meta.V1.LabelSelector LabelSelector;

      /// <summary>
        /// MaxSkew describes the degree to which pods may be unevenly distributed. It's the maximum
        /// permitted difference between the number of matching pods in any two topology domains of
        /// a given topology type. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods
        /// with the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |
        /// | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
        /// scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate
        /// MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. It's a
        /// required field. Default value is 1 and 0 is not allowed.
        /// </summary>
      public readonly int MaxSkew;

      /// <summary>
        /// TopologyKey is the key of node labels. Nodes that have a label with this key and
        /// identical values are considered to be in the same topology. We consider each
        /// &amp;lt;key, value&amp;gt; as a "bucket", and try to put balanced number of pods into
        /// each bucket. It's a required field.
        /// </summary>
      public readonly string TopologyKey;

      /// <summary>
        /// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread
        /// constraint. - DoNotSchedule (default) tells the scheduler not to schedule it -
        /// ScheduleAnyway tells the scheduler to still schedule it It's considered as
        /// "Unsatisfiable" if and only if placing incoming pod on any topology violates "MaxSkew".
        /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
        /// labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If
        /// WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to
        /// zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
        /// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't
        /// make it *more* imbalanced. It's a required field.
        /// </summary>
      public readonly string WhenUnsatisfiable;

      [OutputConstructor]
      private TopologySpreadConstraint(
          Meta.V1.LabelSelector @labelSelector,
          int @maxSkew,
          string @topologyKey,
          string @whenUnsatisfiable)
      {
          this.LabelSelector = @labelSelector;
          this.MaxSkew = @maxSkew;
          this.TopologyKey = @topologyKey;
          this.WhenUnsatisfiable = @whenUnsatisfiable;
      }

    }
    /// <summary>
    /// TypedLocalObjectReference contains enough information to let you locate the typed referenced
    /// object inside the same namespace.
    /// </summary>
    [OutputType]
    public sealed class TypedLocalObjectReference
    {
      /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified,
        /// the specified Kind must be in the core API group. For any other third-party types,
        /// APIGroup is required.
        /// </summary>
      public readonly string ApiGroup;

      /// <summary>
        /// Kind is the type of resource being referenced
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private TypedLocalObjectReference(
          string @apiGroup,
          string @kind,
          string @name)
      {
          this.ApiGroup = @apiGroup;
          this.Kind = @kind;
          this.Name = @name;
      }

    }
    /// <summary>
    /// Volume represents a named volume in a pod that may be accessed by any container in the pod.
    /// </summary>
    [OutputType]
    public sealed class Volume
    {
      /// <summary>
        /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's
        /// host machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
      public readonly Core.V1.AWSElasticBlockStoreVolumeSource AwsElasticBlockStore;

      /// <summary>
        /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
        /// </summary>
      public readonly Core.V1.AzureDiskVolumeSource AzureDisk;

      /// <summary>
        /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
        /// </summary>
      public readonly Core.V1.AzureFileVolumeSource AzureFile;

      /// <summary>
        /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
        /// </summary>
      public readonly Core.V1.CephFSVolumeSource Cephfs;

      /// <summary>
        /// Cinder represents a cinder volume attached and mounted on kubelets host machine. More
        /// info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
      public readonly Core.V1.CinderVolumeSource Cinder;

      /// <summary>
        /// ConfigMap represents a configMap that should populate this volume
        /// </summary>
      public readonly Core.V1.ConfigMapVolumeSource ConfigMap;

      /// <summary>
        /// CSI (Container Storage Interface) represents storage that is handled by an external CSI
        /// driver (Alpha feature).
        /// </summary>
      public readonly Core.V1.CSIVolumeSource Csi;

      /// <summary>
        /// DownwardAPI represents downward API about the pod that should populate this volume
        /// </summary>
      public readonly Core.V1.DownwardAPIVolumeSource DownwardAPI;

      /// <summary>
        /// EmptyDir represents a temporary directory that shares a pod's lifetime. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        /// </summary>
      public readonly Core.V1.EmptyDirVolumeSource EmptyDir;

      /// <summary>
        /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and
        /// then exposed to the pod.
        /// </summary>
      public readonly Core.V1.FCVolumeSource Fc;

      /// <summary>
        /// FlexVolume represents a generic volume resource that is provisioned/attached using an
        /// exec based plugin.
        /// </summary>
      public readonly Core.V1.FlexVolumeSource FlexVolume;

      /// <summary>
        /// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends
        /// on the Flocker control service being running
        /// </summary>
      public readonly Core.V1.FlockerVolumeSource Flocker;

      /// <summary>
        /// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host
        /// machine and then exposed to the pod. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
      public readonly Core.V1.GCEPersistentDiskVolumeSource GcePersistentDisk;

      /// <summary>
        /// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is
        /// deprecated. To provision a container with a git repo, mount an EmptyDir into an
        /// InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's
        /// container.
        /// </summary>
      public readonly Core.V1.GitRepoVolumeSource GitRepo;

      /// <summary>
        /// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More
        /// info: https://examples.k8s.io/volumes/glusterfs/README.md
        /// </summary>
      public readonly Core.V1.GlusterfsVolumeSource Glusterfs;

      /// <summary>
        /// HostPath represents a pre-existing file or directory on the host machine that is
        /// directly exposed to the container. This is generally used for system agents or other
        /// privileged things that are allowed to see the host machine. Most containers will NOT
        /// need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
      public readonly Core.V1.HostPathVolumeSource HostPath;

      /// <summary>
        /// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and
        /// then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
        /// </summary>
      public readonly Core.V1.ISCSIVolumeSource Iscsi;

      /// <summary>
        /// Volume's name. Must be a DNS_LABEL and unique within the pod. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// NFS represents an NFS mount on the host that shares a pod's lifetime More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
      public readonly Core.V1.NFSVolumeSource Nfs;

      /// <summary>
        /// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in
        /// the same namespace. More info:
        /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
      public readonly Core.V1.PersistentVolumeClaimVolumeSource PersistentVolumeClaim;

      /// <summary>
        /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted
        /// on kubelets host machine
        /// </summary>
      public readonly Core.V1.PhotonPersistentDiskVolumeSource PhotonPersistentDisk;

      /// <summary>
        /// PortworxVolume represents a portworx volume attached and mounted on kubelets host
        /// machine
        /// </summary>
      public readonly Core.V1.PortworxVolumeSource PortworxVolume;

      /// <summary>
        /// Items for all in one resources secrets, configmaps, and downward API
        /// </summary>
      public readonly Core.V1.ProjectedVolumeSource Projected;

      /// <summary>
        /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        /// </summary>
      public readonly Core.V1.QuobyteVolumeSource Quobyte;

      /// <summary>
        /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More
        /// info: https://examples.k8s.io/volumes/rbd/README.md
        /// </summary>
      public readonly Core.V1.RBDVolumeSource Rbd;

      /// <summary>
        /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
        /// </summary>
      public readonly Core.V1.ScaleIOVolumeSource ScaleIO;

      /// <summary>
        /// Secret represents a secret that should populate this volume. More info:
        /// https://kubernetes.io/docs/concepts/storage/volumes#secret
        /// </summary>
      public readonly Core.V1.SecretVolumeSource Secret;

      /// <summary>
        /// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
        /// </summary>
      public readonly Core.V1.StorageOSVolumeSource Storageos;

      /// <summary>
        /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
        /// </summary>
      public readonly Core.V1.VsphereVirtualDiskVolumeSource VsphereVolume;

      [OutputConstructor]
      private Volume(
          Core.V1.AWSElasticBlockStoreVolumeSource @awsElasticBlockStore,
          Core.V1.AzureDiskVolumeSource @azureDisk,
          Core.V1.AzureFileVolumeSource @azureFile,
          Core.V1.CephFSVolumeSource @cephfs,
          Core.V1.CinderVolumeSource @cinder,
          Core.V1.ConfigMapVolumeSource @configMap,
          Core.V1.CSIVolumeSource @csi,
          Core.V1.DownwardAPIVolumeSource @downwardAPI,
          Core.V1.EmptyDirVolumeSource @emptyDir,
          Core.V1.FCVolumeSource @fc,
          Core.V1.FlexVolumeSource @flexVolume,
          Core.V1.FlockerVolumeSource @flocker,
          Core.V1.GCEPersistentDiskVolumeSource @gcePersistentDisk,
          Core.V1.GitRepoVolumeSource @gitRepo,
          Core.V1.GlusterfsVolumeSource @glusterfs,
          Core.V1.HostPathVolumeSource @hostPath,
          Core.V1.ISCSIVolumeSource @iscsi,
          string @name,
          Core.V1.NFSVolumeSource @nfs,
          Core.V1.PersistentVolumeClaimVolumeSource @persistentVolumeClaim,
          Core.V1.PhotonPersistentDiskVolumeSource @photonPersistentDisk,
          Core.V1.PortworxVolumeSource @portworxVolume,
          Core.V1.ProjectedVolumeSource @projected,
          Core.V1.QuobyteVolumeSource @quobyte,
          Core.V1.RBDVolumeSource @rbd,
          Core.V1.ScaleIOVolumeSource @scaleIO,
          Core.V1.SecretVolumeSource @secret,
          Core.V1.StorageOSVolumeSource @storageos,
          Core.V1.VsphereVirtualDiskVolumeSource @vsphereVolume)
      {
          this.AwsElasticBlockStore = @awsElasticBlockStore;
          this.AzureDisk = @azureDisk;
          this.AzureFile = @azureFile;
          this.Cephfs = @cephfs;
          this.Cinder = @cinder;
          this.ConfigMap = @configMap;
          this.Csi = @csi;
          this.DownwardAPI = @downwardAPI;
          this.EmptyDir = @emptyDir;
          this.Fc = @fc;
          this.FlexVolume = @flexVolume;
          this.Flocker = @flocker;
          this.GcePersistentDisk = @gcePersistentDisk;
          this.GitRepo = @gitRepo;
          this.Glusterfs = @glusterfs;
          this.HostPath = @hostPath;
          this.Iscsi = @iscsi;
          this.Name = @name;
          this.Nfs = @nfs;
          this.PersistentVolumeClaim = @persistentVolumeClaim;
          this.PhotonPersistentDisk = @photonPersistentDisk;
          this.PortworxVolume = @portworxVolume;
          this.Projected = @projected;
          this.Quobyte = @quobyte;
          this.Rbd = @rbd;
          this.ScaleIO = @scaleIO;
          this.Secret = @secret;
          this.Storageos = @storageos;
          this.VsphereVolume = @vsphereVolume;
      }

    }
    /// <summary>
    /// volumeDevice describes a mapping of a raw block device within a container.
    /// </summary>
    [OutputType]
    public sealed class VolumeDevice
    {
      /// <summary>
        /// devicePath is the path inside of the container that the device will be mapped to.
        /// </summary>
      public readonly string DevicePath;

      /// <summary>
        /// name must match the name of a persistentVolumeClaim in the pod
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private VolumeDevice(
          string @devicePath,
          string @name)
      {
          this.DevicePath = @devicePath;
          this.Name = @name;
      }

    }
    /// <summary>
    /// VolumeMount describes a mounting of a Volume within a container.
    /// </summary>
    [OutputType]
    public sealed class VolumeMount
    {
      /// <summary>
        /// Path within the container at which the volume should be mounted.  Must not contain ':'.
        /// </summary>
      public readonly string MountPath;

      /// <summary>
        /// mountPropagation determines how mounts are propagated from the host to container and the
        /// other way around. When not set, MountPropagationNone is used. This field is beta in
        /// 1.10.
        /// </summary>
      public readonly string MountPropagation;

      /// <summary>
        /// This must match the Name of a Volume.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to
        /// false.
        /// </summary>
      public readonly bool ReadOnly;

      /// <summary>
        /// Path within the volume from which the container's volume should be mounted. Defaults to
        /// "" (volume's root).
        /// </summary>
      public readonly string SubPath;

      /// <summary>
        /// Expanded path within the volume from which the container's volume should be mounted.
        /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are
        /// expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr
        /// and SubPath are mutually exclusive.
        /// </summary>
      public readonly string SubPathExpr;

      [OutputConstructor]
      private VolumeMount(
          string @mountPath,
          string @mountPropagation,
          string @name,
          bool @readOnly,
          string @subPath,
          string @subPathExpr)
      {
          this.MountPath = @mountPath;
          this.MountPropagation = @mountPropagation;
          this.Name = @name;
          this.ReadOnly = @readOnly;
          this.SubPath = @subPath;
          this.SubPathExpr = @subPathExpr;
      }

    }
    /// <summary>
    /// VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed
    /// from.
    /// </summary>
    [OutputType]
    public sealed class VolumeNodeAffinity
    {
      /// <summary>
        /// Required specifies hard node constraints that must be met.
        /// </summary>
      public readonly Core.V1.NodeSelector Required;

      [OutputConstructor]
      private VolumeNodeAffinity(
          Core.V1.NodeSelector @required)
      {
          this.Required = @required;
      }

    }
    /// <summary>
    /// Projection that may be projected along with other supported volume types
    /// </summary>
    [OutputType]
    public sealed class VolumeProjection
    {
      /// <summary>
        /// information about the configMap data to project
        /// </summary>
      public readonly Core.V1.ConfigMapProjection ConfigMap;

      /// <summary>
        /// information about the downwardAPI data to project
        /// </summary>
      public readonly Core.V1.DownwardAPIProjection DownwardAPI;

      /// <summary>
        /// information about the secret data to project
        /// </summary>
      public readonly Core.V1.SecretProjection Secret;

      /// <summary>
        /// information about the serviceAccountToken data to project
        /// </summary>
      public readonly Core.V1.ServiceAccountTokenProjection ServiceAccountToken;

      [OutputConstructor]
      private VolumeProjection(
          Core.V1.ConfigMapProjection @configMap,
          Core.V1.DownwardAPIProjection @downwardAPI,
          Core.V1.SecretProjection @secret,
          Core.V1.ServiceAccountTokenProjection @serviceAccountToken)
      {
          this.ConfigMap = @configMap;
          this.DownwardAPI = @downwardAPI;
          this.Secret = @secret;
          this.ServiceAccountToken = @serviceAccountToken;
      }

    }
    /// <summary>
    /// Represents a vSphere volume resource.
    /// </summary>
    [OutputType]
    public sealed class VsphereVirtualDiskVolumeSource
    {
      /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating
        /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
      public readonly string FsType;

      /// <summary>
        /// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
        /// </summary>
      public readonly string StoragePolicyID;

      /// <summary>
        /// Storage Policy Based Management (SPBM) profile name.
        /// </summary>
      public readonly string StoragePolicyName;

      /// <summary>
        /// Path that identifies vSphere volume vmdk
        /// </summary>
      public readonly string VolumePath;

      [OutputConstructor]
      private VsphereVirtualDiskVolumeSource(
          string @fsType,
          string @storagePolicyID,
          string @storagePolicyName,
          string @volumePath)
      {
          this.FsType = @fsType;
          this.StoragePolicyID = @storagePolicyID;
          this.StoragePolicyName = @storagePolicyName;
          this.VolumePath = @volumePath;
      }

    }
    /// <summary>
    /// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find
    /// the most preferred node(s)
    /// </summary>
    [OutputType]
    public sealed class WeightedPodAffinityTerm
    {
      /// <summary>
        /// Required. A pod affinity term, associated with the corresponding weight.
        /// </summary>
      public readonly Core.V1.PodAffinityTerm PodAffinityTerm;

      /// <summary>
        /// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        /// </summary>
      public readonly int Weight;

      [OutputConstructor]
      private WeightedPodAffinityTerm(
          Core.V1.PodAffinityTerm @podAffinityTerm,
          int @weight)
      {
          this.PodAffinityTerm = @podAffinityTerm;
          this.Weight = @weight;
      }

    }
    /// <summary>
    /// WindowsSecurityContextOptions contain Windows-specific options and credentials.
    /// </summary>
    [OutputType]
    public sealed class WindowsSecurityContextOptions
    {
      /// <summary>
        /// GMSACredentialSpec is where the GMSA admission webhook
        /// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA
        /// credential spec named by the GMSACredentialSpecName field. This field is alpha-level and
        /// is only honored by servers that enable the WindowsGMSA feature flag.
        /// </summary>
      public readonly string GmsaCredentialSpec;

      /// <summary>
        /// GMSACredentialSpecName is the name of the GMSA credential spec to use. This field is
        /// alpha-level and is only honored by servers that enable the WindowsGMSA feature flag.
        /// </summary>
      public readonly string GmsaCredentialSpecName;

      /// <summary>
        /// The UserName in Windows to run the entrypoint of the container process. Defaults to the
        /// user specified in image metadata if unspecified. May also be set in PodSecurityContext.
        /// If set in both SecurityContext and PodSecurityContext, the value specified in
        /// SecurityContext takes precedence. This field is beta-level and may be disabled with the
        /// WindowsRunAsUserName feature flag.
        /// </summary>
      public readonly string RunAsUserName;

      [OutputConstructor]
      private WindowsSecurityContextOptions(
          string @gmsaCredentialSpec,
          string @gmsaCredentialSpecName,
          string @runAsUserName)
      {
          this.GmsaCredentialSpec = @gmsaCredentialSpec;
          this.GmsaCredentialSpecName = @gmsaCredentialSpecName;
          this.RunAsUserName = @runAsUserName;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Discovery
{
  namespace V1Beta1
  {
    /// <summary>
    /// Endpoint represents a single logical "backend" implementing a service.
    /// </summary>
    [OutputType]
    public sealed class Endpoint
    {
      /// <summary>
        /// addresses of this endpoint. The contents of this field are interpreted according to the
        /// corresponding EndpointSlice addressType field. Consumers must handle different types of
        /// addresses in the context of their own capabilities. This must contain at least one
        /// address but no more than 100.
        /// </summary>
      public readonly ImmutableArray<string> Addresses;

      /// <summary>
        /// conditions contains information about the current status of the endpoint.
        /// </summary>
      public readonly Discovery.V1Beta1.EndpointConditions Conditions;

      /// <summary>
        /// hostname of this endpoint. This field may be used by consumers of endpoints to
        /// distinguish endpoints from each other (e.g. in DNS names). Multiple endpoints which use
        /// the same hostname should be considered fungible (e.g. multiple A values in DNS). Must
        /// pass DNS Label (RFC 1123) validation.
        /// </summary>
      public readonly string Hostname;

      /// <summary>
        /// targetRef is a reference to a Kubernetes object that represents this endpoint.
        /// </summary>
      public readonly Core.V1.ObjectReference TargetRef;

      /// <summary>
        /// topology contains arbitrary topology information associated with the endpoint. These
        /// key/value pairs must conform with the label format.
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels Topology may
        /// include a maximum of 16 key/value pairs. This includes, but is not limited to the
        /// following well known keys: * kubernetes.io/hostname: the value indicates the hostname of
        /// the node
        ///   where the endpoint is located. This should match the corresponding
        ///   node label.
        /// * topology.kubernetes.io/zone: the value indicates the zone where the
        ///   endpoint is located. This should match the corresponding node label.
        /// * topology.kubernetes.io/region: the value indicates the region where the
        ///   endpoint is located. This should match the corresponding node label.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Topology;

      [OutputConstructor]
      private Endpoint(
          ImmutableArray<string> @addresses,
          Discovery.V1Beta1.EndpointConditions @conditions,
          string @hostname,
          Core.V1.ObjectReference @targetRef,
          ImmutableDictionary<string, string> @topology)
      {
          this.Addresses = @addresses;
          this.Conditions = @conditions;
          this.Hostname = @hostname;
          this.TargetRef = @targetRef;
          this.Topology = @topology;
      }

    }
    /// <summary>
    /// EndpointConditions represents the current condition of an endpoint.
    /// </summary>
    [OutputType]
    public sealed class EndpointConditions
    {
      /// <summary>
        /// ready indicates that this endpoint is prepared to receive traffic, according to whatever
        /// system is managing the endpoint. A nil value indicates an unknown state. In most cases
        /// consumers should interpret this unknown state as ready.
        /// </summary>
      public readonly bool Ready;

      [OutputConstructor]
      private EndpointConditions(
          bool @ready)
      {
          this.Ready = @ready;
      }

    }
    /// <summary>
    /// EndpointPort represents a Port used by an EndpointSlice
    /// </summary>
    [OutputType]
    public sealed class EndpointPort
    {
      /// <summary>
        /// The application protocol for this port. This field follows standard Kubernetes label
        /// syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335
        /// and http://www.iana.org/assignments/service-names). Non-standard protocols should use
        /// prefixed names. Default is empty string.
        /// </summary>
      public readonly string AppProtocol;

      /// <summary>
        /// The name of this port. All ports in an EndpointSlice must have a unique name. If the
        /// EndpointSlice is dervied from a Kubernetes service, this corresponds to the
        /// Service.ports[].name. Name must either be an empty string or pass DNS_LABEL validation:
        /// * must be no more than 63 characters long. * must consist of lower case alphanumeric
        /// characters or '-'. * must start and end with an alphanumeric character. Default is empty
        /// string.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// The port number of the endpoint. If this is not specified, ports are not restricted and
        /// must be interpreted in the context of the specific consumer.
        /// </summary>
      public readonly int Port;

      /// <summary>
        /// The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
        /// </summary>
      public readonly string Protocol;

      [OutputConstructor]
      private EndpointPort(
          string @appProtocol,
          string @name,
          int @port,
          string @protocol)
      {
          this.AppProtocol = @appProtocol;
          this.Name = @name;
          this.Port = @port;
          this.Protocol = @protocol;
      }

    }
    /// <summary>
    /// EndpointSlice represents a subset of the endpoints that implement a service. For a given
    /// service there may be multiple EndpointSlice objects, selected by labels, which must be
    /// joined to produce the full set of endpoints.
    /// </summary>
    [OutputType]
    public sealed class EndpointSlice
    {
      /// <summary>
        /// addressType specifies the type of address carried by this EndpointSlice. All addresses
        /// in this slice must be the same type. This field is immutable after creation. The
        /// following address types are currently supported: * IPv4: Represents an IPv4 Address. *
        /// IPv6: Represents an IPv6 Address. * FQDN: Represents a Fully Qualified Domain Name.
        /// </summary>
      public readonly string AddressType;

      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// endpoints is a list of unique endpoints in this slice. Each slice may include a maximum
        /// of 1000 endpoints.
        /// </summary>
      public readonly ImmutableArray<Discovery.V1Beta1.Endpoint> Endpoints;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// ports specifies the list of network ports exposed by each endpoint in this slice. Each
        /// port must have a unique name. When ports is empty, it indicates that there are no
        /// defined ports. When a port is defined with a nil port value, it indicates "all ports".
        /// Each slice may include a maximum of 100 ports.
        /// </summary>
      public readonly ImmutableArray<Discovery.V1Beta1.EndpointPort> Ports;

      [OutputConstructor]
      private EndpointSlice(
          string @addressType,
          string @apiVersion,
          ImmutableArray<Discovery.V1Beta1.Endpoint> @endpoints,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<Discovery.V1Beta1.EndpointPort> @ports)
      {
          this.AddressType = @addressType;
          this.ApiVersion = @apiVersion;
          this.Endpoints = @endpoints;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Ports = @ports;
      }

    }
    /// <summary>
    /// EndpointSliceList represents a list of endpoint slices
    /// </summary>
    [OutputType]
    public sealed class EndpointSliceList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of endpoint slices
        /// </summary>
      public readonly ImmutableArray<Discovery.V1Beta1.EndpointSlice> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private EndpointSliceList(
          string @apiVersion,
          ImmutableArray<Discovery.V1Beta1.EndpointSlice> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Events
{
  namespace V1Beta1
  {
    /// <summary>
    /// Event is a report of an event somewhere in the cluster. It generally denotes some state
    /// change in the system.
    /// </summary>
    [OutputType]
    public sealed class Event
    {
      /// <summary>
        /// What action was taken/failed regarding to the regarding object.
        /// </summary>
      public readonly string Action;

      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
      public readonly int DeprecatedCount;

      /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
      public readonly string DeprecatedFirstTimestamp;

      /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
      public readonly string DeprecatedLastTimestamp;

      /// <summary>
        /// Deprecated field assuring backward compatibility with core.v1 Event type
        /// </summary>
      public readonly Core.V1.EventSource DeprecatedSource;

      /// <summary>
        /// Required. Time when this Event was first observed.
        /// </summary>
      public readonly string EventTime;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Optional. A human-readable description of the status of this operation. Maximal length
        /// of the note is 1kB, but libraries should be prepared to handle values up to 64kB.
        /// </summary>
      public readonly string Note;

      /// <summary>
        /// Why the action was taken.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// The object this Event is about. In most cases it's an Object reporting controller
        /// implements. E.g. ReplicaSetController implements ReplicaSets and this event is emitted
        /// because it acts on some changes in a ReplicaSet object.
        /// </summary>
      public readonly Core.V1.ObjectReference Regarding;

      /// <summary>
        /// Optional secondary object for more complex actions. E.g. when regarding object triggers
        /// a creation or deletion of related object.
        /// </summary>
      public readonly Core.V1.ObjectReference Related;

      /// <summary>
        /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
        /// </summary>
      public readonly string ReportingController;

      /// <summary>
        /// ID of the controller instance, e.g. `kubelet-xyzf`.
        /// </summary>
      public readonly string ReportingInstance;

      /// <summary>
        /// Data about the Event series this event represents or nil if it's a singleton Event.
        /// </summary>
      public readonly Events.V1Beta1.EventSeries Series;

      /// <summary>
        /// Type of this event (Normal, Warning), new types could be added in the future.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private Event(
          string @action,
          string @apiVersion,
          int @deprecatedCount,
          string @deprecatedFirstTimestamp,
          string @deprecatedLastTimestamp,
          Core.V1.EventSource @deprecatedSource,
          string @eventTime,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          string @note,
          string @reason,
          Core.V1.ObjectReference @regarding,
          Core.V1.ObjectReference @related,
          string @reportingController,
          string @reportingInstance,
          Events.V1Beta1.EventSeries @series,
          string @type)
      {
          this.Action = @action;
          this.ApiVersion = @apiVersion;
          this.DeprecatedCount = @deprecatedCount;
          this.DeprecatedFirstTimestamp = @deprecatedFirstTimestamp;
          this.DeprecatedLastTimestamp = @deprecatedLastTimestamp;
          this.DeprecatedSource = @deprecatedSource;
          this.EventTime = @eventTime;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Note = @note;
          this.Reason = @reason;
          this.Regarding = @regarding;
          this.Related = @related;
          this.ReportingController = @reportingController;
          this.ReportingInstance = @reportingInstance;
          this.Series = @series;
          this.Type = @type;
      }

    }
    /// <summary>
    /// EventList is a list of Event objects.
    /// </summary>
    [OutputType]
    public sealed class EventList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Events.V1Beta1.Event> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private EventList(
          string @apiVersion,
          ImmutableArray<Events.V1Beta1.Event> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// EventSeries contain information on series of events, i.e. thing that was/is happening
    /// continuously for some time.
    /// </summary>
    [OutputType]
    public sealed class EventSeries
    {
      /// <summary>
        /// Number of occurrences in this series up to the last heartbeat time
        /// </summary>
      public readonly int Count;

      /// <summary>
        /// Time when last Event from the series was seen before last heartbeat.
        /// </summary>
      public readonly string LastObservedTime;

      /// <summary>
        /// Information whether this series is ongoing or finished. Deprecated. Planned removal for
        /// 1.18
        /// </summary>
      public readonly string State;

      [OutputConstructor]
      private EventSeries(
          int @count,
          string @lastObservedTime,
          string @state)
      {
          this.Count = @count;
          this.LastObservedTime = @lastObservedTime;
          this.State = @state;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Extensions
{
  namespace V1Beta1
  {
    /// <summary>
    /// AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
    /// </summary>
    [OutputType]
    public sealed class AllowedCSIDriver
    {
      /// <summary>
        /// Name is the registered name of the CSI driver
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private AllowedCSIDriver(
          string @name)
      {
          this.Name = @name;
      }

    }
    /// <summary>
    /// AllowedFlexVolume represents a single Flexvolume that is allowed to be used. Deprecated: use
    /// AllowedFlexVolume from policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class AllowedFlexVolume
    {
      /// <summary>
        /// driver is the name of the Flexvolume driver.
        /// </summary>
      public readonly string Driver;

      [OutputConstructor]
      private AllowedFlexVolume(
          string @driver)
      {
          this.Driver = @driver;
      }

    }
    /// <summary>
    /// AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods
    /// to use. It requires the path prefix to be defined. Deprecated: use AllowedHostPath from
    /// policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class AllowedHostPath
    {
      /// <summary>
        /// pathPrefix is the path prefix that the host volume must match. It does not support `*`.
        /// Trailing slashes are trimmed when validating the path prefix with a host path.
        /// 
        /// Examples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo` would not allow
        /// `/food` or `/etc/foo`
        /// </summary>
      public readonly string PathPrefix;

      /// <summary>
        /// when set to true, will allow host volumes matching the pathPrefix only if all volume
        /// mounts are readOnly.
        /// </summary>
      public readonly bool ReadOnly;

      [OutputConstructor]
      private AllowedHostPath(
          string @pathPrefix,
          bool @readOnly)
      {
          this.PathPrefix = @pathPrefix;
          this.ReadOnly = @readOnly;
      }

    }
    /// <summary>
    /// DEPRECATED - extensions/v1beta1/DaemonSet is not supported by Kubernetes 1.16+ clusters. Use
    /// apps/v1/DaemonSet instead.
    /// 
    /// DaemonSet represents the configuration of a daemon set.
    /// </summary>
    [OutputType]
    public sealed class DaemonSet
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// The desired behavior of this daemon set. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Extensions.V1Beta1.DaemonSetSpec Spec;

      /// <summary>
        /// The current status of this daemon set. This data may be out of date by some window of
        /// time. Populated by the system. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Extensions.V1Beta1.DaemonSetStatus Status;

      [OutputConstructor]
      private DaemonSet(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Extensions.V1Beta1.DaemonSetSpec @spec,
          Extensions.V1Beta1.DaemonSetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// DaemonSetCondition describes the state of a DaemonSet at a certain point.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of DaemonSet condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DaemonSetCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DaemonSetList is a collection of daemon sets.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// A list of daemon sets.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.DaemonSet> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private DaemonSetList(
          string @apiVersion,
          ImmutableArray<Extensions.V1Beta1.DaemonSet> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DaemonSetSpec is the specification of a daemon set.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetSpec
    {
      /// <summary>
        /// The minimum number of seconds for which a newly created DaemonSet pod should be ready
        /// without any of its container crashing, for it to be considered available. Defaults to 0
        /// (pod will be considered available as soon as it is ready).
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// The number of old history to retain to allow rollback. This is a pointer to distinguish
        /// between explicit zero and not specified. Defaults to 10.
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// A label query over pods that are managed by the daemon set. Must match in order to be
        /// controlled. If empty, defaulted to labels on Pod template. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// An object that describes the pod that will be created. The DaemonSet will create exactly
        /// one copy of this pod on every node that matches the template's node selector (or on
        /// every node if no node selector is specified). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      /// <summary>
        /// DEPRECATED. A sequence number representing a specific generation of the template.
        /// Populated by the system. It can be set only during the creation.
        /// </summary>
      public readonly int TemplateGeneration;

      /// <summary>
        /// An update strategy to replace existing DaemonSet pods with new pods.
        /// </summary>
      public readonly Extensions.V1Beta1.DaemonSetUpdateStrategy UpdateStrategy;

      [OutputConstructor]
      private DaemonSetSpec(
          int @minReadySeconds,
          int @revisionHistoryLimit,
          Meta.V1.LabelSelector @selector,
          Core.V1.PodTemplateSpec @template,
          int @templateGeneration,
          Extensions.V1Beta1.DaemonSetUpdateStrategy @updateStrategy)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.Selector = @selector;
          this.Template = @template;
          this.TemplateGeneration = @templateGeneration;
          this.UpdateStrategy = @updateStrategy;
      }

    }
    /// <summary>
    /// DaemonSetStatus represents the current status of a daemon set.
    /// </summary>
    [OutputType]
    public sealed class DaemonSetStatus
    {
      /// <summary>
        /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as
        /// a collision avoidance mechanism when it needs to create the name for the newest
        /// ControllerRevision.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a DaemonSet's current state.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.DaemonSetCondition> Conditions;

      /// <summary>
        /// The number of nodes that are running at least 1 daemon pod and are supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
      public readonly int CurrentNumberScheduled;

      /// <summary>
        /// The total number of nodes that should be running the daemon pod (including nodes
        /// correctly running the daemon pod). More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
      public readonly int DesiredNumberScheduled;

      /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
      public readonly int NumberAvailable;

      /// <summary>
        /// The number of nodes that are running the daemon pod, but are not supposed to run the
        /// daemon pod. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        /// </summary>
      public readonly int NumberMisscheduled;

      /// <summary>
        /// The number of nodes that should be running the daemon pod and have one or more of the
        /// daemon pod running and ready.
        /// </summary>
      public readonly int NumberReady;

      /// <summary>
        /// The number of nodes that should be running the daemon pod and have none of the daemon
        /// pod running and available (ready for at least spec.minReadySeconds)
        /// </summary>
      public readonly int NumberUnavailable;

      /// <summary>
        /// The most recent generation observed by the daemon set controller.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// The total number of nodes that are running updated daemon pod
        /// </summary>
      public readonly int UpdatedNumberScheduled;

      [OutputConstructor]
      private DaemonSetStatus(
          int @collisionCount,
          ImmutableArray<Extensions.V1Beta1.DaemonSetCondition> @conditions,
          int @currentNumberScheduled,
          int @desiredNumberScheduled,
          int @numberAvailable,
          int @numberMisscheduled,
          int @numberReady,
          int @numberUnavailable,
          int @observedGeneration,
          int @updatedNumberScheduled)
      {
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.CurrentNumberScheduled = @currentNumberScheduled;
          this.DesiredNumberScheduled = @desiredNumberScheduled;
          this.NumberAvailable = @numberAvailable;
          this.NumberMisscheduled = @numberMisscheduled;
          this.NumberReady = @numberReady;
          this.NumberUnavailable = @numberUnavailable;
          this.ObservedGeneration = @observedGeneration;
          this.UpdatedNumberScheduled = @updatedNumberScheduled;
      }

    }
    /// <summary>
    /// 
    /// </summary>
    [OutputType]
    public sealed class DaemonSetUpdateStrategy
    {
      /// <summary>
        /// Rolling update config params. Present only if type = "RollingUpdate".
        /// </summary>
      public readonly Extensions.V1Beta1.RollingUpdateDaemonSet RollingUpdate;

      /// <summary>
        /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is OnDelete.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DaemonSetUpdateStrategy(
          Extensions.V1Beta1.RollingUpdateDaemonSet @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DEPRECATED - extensions/v1beta1/Deployment is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/Deployment instead.
    /// 
    /// Deployment enables declarative updates for Pods and ReplicaSets.
    /// </summary>
    [OutputType]
    public sealed class Deployment
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of the Deployment.
        /// </summary>
      public readonly Extensions.V1Beta1.DeploymentSpec Spec;

      /// <summary>
        /// Most recently observed status of the Deployment.
        /// </summary>
      public readonly Extensions.V1Beta1.DeploymentStatus Status;

      [OutputConstructor]
      private Deployment(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Extensions.V1Beta1.DeploymentSpec @spec,
          Extensions.V1Beta1.DeploymentStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// DeploymentCondition describes the state of a deployment at a certain point.
    /// </summary>
    [OutputType]
    public sealed class DeploymentCondition
    {
      /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// The last time this condition was updated.
        /// </summary>
      public readonly string LastUpdateTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of deployment condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DeploymentCondition(
          string @lastTransitionTime,
          string @lastUpdateTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.LastUpdateTime = @lastUpdateTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// DeploymentList is a list of Deployments.
    /// </summary>
    [OutputType]
    public sealed class DeploymentList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of Deployments.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.Deployment> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private DeploymentList(
          string @apiVersion,
          ImmutableArray<Extensions.V1Beta1.Deployment> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentRollback
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Required: This must match the Name of a deployment.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// The config of this deployment rollback.
        /// </summary>
      public readonly Extensions.V1Beta1.RollbackConfig RollbackTo;

      /// <summary>
        /// The annotations to be updated to a deployment
        /// </summary>
      public readonly ImmutableDictionary<string, string> UpdatedAnnotations;

      [OutputConstructor]
      private DeploymentRollback(
          string @apiVersion,
          string @kind,
          string @name,
          Extensions.V1Beta1.RollbackConfig @rollbackTo,
          ImmutableDictionary<string, string> @updatedAnnotations)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Name = @name;
          this.RollbackTo = @rollbackTo;
          this.UpdatedAnnotations = @updatedAnnotations;
      }

    }
    /// <summary>
    /// DeploymentSpec is the specification of the desired behavior of the Deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentSpec
    {
      /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// Indicates that the deployment is paused and will not be processed by the deployment
        /// controller.
        /// </summary>
      public readonly bool Paused;

      /// <summary>
        /// The maximum time in seconds for a deployment to make progress before it is considered to
        /// be failed. The deployment controller will continue to process failed deployments and a
        /// condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment
        /// status. Note that progress will not be estimated during the time a deployment is paused.
        /// This is set to the max value of int32 (i.e. 2147483647) by default, which means "no
        /// deadline".
        /// </summary>
      public readonly int ProgressDeadlineSeconds;

      /// <summary>
        /// Number of desired pods. This is a pointer to distinguish between explicit zero and not
        /// specified. Defaults to 1.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// The number of old ReplicaSets to retain to allow rollback. This is a pointer to
        /// distinguish between explicit zero and not specified. This is set to the max value of
        /// int32 (i.e. 2147483647) by default, which means "retaining all old RelicaSets".
        /// </summary>
      public readonly int RevisionHistoryLimit;

      /// <summary>
        /// DEPRECATED. The config this deployment is rolling back to. Will be cleared after
        /// rollback is done.
        /// </summary>
      public readonly Extensions.V1Beta1.RollbackConfig RollbackTo;

      /// <summary>
        /// Label selector for pods. Existing ReplicaSets whose pods are selected by this will be
        /// the ones affected by this deployment.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// The deployment strategy to use to replace existing pods with new ones.
        /// </summary>
      public readonly Extensions.V1Beta1.DeploymentStrategy Strategy;

      /// <summary>
        /// Template describes the pods that will be created.
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      [OutputConstructor]
      private DeploymentSpec(
          int @minReadySeconds,
          bool @paused,
          int @progressDeadlineSeconds,
          int @replicas,
          int @revisionHistoryLimit,
          Extensions.V1Beta1.RollbackConfig @rollbackTo,
          Meta.V1.LabelSelector @selector,
          Extensions.V1Beta1.DeploymentStrategy @strategy,
          Core.V1.PodTemplateSpec @template)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.Paused = @paused;
          this.ProgressDeadlineSeconds = @progressDeadlineSeconds;
          this.Replicas = @replicas;
          this.RevisionHistoryLimit = @revisionHistoryLimit;
          this.RollbackTo = @rollbackTo;
          this.Selector = @selector;
          this.Strategy = @strategy;
          this.Template = @template;
      }

    }
    /// <summary>
    /// DeploymentStatus is the most recently observed status of the Deployment.
    /// </summary>
    [OutputType]
    public sealed class DeploymentStatus
    {
      /// <summary>
        /// Total number of available pods (ready for at least minReadySeconds) targeted by this
        /// deployment.
        /// </summary>
      public readonly int AvailableReplicas;

      /// <summary>
        /// Count of hash collisions for the Deployment. The Deployment controller uses this field
        /// as a collision avoidance mechanism when it needs to create the name for the newest
        /// ReplicaSet.
        /// </summary>
      public readonly int CollisionCount;

      /// <summary>
        /// Represents the latest available observations of a deployment's current state.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.DeploymentCondition> Conditions;

      /// <summary>
        /// The generation observed by the deployment controller.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// Total number of ready pods targeted by this deployment.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// Total number of non-terminated pods targeted by this deployment (their labels match the
        /// selector).
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// Total number of unavailable pods targeted by this deployment. This is the total number
        /// of pods that are still required for the deployment to have 100% available capacity. They
        /// may either be pods that are running but not yet available or pods that still have not
        /// been created.
        /// </summary>
      public readonly int UnavailableReplicas;

      /// <summary>
        /// Total number of non-terminated pods targeted by this deployment that have the desired
        /// template spec.
        /// </summary>
      public readonly int UpdatedReplicas;

      [OutputConstructor]
      private DeploymentStatus(
          int @availableReplicas,
          int @collisionCount,
          ImmutableArray<Extensions.V1Beta1.DeploymentCondition> @conditions,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas,
          int @unavailableReplicas,
          int @updatedReplicas)
      {
          this.AvailableReplicas = @availableReplicas;
          this.CollisionCount = @collisionCount;
          this.Conditions = @conditions;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
          this.UnavailableReplicas = @unavailableReplicas;
          this.UpdatedReplicas = @updatedReplicas;
      }

    }
    /// <summary>
    /// DeploymentStrategy describes how to replace existing pods with new ones.
    /// </summary>
    [OutputType]
    public sealed class DeploymentStrategy
    {
      /// <summary>
        /// Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        /// </summary>
      public readonly Extensions.V1Beta1.RollingUpdateDeployment RollingUpdate;

      /// <summary>
        /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private DeploymentStrategy(
          Extensions.V1Beta1.RollingUpdateDeployment @rollingUpdate,
          string @type)
      {
          this.RollingUpdate = @rollingUpdate;
          this.Type = @type;
      }

    }
    /// <summary>
    /// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
    /// Deprecated: use FSGroupStrategyOptions from policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class FSGroupStrategyOptions
    {
      /// <summary>
        /// ranges are the allowed ranges of fs groups.  If you would like to force a single fs
        /// group then supply a single range with the same start and end. Required for MustRunAs.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.IDRange> Ranges;

      /// <summary>
        /// rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
        /// </summary>
      public readonly string Rule;

      [OutputConstructor]
      private FSGroupStrategyOptions(
          ImmutableArray<Extensions.V1Beta1.IDRange> @ranges,
          string @rule)
      {
          this.Ranges = @ranges;
          this.Rule = @rule;
      }

    }
    /// <summary>
    /// HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are
    /// forwarded to the backend.
    /// </summary>
    [OutputType]
    public sealed class HTTPIngressPath
    {
      /// <summary>
        /// Backend defines the referenced service endpoint to which the traffic will be forwarded
        /// to.
        /// </summary>
      public readonly Extensions.V1Beta1.IngressBackend Backend;

      /// <summary>
        /// Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the
        /// egrep/unix syntax, not the perl syntax) matched against the path of an incoming request.
        /// Currently it can contain characters disallowed from the conventional "path" part of a
        /// URL as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path
        /// defaults to a catch all sending traffic to the backend.
        /// </summary>
      public readonly string Path;

      [OutputConstructor]
      private HTTPIngressPath(
          Extensions.V1Beta1.IngressBackend @backend,
          string @path)
      {
          this.Backend = @backend;
          this.Path = @path;
      }

    }
    /// <summary>
    /// HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example:
    /// http://&amp;lt;host&amp;gt;/&amp;lt;path&amp;gt;?&amp;lt;searchpart&amp;gt; -&amp;gt;
    /// backend where where parts of the url correspond to RFC 3986, this resource will be used to
    /// match against everything after the last '/' and before the first '?' or '#'.
    /// </summary>
    [OutputType]
    public sealed class HTTPIngressRuleValue
    {
      /// <summary>
        /// A collection of paths that map requests to backends.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.HTTPIngressPath> Paths;

      [OutputConstructor]
      private HTTPIngressRuleValue(
          ImmutableArray<Extensions.V1Beta1.HTTPIngressPath> @paths)
      {
          this.Paths = @paths;
      }

    }
    /// <summary>
    /// HostPortRange defines a range of host ports that will be enabled by a policy for pods to
    /// use.  It requires both the start and end to be defined. Deprecated: use HostPortRange from
    /// policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class HostPortRange
    {
      /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
      public readonly int Max;

      /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
      public readonly int Min;

      [OutputConstructor]
      private HostPortRange(
          int @max,
          int @min)
      {
          this.Max = @max;
          this.Min = @min;
      }

    }
    /// <summary>
    /// IDRange provides a min/max of an allowed range of IDs. Deprecated: use IDRange from policy
    /// API Group instead.
    /// </summary>
    [OutputType]
    public sealed class IDRange
    {
      /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
      public readonly int Max;

      /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
      public readonly int Min;

      [OutputConstructor]
      private IDRange(
          int @max,
          int @min)
      {
          this.Max = @max;
          this.Min = @min;
      }

    }
    /// <summary>
    /// DEPRECATED 1.9 - This group version of IPBlock is deprecated by networking/v1/IPBlock.
    /// IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
    /// matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
    /// not be included within this rule.
    /// </summary>
    [OutputType]
    public sealed class IPBlock
    {
      /// <summary>
        /// CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24"
        /// </summary>
      public readonly string Cidr;

      /// <summary>
        /// Except is a slice of CIDRs that should not be included within an IP Block Valid examples
        /// are "192.168.1.1/24" Except values will be rejected if they are outside the CIDR range
        /// </summary>
      public readonly ImmutableArray<string> Except;

      [OutputConstructor]
      private IPBlock(
          string @cidr,
          ImmutableArray<string> @except)
      {
          this.Cidr = @cidr;
          this.Except = @except;
      }

    }
    /// <summary>
    /// DEPRECATED - extensions/v1beta1/Ingress is not supported by Kubernetes 1.16+ clusters. Use
    /// networking/v1beta1/Ingress instead.
    /// 
    /// Ingress is a collection of rules that allow inbound connections to reach the endpoints
    /// defined by a backend. An Ingress can be configured to give services externally-reachable
    /// urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. 
    /// </summary>
    [OutputType]
    public sealed class Ingress
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec is the desired state of the Ingress. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Extensions.V1Beta1.IngressSpec Spec;

      /// <summary>
        /// Status is the current state of the Ingress. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Extensions.V1Beta1.IngressStatus Status;

      [OutputConstructor]
      private Ingress(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Extensions.V1Beta1.IngressSpec @spec,
          Extensions.V1Beta1.IngressStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// IngressBackend describes all endpoints for a given service and port.
    /// </summary>
    [OutputType]
    public sealed class IngressBackend
    {
      /// <summary>
        /// Specifies the name of the referenced service.
        /// </summary>
      public readonly string ServiceName;

      /// <summary>
        /// Specifies the port of the referenced service.
        /// </summary>
      public readonly Union<int,string> ServicePort;

      [OutputConstructor]
      private IngressBackend(
          string @serviceName,
          Union<int,string> @servicePort)
      {
          this.ServiceName = @serviceName;
          this.ServicePort = @servicePort;
      }

    }
    /// <summary>
    /// IngressList is a collection of Ingress.
    /// </summary>
    [OutputType]
    public sealed class IngressList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of Ingress.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.Ingress> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private IngressList(
          string @apiVersion,
          ImmutableArray<Extensions.V1Beta1.Ingress> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// IngressRule represents the rules mapping the paths under a specified host to the related
    /// backend services. Incoming requests are first evaluated for a host match, then routed to the
    /// backend associated with the matching IngressRuleValue.
    /// </summary>
    [OutputType]
    public sealed class IngressRule
    {
      /// <summary>
        /// Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note
        /// the following deviations from the "host" part of the URI as defined in the RFC: 1. IPs
        /// are not allowed. Currently an IngressRuleValue can only apply to the
        /// 	  IP in the Spec of the parent Ingress.
        /// 2. The `:` delimiter is not respected because ports are not allowed.
        /// 	  Currently the port of an Ingress is implicitly :80 for http and
        /// 	  :443 for https.
        /// Both these may change in the future. Incoming requests are matched against the host
        /// before the IngressRuleValue. If the host is unspecified, the Ingress routes all traffic
        /// based on the specified IngressRuleValue.
        /// </summary>
      public readonly string Host;

      
      public readonly Extensions.V1Beta1.HTTPIngressRuleValue Http;

      [OutputConstructor]
      private IngressRule(
          string @host,
          Extensions.V1Beta1.HTTPIngressRuleValue @http)
      {
          this.Host = @host;
          this.Http = @http;
      }

    }
    /// <summary>
    /// IngressSpec describes the Ingress the user wishes to exist.
    /// </summary>
    [OutputType]
    public sealed class IngressSpec
    {
      /// <summary>
        /// A default backend capable of servicing requests that don't match any rule. At least one
        /// of 'backend' or 'rules' must be specified. This field is optional to allow the
        /// loadbalancer controller or defaulting logic to specify a global default.
        /// </summary>
      public readonly Extensions.V1Beta1.IngressBackend Backend;

      /// <summary>
        /// A list of host rules used to configure the Ingress. If unspecified, or no rule matches,
        /// all traffic is sent to the default backend.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.IngressRule> Rules;

      /// <summary>
        /// TLS configuration. Currently the Ingress only supports a single TLS port, 443. If
        /// multiple members of this list specify different hosts, they will be multiplexed on the
        /// same port according to the hostname specified through the SNI TLS extension, if the
        /// ingress controller fulfilling the ingress supports SNI.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.IngressTLS> Tls;

      [OutputConstructor]
      private IngressSpec(
          Extensions.V1Beta1.IngressBackend @backend,
          ImmutableArray<Extensions.V1Beta1.IngressRule> @rules,
          ImmutableArray<Extensions.V1Beta1.IngressTLS> @tls)
      {
          this.Backend = @backend;
          this.Rules = @rules;
          this.Tls = @tls;
      }

    }
    /// <summary>
    /// IngressStatus describe the current state of the Ingress.
    /// </summary>
    [OutputType]
    public sealed class IngressStatus
    {
      /// <summary>
        /// LoadBalancer contains the current status of the load-balancer.
        /// </summary>
      public readonly Core.V1.LoadBalancerStatus LoadBalancer;

      [OutputConstructor]
      private IngressStatus(
          Core.V1.LoadBalancerStatus @loadBalancer)
      {
          this.LoadBalancer = @loadBalancer;
      }

    }
    /// <summary>
    /// IngressTLS describes the transport layer security associated with an Ingress.
    /// </summary>
    [OutputType]
    public sealed class IngressTLS
    {
      /// <summary>
        /// Hosts are a list of hosts included in the TLS certificate. The values in this list must
        /// match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the
        /// loadbalancer controller fulfilling this Ingress, if left unspecified.
        /// </summary>
      public readonly ImmutableArray<string> Hosts;

      /// <summary>
        /// SecretName is the name of the secret used to terminate SSL traffic on 443. Field is left
        /// optional to allow SSL routing based on SNI hostname alone. If the SNI host in a listener
        /// conflicts with the "Host" header field used by an IngressRule, the SNI host is used for
        /// termination and value of the Host header is used for routing.
        /// </summary>
      public readonly string SecretName;

      [OutputConstructor]
      private IngressTLS(
          ImmutableArray<string> @hosts,
          string @secretName)
      {
          this.Hosts = @hosts;
          this.SecretName = @secretName;
      }

    }
    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by
    /// networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a
    /// set of Pods
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicy
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior for this NetworkPolicy.
        /// </summary>
      public readonly Extensions.V1Beta1.NetworkPolicySpec Spec;

      [OutputConstructor]
      private NetworkPolicy(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Extensions.V1Beta1.NetworkPolicySpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyEgressRule is deprecated by
    /// networking/v1/NetworkPolicyEgressRule. NetworkPolicyEgressRule describes a particular set of
    /// traffic that is allowed out of pods matched by a NetworkPolicySpec's podSelector. The
    /// traffic must match both ports and to. This type is beta-level in 1.8
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyEgressRule
    {
      /// <summary>
        /// List of destination ports for outgoing traffic. Each item in this list is combined using
        /// a logical OR. If this field is empty or missing, this rule matches all ports (traffic
        /// not restricted by port). If this field is present and contains at least one item, then
        /// this rule allows traffic only if the traffic matches at least one port in the list.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.NetworkPolicyPort> Ports;

      /// <summary>
        /// List of destinations for outgoing traffic of pods selected for this rule. Items in this
        /// list are combined using a logical OR operation. If this field is empty or missing, this
        /// rule matches all destinations (traffic not restricted by destination). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the to list.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.NetworkPolicyPeer> To;

      [OutputConstructor]
      private NetworkPolicyEgressRule(
          ImmutableArray<Extensions.V1Beta1.NetworkPolicyPort> @ports,
          ImmutableArray<Extensions.V1Beta1.NetworkPolicyPeer> @to)
      {
          this.Ports = @ports;
          this.To = @to;
      }

    }
    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyIngressRule is deprecated by
    /// networking/v1/NetworkPolicyIngressRule. This NetworkPolicyIngressRule matches traffic if and
    /// only if the traffic matches both ports AND from.
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyIngressRule
    {
      /// <summary>
        /// List of sources which should be able to access the pods selected for this rule. Items in
        /// this list are combined using a logical OR operation. If this field is empty or missing,
        /// this rule matches all sources (traffic not restricted by source). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the from list.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.NetworkPolicyPeer> From;

      /// <summary>
        /// List of ports which should be made accessible on the pods selected for this rule. Each
        /// item in this list is combined using a logical OR. If this field is empty or missing,
        /// this rule matches all ports (traffic not restricted by port). If this field is present
        /// and contains at least one item, then this rule allows traffic only if the traffic
        /// matches at least one port in the list.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.NetworkPolicyPort> Ports;

      [OutputConstructor]
      private NetworkPolicyIngressRule(
          ImmutableArray<Extensions.V1Beta1.NetworkPolicyPeer> @from,
          ImmutableArray<Extensions.V1Beta1.NetworkPolicyPort> @ports)
      {
          this.From = @from;
          this.Ports = @ports;
      }

    }
    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyList is deprecated by
    /// networking/v1/NetworkPolicyList. Network Policy List is a list of NetworkPolicy objects.
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.NetworkPolicy> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private NetworkPolicyList(
          string @apiVersion,
          ImmutableArray<Extensions.V1Beta1.NetworkPolicy> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyPeer is deprecated by
    /// networking/v1/NetworkPolicyPeer.
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyPeer
    {
      /// <summary>
        /// IPBlock defines policy on a particular IPBlock. If this field is set then neither of the
        /// other fields can be.
        /// </summary>
      public readonly Extensions.V1Beta1.IPBlock IpBlock;

      /// <summary>
        /// Selects Namespaces using cluster-scoped labels. This field follows standard label
        /// selector semantics; if present but empty, it selects all namespaces.
        /// 
        /// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects all Pods in the Namespaces selected by NamespaceSelector.
        /// </summary>
      public readonly Meta.V1.LabelSelector NamespaceSelector;

      /// <summary>
        /// This is a label selector which selects Pods. This field follows standard label selector
        /// semantics; if present but empty, it selects all pods.
        /// 
        /// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects the Pods matching PodSelector in the policy's own Namespace.
        /// </summary>
      public readonly Meta.V1.LabelSelector PodSelector;

      [OutputConstructor]
      private NetworkPolicyPeer(
          Extensions.V1Beta1.IPBlock @ipBlock,
          Meta.V1.LabelSelector @namespaceSelector,
          Meta.V1.LabelSelector @podSelector)
      {
          this.IpBlock = @ipBlock;
          this.NamespaceSelector = @namespaceSelector;
          this.PodSelector = @podSelector;
      }

    }
    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicyPort is deprecated by
    /// networking/v1/NetworkPolicyPort.
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyPort
    {
      /// <summary>
        /// If specified, the port on the given protocol.  This can either be a numerical or named
        /// port on a pod.  If this field is not provided, this matches all port names and numbers.
        /// If present, only traffic on the specified protocol AND port will be matched.
        /// </summary>
      public readonly Union<int,string> Port;

      /// <summary>
        /// Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified,
        /// this field defaults to TCP.
        /// </summary>
      public readonly string Protocol;

      [OutputConstructor]
      private NetworkPolicyPort(
          Union<int,string> @port,
          string @protocol)
      {
          this.Port = @port;
          this.Protocol = @protocol;
      }

    }
    /// <summary>
    /// DEPRECATED 1.9 - This group version of NetworkPolicySpec is deprecated by
    /// networking/v1/NetworkPolicySpec.
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicySpec
    {
      /// <summary>
        /// List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if
        /// there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
        /// traffic), OR if the traffic matches at least one egress rule across all of the
        /// NetworkPolicy objects whose podSelector matches the pod. If this field is empty then
        /// this NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the
        /// pods it selects are isolated by default). This field is beta-level in 1.8
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.NetworkPolicyEgressRule> Egress;

      /// <summary>
        /// List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if
        /// there are no NetworkPolicies selecting the pod OR if the traffic source is the pod's
        /// local node, OR if the traffic matches at least one ingress rule across all of the
        /// NetworkPolicy objects whose podSelector matches the pod. If this field is empty then
        /// this NetworkPolicy does not allow any traffic (and serves solely to ensure that the pods
        /// it selects are isolated by default).
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.NetworkPolicyIngressRule> Ingress;

      /// <summary>
        /// Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
        /// is applied to any pods selected by this field. Multiple network policies can select the
        /// same set of pods.  In this case, the ingress rules for each are combined additively.
        /// This field is NOT optional and follows standard label selector semantics. An empty
        /// podSelector matches all pods in this namespace.
        /// </summary>
      public readonly Meta.V1.LabelSelector PodSelector;

      /// <summary>
        /// List of rule types that the NetworkPolicy relates to. Valid options are "Ingress",
        /// "Egress", or "Ingress,Egress". If this field is not specified, it will default based on
        /// the existence of Ingress or Egress rules; policies that contain an Egress section are
        /// assumed to affect Egress, and all policies (whether or not they contain an Ingress
        /// section) are assumed to affect Ingress. If you want to write an egress-only policy, you
        /// must explicitly specify policyTypes [ "Egress" ]. Likewise, if you want to write a
        /// policy that specifies that no egress is allowed, you must specify a policyTypes value
        /// that include "Egress" (since such a policy would not include an Egress section and would
        /// otherwise default to just [ "Ingress" ]). This field is beta-level in 1.8
        /// </summary>
      public readonly ImmutableArray<string> PolicyTypes;

      [OutputConstructor]
      private NetworkPolicySpec(
          ImmutableArray<Extensions.V1Beta1.NetworkPolicyEgressRule> @egress,
          ImmutableArray<Extensions.V1Beta1.NetworkPolicyIngressRule> @ingress,
          Meta.V1.LabelSelector @podSelector,
          ImmutableArray<string> @policyTypes)
      {
          this.Egress = @egress;
          this.Ingress = @ingress;
          this.PodSelector = @podSelector;
          this.PolicyTypes = @policyTypes;
      }

    }
    /// <summary>
    /// PodSecurityPolicy governs the ability to make requests that affect the Security Context that
    /// will be applied to a pod and container. Deprecated: use PodSecurityPolicy from policy API
    /// Group instead.
    /// </summary>
    [OutputType]
    public sealed class PodSecurityPolicy
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// spec defines the policy enforced.
        /// </summary>
      public readonly Extensions.V1Beta1.PodSecurityPolicySpec Spec;

      [OutputConstructor]
      private PodSecurityPolicy(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Extensions.V1Beta1.PodSecurityPolicySpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// PodSecurityPolicyList is a list of PodSecurityPolicy objects. Deprecated: use
    /// PodSecurityPolicyList from policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class PodSecurityPolicyList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.PodSecurityPolicy> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PodSecurityPolicyList(
          string @apiVersion,
          ImmutableArray<Extensions.V1Beta1.PodSecurityPolicy> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PodSecurityPolicySpec defines the policy enforced. Deprecated: use PodSecurityPolicySpec
    /// from policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class PodSecurityPolicySpec
    {
      /// <summary>
        /// allowPrivilegeEscalation determines if a pod can request to allow privilege escalation.
        /// If unspecified, defaults to true.
        /// </summary>
      public readonly bool AllowPrivilegeEscalation;

      /// <summary>
        /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be
        /// embedded within a pod spec. An empty value indicates that any CSI driver can be used for
        /// inline ephemeral volumes.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.AllowedCSIDriver> AllowedCSIDrivers;

      /// <summary>
        /// allowedCapabilities is a list of capabilities that can be requested to add to the
        /// container. Capabilities in this field may be added at the pod author's discretion. You
        /// must not list a capability in both allowedCapabilities and requiredDropCapabilities.
        /// </summary>
      public readonly ImmutableArray<string> AllowedCapabilities;

      /// <summary>
        /// allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that
        /// all Flexvolumes may be used.  This parameter is effective only when the usage of the
        /// Flexvolumes is allowed in the "volumes" field.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.AllowedFlexVolume> AllowedFlexVolumes;

      /// <summary>
        /// allowedHostPaths is a white list of allowed host paths. Empty indicates that all host
        /// paths may be used.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.AllowedHostPath> AllowedHostPaths;

      /// <summary>
        /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates
        /// that only the DefaultProcMountType may be used. This requires the ProcMountType feature
        /// flag to be enabled.
        /// </summary>
      public readonly ImmutableArray<string> AllowedProcMountTypes;

      /// <summary>
        /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
        /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
        /// as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet
        /// has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
        /// 
        /// Examples: e.g. "foo/*" allows "foo/bar", "foo/baz", etc. e.g. "foo.*" allows "foo.bar",
        /// "foo.baz", etc.
        /// </summary>
      public readonly ImmutableArray<string> AllowedUnsafeSysctls;

      /// <summary>
        /// defaultAddCapabilities is the default set of capabilities that will be added to the
        /// container unless the pod spec specifically drops the capability.  You may not list a
        /// capability in both defaultAddCapabilities and requiredDropCapabilities. Capabilities
        /// added here are implicitly allowed, and need not be included in the allowedCapabilities
        /// list.
        /// </summary>
      public readonly ImmutableArray<string> DefaultAddCapabilities;

      /// <summary>
        /// defaultAllowPrivilegeEscalation controls the default setting for whether a process can
        /// gain more privileges than its parent process.
        /// </summary>
      public readonly bool DefaultAllowPrivilegeEscalation;

      /// <summary>
        /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry
        /// is either a plain sysctl name or ends in "*" in which case it is considered as a prefix
        /// of forbidden sysctls. Single * means all sysctls are forbidden.
        /// 
        /// Examples: e.g. "foo/*" forbids "foo/bar", "foo/baz", etc. e.g. "foo.*" forbids
        /// "foo.bar", "foo.baz", etc.
        /// </summary>
      public readonly ImmutableArray<string> ForbiddenSysctls;

      /// <summary>
        /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
      public readonly Extensions.V1Beta1.FSGroupStrategyOptions FsGroup;

      /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
      public readonly bool HostIPC;

      /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
      public readonly bool HostNetwork;

      /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
      public readonly bool HostPID;

      /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.HostPortRange> HostPorts;

      /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
      public readonly bool Privileged;

      /// <summary>
        /// readOnlyRootFilesystem when set to true will force containers to run with a read only
        /// root file system.  If the container specifically requests to run with a non-read only
        /// root file system the PSP should deny the pod. If set to false the container may run with
        /// a read only root file system if it wishes but it will not be forced to.
        /// </summary>
      public readonly bool ReadOnlyRootFilesystem;

      /// <summary>
        /// requiredDropCapabilities are the capabilities that will be dropped from the container.
        /// These are required to be dropped and cannot be added.
        /// </summary>
      public readonly ImmutableArray<string> RequiredDropCapabilities;

      /// <summary>
        /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be
        /// set. If this field is omitted, the pod's RunAsGroup can take any value. This field
        /// requires the RunAsGroup feature gate to be enabled.
        /// </summary>
      public readonly Extensions.V1Beta1.RunAsGroupStrategyOptions RunAsGroup;

      /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be
        /// set.
        /// </summary>
      public readonly Extensions.V1Beta1.RunAsUserStrategyOptions RunAsUser;

      /// <summary>
        /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
        /// If this field is omitted, the pod's runtimeClassName field is unrestricted. Enforcement
        /// of this field depends on the RuntimeClass feature gate being enabled.
        /// </summary>
      public readonly Extensions.V1Beta1.RuntimeClassStrategyOptions RuntimeClass;

      /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
      public readonly Extensions.V1Beta1.SELinuxStrategyOptions SeLinux;

      /// <summary>
        /// supplementalGroups is the strategy that will dictate what supplemental groups are used
        /// by the SecurityContext.
        /// </summary>
      public readonly Extensions.V1Beta1.SupplementalGroupsStrategyOptions SupplementalGroups;

      /// <summary>
        /// volumes is a white list of allowed volume plugins. Empty indicates that no volumes may
        /// be used. To allow all volumes you may use '*'.
        /// </summary>
      public readonly ImmutableArray<string> Volumes;

      [OutputConstructor]
      private PodSecurityPolicySpec(
          bool @allowPrivilegeEscalation,
          ImmutableArray<Extensions.V1Beta1.AllowedCSIDriver> @allowedCSIDrivers,
          ImmutableArray<string> @allowedCapabilities,
          ImmutableArray<Extensions.V1Beta1.AllowedFlexVolume> @allowedFlexVolumes,
          ImmutableArray<Extensions.V1Beta1.AllowedHostPath> @allowedHostPaths,
          ImmutableArray<string> @allowedProcMountTypes,
          ImmutableArray<string> @allowedUnsafeSysctls,
          ImmutableArray<string> @defaultAddCapabilities,
          bool @defaultAllowPrivilegeEscalation,
          ImmutableArray<string> @forbiddenSysctls,
          Extensions.V1Beta1.FSGroupStrategyOptions @fsGroup,
          bool @hostIPC,
          bool @hostNetwork,
          bool @hostPID,
          ImmutableArray<Extensions.V1Beta1.HostPortRange> @hostPorts,
          bool @privileged,
          bool @readOnlyRootFilesystem,
          ImmutableArray<string> @requiredDropCapabilities,
          Extensions.V1Beta1.RunAsGroupStrategyOptions @runAsGroup,
          Extensions.V1Beta1.RunAsUserStrategyOptions @runAsUser,
          Extensions.V1Beta1.RuntimeClassStrategyOptions @runtimeClass,
          Extensions.V1Beta1.SELinuxStrategyOptions @seLinux,
          Extensions.V1Beta1.SupplementalGroupsStrategyOptions @supplementalGroups,
          ImmutableArray<string> @volumes)
      {
          this.AllowPrivilegeEscalation = @allowPrivilegeEscalation;
          this.AllowedCSIDrivers = @allowedCSIDrivers;
          this.AllowedCapabilities = @allowedCapabilities;
          this.AllowedFlexVolumes = @allowedFlexVolumes;
          this.AllowedHostPaths = @allowedHostPaths;
          this.AllowedProcMountTypes = @allowedProcMountTypes;
          this.AllowedUnsafeSysctls = @allowedUnsafeSysctls;
          this.DefaultAddCapabilities = @defaultAddCapabilities;
          this.DefaultAllowPrivilegeEscalation = @defaultAllowPrivilegeEscalation;
          this.ForbiddenSysctls = @forbiddenSysctls;
          this.FsGroup = @fsGroup;
          this.HostIPC = @hostIPC;
          this.HostNetwork = @hostNetwork;
          this.HostPID = @hostPID;
          this.HostPorts = @hostPorts;
          this.Privileged = @privileged;
          this.ReadOnlyRootFilesystem = @readOnlyRootFilesystem;
          this.RequiredDropCapabilities = @requiredDropCapabilities;
          this.RunAsGroup = @runAsGroup;
          this.RunAsUser = @runAsUser;
          this.RuntimeClass = @runtimeClass;
          this.SeLinux = @seLinux;
          this.SupplementalGroups = @supplementalGroups;
          this.Volumes = @volumes;
      }

    }
    /// <summary>
    /// DEPRECATED - extensions/v1beta1/ReplicaSet is not supported by Kubernetes 1.16+ clusters.
    /// Use apps/v1/ReplicaSet instead.
    /// 
    /// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSet
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
        /// that the ReplicaSet manages. Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec defines the specification of the desired behavior of the ReplicaSet. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Extensions.V1Beta1.ReplicaSetSpec Spec;

      /// <summary>
        /// Status is the most recently observed status of the ReplicaSet. This data may be out of
        /// date by some window of time. Populated by the system. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Extensions.V1Beta1.ReplicaSetStatus Status;

      [OutputConstructor]
      private ReplicaSet(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Extensions.V1Beta1.ReplicaSetSpec @spec,
          Extensions.V1Beta1.ReplicaSetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// ReplicaSetCondition describes the state of a replica set at a certain point.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetCondition
    {
      /// <summary>
        /// The last time the condition transitioned from one status to another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// A human readable message indicating details about the transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// The reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the condition, one of True, False, Unknown.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// Type of replica set condition.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private ReplicaSetCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// ReplicaSetList is a collection of ReplicaSets.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// List of ReplicaSets. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.ReplicaSet> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ReplicaSetList(
          string @apiVersion,
          ImmutableArray<Extensions.V1Beta1.ReplicaSet> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ReplicaSetSpec is the specification of a ReplicaSet.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetSpec
    {
      /// <summary>
        /// Minimum number of seconds for which a newly created pod should be ready without any of
        /// its container crashing, for it to be considered available. Defaults to 0 (pod will be
        /// considered available as soon as it is ready)
        /// </summary>
      public readonly int MinReadySeconds;

      /// <summary>
        /// Replicas is the number of desired replicas. This is a pointer to distinguish between
        /// explicit zero and unspecified. Defaults to 1. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// Selector is a label query over pods that should match the replica count. If the selector
        /// is empty, it is defaulted to the labels present on the pod template. Label keys and
        /// values that must match in order to be controlled by this replica set. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// Template is the object that describes the pod that will be created if insufficient
        /// replicas are detected. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
        /// </summary>
      public readonly Core.V1.PodTemplateSpec Template;

      [OutputConstructor]
      private ReplicaSetSpec(
          int @minReadySeconds,
          int @replicas,
          Meta.V1.LabelSelector @selector,
          Core.V1.PodTemplateSpec @template)
      {
          this.MinReadySeconds = @minReadySeconds;
          this.Replicas = @replicas;
          this.Selector = @selector;
          this.Template = @template;
      }

    }
    /// <summary>
    /// ReplicaSetStatus represents the current status of a ReplicaSet.
    /// </summary>
    [OutputType]
    public sealed class ReplicaSetStatus
    {
      /// <summary>
        /// The number of available replicas (ready for at least minReadySeconds) for this replica
        /// set.
        /// </summary>
      public readonly int AvailableReplicas;

      /// <summary>
        /// Represents the latest available observations of a replica set's current state.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.ReplicaSetCondition> Conditions;

      /// <summary>
        /// The number of pods that have labels matching the labels of the pod template of the
        /// replicaset.
        /// </summary>
      public readonly int FullyLabeledReplicas;

      /// <summary>
        /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
        /// </summary>
      public readonly int ObservedGeneration;

      /// <summary>
        /// The number of ready replicas for this replica set.
        /// </summary>
      public readonly int ReadyReplicas;

      /// <summary>
        /// Replicas is the most recently oberved number of replicas. More info:
        /// https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
        /// </summary>
      public readonly int Replicas;

      [OutputConstructor]
      private ReplicaSetStatus(
          int @availableReplicas,
          ImmutableArray<Extensions.V1Beta1.ReplicaSetCondition> @conditions,
          int @fullyLabeledReplicas,
          int @observedGeneration,
          int @readyReplicas,
          int @replicas)
      {
          this.AvailableReplicas = @availableReplicas;
          this.Conditions = @conditions;
          this.FullyLabeledReplicas = @fullyLabeledReplicas;
          this.ObservedGeneration = @observedGeneration;
          this.ReadyReplicas = @readyReplicas;
          this.Replicas = @replicas;
      }

    }
    /// <summary>
    /// DEPRECATED.
    /// </summary>
    [OutputType]
    public sealed class RollbackConfig
    {
      /// <summary>
        /// The revision to rollback to. If set to 0, rollback to the last revision.
        /// </summary>
      public readonly int Revision;

      [OutputConstructor]
      private RollbackConfig(
          int @revision)
      {
          this.Revision = @revision;
      }

    }
    /// <summary>
    /// Spec to control the desired behavior of daemon set rolling update.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateDaemonSet
    {
      /// <summary>
        /// The maximum number of DaemonSet pods that can be unavailable during the update. Value
        /// can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at
        /// the start of the update (ex: 10%). Absolute number is calculated from percentage by
        /// rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at
        /// most 30% of the total number of nodes that should be running the daemon pod (i.e.
        /// status.desiredNumberScheduled) can have their pods stopped for an update at any given
        /// time. The update starts by stopping at most 30% of those DaemonSet pods and then brings
        /// up new DaemonSet pods in their place. Once the new pods are available, it then proceeds
        /// onto other DaemonSet pods, thus ensuring that at least 70% of original number of
        /// DaemonSet pods are available at all times during the update.
        /// </summary>
      public readonly Union<int,string> MaxUnavailable;

      [OutputConstructor]
      private RollingUpdateDaemonSet(
          Union<int,string> @maxUnavailable)
      {
          this.MaxUnavailable = @maxUnavailable;
      }

    }
    /// <summary>
    /// Spec to control the desired behavior of rolling update.
    /// </summary>
    [OutputType]
    public sealed class RollingUpdateDeployment
    {
      /// <summary>
        /// The maximum number of pods that can be scheduled above the desired number of pods. Value
        /// can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can
        /// not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by
        /// rounding up. By default, a value of 1 is used. Example: when this is set to 30%, the new
        /// RC can be scaled up immediately when the rolling update starts, such that the total
        /// number of old and new pods do not exceed 130% of desired pods. Once old pods have been
        /// killed, new RC can be scaled up further, ensuring that total number of pods running at
        /// any time during the update is at most 130% of desired pods.
        /// </summary>
      public readonly Union<int,string> MaxSurge;

      /// <summary>
        /// The maximum number of pods that can be unavailable during the update. Value can be an
        /// absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
        /// calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. By
        /// default, a fixed value of 1 is used. Example: when this is set to 30%, the old RC can be
        /// scaled down to 70% of desired pods immediately when the rolling update starts. Once new
        /// pods are ready, old RC can be scaled down further, followed by scaling up the new RC,
        /// ensuring that the total number of pods available at all times during the update is at
        /// least 70% of desired pods.
        /// </summary>
      public readonly Union<int,string> MaxUnavailable;

      [OutputConstructor]
      private RollingUpdateDeployment(
          Union<int,string> @maxSurge,
          Union<int,string> @maxUnavailable)
      {
          this.MaxSurge = @maxSurge;
          this.MaxUnavailable = @maxUnavailable;
      }

    }
    /// <summary>
    /// RunAsGroupStrategyOptions defines the strategy type and any options used to create the
    /// strategy. Deprecated: use RunAsGroupStrategyOptions from policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class RunAsGroupStrategyOptions
    {
      /// <summary>
        /// ranges are the allowed ranges of gids that may be used. If you would like to force a
        /// single gid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.IDRange> Ranges;

      /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
        /// </summary>
      public readonly string Rule;

      [OutputConstructor]
      private RunAsGroupStrategyOptions(
          ImmutableArray<Extensions.V1Beta1.IDRange> @ranges,
          string @rule)
      {
          this.Ranges = @ranges;
          this.Rule = @rule;
      }

    }
    /// <summary>
    /// RunAsUserStrategyOptions defines the strategy type and any options used to create the
    /// strategy. Deprecated: use RunAsUserStrategyOptions from policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class RunAsUserStrategyOptions
    {
      /// <summary>
        /// ranges are the allowed ranges of uids that may be used. If you would like to force a
        /// single uid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.IDRange> Ranges;

      /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
      public readonly string Rule;

      [OutputConstructor]
      private RunAsUserStrategyOptions(
          ImmutableArray<Extensions.V1Beta1.IDRange> @ranges,
          string @rule)
      {
          this.Ranges = @ranges;
          this.Rule = @rule;
      }

    }
    /// <summary>
    /// RuntimeClassStrategyOptions define the strategy that will dictate the allowable
    /// RuntimeClasses for a pod.
    /// </summary>
    [OutputType]
    public sealed class RuntimeClassStrategyOptions
    {
      /// <summary>
        /// allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a
        /// pod. A value of "*" means that any RuntimeClass name is allowed, and must be the only
        /// item in the list. An empty list requires the RuntimeClassName field to be unset.
        /// </summary>
      public readonly ImmutableArray<string> AllowedRuntimeClassNames;

      /// <summary>
        /// defaultRuntimeClassName is the default RuntimeClassName to set on the pod. The default
        /// MUST be allowed by the allowedRuntimeClassNames list. A value of nil does not mutate the
        /// Pod.
        /// </summary>
      public readonly string DefaultRuntimeClassName;

      [OutputConstructor]
      private RuntimeClassStrategyOptions(
          ImmutableArray<string> @allowedRuntimeClassNames,
          string @defaultRuntimeClassName)
      {
          this.AllowedRuntimeClassNames = @allowedRuntimeClassNames;
          this.DefaultRuntimeClassName = @defaultRuntimeClassName;
      }

    }
    /// <summary>
    /// SELinuxStrategyOptions defines the strategy type and any options used to create the
    /// strategy. Deprecated: use SELinuxStrategyOptions from policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class SELinuxStrategyOptions
    {
      /// <summary>
        /// rule is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
      public readonly string Rule;

      /// <summary>
        /// seLinuxOptions required to run as; required for MustRunAs More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
      public readonly Core.V1.SELinuxOptions SeLinuxOptions;

      [OutputConstructor]
      private SELinuxStrategyOptions(
          string @rule,
          Core.V1.SELinuxOptions @seLinuxOptions)
      {
          this.Rule = @rule;
          this.SeLinuxOptions = @seLinuxOptions;
      }

    }
    /// <summary>
    /// represents a scaling request for a resource.
    /// </summary>
    [OutputType]
    public sealed class Scale
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata; More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// defines the behavior of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// </summary>
      public readonly Extensions.V1Beta1.ScaleSpec Spec;

      /// <summary>
        /// current status of the scale. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
        /// Read-only.
        /// </summary>
      public readonly Extensions.V1Beta1.ScaleStatus Status;

      [OutputConstructor]
      private Scale(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Extensions.V1Beta1.ScaleSpec @spec,
          Extensions.V1Beta1.ScaleStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// describes the attributes of a scale subresource
    /// </summary>
    [OutputType]
    public sealed class ScaleSpec
    {
      /// <summary>
        /// desired number of instances for the scaled object.
        /// </summary>
      public readonly int Replicas;

      [OutputConstructor]
      private ScaleSpec(
          int @replicas)
      {
          this.Replicas = @replicas;
      }

    }
    /// <summary>
    /// represents the current status of a scale subresource.
    /// </summary>
    [OutputType]
    public sealed class ScaleStatus
    {
      /// <summary>
        /// actual number of observed instances of the scaled object.
        /// </summary>
      public readonly int Replicas;

      /// <summary>
        /// label query over pods that should match the replicas count. More info:
        /// http://kubernetes.io/docs/user-guide/labels#label-selectors
        /// </summary>
      public readonly ImmutableDictionary<string, string> Selector;

      /// <summary>
        /// label selector for pods that should match the replicas count. This is a serializated
        /// version of both map-based and more expressive set-based selectors. This is done to avoid
        /// introspection in the clients. The string will be in the same format as the query-param
        /// syntax. If the target type only supports map-based selectors, both this field and
        /// map-based selector field are populated. More info:
        /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        /// </summary>
      public readonly string TargetSelector;

      [OutputConstructor]
      private ScaleStatus(
          int @replicas,
          ImmutableDictionary<string, string> @selector,
          string @targetSelector)
      {
          this.Replicas = @replicas;
          this.Selector = @selector;
          this.TargetSelector = @targetSelector;
      }

    }
    /// <summary>
    /// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the
    /// strategy. Deprecated: use SupplementalGroupsStrategyOptions from policy API Group instead.
    /// </summary>
    [OutputType]
    public sealed class SupplementalGroupsStrategyOptions
    {
      /// <summary>
        /// ranges are the allowed ranges of supplemental groups.  If you would like to force a
        /// single supplemental group then supply a single range with the same start and end.
        /// Required for MustRunAs.
        /// </summary>
      public readonly ImmutableArray<Extensions.V1Beta1.IDRange> Ranges;

      /// <summary>
        /// rule is the strategy that will dictate what supplemental groups is used in the
        /// SecurityContext.
        /// </summary>
      public readonly string Rule;

      [OutputConstructor]
      private SupplementalGroupsStrategyOptions(
          ImmutableArray<Extensions.V1Beta1.IDRange> @ranges,
          string @rule)
      {
          this.Ranges = @ranges;
          this.Rule = @rule;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.FlowControl
{
  namespace V1Alpha1
  {
    /// <summary>
    /// FlowDistinguisherMethod specifies the method of a flow distinguisher.
    /// </summary>
    [OutputType]
    public sealed class FlowDistinguisherMethod
    {
      /// <summary>
        /// `type` is the type of flow distinguisher method The supported types are "ByUser" and
        /// "ByNamespace". Required.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private FlowDistinguisherMethod(
          string @type)
      {
          this.Type = @type;
      }

    }
    /// <summary>
    /// FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of
    /// inbound API requests with similar attributes and is identified by a pair of strings: the
    /// name of the FlowSchema and a "flow distinguisher".
    /// </summary>
    [OutputType]
    public sealed class FlowSchema
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// `metadata` is the standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// `spec` is the specification of the desired behavior of a FlowSchema. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly FlowControl.V1Alpha1.FlowSchemaSpec Spec;

      /// <summary>
        /// `status` is the current status of a FlowSchema. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly FlowControl.V1Alpha1.FlowSchemaStatus Status;

      [OutputConstructor]
      private FlowSchema(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          FlowControl.V1Alpha1.FlowSchemaSpec @spec,
          FlowControl.V1Alpha1.FlowSchemaStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// FlowSchemaCondition describes conditions for a FlowSchema.
    /// </summary>
    [OutputType]
    public sealed class FlowSchemaCondition
    {
      /// <summary>
        /// `lastTransitionTime` is the last time the condition transitioned from one status to
        /// another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// `message` is a human-readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// `status` is the status of the condition. Can be True, False, Unknown. Required.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// `type` is the type of the condition. Required.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private FlowSchemaCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// FlowSchemaList is a list of FlowSchema objects.
    /// </summary>
    [OutputType]
    public sealed class FlowSchemaList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// `items` is a list of FlowSchemas.
        /// </summary>
      public readonly ImmutableArray<FlowControl.V1Alpha1.FlowSchema> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// `metadata` is the standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private FlowSchemaList(
          string @apiVersion,
          ImmutableArray<FlowControl.V1Alpha1.FlowSchema> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// FlowSchemaSpec describes how the FlowSchema's specification looks like.
    /// </summary>
    [OutputType]
    public sealed class FlowSchemaSpec
    {
      /// <summary>
        /// `distinguisherMethod` defines how to compute the flow distinguisher for requests that
        /// match this schema. `nil` specifies that the distinguisher is disabled and thus will
        /// always be the empty string.
        /// </summary>
      public readonly FlowControl.V1Alpha1.FlowDistinguisherMethod DistinguisherMethod;

      /// <summary>
        /// `matchingPrecedence` is used to choose among the FlowSchemas that match a given request.
        /// The chosen FlowSchema is among those with the numerically lowest (which we take to be
        /// logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be
        /// non-negative. Note that if the precedence is not specified or zero, it will be set to
        /// 1000 as default.
        /// </summary>
      public readonly int MatchingPrecedence;

      /// <summary>
        /// `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the
        /// cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked
        /// as invalid in its status. Required.
        /// </summary>
      public readonly FlowControl.V1Alpha1.PriorityLevelConfigurationReference PriorityLevelConfiguration;

      /// <summary>
        /// `rules` describes which requests will match this flow schema. This FlowSchema matches a
        /// request if and only if at least one member of rules matches the request. if it is an
        /// empty slice, there will be no requests matching the FlowSchema.
        /// </summary>
      public readonly ImmutableArray<FlowControl.V1Alpha1.PolicyRulesWithSubjects> Rules;

      [OutputConstructor]
      private FlowSchemaSpec(
          FlowControl.V1Alpha1.FlowDistinguisherMethod @distinguisherMethod,
          int @matchingPrecedence,
          FlowControl.V1Alpha1.PriorityLevelConfigurationReference @priorityLevelConfiguration,
          ImmutableArray<FlowControl.V1Alpha1.PolicyRulesWithSubjects> @rules)
      {
          this.DistinguisherMethod = @distinguisherMethod;
          this.MatchingPrecedence = @matchingPrecedence;
          this.PriorityLevelConfiguration = @priorityLevelConfiguration;
          this.Rules = @rules;
      }

    }
    /// <summary>
    /// FlowSchemaStatus represents the current state of a FlowSchema.
    /// </summary>
    [OutputType]
    public sealed class FlowSchemaStatus
    {
      /// <summary>
        /// `conditions` is a list of the current states of FlowSchema.
        /// </summary>
      public readonly ImmutableArray<FlowControl.V1Alpha1.FlowSchemaCondition> Conditions;

      [OutputConstructor]
      private FlowSchemaStatus(
          ImmutableArray<FlowControl.V1Alpha1.FlowSchemaCondition> @conditions)
      {
          this.Conditions = @conditions;
      }

    }
    /// <summary>
    /// GroupSubject holds detailed information for group-kind subject.
    /// </summary>
    [OutputType]
    public sealed class GroupSubject
    {
      /// <summary>
        /// name is the user group that matches, or "*" to match all user groups. See
        /// https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for
        /// some well-known group names. Required.
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private GroupSubject(
          string @name)
      {
          this.Name = @name;
      }

    }
    /// <summary>
    /// LimitResponse defines how to handle requests that can not be executed right now.
    /// </summary>
    [OutputType]
    public sealed class LimitResponse
    {
      /// <summary>
        /// `queuing` holds the configuration parameters for queuing. This field may be non-empty
        /// only if `type` is `"Queue"`.
        /// </summary>
      public readonly FlowControl.V1Alpha1.QueuingConfiguration Queuing;

      /// <summary>
        /// `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon
        /// arrival are held in a queue until they can be executed or a queuing limit is reached.
        /// "Reject" means that requests that can not be executed upon arrival are rejected.
        /// Required.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private LimitResponse(
          FlowControl.V1Alpha1.QueuingConfiguration @queuing,
          string @type)
      {
          this.Queuing = @queuing;
          this.Type = @type;
      }

    }
    /// <summary>
    /// LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to
    /// limits. It addresses two issues:
    ///  * How are requests for this priority level limited?
    ///  * What should be done with requests that exceed the limit?
    /// </summary>
    [OutputType]
    public sealed class LimitedPriorityLevelConfiguration
    {
      /// <summary>
        /// `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the
        /// number of requests of this priority level that may be exeucting at a given time.  ACS
        /// must be a positive number. The server's concurrency limit (SCL) is divided among the
        /// concurrency-controlled priority levels in proportion to their assured concurrency
        /// shares. This produces the assured concurrency value (ACV) --- the number of requests
        /// that may be executing at a time --- for each such priority level:
        /// 
        ///             ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
        /// 
        /// bigger numbers of ACS mean more reserved concurrent requests (at the expense of every
        /// other PL). This field has a default value of 30.
        /// </summary>
      public readonly int AssuredConcurrencyShares;

      /// <summary>
        /// `limitResponse` indicates what to do with requests that can not be executed right now
        /// </summary>
      public readonly FlowControl.V1Alpha1.LimitResponse LimitResponse;

      [OutputConstructor]
      private LimitedPriorityLevelConfiguration(
          int @assuredConcurrencyShares,
          FlowControl.V1Alpha1.LimitResponse @limitResponse)
      {
          this.AssuredConcurrencyShares = @assuredConcurrencyShares;
          this.LimitResponse = @limitResponse;
      }

    }
    /// <summary>
    /// NonResourcePolicyRule is a predicate that matches non-resource requests according to their
    /// verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only
    /// if both (a) at least one member of verbs matches the request and (b) at least one member of
    /// nonResourceURLs matches the request.
    /// </summary>
    [OutputType]
    public sealed class NonResourcePolicyRule
    {
      /// <summary>
        /// `nonResourceURLs` is a set of url prefixes that a user should have access to and may not
        /// be empty. For example:
        ///   - "/healthz" is legal
        ///   - "/hea*" is illegal
        ///   - "/hea" is legal but matches nothing
        ///   - "/hea/*" also matches nothing
        ///   - "/healthz/*" matches all per-component health checks.
        /// "*" matches all non-resource urls. if it is present, it must be the only entry.
        /// Required.
        /// </summary>
      public readonly ImmutableArray<string> NonResourceURLs;

      /// <summary>
        /// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it
        /// is present, it must be the only entry. Required.
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      [OutputConstructor]
      private NonResourcePolicyRule(
          ImmutableArray<string> @nonResourceURLs,
          ImmutableArray<string> @verbs)
      {
          this.NonResourceURLs = @nonResourceURLs;
          this.Verbs = @verbs;
      }

    }
    /// <summary>
    /// PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The
    /// test considers the subject making the request, the verb being requested, and the resource to
    /// be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at
    /// least one member of subjects matches the request and (b) at least one member of
    /// resourceRules or nonResourceRules matches the request.
    /// </summary>
    [OutputType]
    public sealed class PolicyRulesWithSubjects
    {
      /// <summary>
        /// `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests
        /// according to their verb and the target non-resource URL.
        /// </summary>
      public readonly ImmutableArray<FlowControl.V1Alpha1.NonResourcePolicyRule> NonResourceRules;

      /// <summary>
        /// `resourceRules` is a slice of ResourcePolicyRules that identify matching requests
        /// according to their verb and the target resource. At least one of `resourceRules` and
        /// `nonResourceRules` has to be non-empty.
        /// </summary>
      public readonly ImmutableArray<FlowControl.V1Alpha1.ResourcePolicyRule> ResourceRules;

      /// <summary>
        /// subjects is the list of normal user, serviceaccount, or group that this rule cares
        /// about. There must be at least one member in this slice. A slice that includes both the
        /// system:authenticated and system:unauthenticated user groups matches every request.
        /// Required.
        /// </summary>
      public readonly ImmutableArray<FlowControl.V1Alpha1.Subject> Subjects;

      [OutputConstructor]
      private PolicyRulesWithSubjects(
          ImmutableArray<FlowControl.V1Alpha1.NonResourcePolicyRule> @nonResourceRules,
          ImmutableArray<FlowControl.V1Alpha1.ResourcePolicyRule> @resourceRules,
          ImmutableArray<FlowControl.V1Alpha1.Subject> @subjects)
      {
          this.NonResourceRules = @nonResourceRules;
          this.ResourceRules = @resourceRules;
          this.Subjects = @subjects;
      }

    }
    /// <summary>
    /// PriorityLevelConfiguration represents the configuration of a priority level.
    /// </summary>
    [OutputType]
    public sealed class PriorityLevelConfiguration
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// `metadata` is the standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// `spec` is the specification of the desired behavior of a "request-priority". More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly FlowControl.V1Alpha1.PriorityLevelConfigurationSpec Spec;

      /// <summary>
        /// `status` is the current status of a "request-priority". More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly FlowControl.V1Alpha1.PriorityLevelConfigurationStatus Status;

      [OutputConstructor]
      private PriorityLevelConfiguration(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          FlowControl.V1Alpha1.PriorityLevelConfigurationSpec @spec,
          FlowControl.V1Alpha1.PriorityLevelConfigurationStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// PriorityLevelConfigurationCondition defines the condition of priority level.
    /// </summary>
    [OutputType]
    public sealed class PriorityLevelConfigurationCondition
    {
      /// <summary>
        /// `lastTransitionTime` is the last time the condition transitioned from one status to
        /// another.
        /// </summary>
      public readonly string LastTransitionTime;

      /// <summary>
        /// `message` is a human-readable message indicating details about last transition.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// `status` is the status of the condition. Can be True, False, Unknown. Required.
        /// </summary>
      public readonly string Status;

      /// <summary>
        /// `type` is the type of the condition. Required.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private PriorityLevelConfigurationCondition(
          string @lastTransitionTime,
          string @message,
          string @reason,
          string @status,
          string @type)
      {
          this.LastTransitionTime = @lastTransitionTime;
          this.Message = @message;
          this.Reason = @reason;
          this.Status = @status;
          this.Type = @type;
      }

    }
    /// <summary>
    /// PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects.
    /// </summary>
    [OutputType]
    public sealed class PriorityLevelConfigurationList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// `items` is a list of request-priorities.
        /// </summary>
      public readonly ImmutableArray<FlowControl.V1Alpha1.PriorityLevelConfiguration> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// `metadata` is the standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PriorityLevelConfigurationList(
          string @apiVersion,
          ImmutableArray<FlowControl.V1Alpha1.PriorityLevelConfiguration> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PriorityLevelConfigurationReference contains information that points to the
    /// "request-priority" being used.
    /// </summary>
    [OutputType]
    public sealed class PriorityLevelConfigurationReference
    {
      /// <summary>
        /// `name` is the name of the priority level configuration being referenced Required.
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private PriorityLevelConfigurationReference(
          string @name)
      {
          this.Name = @name;
      }

    }
    /// <summary>
    /// PriorityLevelConfigurationSpec specifies the configuration of a priority level.
    /// </summary>
    [OutputType]
    public sealed class PriorityLevelConfigurationSpec
    {
      /// <summary>
        /// `limited` specifies how requests are handled for a Limited priority level. This field
        /// must be non-empty if and only if `type` is `"Limited"`.
        /// </summary>
      public readonly FlowControl.V1Alpha1.LimitedPriorityLevelConfiguration Limited;

      /// <summary>
        /// `type` indicates whether this priority level is subject to limitation on request
        /// execution.  A value of `"Exempt"` means that requests of this priority level are not
        /// subject to a limit (and thus are never queued) and do not detract from the capacity made
        /// available to other priority levels.  A value of `"Limited"` means that (a) requests of
        /// this priority level _are_ subject to limits and (b) some of the server's limited
        /// capacity is made available exclusively to this priority level. Required.
        /// </summary>
      public readonly string Type;

      [OutputConstructor]
      private PriorityLevelConfigurationSpec(
          FlowControl.V1Alpha1.LimitedPriorityLevelConfiguration @limited,
          string @type)
      {
          this.Limited = @limited;
          this.Type = @type;
      }

    }
    /// <summary>
    /// PriorityLevelConfigurationStatus represents the current state of a "request-priority".
    /// </summary>
    [OutputType]
    public sealed class PriorityLevelConfigurationStatus
    {
      /// <summary>
        /// `conditions` is the current state of "request-priority".
        /// </summary>
      public readonly ImmutableArray<FlowControl.V1Alpha1.PriorityLevelConfigurationCondition> Conditions;

      [OutputConstructor]
      private PriorityLevelConfigurationStatus(
          ImmutableArray<FlowControl.V1Alpha1.PriorityLevelConfigurationCondition> @conditions)
      {
          this.Conditions = @conditions;
      }

    }
    /// <summary>
    /// QueuingConfiguration holds the configuration parameters for queuing
    /// </summary>
    [OutputType]
    public sealed class QueuingConfiguration
    {
      /// <summary>
        /// `handSize` is a small positive number that configures the shuffle sharding of requests
        /// into queues.  When enqueuing a request at this priority level the request's flow
        /// identifier (a string pair) is hashed and the hash value is used to shuffle the list of
        /// queues and deal a hand of the size specified here.  The request is put into one of the
        /// shortest queues in that hand. `handSize` must be no larger than `queues`, and should be
        /// significantly smaller (so that a few heavy flows do not saturate most of the queues).
        /// See the user-facing documentation for more extensive guidance on setting this field.
        /// This field has a default value of 8.
        /// </summary>
      public readonly int HandSize;

      /// <summary>
        /// `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given
        /// queue of this priority level at a time; excess requests are rejected.  This value must
        /// be positive.  If not specified, it will be defaulted to 50.
        /// </summary>
      public readonly int QueueLengthLimit;

      /// <summary>
        /// `queues` is the number of queues for this priority level. The queues exist independently
        /// at each apiserver. The value must be positive.  Setting it to 1 effectively precludes
        /// shufflesharding and thus makes the distinguisher method of associated flow schemas
        /// irrelevant.  This field has a default value of 64.
        /// </summary>
      public readonly int Queues;

      [OutputConstructor]
      private QueuingConfiguration(
          int @handSize,
          int @queueLengthLimit,
          int @queues)
      {
          this.HandSize = @handSize;
          this.QueueLengthLimit = @queueLengthLimit;
          this.Queues = @queues;
      }

    }
    /// <summary>
    /// ResourcePolicyRule is a predicate that matches some resource requests, testing the request's
    /// verb and the target resource. A ResourcePolicyRule matches a resource request if and only
    /// if: (a) at least one member of verbs matches the request, (b) at least one member of
    /// apiGroups matches the request, (c) at least one member of resources matches the request, and
    /// (d) least one member of namespaces matches the request.
    /// </summary>
    [OutputType]
    public sealed class ResourcePolicyRule
    {
      /// <summary>
        /// `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API
        /// groups and, if present, must be the only entry. Required.
        /// </summary>
      public readonly ImmutableArray<string> ApiGroups;

      /// <summary>
        /// `clusterScope` indicates whether to match requests that do not specify a namespace
        /// (which happens either because the resource is not namespaced or the request targets all
        /// namespaces). If this field is omitted or false then the `namespaces` field must contain
        /// a non-empty list.
        /// </summary>
      public readonly bool ClusterScope;

      /// <summary>
        /// `namespaces` is a list of target namespaces that restricts matches.  A request that
        /// specifies a target namespace matches only if either (a) this list contains that target
        /// namespace or (b) this list contains "*".  Note that "*" matches any specified namespace
        /// but does not match a request that _does not specify_ a namespace (see the `clusterScope`
        /// field for that). This list may be empty, but only if `clusterScope` is true.
        /// </summary>
      public readonly ImmutableArray<string> Namespaces;

      /// <summary>
        /// `resources` is a list of matching resources (i.e., lowercase and plural) with, if
        /// desired, subresource.  For example, [ "services", "nodes/status" ].  This list may not
        /// be empty. "*" matches all resources and, if present, must be the only entry. Required.
        /// </summary>
      public readonly ImmutableArray<string> Resources;

      /// <summary>
        /// `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if
        /// present, must be the only entry. Required.
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      [OutputConstructor]
      private ResourcePolicyRule(
          ImmutableArray<string> @apiGroups,
          bool @clusterScope,
          ImmutableArray<string> @namespaces,
          ImmutableArray<string> @resources,
          ImmutableArray<string> @verbs)
      {
          this.ApiGroups = @apiGroups;
          this.ClusterScope = @clusterScope;
          this.Namespaces = @namespaces;
          this.Resources = @resources;
          this.Verbs = @verbs;
      }

    }
    /// <summary>
    /// ServiceAccountSubject holds detailed information for service-account-kind subject.
    /// </summary>
    [OutputType]
    public sealed class ServiceAccountSubject
    {
      /// <summary>
        /// `name` is the name of matching ServiceAccount objects, or "*" to match regardless of
        /// name. Required.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// `namespace` is the namespace of matching ServiceAccount objects. Required.
        /// </summary>
      public readonly string Namespace;

      [OutputConstructor]
      private ServiceAccountSubject(
          string @name,
          string @namespace)
      {
          this.Name = @name;
          this.Namespace = @namespace;
      }

    }
    /// <summary>
    /// Subject matches the originator of a request, as identified by the request authentication
    /// system. There are three ways of matching an originator; by user, group, or service account.
    /// </summary>
    [OutputType]
    public sealed class Subject
    {
      
      public readonly FlowControl.V1Alpha1.GroupSubject Group;

      /// <summary>
        /// Required
        /// </summary>
      public readonly string Kind;

      
      public readonly FlowControl.V1Alpha1.ServiceAccountSubject ServiceAccount;

      
      public readonly FlowControl.V1Alpha1.UserSubject User;

      [OutputConstructor]
      private Subject(
          FlowControl.V1Alpha1.GroupSubject @group,
          string @kind,
          FlowControl.V1Alpha1.ServiceAccountSubject @serviceAccount,
          FlowControl.V1Alpha1.UserSubject @user)
      {
          this.Group = @group;
          this.Kind = @kind;
          this.ServiceAccount = @serviceAccount;
          this.User = @user;
      }

    }
    /// <summary>
    /// UserSubject holds detailed information for user-kind subject.
    /// </summary>
    [OutputType]
    public sealed class UserSubject
    {
      /// <summary>
        /// `name` is the username that matches, or "*" to match all usernames. Required.
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private UserSubject(
          string @name)
      {
          this.Name = @name;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Meta
{
  namespace V1
  {
    /// <summary>
    /// APIGroup contains the name, the supported versions, and the preferred version of a group.
    /// </summary>
    [OutputType]
    public sealed class APIGroup
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// name is the name of the group.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// preferredVersion is the version preferred by the API server, which probably is the
        /// storage version.
        /// </summary>
      public readonly Meta.V1.GroupVersionForDiscovery PreferredVersion;

      /// <summary>
        /// a map of client CIDR to server address that is serving this group. This is to help
        /// clients reach servers in the most network-efficient way possible. Clients can use the
        /// appropriate server address as per the CIDR that they match. In case of multiple matches,
        /// clients should use the longest matching CIDR. The server returns only those CIDRs that
        /// it thinks that the client can match. For example: the master will return an internal IP
        /// CIDR only, if the client reaches the server using an internal IP. Server looks at
        /// X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get
        /// the client IP.
        /// </summary>
      public readonly ImmutableArray<Meta.V1.ServerAddressByClientCIDR> ServerAddressByClientCIDRs;

      /// <summary>
        /// versions are the versions supported in this group.
        /// </summary>
      public readonly ImmutableArray<Meta.V1.GroupVersionForDiscovery> Versions;

      [OutputConstructor]
      private APIGroup(
          string @apiVersion,
          string @kind,
          string @name,
          Meta.V1.GroupVersionForDiscovery @preferredVersion,
          ImmutableArray<Meta.V1.ServerAddressByClientCIDR> @serverAddressByClientCIDRs,
          ImmutableArray<Meta.V1.GroupVersionForDiscovery> @versions)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Name = @name;
          this.PreferredVersion = @preferredVersion;
          this.ServerAddressByClientCIDRs = @serverAddressByClientCIDRs;
          this.Versions = @versions;
      }

    }
    /// <summary>
    /// APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis.
    /// </summary>
    [OutputType]
    public sealed class APIGroupList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// groups is a list of APIGroup.
        /// </summary>
      public readonly ImmutableArray<Meta.V1.APIGroup> Groups;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      [OutputConstructor]
      private APIGroupList(
          string @apiVersion,
          ImmutableArray<Meta.V1.APIGroup> @groups,
          string @kind)
      {
          this.ApiVersion = @apiVersion;
          this.Groups = @groups;
          this.Kind = @kind;
      }

    }
    /// <summary>
    /// APIResource specifies the name of a resource and whether it is namespaced.
    /// </summary>
    [OutputType]
    public sealed class APIResource
    {
      /// <summary>
        /// categories is a list of the grouped resources this resource belongs to (e.g. 'all')
        /// </summary>
      public readonly ImmutableArray<string> Categories;

      /// <summary>
        /// group is the preferred group of the resource.  Empty implies the group of the containing
        /// resource list. For subresources, this may have a different value, for example: Scale".
        /// </summary>
      public readonly string Group;

      /// <summary>
        /// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// name is the plural name of the resource.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// namespaced indicates if a resource is namespaced or not.
        /// </summary>
      public readonly bool Namespaced;

      /// <summary>
        /// shortNames is a list of suggested short names of the resource.
        /// </summary>
      public readonly ImmutableArray<string> ShortNames;

      /// <summary>
        /// singularName is the singular name of the resource.  This allows clients to handle plural
        /// and singular opaquely. The singularName is more correct for reporting status on a single
        /// item and both singular and plural are allowed from the kubectl CLI interface.
        /// </summary>
      public readonly string SingularName;

      /// <summary>
        /// The hash value of the storage version, the version this resource is converted to when
        /// written to the data store. Value must be treated as opaque by clients. Only equality
        /// comparison on the value is valid. This is an alpha feature and may change or be removed
        /// in the future. The field is populated by the apiserver only if the StorageVersionHash
        /// feature gate is enabled. This field will remain optional even if it graduates.
        /// </summary>
      public readonly string StorageVersionHash;

      /// <summary>
        /// verbs is a list of supported kube verbs (this includes get, list, watch, create, update,
        /// patch, delete, deletecollection, and proxy)
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      /// <summary>
        /// version is the preferred version of the resource.  Empty implies the version of the
        /// containing resource list For subresources, this may have a different value, for example:
        /// v1 (while inside a v1beta1 version of the core resource's group)".
        /// </summary>
      public readonly string Version;

      [OutputConstructor]
      private APIResource(
          ImmutableArray<string> @categories,
          string @group,
          string @kind,
          string @name,
          bool @namespaced,
          ImmutableArray<string> @shortNames,
          string @singularName,
          string @storageVersionHash,
          ImmutableArray<string> @verbs,
          string @version)
      {
          this.Categories = @categories;
          this.Group = @group;
          this.Kind = @kind;
          this.Name = @name;
          this.Namespaced = @namespaced;
          this.ShortNames = @shortNames;
          this.SingularName = @singularName;
          this.StorageVersionHash = @storageVersionHash;
          this.Verbs = @verbs;
          this.Version = @version;
      }

    }
    /// <summary>
    /// APIResourceList is a list of APIResource, it is used to expose the name of the resources
    /// supported in a specific group and version, and if the resource is namespaced.
    /// </summary>
    [OutputType]
    public sealed class APIResourceList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// groupVersion is the group and version this APIResourceList is for.
        /// </summary>
      public readonly string GroupVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// resources contains the name of the resources and if they are namespaced.
        /// </summary>
      public readonly ImmutableArray<Meta.V1.APIResource> Resources;

      [OutputConstructor]
      private APIResourceList(
          string @apiVersion,
          string @groupVersion,
          string @kind,
          ImmutableArray<Meta.V1.APIResource> @resources)
      {
          this.ApiVersion = @apiVersion;
          this.GroupVersion = @groupVersion;
          this.Kind = @kind;
          this.Resources = @resources;
      }

    }
    /// <summary>
    /// APIVersions lists the versions that are available, to allow clients to discover the API at
    /// /api, which is the root path of the legacy v1 API.
    /// </summary>
    [OutputType]
    public sealed class APIVersions
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// a map of client CIDR to server address that is serving this group. This is to help
        /// clients reach servers in the most network-efficient way possible. Clients can use the
        /// appropriate server address as per the CIDR that they match. In case of multiple matches,
        /// clients should use the longest matching CIDR. The server returns only those CIDRs that
        /// it thinks that the client can match. For example: the master will return an internal IP
        /// CIDR only, if the client reaches the server using an internal IP. Server looks at
        /// X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get
        /// the client IP.
        /// </summary>
      public readonly ImmutableArray<Meta.V1.ServerAddressByClientCIDR> ServerAddressByClientCIDRs;

      /// <summary>
        /// versions are the api versions that are available.
        /// </summary>
      public readonly ImmutableArray<string> Versions;

      [OutputConstructor]
      private APIVersions(
          string @apiVersion,
          string @kind,
          ImmutableArray<Meta.V1.ServerAddressByClientCIDR> @serverAddressByClientCIDRs,
          ImmutableArray<string> @versions)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.ServerAddressByClientCIDRs = @serverAddressByClientCIDRs;
          this.Versions = @versions;
      }

    }
    /// <summary>
    /// DeleteOptions may be provided when deleting an API object.
    /// </summary>
    [OutputType]
    public sealed class DeleteOptions
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// When present, indicates that modifications should not be persisted. An invalid or
        /// unrecognized dryRun directive will result in an error response and no further processing
        /// of the request. Valid values are: - All: all dry run stages will be processed
        /// </summary>
      public readonly ImmutableArray<string> DryRun;

      /// <summary>
        /// The duration in seconds before the object should be deleted. Value must be non-negative
        /// integer. The value zero indicates delete immediately. If this value is nil, the default
        /// grace period for the specified type will be used. Defaults to a per object value if not
        /// specified. zero means delete immediately.
        /// </summary>
      public readonly int GracePeriodSeconds;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be
        /// added to/removed from the object's finalizers list. Either this field or
        /// PropagationPolicy may be set, but not both.
        /// </summary>
      public readonly bool OrphanDependents;

      /// <summary>
        /// Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict
        /// status will be returned.
        /// </summary>
      public readonly Meta.V1.Preconditions Preconditions;

      /// <summary>
        /// Whether and how garbage collection will be performed. Either this field or
        /// OrphanDependents may be set, but not both. The default policy is decided by the existing
        /// finalizer set in the metadata.finalizers and the resource-specific default policy.
        /// Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the
        /// garbage collector to delete the dependents in the background; 'Foreground' - a cascading
        /// policy that deletes all dependents in the foreground.
        /// </summary>
      public readonly string PropagationPolicy;

      [OutputConstructor]
      private DeleteOptions(
          string @apiVersion,
          ImmutableArray<string> @dryRun,
          int @gracePeriodSeconds,
          string @kind,
          bool @orphanDependents,
          Meta.V1.Preconditions @preconditions,
          string @propagationPolicy)
      {
          this.ApiVersion = @apiVersion;
          this.DryRun = @dryRun;
          this.GracePeriodSeconds = @gracePeriodSeconds;
          this.Kind = @kind;
          this.OrphanDependents = @orphanDependents;
          this.Preconditions = @preconditions;
          this.PropagationPolicy = @propagationPolicy;
      }

    }
    /// <summary>
    /// GroupVersion contains the "group/version" and "version" string of a version. It is made a
    /// struct to keep extensibility.
    /// </summary>
    [OutputType]
    public sealed class GroupVersionForDiscovery
    {
      /// <summary>
        /// groupVersion specifies the API group and version in the form "group/version"
        /// </summary>
      public readonly string GroupVersion;

      /// <summary>
        /// version specifies the version in the form of "version". This is to save the clients the
        /// trouble of splitting the GroupVersion.
        /// </summary>
      public readonly string Version;

      [OutputConstructor]
      private GroupVersionForDiscovery(
          string @groupVersion,
          string @version)
      {
          this.GroupVersion = @groupVersion;
          this.Version = @version;
      }

    }
    /// <summary>
    /// A label selector is a label query over a set of resources. The result of matchLabels and
    /// matchExpressions are ANDed. An empty label selector matches all objects. A null label
    /// selector matches no objects.
    /// </summary>
    [OutputType]
    public sealed class LabelSelector
    {
      /// <summary>
        /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
      public readonly ImmutableArray<Meta.V1.LabelSelectorRequirement> MatchExpressions;

      /// <summary>
        /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map
        /// is equivalent to an element of matchExpressions, whose key field is "key", the operator
        /// is "In", and the values array contains only "value". The requirements are ANDed.
        /// </summary>
      public readonly ImmutableDictionary<string, string> MatchLabels;

      [OutputConstructor]
      private LabelSelector(
          ImmutableArray<Meta.V1.LabelSelectorRequirement> @matchExpressions,
          ImmutableDictionary<string, string> @matchLabels)
      {
          this.MatchExpressions = @matchExpressions;
          this.MatchLabels = @matchLabels;
      }

    }
    /// <summary>
    /// A label selector requirement is a selector that contains values, a key, and an operator that
    /// relates the key and values.
    /// </summary>
    [OutputType]
    public sealed class LabelSelectorRequirement
    {
      /// <summary>
        /// key is the label key that the selector applies to.
        /// </summary>
      public readonly string Key;

      /// <summary>
        /// operator represents a key's relationship to a set of values. Valid operators are In,
        /// NotIn, Exists and DoesNotExist.
        /// </summary>
      public readonly string Operator;

      /// <summary>
        /// values is an array of string values. If the operator is In or NotIn, the values array
        /// must be non-empty. If the operator is Exists or DoesNotExist, the values array must be
        /// empty. This array is replaced during a strategic merge patch.
        /// </summary>
      public readonly ImmutableArray<string> Values;

      [OutputConstructor]
      private LabelSelectorRequirement(
          string @key,
          string @operator,
          ImmutableArray<string> @values)
      {
          this.Key = @key;
          this.Operator = @operator;
          this.Values = @values;
      }

    }
    /// <summary>
    /// ListMeta describes metadata that synthetic resources must have, including lists and various
    /// status objects. A resource may have only one of {ObjectMeta, ListMeta}.
    /// </summary>
    [OutputType]
    public sealed class ListMeta
    {
      /// <summary>
        /// continue may be set if the user set a limit on the number of items returned, and
        /// indicates that the server has more data available. The value is opaque and may be used
        /// to issue another request to the endpoint that served this list to retrieve the next set
        /// of available objects. Continuing a consistent list may not be possible if the server
        /// configuration has changed or more than a few minutes have passed. The resourceVersion
        /// field returned when using this continue value will be identical to the value in the
        /// first response, unless you have received this token from an error message.
        /// </summary>
      public readonly string Continue;

      /// <summary>
        /// remainingItemCount is the number of subsequent items in the list which are not included
        /// in this list response. If the list request contained label or field selectors, then the
        /// number of remaining items is unknown and the field will be left unset and omitted during
        /// serialization. If the list is complete (either because it is not chunking or because
        /// this is the last chunk), then there are no more remaining items and this field will be
        /// left unset and omitted during serialization. Servers older than v1.15 do not set this
        /// field. The intended use of the remainingItemCount is *estimating* the size of a
        /// collection. Clients should not rely on the remainingItemCount to be set or to be exact.
        /// </summary>
      public readonly int RemainingItemCount;

      /// <summary>
        /// String that identifies the server's internal version of this object that can be used by
        /// clients to determine when objects have changed. Value must be treated as opaque by
        /// clients and passed unmodified back to the server. Populated by the system. Read-only.
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
      public readonly string ResourceVersion;

      /// <summary>
        /// selfLink is a URL representing this object. Populated by the system. Read-only.
        /// 
        /// DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is
        /// planned to be removed in 1.21 release.
        /// </summary>
      public readonly string SelfLink;

      [OutputConstructor]
      private ListMeta(
          string @continue,
          int @remainingItemCount,
          string @resourceVersion,
          string @selfLink)
      {
          this.Continue = @continue;
          this.RemainingItemCount = @remainingItemCount;
          this.ResourceVersion = @resourceVersion;
          this.SelfLink = @selfLink;
      }

    }
    /// <summary>
    /// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that
    /// the fieldset applies to.
    /// </summary>
    [OutputType]
    public sealed class ManagedFieldsEntry
    {
      /// <summary>
        /// APIVersion defines the version of this resource that this field set applies to. The
        /// format is "group/version" just like the top-level APIVersion field. It is necessary to
        /// track the version of a field set because it cannot be automatically converted.
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// FieldsType is the discriminator for the different fields format and version. There is
        /// currently only one possible value: "FieldsV1"
        /// </summary>
      public readonly string FieldsType;

      /// <summary>
        /// FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
        /// </summary>
      public readonly System.Text.Json.JsonElement FieldsV1;

      /// <summary>
        /// Manager is an identifier of the workflow managing these fields.
        /// </summary>
      public readonly string Manager;

      /// <summary>
        /// Operation is the type of operation which lead to this ManagedFieldsEntry being created.
        /// The only valid values for this field are 'Apply' and 'Update'.
        /// </summary>
      public readonly string Operation;

      /// <summary>
        /// Time is timestamp of when these fields were set. It should always be empty if Operation
        /// is 'Apply'
        /// </summary>
      public readonly string Time;

      [OutputConstructor]
      private ManagedFieldsEntry(
          string @apiVersion,
          string @fieldsType,
          System.Text.Json.JsonElement @fieldsV1,
          string @manager,
          string @operation,
          string @time)
      {
          this.ApiVersion = @apiVersion;
          this.FieldsType = @fieldsType;
          this.FieldsV1 = @fieldsV1;
          this.Manager = @manager;
          this.Operation = @operation;
          this.Time = @time;
      }

    }
    /// <summary>
    /// ObjectMeta is metadata that all persisted resources must have, which includes all objects
    /// users must create.
    /// </summary>
    [OutputType]
    public sealed class ObjectMeta
    {
      /// <summary>
        /// Annotations is an unstructured key value map stored with a resource that may be set by
        /// external tools to store and retrieve arbitrary metadata. They are not queryable and
        /// should be preserved when modifying objects. More info:
        /// http://kubernetes.io/docs/user-guide/annotations
        /// </summary>
      public readonly ImmutableDictionary<string, string> Annotations;

      /// <summary>
        /// The name of the cluster which the object belongs to. This is used to distinguish
        /// resources with same name and namespace in different clusters. This field is not set
        /// anywhere right now and apiserver is going to ignore it if set in create or update
        /// request.
        /// </summary>
      public readonly string ClusterName;

      /// <summary>
        /// CreationTimestamp is a timestamp representing the server time when this object was
        /// created. It is not guaranteed to be set in happens-before order across separate
        /// operations. Clients may not set this value. It is represented in RFC3339 form and is in
        /// UTC.
        /// 
        /// Populated by the system. Read-only. Null for lists. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly string CreationTimestamp;

      /// <summary>
        /// Number of seconds allowed for this object to gracefully terminate before it will be
        /// removed from the system. Only set when deletionTimestamp is also set. May only be
        /// shortened. Read-only.
        /// </summary>
      public readonly int DeletionGracePeriodSeconds;

      /// <summary>
        /// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
        /// field is set by the server when a graceful deletion is requested by the user, and is not
        /// directly settable by a client. The resource is expected to be deleted (no longer visible
        /// from resource lists, and not reachable by name) after the time in this field, once the
        /// finalizers list is empty. As long as the finalizers list contains items, deletion is
        /// blocked. Once the deletionTimestamp is set, this value may not be unset or be set
        /// further into the future, although it may be shortened or the resource may be deleted
        /// prior to this time. For example, a user may request that a pod is deleted in 30 seconds.
        /// The Kubelet will react by sending a graceful termination signal to the containers in the
        /// pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to
        /// the container and after cleanup, remove the pod from the API. In the presence of network
        /// partitions, this object may still exist after this timestamp, until an administrator or
        /// automated process can determine the resource is fully terminated. If not set, graceful
        /// deletion of the object has not been requested.
        /// 
        /// Populated by the system when a graceful deletion is requested. Read-only. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly string DeletionTimestamp;

      /// <summary>
        /// Must be empty before the object is deleted from the registry. Each entry is an
        /// identifier for the responsible component that will remove the entry from the list. If
        /// the deletionTimestamp of the object is non-nil, entries in this list can only be
        /// removed. Finalizers may be processed and removed in any order.  Order is NOT enforced
        /// because it introduces significant risk of stuck finalizers. finalizers is a shared
        /// field, any actor with permission can reorder it. If the finalizer list is processed in
        /// order, then this can lead to a situation in which the component responsible for the
        /// first finalizer in the list is waiting for a signal (field value, external system, or
        /// other) produced by a component responsible for a finalizer later in the list, resulting
        /// in a deadlock. Without enforced ordering finalizers are free to order amongst themselves
        /// and are not vulnerable to ordering changes in the list.
        /// </summary>
      public readonly ImmutableArray<string> Finalizers;

      /// <summary>
        /// GenerateName is an optional prefix, used by the server, to generate a unique name ONLY
        /// IF the Name field has not been provided. If this field is used, the name returned to the
        /// client will be different than the name passed. This value will also be combined with a
        /// unique suffix. The provided value has the same validation rules as the Name field, and
        /// may be truncated by the length of the suffix required to make the value unique on the
        /// server.
        /// 
        /// If this field is specified and the generated name exists, the server will NOT return a
        /// 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout
        /// indicating a unique name could not be found in the time allotted, and the client should
        /// retry (optionally after the time indicated in the Retry-After header).
        /// 
        /// Applied only if Name is not specified. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
        /// </summary>
      public readonly string GenerateName;

      /// <summary>
        /// A sequence number representing a specific generation of the desired state. Populated by
        /// the system. Read-only.
        /// </summary>
      public readonly int Generation;

      /// <summary>
        /// Map of string keys and values that can be used to organize and categorize (scope and
        /// select) objects. May match selectors of replication controllers and services. More info:
        /// http://kubernetes.io/docs/user-guide/labels
        /// </summary>
      public readonly ImmutableDictionary<string, string> Labels;

      /// <summary>
        /// ManagedFields maps workflow-id and version to the set of fields that are managed by that
        /// workflow. This is mostly for internal housekeeping, and users typically shouldn't need
        /// to set or understand this field. A workflow can be the user's name, a controller's name,
        /// or the name of a specific apply path like "ci-cd". The set of fields is always in the
        /// version that the workflow used when modifying the object.
        /// </summary>
      public readonly ImmutableArray<Meta.V1.ManagedFieldsEntry> ManagedFields;

      /// <summary>
        /// Name must be unique within a namespace. Is required when creating resources, although
        /// some resources may allow a client to request the generation of an appropriate name
        /// automatically. Name is primarily intended for creation idempotence and configuration
        /// definition. Cannot be updated. More info:
        /// http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace defines the space within each name must be unique. An empty namespace is
        /// equivalent to the "default" namespace, but "default" is the canonical representation.
        /// Not all objects are required to be scoped to a namespace - the value of this field for
        /// those objects will be empty.
        /// 
        /// Must be a DNS_LABEL. Cannot be updated. More info:
        /// http://kubernetes.io/docs/user-guide/namespaces
        /// </summary>
      public readonly string Namespace;

      /// <summary>
        /// List of objects depended by this object. If ALL objects in the list have been deleted,
        /// this object will be garbage collected. If this object is managed by a controller, then
        /// an entry in this list will point to this controller, with the controller field set to
        /// true. There cannot be more than one managing controller.
        /// </summary>
      public readonly ImmutableArray<Meta.V1.OwnerReference> OwnerReferences;

      /// <summary>
        /// An opaque value that represents the internal version of this object that can be used by
        /// clients to determine when objects have changed. May be used for optimistic concurrency,
        /// change detection, and the watch operation on a resource or set of resources. Clients
        /// must treat these values as opaque and passed unmodified back to the server. They may
        /// only be valid for a particular resource or set of resources.
        /// 
        /// Populated by the system. Read-only. Value must be treated as opaque by clients and .
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
      public readonly string ResourceVersion;

      /// <summary>
        /// SelfLink is a URL representing this object. Populated by the system. Read-only.
        /// 
        /// DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is
        /// planned to be removed in 1.21 release.
        /// </summary>
      public readonly string SelfLink;

      /// <summary>
        /// UID is the unique in time and space value for this object. It is typically generated by
        /// the server on successful creation of a resource and is not allowed to change on PUT
        /// operations.
        /// 
        /// Populated by the system. Read-only. More info:
        /// http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
      public readonly string Uid;

      [OutputConstructor]
      private ObjectMeta(
          ImmutableDictionary<string, string> @annotations,
          string @clusterName,
          string @creationTimestamp,
          int @deletionGracePeriodSeconds,
          string @deletionTimestamp,
          ImmutableArray<string> @finalizers,
          string @generateName,
          int @generation,
          ImmutableDictionary<string, string> @labels,
          ImmutableArray<Meta.V1.ManagedFieldsEntry> @managedFields,
          string @name,
          string @namespace,
          ImmutableArray<Meta.V1.OwnerReference> @ownerReferences,
          string @resourceVersion,
          string @selfLink,
          string @uid)
      {
          this.Annotations = @annotations;
          this.ClusterName = @clusterName;
          this.CreationTimestamp = @creationTimestamp;
          this.DeletionGracePeriodSeconds = @deletionGracePeriodSeconds;
          this.DeletionTimestamp = @deletionTimestamp;
          this.Finalizers = @finalizers;
          this.GenerateName = @generateName;
          this.Generation = @generation;
          this.Labels = @labels;
          this.ManagedFields = @managedFields;
          this.Name = @name;
          this.Namespace = @namespace;
          this.OwnerReferences = @ownerReferences;
          this.ResourceVersion = @resourceVersion;
          this.SelfLink = @selfLink;
          this.Uid = @uid;
      }

    }
    /// <summary>
    /// OwnerReference contains enough information to let you identify an owning object. An owning
    /// object must be in the same namespace as the dependent, or be cluster-scoped, so there is no
    /// namespace field.
    /// </summary>
    [OutputType]
    public sealed class OwnerReference
    {
      /// <summary>
        /// API version of the referent.
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot
        /// be deleted from the key-value store until this reference is removed. Defaults to false.
        /// To set this field, a user needs "delete" permission of the owner, otherwise 422
        /// (Unprocessable Entity) will be returned.
        /// </summary>
      public readonly bool BlockOwnerDeletion;

      /// <summary>
        /// If true, this reference points to the managing controller.
        /// </summary>
      public readonly bool Controller;

      /// <summary>
        /// Kind of the referent. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
      public readonly string Uid;

      [OutputConstructor]
      private OwnerReference(
          string @apiVersion,
          bool @blockOwnerDeletion,
          bool @controller,
          string @kind,
          string @name,
          string @uid)
      {
          this.ApiVersion = @apiVersion;
          this.BlockOwnerDeletion = @blockOwnerDeletion;
          this.Controller = @controller;
          this.Kind = @kind;
          this.Name = @name;
          this.Uid = @uid;
      }

    }
    /// <summary>
    /// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
    /// </summary>
    [OutputType]
    public sealed class Preconditions
    {
      /// <summary>
        /// Specifies the target ResourceVersion
        /// </summary>
      public readonly string ResourceVersion;

      /// <summary>
        /// Specifies the target UID.
        /// </summary>
      public readonly string Uid;

      [OutputConstructor]
      private Preconditions(
          string @resourceVersion,
          string @uid)
      {
          this.ResourceVersion = @resourceVersion;
          this.Uid = @uid;
      }

    }
    /// <summary>
    /// ServerAddressByClientCIDR helps the client to determine the server address that they should
    /// use, depending on the clientCIDR that they match.
    /// </summary>
    [OutputType]
    public sealed class ServerAddressByClientCIDR
    {
      /// <summary>
        /// The CIDR with which clients can match their IP to figure out the server address that
        /// they should use.
        /// </summary>
      public readonly string ClientCIDR;

      /// <summary>
        /// Address of this server, suitable for a client that matches the above CIDR. This can be a
        /// hostname, hostname:port, IP or IP:port.
        /// </summary>
      public readonly string ServerAddress;

      [OutputConstructor]
      private ServerAddressByClientCIDR(
          string @clientCIDR,
          string @serverAddress)
      {
          this.ClientCIDR = @clientCIDR;
          this.ServerAddress = @serverAddress;
      }

    }
    /// <summary>
    /// Status is a return value for calls that don't return other objects.
    /// </summary>
    [OutputType]
    public sealed class Status
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Suggested HTTP return code for this status, 0 if not set.
        /// </summary>
      public readonly int Code;

      /// <summary>
        /// Extended data associated with the reason.  Each reason may define its own extended
        /// details. This field is optional and the data returned is not guaranteed to conform to
        /// any schema except that defined by the reason type.
        /// </summary>
      public readonly Meta.V1.StatusDetails Details;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// A human-readable description of the status of this operation.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      /// <summary>
        /// A machine-readable description of why this operation is in the "Failure" status. If this
        /// value is empty there is no information available. A Reason clarifies an HTTP status code
        /// but does not override it.
        /// </summary>
      public readonly string Reason;

      /// <summary>
        /// Status of the operation. One of: "Success" or "Failure". More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly string StatusValue;

      [OutputConstructor]
      private Status(
          string @apiVersion,
          int @code,
          Meta.V1.StatusDetails @details,
          string @kind,
          string @message,
          Meta.V1.ListMeta @metadata,
          string @reason,
          string @status)
      {
          this.ApiVersion = @apiVersion;
          this.Code = @code;
          this.Details = @details;
          this.Kind = @kind;
          this.Message = @message;
          this.Metadata = @metadata;
          this.Reason = @reason;
          this.StatusValue = @status;
      }

    }
    /// <summary>
    /// StatusCause provides more information about an api.Status failure, including cases when
    /// multiple errors are encountered.
    /// </summary>
    [OutputType]
    public sealed class StatusCause
    {
      /// <summary>
        /// The field of the resource that has caused this error, as named by its JSON
        /// serialization. May include dot and postfix notation for nested attributes. Arrays are
        /// zero-indexed.  Fields may appear more than once in an array of causes due to fields
        /// having multiple errors. Optional.
        /// 
        /// Examples:
        ///   "name" - the field "name" on the current resource
        ///   "items[0].name" - the field "name" on the first array entry in "items"
        /// </summary>
      public readonly string Field;

      /// <summary>
        /// A human-readable description of the cause of the error.  This field may be presented
        /// as-is to a reader.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// A machine-readable description of the cause of the error. If this value is empty there
        /// is no information available.
        /// </summary>
      public readonly string Reason;

      [OutputConstructor]
      private StatusCause(
          string @field,
          string @message,
          string @reason)
      {
          this.Field = @field;
          this.Message = @message;
          this.Reason = @reason;
      }

    }
    /// <summary>
    /// StatusDetails is a set of additional properties that MAY be set by the server to provide
    /// additional information about a response. The Reason field of a Status object defines what
    /// attributes will be set. Clients must ignore fields that do not match the defined type of
    /// each attribute, and should assume that any attribute may be empty, invalid, or under
    /// defined.
    /// </summary>
    [OutputType]
    public sealed class StatusDetails
    {
      /// <summary>
        /// The Causes array includes more details associated with the StatusReason failure. Not all
        /// StatusReasons may provide detailed causes.
        /// </summary>
      public readonly ImmutableArray<Meta.V1.StatusCause> Causes;

      /// <summary>
        /// The group attribute of the resource associated with the status StatusReason.
        /// </summary>
      public readonly string Group;

      /// <summary>
        /// The kind attribute of the resource associated with the status StatusReason. On some
        /// operations may differ from the requested resource Kind. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// The name attribute of the resource associated with the status StatusReason (when there
        /// is a single name which can be described).
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// If specified, the time in seconds before the operation should be retried. Some errors
        /// may indicate the client must take an alternate action - for those errors this field may
        /// indicate how long to wait before taking the alternate action.
        /// </summary>
      public readonly int RetryAfterSeconds;

      /// <summary>
        /// UID of the resource. (when there is a single resource which can be described). More
        /// info: http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
      public readonly string Uid;

      [OutputConstructor]
      private StatusDetails(
          ImmutableArray<Meta.V1.StatusCause> @causes,
          string @group,
          string @kind,
          string @name,
          int @retryAfterSeconds,
          string @uid)
      {
          this.Causes = @causes;
          this.Group = @group;
          this.Kind = @kind;
          this.Name = @name;
          this.RetryAfterSeconds = @retryAfterSeconds;
          this.Uid = @uid;
      }

    }
    /// <summary>
    /// Event represents a single event to a watched resource.
    /// </summary>
    [OutputType]
    public sealed class WatchEvent
    {
      /// <summary>
        /// Object is:
        ///  * If Type is Added or Modified: the new state of the object.
        ///  * If Type is Deleted: the state of the object immediately before deletion.
        ///  * If Type is Error: *Status is recommended; other types may make sense
        ///    depending on context.
        /// </summary>
      public readonly System.Text.Json.JsonElement Object;

      
      public readonly string Type;

      [OutputConstructor]
      private WatchEvent(
          System.Text.Json.JsonElement @object,
          string @type)
      {
          this.Object = @object;
          this.Type = @type;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Networking
{
  namespace V1
  {
    /// <summary>
    /// IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
    /// matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
    /// not be included within this rule.
    /// </summary>
    [OutputType]
    public sealed class IPBlock
    {
      /// <summary>
        /// CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24"
        /// </summary>
      public readonly string Cidr;

      /// <summary>
        /// Except is a slice of CIDRs that should not be included within an IP Block Valid examples
        /// are "192.168.1.1/24" Except values will be rejected if they are outside the CIDR range
        /// </summary>
      public readonly ImmutableArray<string> Except;

      [OutputConstructor]
      private IPBlock(
          string @cidr,
          ImmutableArray<string> @except)
      {
          this.Cidr = @cidr;
          this.Except = @except;
      }

    }
    /// <summary>
    /// NetworkPolicy describes what network traffic is allowed for a set of Pods
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicy
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior for this NetworkPolicy.
        /// </summary>
      public readonly Networking.V1.NetworkPolicySpec Spec;

      [OutputConstructor]
      private NetworkPolicy(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Networking.V1.NetworkPolicySpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
    /// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to. This
    /// type is beta-level in 1.8
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyEgressRule
    {
      /// <summary>
        /// List of destination ports for outgoing traffic. Each item in this list is combined using
        /// a logical OR. If this field is empty or missing, this rule matches all ports (traffic
        /// not restricted by port). If this field is present and contains at least one item, then
        /// this rule allows traffic only if the traffic matches at least one port in the list.
        /// </summary>
      public readonly ImmutableArray<Networking.V1.NetworkPolicyPort> Ports;

      /// <summary>
        /// List of destinations for outgoing traffic of pods selected for this rule. Items in this
        /// list are combined using a logical OR operation. If this field is empty or missing, this
        /// rule matches all destinations (traffic not restricted by destination). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the to list.
        /// </summary>
      public readonly ImmutableArray<Networking.V1.NetworkPolicyPeer> To;

      [OutputConstructor]
      private NetworkPolicyEgressRule(
          ImmutableArray<Networking.V1.NetworkPolicyPort> @ports,
          ImmutableArray<Networking.V1.NetworkPolicyPeer> @to)
      {
          this.Ports = @ports;
          this.To = @to;
      }

    }
    /// <summary>
    /// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
    /// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyIngressRule
    {
      /// <summary>
        /// List of sources which should be able to access the pods selected for this rule. Items in
        /// this list are combined using a logical OR operation. If this field is empty or missing,
        /// this rule matches all sources (traffic not restricted by source). If this field is
        /// present and contains at least one item, this rule allows traffic only if the traffic
        /// matches at least one item in the from list.
        /// </summary>
      public readonly ImmutableArray<Networking.V1.NetworkPolicyPeer> From;

      /// <summary>
        /// List of ports which should be made accessible on the pods selected for this rule. Each
        /// item in this list is combined using a logical OR. If this field is empty or missing,
        /// this rule matches all ports (traffic not restricted by port). If this field is present
        /// and contains at least one item, then this rule allows traffic only if the traffic
        /// matches at least one port in the list.
        /// </summary>
      public readonly ImmutableArray<Networking.V1.NetworkPolicyPort> Ports;

      [OutputConstructor]
      private NetworkPolicyIngressRule(
          ImmutableArray<Networking.V1.NetworkPolicyPeer> @from,
          ImmutableArray<Networking.V1.NetworkPolicyPort> @ports)
      {
          this.From = @from;
          this.Ports = @ports;
      }

    }
    /// <summary>
    /// NetworkPolicyList is a list of NetworkPolicy objects.
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Networking.V1.NetworkPolicy> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private NetworkPolicyList(
          string @apiVersion,
          ImmutableArray<Networking.V1.NetworkPolicy> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// NetworkPolicyPeer describes a peer to allow traffic from. Only certain combinations of
    /// fields are allowed
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyPeer
    {
      /// <summary>
        /// IPBlock defines policy on a particular IPBlock. If this field is set then neither of the
        /// other fields can be.
        /// </summary>
      public readonly Networking.V1.IPBlock IpBlock;

      /// <summary>
        /// Selects Namespaces using cluster-scoped labels. This field follows standard label
        /// selector semantics; if present but empty, it selects all namespaces.
        /// 
        /// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects all Pods in the Namespaces selected by NamespaceSelector.
        /// </summary>
      public readonly Meta.V1.LabelSelector NamespaceSelector;

      /// <summary>
        /// This is a label selector which selects Pods. This field follows standard label selector
        /// semantics; if present but empty, it selects all pods.
        /// 
        /// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
        /// matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it
        /// selects the Pods matching PodSelector in the policy's own Namespace.
        /// </summary>
      public readonly Meta.V1.LabelSelector PodSelector;

      [OutputConstructor]
      private NetworkPolicyPeer(
          Networking.V1.IPBlock @ipBlock,
          Meta.V1.LabelSelector @namespaceSelector,
          Meta.V1.LabelSelector @podSelector)
      {
          this.IpBlock = @ipBlock;
          this.NamespaceSelector = @namespaceSelector;
          this.PodSelector = @podSelector;
      }

    }
    /// <summary>
    /// NetworkPolicyPort describes a port to allow traffic on
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicyPort
    {
      /// <summary>
        /// The port on the given protocol. This can either be a numerical or named port on a pod.
        /// If this field is not provided, this matches all port names and numbers.
        /// </summary>
      public readonly Union<int,string> Port;

      /// <summary>
        /// The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field
        /// defaults to TCP.
        /// </summary>
      public readonly string Protocol;

      [OutputConstructor]
      private NetworkPolicyPort(
          Union<int,string> @port,
          string @protocol)
      {
          this.Port = @port;
          this.Protocol = @protocol;
      }

    }
    /// <summary>
    /// NetworkPolicySpec provides the specification of a NetworkPolicy
    /// </summary>
    [OutputType]
    public sealed class NetworkPolicySpec
    {
      /// <summary>
        /// List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if
        /// there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
        /// traffic), OR if the traffic matches at least one egress rule across all of the
        /// NetworkPolicy objects whose podSelector matches the pod. If this field is empty then
        /// this NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the
        /// pods it selects are isolated by default). This field is beta-level in 1.8
        /// </summary>
      public readonly ImmutableArray<Networking.V1.NetworkPolicyEgressRule> Egress;

      /// <summary>
        /// List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if
        /// there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
        /// traffic), OR if the traffic source is the pod's local node, OR if the traffic matches at
        /// least one ingress rule across all of the NetworkPolicy objects whose podSelector matches
        /// the pod. If this field is empty then this NetworkPolicy does not allow any traffic (and
        /// serves solely to ensure that the pods it selects are isolated by default)
        /// </summary>
      public readonly ImmutableArray<Networking.V1.NetworkPolicyIngressRule> Ingress;

      /// <summary>
        /// Selects the pods to which this NetworkPolicy object applies. The array of ingress rules
        /// is applied to any pods selected by this field. Multiple network policies can select the
        /// same set of pods. In this case, the ingress rules for each are combined additively. This
        /// field is NOT optional and follows standard label selector semantics. An empty
        /// podSelector matches all pods in this namespace.
        /// </summary>
      public readonly Meta.V1.LabelSelector PodSelector;

      /// <summary>
        /// List of rule types that the NetworkPolicy relates to. Valid options are "Ingress",
        /// "Egress", or "Ingress,Egress". If this field is not specified, it will default based on
        /// the existence of Ingress or Egress rules; policies that contain an Egress section are
        /// assumed to affect Egress, and all policies (whether or not they contain an Ingress
        /// section) are assumed to affect Ingress. If you want to write an egress-only policy, you
        /// must explicitly specify policyTypes [ "Egress" ]. Likewise, if you want to write a
        /// policy that specifies that no egress is allowed, you must specify a policyTypes value
        /// that include "Egress" (since such a policy would not include an Egress section and would
        /// otherwise default to just [ "Ingress" ]). This field is beta-level in 1.8
        /// </summary>
      public readonly ImmutableArray<string> PolicyTypes;

      [OutputConstructor]
      private NetworkPolicySpec(
          ImmutableArray<Networking.V1.NetworkPolicyEgressRule> @egress,
          ImmutableArray<Networking.V1.NetworkPolicyIngressRule> @ingress,
          Meta.V1.LabelSelector @podSelector,
          ImmutableArray<string> @policyTypes)
      {
          this.Egress = @egress;
          this.Ingress = @ingress;
          this.PodSelector = @podSelector;
          this.PolicyTypes = @policyTypes;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are
    /// forwarded to the backend.
    /// </summary>
    [OutputType]
    public sealed class HTTPIngressPath
    {
      /// <summary>
        /// Backend defines the referenced service endpoint to which the traffic will be forwarded
        /// to.
        /// </summary>
      public readonly Networking.V1Beta1.IngressBackend Backend;

      /// <summary>
        /// Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the
        /// egrep/unix syntax, not the perl syntax) matched against the path of an incoming request.
        /// Currently it can contain characters disallowed from the conventional "path" part of a
        /// URL as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path
        /// defaults to a catch all sending traffic to the backend.
        /// </summary>
      public readonly string Path;

      [OutputConstructor]
      private HTTPIngressPath(
          Networking.V1Beta1.IngressBackend @backend,
          string @path)
      {
          this.Backend = @backend;
          this.Path = @path;
      }

    }
    /// <summary>
    /// HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example:
    /// http://&amp;lt;host&amp;gt;/&amp;lt;path&amp;gt;?&amp;lt;searchpart&amp;gt; -&amp;gt;
    /// backend where where parts of the url correspond to RFC 3986, this resource will be used to
    /// match against everything after the last '/' and before the first '?' or '#'.
    /// </summary>
    [OutputType]
    public sealed class HTTPIngressRuleValue
    {
      /// <summary>
        /// A collection of paths that map requests to backends.
        /// </summary>
      public readonly ImmutableArray<Networking.V1Beta1.HTTPIngressPath> Paths;

      [OutputConstructor]
      private HTTPIngressRuleValue(
          ImmutableArray<Networking.V1Beta1.HTTPIngressPath> @paths)
      {
          this.Paths = @paths;
      }

    }
    /// <summary>
    /// Ingress is a collection of rules that allow inbound connections to reach the endpoints
    /// defined by a backend. An Ingress can be configured to give services externally-reachable
    /// urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
    /// </summary>
    [OutputType]
    public sealed class Ingress
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Spec is the desired state of the Ingress. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Networking.V1Beta1.IngressSpec Spec;

      /// <summary>
        /// Status is the current state of the Ingress. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Networking.V1Beta1.IngressStatus Status;

      [OutputConstructor]
      private Ingress(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Networking.V1Beta1.IngressSpec @spec,
          Networking.V1Beta1.IngressStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// IngressBackend describes all endpoints for a given service and port.
    /// </summary>
    [OutputType]
    public sealed class IngressBackend
    {
      /// <summary>
        /// Specifies the name of the referenced service.
        /// </summary>
      public readonly string ServiceName;

      /// <summary>
        /// Specifies the port of the referenced service.
        /// </summary>
      public readonly Union<int,string> ServicePort;

      [OutputConstructor]
      private IngressBackend(
          string @serviceName,
          Union<int,string> @servicePort)
      {
          this.ServiceName = @serviceName;
          this.ServicePort = @servicePort;
      }

    }
    /// <summary>
    /// IngressList is a collection of Ingress.
    /// </summary>
    [OutputType]
    public sealed class IngressList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of Ingress.
        /// </summary>
      public readonly ImmutableArray<Networking.V1Beta1.Ingress> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private IngressList(
          string @apiVersion,
          ImmutableArray<Networking.V1Beta1.Ingress> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// IngressRule represents the rules mapping the paths under a specified host to the related
    /// backend services. Incoming requests are first evaluated for a host match, then routed to the
    /// backend associated with the matching IngressRuleValue.
    /// </summary>
    [OutputType]
    public sealed class IngressRule
    {
      /// <summary>
        /// Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note
        /// the following deviations from the "host" part of the URI as defined in the RFC: 1. IPs
        /// are not allowed. Currently an IngressRuleValue can only apply to the
        /// 	  IP in the Spec of the parent Ingress.
        /// 2. The `:` delimiter is not respected because ports are not allowed.
        /// 	  Currently the port of an Ingress is implicitly :80 for http and
        /// 	  :443 for https.
        /// Both these may change in the future. Incoming requests are matched against the host
        /// before the IngressRuleValue. If the host is unspecified, the Ingress routes all traffic
        /// based on the specified IngressRuleValue.
        /// </summary>
      public readonly string Host;

      
      public readonly Networking.V1Beta1.HTTPIngressRuleValue Http;

      [OutputConstructor]
      private IngressRule(
          string @host,
          Networking.V1Beta1.HTTPIngressRuleValue @http)
      {
          this.Host = @host;
          this.Http = @http;
      }

    }
    /// <summary>
    /// IngressSpec describes the Ingress the user wishes to exist.
    /// </summary>
    [OutputType]
    public sealed class IngressSpec
    {
      /// <summary>
        /// A default backend capable of servicing requests that don't match any rule. At least one
        /// of 'backend' or 'rules' must be specified. This field is optional to allow the
        /// loadbalancer controller or defaulting logic to specify a global default.
        /// </summary>
      public readonly Networking.V1Beta1.IngressBackend Backend;

      /// <summary>
        /// A list of host rules used to configure the Ingress. If unspecified, or no rule matches,
        /// all traffic is sent to the default backend.
        /// </summary>
      public readonly ImmutableArray<Networking.V1Beta1.IngressRule> Rules;

      /// <summary>
        /// TLS configuration. Currently the Ingress only supports a single TLS port, 443. If
        /// multiple members of this list specify different hosts, they will be multiplexed on the
        /// same port according to the hostname specified through the SNI TLS extension, if the
        /// ingress controller fulfilling the ingress supports SNI.
        /// </summary>
      public readonly ImmutableArray<Networking.V1Beta1.IngressTLS> Tls;

      [OutputConstructor]
      private IngressSpec(
          Networking.V1Beta1.IngressBackend @backend,
          ImmutableArray<Networking.V1Beta1.IngressRule> @rules,
          ImmutableArray<Networking.V1Beta1.IngressTLS> @tls)
      {
          this.Backend = @backend;
          this.Rules = @rules;
          this.Tls = @tls;
      }

    }
    /// <summary>
    /// IngressStatus describe the current state of the Ingress.
    /// </summary>
    [OutputType]
    public sealed class IngressStatus
    {
      /// <summary>
        /// LoadBalancer contains the current status of the load-balancer.
        /// </summary>
      public readonly Core.V1.LoadBalancerStatus LoadBalancer;

      [OutputConstructor]
      private IngressStatus(
          Core.V1.LoadBalancerStatus @loadBalancer)
      {
          this.LoadBalancer = @loadBalancer;
      }

    }
    /// <summary>
    /// IngressTLS describes the transport layer security associated with an Ingress.
    /// </summary>
    [OutputType]
    public sealed class IngressTLS
    {
      /// <summary>
        /// Hosts are a list of hosts included in the TLS certificate. The values in this list must
        /// match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the
        /// loadbalancer controller fulfilling this Ingress, if left unspecified.
        /// </summary>
      public readonly ImmutableArray<string> Hosts;

      /// <summary>
        /// SecretName is the name of the secret used to terminate SSL traffic on 443. Field is left
        /// optional to allow SSL routing based on SNI hostname alone. If the SNI host in a listener
        /// conflicts with the "Host" header field used by an IngressRule, the SNI host is used for
        /// termination and value of the Host header is used for routing.
        /// </summary>
      public readonly string SecretName;

      [OutputConstructor]
      private IngressTLS(
          ImmutableArray<string> @hosts,
          string @secretName)
      {
          this.Hosts = @hosts;
          this.SecretName = @secretName;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Node
{
  namespace V1Alpha1
  {
    /// <summary>
    /// Overhead structure represents the resource overhead associated with running a pod.
    /// </summary>
    [OutputType]
    public sealed class Overhead
    {
      /// <summary>
        /// PodFixed represents the fixed resource overhead associated with running a pod.
        /// </summary>
      public readonly ImmutableDictionary<string, string> PodFixed;

      [OutputConstructor]
      private Overhead(
          ImmutableDictionary<string, string> @podFixed)
      {
          this.PodFixed = @podFixed;
      }

    }
    /// <summary>
    /// RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass
    /// is used to determine which container runtime is used to run all containers in a pod.
    /// RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and
    /// referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName
    /// reference before running the pod.  For more details, see
    /// https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
    /// </summary>
    [OutputType]
    public sealed class RuntimeClass
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the RuntimeClass More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        /// </summary>
      public readonly Node.V1Alpha1.RuntimeClassSpec Spec;

      [OutputConstructor]
      private RuntimeClass(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Node.V1Alpha1.RuntimeClassSpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// RuntimeClassList is a list of RuntimeClass objects.
    /// </summary>
    [OutputType]
    public sealed class RuntimeClassList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Node.V1Alpha1.RuntimeClass> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private RuntimeClassList(
          string @apiVersion,
          ImmutableArray<Node.V1Alpha1.RuntimeClass> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// RuntimeClassSpec is a specification of a RuntimeClass. It contains parameters that are
    /// required to describe the RuntimeClass to the Container Runtime Interface (CRI)
    /// implementation, as well as any other components that need to understand how the pod will be
    /// run. The RuntimeClassSpec is immutable.
    /// </summary>
    [OutputType]
    public sealed class RuntimeClassSpec
    {
      /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a given
        /// RuntimeClass. For more details, see
        /// https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
        /// alpha-level as of Kubernetes v1.15, and is only honored by servers that enable the
        /// PodOverhead feature.
        /// </summary>
      public readonly Node.V1Alpha1.Overhead Overhead;

      /// <summary>
        /// RuntimeHandler specifies the underlying runtime and configuration that the CRI
        /// implementation will use to handle pods of this class. The possible values are specific
        /// to the node &amp; CRI configuration.  It is assumed that all handlers are available on
        /// every node, and handlers of the same name are equivalent on every node. For example, a
        /// handler called "runc" might specify that the runc OCI runtime (using native Linux
        /// containers) will be used to run the containers in a pod. The RuntimeHandler must conform
        /// to the DNS Label (RFC 1123) requirements and is immutable.
        /// </summary>
      public readonly string RuntimeHandler;

      /// <summary>
        /// Scheduling holds the scheduling constraints to ensure that pods running with this
        /// RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this
        /// RuntimeClass is assumed to be supported by all nodes.
        /// </summary>
      public readonly Node.V1Alpha1.Scheduling Scheduling;

      [OutputConstructor]
      private RuntimeClassSpec(
          Node.V1Alpha1.Overhead @overhead,
          string @runtimeHandler,
          Node.V1Alpha1.Scheduling @scheduling)
      {
          this.Overhead = @overhead;
          this.RuntimeHandler = @runtimeHandler;
          this.Scheduling = @scheduling;
      }

    }
    /// <summary>
    /// Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.
    /// </summary>
    [OutputType]
    public sealed class Scheduling
    {
      /// <summary>
        /// nodeSelector lists labels that must be present on nodes that support this RuntimeClass.
        /// Pods using this RuntimeClass can only be scheduled to a node matched by this selector.
        /// The RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any
        /// conflicts will cause the pod to be rejected in admission.
        /// </summary>
      public readonly ImmutableDictionary<string, string> NodeSelector;

      /// <summary>
        /// tolerations are appended (excluding duplicates) to pods running with this RuntimeClass
        /// during admission, effectively unioning the set of nodes tolerated by the pod and the
        /// RuntimeClass.
        /// </summary>
      public readonly ImmutableArray<Core.V1.Toleration> Tolerations;

      [OutputConstructor]
      private Scheduling(
          ImmutableDictionary<string, string> @nodeSelector,
          ImmutableArray<Core.V1.Toleration> @tolerations)
      {
          this.NodeSelector = @nodeSelector;
          this.Tolerations = @tolerations;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// Overhead structure represents the resource overhead associated with running a pod.
    /// </summary>
    [OutputType]
    public sealed class Overhead
    {
      /// <summary>
        /// PodFixed represents the fixed resource overhead associated with running a pod.
        /// </summary>
      public readonly ImmutableDictionary<string, string> PodFixed;

      [OutputConstructor]
      private Overhead(
          ImmutableDictionary<string, string> @podFixed)
      {
          this.PodFixed = @podFixed;
      }

    }
    /// <summary>
    /// RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass
    /// is used to determine which container runtime is used to run all containers in a pod.
    /// RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and
    /// referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName
    /// reference before running the pod.  For more details, see
    /// https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
    /// </summary>
    [OutputType]
    public sealed class RuntimeClass
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Handler specifies the underlying runtime and configuration that the CRI implementation
        /// will use to handle pods of this class. The possible values are specific to the node
        /// &amp; CRI configuration.  It is assumed that all handlers are available on every node,
        /// and handlers of the same name are equivalent on every node. For example, a handler
        /// called "runc" might specify that the runc OCI runtime (using native Linux containers)
        /// will be used to run the containers in a pod. The Handler must conform to the DNS Label
        /// (RFC 1123) requirements, and is immutable.
        /// </summary>
      public readonly string Handler;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Overhead represents the resource overhead associated with running a pod for a given
        /// RuntimeClass. For more details, see
        /// https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
        /// alpha-level as of Kubernetes v1.15, and is only honored by servers that enable the
        /// PodOverhead feature.
        /// </summary>
      public readonly Node.V1Beta1.Overhead Overhead;

      /// <summary>
        /// Scheduling holds the scheduling constraints to ensure that pods running with this
        /// RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this
        /// RuntimeClass is assumed to be supported by all nodes.
        /// </summary>
      public readonly Node.V1Beta1.Scheduling Scheduling;

      [OutputConstructor]
      private RuntimeClass(
          string @apiVersion,
          string @handler,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Node.V1Beta1.Overhead @overhead,
          Node.V1Beta1.Scheduling @scheduling)
      {
          this.ApiVersion = @apiVersion;
          this.Handler = @handler;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Overhead = @overhead;
          this.Scheduling = @scheduling;
      }

    }
    /// <summary>
    /// RuntimeClassList is a list of RuntimeClass objects.
    /// </summary>
    [OutputType]
    public sealed class RuntimeClassList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Node.V1Beta1.RuntimeClass> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private RuntimeClassList(
          string @apiVersion,
          ImmutableArray<Node.V1Beta1.RuntimeClass> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.
    /// </summary>
    [OutputType]
    public sealed class Scheduling
    {
      /// <summary>
        /// nodeSelector lists labels that must be present on nodes that support this RuntimeClass.
        /// Pods using this RuntimeClass can only be scheduled to a node matched by this selector.
        /// The RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any
        /// conflicts will cause the pod to be rejected in admission.
        /// </summary>
      public readonly ImmutableDictionary<string, string> NodeSelector;

      /// <summary>
        /// tolerations are appended (excluding duplicates) to pods running with this RuntimeClass
        /// during admission, effectively unioning the set of nodes tolerated by the pod and the
        /// RuntimeClass.
        /// </summary>
      public readonly ImmutableArray<Core.V1.Toleration> Tolerations;

      [OutputConstructor]
      private Scheduling(
          ImmutableDictionary<string, string> @nodeSelector,
          ImmutableArray<Core.V1.Toleration> @tolerations)
      {
          this.NodeSelector = @nodeSelector;
          this.Tolerations = @tolerations;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Pkg
{
  namespace Version
  {
    /// <summary>
    /// Info contains versioning information. how we'll want to distribute that information.
    /// </summary>
    [OutputType]
    public sealed class Info
    {
      
      public readonly string BuildDate;

      
      public readonly string Compiler;

      
      public readonly string GitCommit;

      
      public readonly string GitTreeState;

      
      public readonly string GitVersion;

      
      public readonly string GoVersion;

      
      public readonly string Major;

      
      public readonly string Minor;

      
      public readonly string Platform;

      [OutputConstructor]
      private Info(
          string @buildDate,
          string @compiler,
          string @gitCommit,
          string @gitTreeState,
          string @gitVersion,
          string @goVersion,
          string @major,
          string @minor,
          string @platform)
      {
          this.BuildDate = @buildDate;
          this.Compiler = @compiler;
          this.GitCommit = @gitCommit;
          this.GitTreeState = @gitTreeState;
          this.GitVersion = @gitVersion;
          this.GoVersion = @goVersion;
          this.Major = @major;
          this.Minor = @minor;
          this.Platform = @platform;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Policy
{
  namespace V1Beta1
  {
    /// <summary>
    /// AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
    /// </summary>
    [OutputType]
    public sealed class AllowedCSIDriver
    {
      /// <summary>
        /// Name is the registered name of the CSI driver
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private AllowedCSIDriver(
          string @name)
      {
          this.Name = @name;
      }

    }
    /// <summary>
    /// AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
    /// </summary>
    [OutputType]
    public sealed class AllowedFlexVolume
    {
      /// <summary>
        /// driver is the name of the Flexvolume driver.
        /// </summary>
      public readonly string Driver;

      [OutputConstructor]
      private AllowedFlexVolume(
          string @driver)
      {
          this.Driver = @driver;
      }

    }
    /// <summary>
    /// AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods
    /// to use. It requires the path prefix to be defined.
    /// </summary>
    [OutputType]
    public sealed class AllowedHostPath
    {
      /// <summary>
        /// pathPrefix is the path prefix that the host volume must match. It does not support `*`.
        /// Trailing slashes are trimmed when validating the path prefix with a host path.
        /// 
        /// Examples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo` would not allow
        /// `/food` or `/etc/foo`
        /// </summary>
      public readonly string PathPrefix;

      /// <summary>
        /// when set to true, will allow host volumes matching the pathPrefix only if all volume
        /// mounts are readOnly.
        /// </summary>
      public readonly bool ReadOnly;

      [OutputConstructor]
      private AllowedHostPath(
          string @pathPrefix,
          bool @readOnly)
      {
          this.PathPrefix = @pathPrefix;
          this.ReadOnly = @readOnly;
      }

    }
    /// <summary>
    /// Eviction evicts a pod from its node subject to certain policies and safety constraints. This
    /// is a subresource of Pod.  A request to cause such an eviction is created by POSTing to
    /// .../pods/&amp;lt;pod name&amp;gt;/evictions.
    /// </summary>
    [OutputType]
    public sealed class Eviction
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// DeleteOptions may be provided
        /// </summary>
      public readonly Meta.V1.DeleteOptions DeleteOptions;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// ObjectMeta describes the pod that is being evicted.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      [OutputConstructor]
      private Eviction(
          string @apiVersion,
          Meta.V1.DeleteOptions @deleteOptions,
          string @kind,
          Meta.V1.ObjectMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.DeleteOptions = @deleteOptions;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
    /// </summary>
    [OutputType]
    public sealed class FSGroupStrategyOptions
    {
      /// <summary>
        /// ranges are the allowed ranges of fs groups.  If you would like to force a single fs
        /// group then supply a single range with the same start and end. Required for MustRunAs.
        /// </summary>
      public readonly ImmutableArray<Policy.V1Beta1.IDRange> Ranges;

      /// <summary>
        /// rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
        /// </summary>
      public readonly string Rule;

      [OutputConstructor]
      private FSGroupStrategyOptions(
          ImmutableArray<Policy.V1Beta1.IDRange> @ranges,
          string @rule)
      {
          this.Ranges = @ranges;
          this.Rule = @rule;
      }

    }
    /// <summary>
    /// HostPortRange defines a range of host ports that will be enabled by a policy for pods to
    /// use.  It requires both the start and end to be defined.
    /// </summary>
    [OutputType]
    public sealed class HostPortRange
    {
      /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
      public readonly int Max;

      /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
      public readonly int Min;

      [OutputConstructor]
      private HostPortRange(
          int @max,
          int @min)
      {
          this.Max = @max;
          this.Min = @min;
      }

    }
    /// <summary>
    /// IDRange provides a min/max of an allowed range of IDs.
    /// </summary>
    [OutputType]
    public sealed class IDRange
    {
      /// <summary>
        /// max is the end of the range, inclusive.
        /// </summary>
      public readonly int Max;

      /// <summary>
        /// min is the start of the range, inclusive.
        /// </summary>
      public readonly int Min;

      [OutputConstructor]
      private IDRange(
          int @max,
          int @min)
      {
          this.Max = @max;
          this.Min = @min;
      }

    }
    /// <summary>
    /// PodDisruptionBudget is an object to define the max disruption that can be caused to a
    /// collection of pods
    /// </summary>
    [OutputType]
    public sealed class PodDisruptionBudget
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired behavior of the PodDisruptionBudget.
        /// </summary>
      public readonly Policy.V1Beta1.PodDisruptionBudgetSpec Spec;

      /// <summary>
        /// Most recently observed status of the PodDisruptionBudget.
        /// </summary>
      public readonly Policy.V1Beta1.PodDisruptionBudgetStatus Status;

      [OutputConstructor]
      private PodDisruptionBudget(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Policy.V1Beta1.PodDisruptionBudgetSpec @spec,
          Policy.V1Beta1.PodDisruptionBudgetStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
    /// </summary>
    [OutputType]
    public sealed class PodDisruptionBudgetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      
      public readonly ImmutableArray<Policy.V1Beta1.PodDisruptionBudget> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PodDisruptionBudgetList(
          string @apiVersion,
          ImmutableArray<Policy.V1Beta1.PodDisruptionBudget> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
    /// </summary>
    [OutputType]
    public sealed class PodDisruptionBudgetSpec
    {
      /// <summary>
        /// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are
        /// unavailable after the eviction, i.e. even in absence of the evicted pod. For example,
        /// one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive
        /// setting with "minAvailable".
        /// </summary>
      public readonly Union<int,string> MaxUnavailable;

      /// <summary>
        /// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still
        /// be available after the eviction, i.e. even in the absence of the evicted pod.  So for
        /// example you can prevent all voluntary evictions by specifying "100%".
        /// </summary>
      public readonly Union<int,string> MinAvailable;

      /// <summary>
        /// Label query over pods whose evictions are managed by the disruption budget.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      [OutputConstructor]
      private PodDisruptionBudgetSpec(
          Union<int,string> @maxUnavailable,
          Union<int,string> @minAvailable,
          Meta.V1.LabelSelector @selector)
      {
          this.MaxUnavailable = @maxUnavailable;
          this.MinAvailable = @minAvailable;
          this.Selector = @selector;
      }

    }
    /// <summary>
    /// PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget.
    /// Status may trail the actual state of a system.
    /// </summary>
    [OutputType]
    public sealed class PodDisruptionBudgetStatus
    {
      /// <summary>
        /// current number of healthy pods
        /// </summary>
      public readonly int CurrentHealthy;

      /// <summary>
        /// minimum desired number of healthy pods
        /// </summary>
      public readonly int DesiredHealthy;

      /// <summary>
        /// DisruptedPods contains information about pods whose eviction was processed by the API
        /// server eviction subresource handler but has not yet been observed by the
        /// PodDisruptionBudget controller. A pod will be in this map from the time when the API
        /// server processed the eviction request to the time when the pod is seen by PDB controller
        /// as having been marked for deletion (or after a timeout). The key in the map is the name
        /// of the pod and the value is the time when the API server processed the eviction request.
        /// If the deletion didn't occur and a pod is still there it will be removed from the list
        /// automatically by PodDisruptionBudget controller after some time. If everything goes
        /// smooth this map should be empty for the most of the time. Large number of entries in the
        /// map may indicate problems with pod deletions.
        /// </summary>
      public readonly ImmutableDictionary<string, string> DisruptedPods;

      /// <summary>
        /// Number of pod disruptions that are currently allowed.
        /// </summary>
      public readonly int DisruptionsAllowed;

      /// <summary>
        /// total number of pods counted by this disruption budget
        /// </summary>
      public readonly int ExpectedPods;

      /// <summary>
        /// Most recent generation observed when updating this PDB status. PodDisruptionsAllowed and
        /// other status information is valid only if observedGeneration equals to PDB's object
        /// generation.
        /// </summary>
      public readonly int ObservedGeneration;

      [OutputConstructor]
      private PodDisruptionBudgetStatus(
          int @currentHealthy,
          int @desiredHealthy,
          ImmutableDictionary<string, string> @disruptedPods,
          int @disruptionsAllowed,
          int @expectedPods,
          int @observedGeneration)
      {
          this.CurrentHealthy = @currentHealthy;
          this.DesiredHealthy = @desiredHealthy;
          this.DisruptedPods = @disruptedPods;
          this.DisruptionsAllowed = @disruptionsAllowed;
          this.ExpectedPods = @expectedPods;
          this.ObservedGeneration = @observedGeneration;
      }

    }
    /// <summary>
    /// PodSecurityPolicy governs the ability to make requests that affect the Security Context that
    /// will be applied to a pod and container.
    /// </summary>
    [OutputType]
    public sealed class PodSecurityPolicy
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// spec defines the policy enforced.
        /// </summary>
      public readonly Policy.V1Beta1.PodSecurityPolicySpec Spec;

      [OutputConstructor]
      private PodSecurityPolicy(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Policy.V1Beta1.PodSecurityPolicySpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// PodSecurityPolicyList is a list of PodSecurityPolicy objects.
    /// </summary>
    [OutputType]
    public sealed class PodSecurityPolicyList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Policy.V1Beta1.PodSecurityPolicy> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PodSecurityPolicyList(
          string @apiVersion,
          ImmutableArray<Policy.V1Beta1.PodSecurityPolicy> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PodSecurityPolicySpec defines the policy enforced.
    /// </summary>
    [OutputType]
    public sealed class PodSecurityPolicySpec
    {
      /// <summary>
        /// allowPrivilegeEscalation determines if a pod can request to allow privilege escalation.
        /// If unspecified, defaults to true.
        /// </summary>
      public readonly bool AllowPrivilegeEscalation;

      /// <summary>
        /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be
        /// embedded within a pod spec. An empty value indicates that any CSI driver can be used for
        /// inline ephemeral volumes. This is an alpha field, and is only honored if the API server
        /// enables the CSIInlineVolume feature gate.
        /// </summary>
      public readonly ImmutableArray<Policy.V1Beta1.AllowedCSIDriver> AllowedCSIDrivers;

      /// <summary>
        /// allowedCapabilities is a list of capabilities that can be requested to add to the
        /// container. Capabilities in this field may be added at the pod author's discretion. You
        /// must not list a capability in both allowedCapabilities and requiredDropCapabilities.
        /// </summary>
      public readonly ImmutableArray<string> AllowedCapabilities;

      /// <summary>
        /// allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that
        /// all Flexvolumes may be used.  This parameter is effective only when the usage of the
        /// Flexvolumes is allowed in the "volumes" field.
        /// </summary>
      public readonly ImmutableArray<Policy.V1Beta1.AllowedFlexVolume> AllowedFlexVolumes;

      /// <summary>
        /// allowedHostPaths is a white list of allowed host paths. Empty indicates that all host
        /// paths may be used.
        /// </summary>
      public readonly ImmutableArray<Policy.V1Beta1.AllowedHostPath> AllowedHostPaths;

      /// <summary>
        /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates
        /// that only the DefaultProcMountType may be used. This requires the ProcMountType feature
        /// flag to be enabled.
        /// </summary>
      public readonly ImmutableArray<string> AllowedProcMountTypes;

      /// <summary>
        /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
        /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
        /// as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet
        /// has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
        /// 
        /// Examples: e.g. "foo/*" allows "foo/bar", "foo/baz", etc. e.g. "foo.*" allows "foo.bar",
        /// "foo.baz", etc.
        /// </summary>
      public readonly ImmutableArray<string> AllowedUnsafeSysctls;

      /// <summary>
        /// defaultAddCapabilities is the default set of capabilities that will be added to the
        /// container unless the pod spec specifically drops the capability.  You may not list a
        /// capability in both defaultAddCapabilities and requiredDropCapabilities. Capabilities
        /// added here are implicitly allowed, and need not be included in the allowedCapabilities
        /// list.
        /// </summary>
      public readonly ImmutableArray<string> DefaultAddCapabilities;

      /// <summary>
        /// defaultAllowPrivilegeEscalation controls the default setting for whether a process can
        /// gain more privileges than its parent process.
        /// </summary>
      public readonly bool DefaultAllowPrivilegeEscalation;

      /// <summary>
        /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry
        /// is either a plain sysctl name or ends in "*" in which case it is considered as a prefix
        /// of forbidden sysctls. Single * means all sysctls are forbidden.
        /// 
        /// Examples: e.g. "foo/*" forbids "foo/bar", "foo/baz", etc. e.g. "foo.*" forbids
        /// "foo.bar", "foo.baz", etc.
        /// </summary>
      public readonly ImmutableArray<string> ForbiddenSysctls;

      /// <summary>
        /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
      public readonly Policy.V1Beta1.FSGroupStrategyOptions FsGroup;

      /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
      public readonly bool HostIPC;

      /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
      public readonly bool HostNetwork;

      /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
      public readonly bool HostPID;

      /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
      public readonly ImmutableArray<Policy.V1Beta1.HostPortRange> HostPorts;

      /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
      public readonly bool Privileged;

      /// <summary>
        /// readOnlyRootFilesystem when set to true will force containers to run with a read only
        /// root file system.  If the container specifically requests to run with a non-read only
        /// root file system the PSP should deny the pod. If set to false the container may run with
        /// a read only root file system if it wishes but it will not be forced to.
        /// </summary>
      public readonly bool ReadOnlyRootFilesystem;

      /// <summary>
        /// requiredDropCapabilities are the capabilities that will be dropped from the container.
        /// These are required to be dropped and cannot be added.
        /// </summary>
      public readonly ImmutableArray<string> RequiredDropCapabilities;

      /// <summary>
        /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be
        /// set. If this field is omitted, the pod's RunAsGroup can take any value. This field
        /// requires the RunAsGroup feature gate to be enabled.
        /// </summary>
      public readonly Policy.V1Beta1.RunAsGroupStrategyOptions RunAsGroup;

      /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be
        /// set.
        /// </summary>
      public readonly Policy.V1Beta1.RunAsUserStrategyOptions RunAsUser;

      /// <summary>
        /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
        /// If this field is omitted, the pod's runtimeClassName field is unrestricted. Enforcement
        /// of this field depends on the RuntimeClass feature gate being enabled.
        /// </summary>
      public readonly Policy.V1Beta1.RuntimeClassStrategyOptions RuntimeClass;

      /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
      public readonly Policy.V1Beta1.SELinuxStrategyOptions SeLinux;

      /// <summary>
        /// supplementalGroups is the strategy that will dictate what supplemental groups are used
        /// by the SecurityContext.
        /// </summary>
      public readonly Policy.V1Beta1.SupplementalGroupsStrategyOptions SupplementalGroups;

      /// <summary>
        /// volumes is a white list of allowed volume plugins. Empty indicates that no volumes may
        /// be used. To allow all volumes you may use '*'.
        /// </summary>
      public readonly ImmutableArray<string> Volumes;

      [OutputConstructor]
      private PodSecurityPolicySpec(
          bool @allowPrivilegeEscalation,
          ImmutableArray<Policy.V1Beta1.AllowedCSIDriver> @allowedCSIDrivers,
          ImmutableArray<string> @allowedCapabilities,
          ImmutableArray<Policy.V1Beta1.AllowedFlexVolume> @allowedFlexVolumes,
          ImmutableArray<Policy.V1Beta1.AllowedHostPath> @allowedHostPaths,
          ImmutableArray<string> @allowedProcMountTypes,
          ImmutableArray<string> @allowedUnsafeSysctls,
          ImmutableArray<string> @defaultAddCapabilities,
          bool @defaultAllowPrivilegeEscalation,
          ImmutableArray<string> @forbiddenSysctls,
          Policy.V1Beta1.FSGroupStrategyOptions @fsGroup,
          bool @hostIPC,
          bool @hostNetwork,
          bool @hostPID,
          ImmutableArray<Policy.V1Beta1.HostPortRange> @hostPorts,
          bool @privileged,
          bool @readOnlyRootFilesystem,
          ImmutableArray<string> @requiredDropCapabilities,
          Policy.V1Beta1.RunAsGroupStrategyOptions @runAsGroup,
          Policy.V1Beta1.RunAsUserStrategyOptions @runAsUser,
          Policy.V1Beta1.RuntimeClassStrategyOptions @runtimeClass,
          Policy.V1Beta1.SELinuxStrategyOptions @seLinux,
          Policy.V1Beta1.SupplementalGroupsStrategyOptions @supplementalGroups,
          ImmutableArray<string> @volumes)
      {
          this.AllowPrivilegeEscalation = @allowPrivilegeEscalation;
          this.AllowedCSIDrivers = @allowedCSIDrivers;
          this.AllowedCapabilities = @allowedCapabilities;
          this.AllowedFlexVolumes = @allowedFlexVolumes;
          this.AllowedHostPaths = @allowedHostPaths;
          this.AllowedProcMountTypes = @allowedProcMountTypes;
          this.AllowedUnsafeSysctls = @allowedUnsafeSysctls;
          this.DefaultAddCapabilities = @defaultAddCapabilities;
          this.DefaultAllowPrivilegeEscalation = @defaultAllowPrivilegeEscalation;
          this.ForbiddenSysctls = @forbiddenSysctls;
          this.FsGroup = @fsGroup;
          this.HostIPC = @hostIPC;
          this.HostNetwork = @hostNetwork;
          this.HostPID = @hostPID;
          this.HostPorts = @hostPorts;
          this.Privileged = @privileged;
          this.ReadOnlyRootFilesystem = @readOnlyRootFilesystem;
          this.RequiredDropCapabilities = @requiredDropCapabilities;
          this.RunAsGroup = @runAsGroup;
          this.RunAsUser = @runAsUser;
          this.RuntimeClass = @runtimeClass;
          this.SeLinux = @seLinux;
          this.SupplementalGroups = @supplementalGroups;
          this.Volumes = @volumes;
      }

    }
    /// <summary>
    /// RunAsGroupStrategyOptions defines the strategy type and any options used to create the
    /// strategy.
    /// </summary>
    [OutputType]
    public sealed class RunAsGroupStrategyOptions
    {
      /// <summary>
        /// ranges are the allowed ranges of gids that may be used. If you would like to force a
        /// single gid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
      public readonly ImmutableArray<Policy.V1Beta1.IDRange> Ranges;

      /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
        /// </summary>
      public readonly string Rule;

      [OutputConstructor]
      private RunAsGroupStrategyOptions(
          ImmutableArray<Policy.V1Beta1.IDRange> @ranges,
          string @rule)
      {
          this.Ranges = @ranges;
          this.Rule = @rule;
      }

    }
    /// <summary>
    /// RunAsUserStrategyOptions defines the strategy type and any options used to create the
    /// strategy.
    /// </summary>
    [OutputType]
    public sealed class RunAsUserStrategyOptions
    {
      /// <summary>
        /// ranges are the allowed ranges of uids that may be used. If you would like to force a
        /// single uid then supply a single range with the same start and end. Required for
        /// MustRunAs.
        /// </summary>
      public readonly ImmutableArray<Policy.V1Beta1.IDRange> Ranges;

      /// <summary>
        /// rule is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
      public readonly string Rule;

      [OutputConstructor]
      private RunAsUserStrategyOptions(
          ImmutableArray<Policy.V1Beta1.IDRange> @ranges,
          string @rule)
      {
          this.Ranges = @ranges;
          this.Rule = @rule;
      }

    }
    /// <summary>
    /// RuntimeClassStrategyOptions define the strategy that will dictate the allowable
    /// RuntimeClasses for a pod.
    /// </summary>
    [OutputType]
    public sealed class RuntimeClassStrategyOptions
    {
      /// <summary>
        /// allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a
        /// pod. A value of "*" means that any RuntimeClass name is allowed, and must be the only
        /// item in the list. An empty list requires the RuntimeClassName field to be unset.
        /// </summary>
      public readonly ImmutableArray<string> AllowedRuntimeClassNames;

      /// <summary>
        /// defaultRuntimeClassName is the default RuntimeClassName to set on the pod. The default
        /// MUST be allowed by the allowedRuntimeClassNames list. A value of nil does not mutate the
        /// Pod.
        /// </summary>
      public readonly string DefaultRuntimeClassName;

      [OutputConstructor]
      private RuntimeClassStrategyOptions(
          ImmutableArray<string> @allowedRuntimeClassNames,
          string @defaultRuntimeClassName)
      {
          this.AllowedRuntimeClassNames = @allowedRuntimeClassNames;
          this.DefaultRuntimeClassName = @defaultRuntimeClassName;
      }

    }
    /// <summary>
    /// SELinuxStrategyOptions defines the strategy type and any options used to create the
    /// strategy.
    /// </summary>
    [OutputType]
    public sealed class SELinuxStrategyOptions
    {
      /// <summary>
        /// rule is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
      public readonly string Rule;

      /// <summary>
        /// seLinuxOptions required to run as; required for MustRunAs More info:
        /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
      public readonly Core.V1.SELinuxOptions SeLinuxOptions;

      [OutputConstructor]
      private SELinuxStrategyOptions(
          string @rule,
          Core.V1.SELinuxOptions @seLinuxOptions)
      {
          this.Rule = @rule;
          this.SeLinuxOptions = @seLinuxOptions;
      }

    }
    /// <summary>
    /// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the
    /// strategy.
    /// </summary>
    [OutputType]
    public sealed class SupplementalGroupsStrategyOptions
    {
      /// <summary>
        /// ranges are the allowed ranges of supplemental groups.  If you would like to force a
        /// single supplemental group then supply a single range with the same start and end.
        /// Required for MustRunAs.
        /// </summary>
      public readonly ImmutableArray<Policy.V1Beta1.IDRange> Ranges;

      /// <summary>
        /// rule is the strategy that will dictate what supplemental groups is used in the
        /// SecurityContext.
        /// </summary>
      public readonly string Rule;

      [OutputConstructor]
      private SupplementalGroupsStrategyOptions(
          ImmutableArray<Policy.V1Beta1.IDRange> @ranges,
          string @rule)
      {
          this.Ranges = @ranges;
          this.Rule = @rule;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Rbac
{
  namespace V1
  {
    /// <summary>
    /// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
    /// </summary>
    [OutputType]
    public sealed class AggregationRule
    {
      /// <summary>
        /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles
        /// and create the rules. If any of the selectors match, then the ClusterRole's permissions
        /// will be added
        /// </summary>
      public readonly ImmutableArray<Meta.V1.LabelSelector> ClusterRoleSelectors;

      [OutputConstructor]
      private AggregationRule(
          ImmutableArray<Meta.V1.LabelSelector> @clusterRoleSelectors)
      {
          this.ClusterRoleSelectors = @clusterRoleSelectors;
      }

    }
    /// <summary>
    /// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
    /// unit by a RoleBinding or ClusterRoleBinding.
    /// </summary>
    [OutputType]
    public sealed class ClusterRole
    {
      /// <summary>
        /// AggregationRule is an optional field that describes how to build the Rules for this
        /// ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
        /// changes to Rules will be stomped by the controller.
        /// </summary>
      public readonly Rbac.V1.AggregationRule AggregationRule;

      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Rules holds all the PolicyRules for this ClusterRole
        /// </summary>
      public readonly ImmutableArray<Rbac.V1.PolicyRule> Rules;

      [OutputConstructor]
      private ClusterRole(
          Rbac.V1.AggregationRule @aggregationRule,
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<Rbac.V1.PolicyRule> @rules)
      {
          this.AggregationRule = @aggregationRule;
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Rules = @rules;
      }

    }
    /// <summary>
    /// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
    /// ClusterRole in the global namespace, and adds who information via Subject.
    /// </summary>
    [OutputType]
    public sealed class ClusterRoleBinding
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot
        /// be resolved, the Authorizer must return an error.
        /// </summary>
      public readonly Rbac.V1.RoleRef RoleRef;

      /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
      public readonly ImmutableArray<Rbac.V1.Subject> Subjects;

      [OutputConstructor]
      private ClusterRoleBinding(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Rbac.V1.RoleRef @roleRef,
          ImmutableArray<Rbac.V1.Subject> @subjects)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.RoleRef = @roleRef;
          this.Subjects = @subjects;
      }

    }
    /// <summary>
    /// ClusterRoleBindingList is a collection of ClusterRoleBindings
    /// </summary>
    [OutputType]
    public sealed class ClusterRoleBindingList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of ClusterRoleBindings
        /// </summary>
      public readonly ImmutableArray<Rbac.V1.ClusterRoleBinding> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ClusterRoleBindingList(
          string @apiVersion,
          ImmutableArray<Rbac.V1.ClusterRoleBinding> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ClusterRoleList is a collection of ClusterRoles
    /// </summary>
    [OutputType]
    public sealed class ClusterRoleList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of ClusterRoles
        /// </summary>
      public readonly ImmutableArray<Rbac.V1.ClusterRole> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ClusterRoleList(
          string @apiVersion,
          ImmutableArray<Rbac.V1.ClusterRole> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PolicyRule holds information that describes a policy rule, but does not contain information
    /// about who the rule applies to or which namespace the rule applies to.
    /// </summary>
    [OutputType]
    public sealed class PolicyRule
    {
      /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.
        /// </summary>
      public readonly ImmutableArray<string> ApiGroups;

      /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path Since non-resource URLs are not
        /// namespaced, this field is only applicable for ClusterRoles referenced from a
        /// ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or
        /// "secrets") or non-resource URL paths (such as "/api"),  but not both.
        /// </summary>
      public readonly ImmutableArray<string> NonResourceURLs;

      /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.
        /// </summary>
      public readonly ImmutableArray<string> ResourceNames;

      /// <summary>
        /// Resources is a list of resources this rule applies to.  ResourceAll represents all
        /// resources.
        /// </summary>
      public readonly ImmutableArray<string> Resources;

      /// <summary>
        /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
        /// contained in this rule.  VerbAll represents all kinds.
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      [OutputConstructor]
      private PolicyRule(
          ImmutableArray<string> @apiGroups,
          ImmutableArray<string> @nonResourceURLs,
          ImmutableArray<string> @resourceNames,
          ImmutableArray<string> @resources,
          ImmutableArray<string> @verbs)
      {
          this.ApiGroups = @apiGroups;
          this.NonResourceURLs = @nonResourceURLs;
          this.ResourceNames = @resourceNames;
          this.Resources = @resources;
          this.Verbs = @verbs;
      }

    }
    /// <summary>
    /// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
    /// RoleBinding.
    /// </summary>
    [OutputType]
    public sealed class Role
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Rules holds all the PolicyRules for this Role
        /// </summary>
      public readonly ImmutableArray<Rbac.V1.PolicyRule> Rules;

      [OutputConstructor]
      private Role(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<Rbac.V1.PolicyRule> @rules)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Rules = @rules;
      }

    }
    /// <summary>
    /// RoleBinding references a role, but does not contain it.  It can reference a Role in the same
    /// namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
    /// namespace information by which namespace it exists in.  RoleBindings in a given namespace
    /// only have effect in that namespace.
    /// </summary>
    [OutputType]
    public sealed class RoleBinding
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global
        /// namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
        /// </summary>
      public readonly Rbac.V1.RoleRef RoleRef;

      /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
      public readonly ImmutableArray<Rbac.V1.Subject> Subjects;

      [OutputConstructor]
      private RoleBinding(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Rbac.V1.RoleRef @roleRef,
          ImmutableArray<Rbac.V1.Subject> @subjects)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.RoleRef = @roleRef;
          this.Subjects = @subjects;
      }

    }
    /// <summary>
    /// RoleBindingList is a collection of RoleBindings
    /// </summary>
    [OutputType]
    public sealed class RoleBindingList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of RoleBindings
        /// </summary>
      public readonly ImmutableArray<Rbac.V1.RoleBinding> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private RoleBindingList(
          string @apiVersion,
          ImmutableArray<Rbac.V1.RoleBinding> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// RoleList is a collection of Roles
    /// </summary>
    [OutputType]
    public sealed class RoleList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of Roles
        /// </summary>
      public readonly ImmutableArray<Rbac.V1.Role> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private RoleList(
          string @apiVersion,
          ImmutableArray<Rbac.V1.Role> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// RoleRef contains information that points to the role being used
    /// </summary>
    [OutputType]
    public sealed class RoleRef
    {
      /// <summary>
        /// APIGroup is the group for the resource being referenced
        /// </summary>
      public readonly string ApiGroup;

      /// <summary>
        /// Kind is the type of resource being referenced
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private RoleRef(
          string @apiGroup,
          string @kind,
          string @name)
      {
          this.ApiGroup = @apiGroup;
          this.Kind = @kind;
          this.Name = @name;
      }

    }
    /// <summary>
    /// Subject contains a reference to the object or user identities a role binding applies to.
    /// This can either hold a direct API object reference, or a value for non-objects such as user
    /// and group names.
    /// </summary>
    [OutputType]
    public sealed class Subject
    {
      /// <summary>
        /// APIGroup holds the API group of the referenced subject. Defaults to "" for
        /// ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group
        /// subjects.
        /// </summary>
      public readonly string ApiGroup;

      /// <summary>
        /// Kind of object being referenced. Values defined by this API group are "User", "Group",
        /// and "ServiceAccount". If the Authorizer does not recognized the kind value, the
        /// Authorizer should report an error.
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name of the object being referenced.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User"
        /// or "Group", and this value is not empty the Authorizer should report an error.
        /// </summary>
      public readonly string Namespace;

      [OutputConstructor]
      private Subject(
          string @apiGroup,
          string @kind,
          string @name,
          string @namespace)
      {
          this.ApiGroup = @apiGroup;
          this.Kind = @kind;
          this.Name = @name;
          this.Namespace = @namespace;
      }

    }
  }

  namespace V1Alpha1
  {
    /// <summary>
    /// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
    /// </summary>
    [OutputType]
    public sealed class AggregationRule
    {
      /// <summary>
        /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles
        /// and create the rules. If any of the selectors match, then the ClusterRole's permissions
        /// will be added
        /// </summary>
      public readonly ImmutableArray<Meta.V1.LabelSelector> ClusterRoleSelectors;

      [OutputConstructor]
      private AggregationRule(
          ImmutableArray<Meta.V1.LabelSelector> @clusterRoleSelectors)
      {
          this.ClusterRoleSelectors = @clusterRoleSelectors;
      }

    }
    /// <summary>
    /// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
    /// unit by a RoleBinding or ClusterRoleBinding. Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 ClusterRole, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class ClusterRole
    {
      /// <summary>
        /// AggregationRule is an optional field that describes how to build the Rules for this
        /// ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
        /// changes to Rules will be stomped by the controller.
        /// </summary>
      public readonly Rbac.V1Alpha1.AggregationRule AggregationRule;

      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Rules holds all the PolicyRules for this ClusterRole
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Alpha1.PolicyRule> Rules;

      [OutputConstructor]
      private ClusterRole(
          Rbac.V1Alpha1.AggregationRule @aggregationRule,
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<Rbac.V1Alpha1.PolicyRule> @rules)
      {
          this.AggregationRule = @aggregationRule;
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Rules = @rules;
      }

    }
    /// <summary>
    /// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
    /// ClusterRole in the global namespace, and adds who information via Subject. Deprecated in
    /// v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRoleBinding, and will no longer be
    /// served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class ClusterRoleBinding
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot
        /// be resolved, the Authorizer must return an error.
        /// </summary>
      public readonly Rbac.V1Alpha1.RoleRef RoleRef;

      /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Alpha1.Subject> Subjects;

      [OutputConstructor]
      private ClusterRoleBinding(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Rbac.V1Alpha1.RoleRef @roleRef,
          ImmutableArray<Rbac.V1Alpha1.Subject> @subjects)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.RoleRef = @roleRef;
          this.Subjects = @subjects;
      }

    }
    /// <summary>
    /// ClusterRoleBindingList is a collection of ClusterRoleBindings. Deprecated in v1.17 in favor
    /// of rbac.authorization.k8s.io/v1 ClusterRoleBindings, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class ClusterRoleBindingList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of ClusterRoleBindings
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Alpha1.ClusterRoleBinding> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ClusterRoleBindingList(
          string @apiVersion,
          ImmutableArray<Rbac.V1Alpha1.ClusterRoleBinding> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ClusterRoleList is a collection of ClusterRoles. Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 ClusterRoles, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class ClusterRoleList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of ClusterRoles
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Alpha1.ClusterRole> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ClusterRoleList(
          string @apiVersion,
          ImmutableArray<Rbac.V1Alpha1.ClusterRole> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PolicyRule holds information that describes a policy rule, but does not contain information
    /// about who the rule applies to or which namespace the rule applies to.
    /// </summary>
    [OutputType]
    public sealed class PolicyRule
    {
      /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.
        /// </summary>
      public readonly ImmutableArray<string> ApiGroups;

      /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path This name is intentionally
        /// different than the internal type so that the DefaultConvert works nicely and because the
        /// ordering may be different. Since non-resource URLs are not namespaced, this field is
        /// only applicable for ClusterRoles referenced from a ClusterRoleBinding. Rules can either
        /// apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as
        /// "/api"),  but not both.
        /// </summary>
      public readonly ImmutableArray<string> NonResourceURLs;

      /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.
        /// </summary>
      public readonly ImmutableArray<string> ResourceNames;

      /// <summary>
        /// Resources is a list of resources this rule applies to.  ResourceAll represents all
        /// resources.
        /// </summary>
      public readonly ImmutableArray<string> Resources;

      /// <summary>
        /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
        /// contained in this rule.  VerbAll represents all kinds.
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      [OutputConstructor]
      private PolicyRule(
          ImmutableArray<string> @apiGroups,
          ImmutableArray<string> @nonResourceURLs,
          ImmutableArray<string> @resourceNames,
          ImmutableArray<string> @resources,
          ImmutableArray<string> @verbs)
      {
          this.ApiGroups = @apiGroups;
          this.NonResourceURLs = @nonResourceURLs;
          this.ResourceNames = @resourceNames;
          this.Resources = @resources;
          this.Verbs = @verbs;
      }

    }
    /// <summary>
    /// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
    /// RoleBinding. Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 Role, and will no
    /// longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class Role
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Rules holds all the PolicyRules for this Role
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Alpha1.PolicyRule> Rules;

      [OutputConstructor]
      private Role(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<Rbac.V1Alpha1.PolicyRule> @rules)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Rules = @rules;
      }

    }
    /// <summary>
    /// RoleBinding references a role, but does not contain it.  It can reference a Role in the same
    /// namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
    /// namespace information by which namespace it exists in.  RoleBindings in a given namespace
    /// only have effect in that namespace. Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 RoleBinding, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class RoleBinding
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global
        /// namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
        /// </summary>
      public readonly Rbac.V1Alpha1.RoleRef RoleRef;

      /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Alpha1.Subject> Subjects;

      [OutputConstructor]
      private RoleBinding(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Rbac.V1Alpha1.RoleRef @roleRef,
          ImmutableArray<Rbac.V1Alpha1.Subject> @subjects)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.RoleRef = @roleRef;
          this.Subjects = @subjects;
      }

    }
    /// <summary>
    /// RoleBindingList is a collection of RoleBindings Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 RoleBindingList, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class RoleBindingList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of RoleBindings
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Alpha1.RoleBinding> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private RoleBindingList(
          string @apiVersion,
          ImmutableArray<Rbac.V1Alpha1.RoleBinding> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// RoleList is a collection of Roles. Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 RoleList, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class RoleList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of Roles
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Alpha1.Role> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private RoleList(
          string @apiVersion,
          ImmutableArray<Rbac.V1Alpha1.Role> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// RoleRef contains information that points to the role being used
    /// </summary>
    [OutputType]
    public sealed class RoleRef
    {
      /// <summary>
        /// APIGroup is the group for the resource being referenced
        /// </summary>
      public readonly string ApiGroup;

      /// <summary>
        /// Kind is the type of resource being referenced
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private RoleRef(
          string @apiGroup,
          string @kind,
          string @name)
      {
          this.ApiGroup = @apiGroup;
          this.Kind = @kind;
          this.Name = @name;
      }

    }
    /// <summary>
    /// Subject contains a reference to the object or user identities a role binding applies to.
    /// This can either hold a direct API object reference, or a value for non-objects such as user
    /// and group names.
    /// </summary>
    [OutputType]
    public sealed class Subject
    {
      /// <summary>
        /// APIVersion holds the API group and version of the referenced subject. Defaults to "v1"
        /// for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io/v1alpha1" for User
        /// and Group subjects.
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind of object being referenced. Values defined by this API group are "User", "Group",
        /// and "ServiceAccount". If the Authorizer does not recognized the kind value, the
        /// Authorizer should report an error.
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name of the object being referenced.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User"
        /// or "Group", and this value is not empty the Authorizer should report an error.
        /// </summary>
      public readonly string Namespace;

      [OutputConstructor]
      private Subject(
          string @apiVersion,
          string @kind,
          string @name,
          string @namespace)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Name = @name;
          this.Namespace = @namespace;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
    /// </summary>
    [OutputType]
    public sealed class AggregationRule
    {
      /// <summary>
        /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles
        /// and create the rules. If any of the selectors match, then the ClusterRole's permissions
        /// will be added
        /// </summary>
      public readonly ImmutableArray<Meta.V1.LabelSelector> ClusterRoleSelectors;

      [OutputConstructor]
      private AggregationRule(
          ImmutableArray<Meta.V1.LabelSelector> @clusterRoleSelectors)
      {
          this.ClusterRoleSelectors = @clusterRoleSelectors;
      }

    }
    /// <summary>
    /// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
    /// unit by a RoleBinding or ClusterRoleBinding. Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 ClusterRole, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class ClusterRole
    {
      /// <summary>
        /// AggregationRule is an optional field that describes how to build the Rules for this
        /// ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
        /// changes to Rules will be stomped by the controller.
        /// </summary>
      public readonly Rbac.V1Beta1.AggregationRule AggregationRule;

      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Rules holds all the PolicyRules for this ClusterRole
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Beta1.PolicyRule> Rules;

      [OutputConstructor]
      private ClusterRole(
          Rbac.V1Beta1.AggregationRule @aggregationRule,
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<Rbac.V1Beta1.PolicyRule> @rules)
      {
          this.AggregationRule = @aggregationRule;
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Rules = @rules;
      }

    }
    /// <summary>
    /// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
    /// ClusterRole in the global namespace, and adds who information via Subject. Deprecated in
    /// v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRoleBinding, and will no longer be
    /// served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class ClusterRoleBinding
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot
        /// be resolved, the Authorizer must return an error.
        /// </summary>
      public readonly Rbac.V1Beta1.RoleRef RoleRef;

      /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Beta1.Subject> Subjects;

      [OutputConstructor]
      private ClusterRoleBinding(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Rbac.V1Beta1.RoleRef @roleRef,
          ImmutableArray<Rbac.V1Beta1.Subject> @subjects)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.RoleRef = @roleRef;
          this.Subjects = @subjects;
      }

    }
    /// <summary>
    /// ClusterRoleBindingList is a collection of ClusterRoleBindings. Deprecated in v1.17 in favor
    /// of rbac.authorization.k8s.io/v1 ClusterRoleBindingList, and will no longer be served in
    /// v1.20.
    /// </summary>
    [OutputType]
    public sealed class ClusterRoleBindingList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of ClusterRoleBindings
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Beta1.ClusterRoleBinding> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ClusterRoleBindingList(
          string @apiVersion,
          ImmutableArray<Rbac.V1Beta1.ClusterRoleBinding> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// ClusterRoleList is a collection of ClusterRoles. Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 ClusterRoles, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class ClusterRoleList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of ClusterRoles
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Beta1.ClusterRole> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private ClusterRoleList(
          string @apiVersion,
          ImmutableArray<Rbac.V1Beta1.ClusterRole> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PolicyRule holds information that describes a policy rule, but does not contain information
    /// about who the rule applies to or which namespace the rule applies to.
    /// </summary>
    [OutputType]
    public sealed class PolicyRule
    {
      /// <summary>
        /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API
        /// groups are specified, any action requested against one of the enumerated resources in
        /// any API group will be allowed.
        /// </summary>
      public readonly ImmutableArray<string> ApiGroups;

      /// <summary>
        /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are
        /// allowed, but only as the full, final step in the path Since non-resource URLs are not
        /// namespaced, this field is only applicable for ClusterRoles referenced from a
        /// ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or
        /// "secrets") or non-resource URL paths (such as "/api"),  but not both.
        /// </summary>
      public readonly ImmutableArray<string> NonResourceURLs;

      /// <summary>
        /// ResourceNames is an optional white list of names that the rule applies to.  An empty set
        /// means that everything is allowed.
        /// </summary>
      public readonly ImmutableArray<string> ResourceNames;

      /// <summary>
        /// Resources is a list of resources this rule applies to.  '*' represents all resources in
        /// the specified apiGroups. '*/foo' represents the subresource 'foo' for all resources in
        /// the specified apiGroups.
        /// </summary>
      public readonly ImmutableArray<string> Resources;

      /// <summary>
        /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
        /// contained in this rule.  VerbAll represents all kinds.
        /// </summary>
      public readonly ImmutableArray<string> Verbs;

      [OutputConstructor]
      private PolicyRule(
          ImmutableArray<string> @apiGroups,
          ImmutableArray<string> @nonResourceURLs,
          ImmutableArray<string> @resourceNames,
          ImmutableArray<string> @resources,
          ImmutableArray<string> @verbs)
      {
          this.ApiGroups = @apiGroups;
          this.NonResourceURLs = @nonResourceURLs;
          this.ResourceNames = @resourceNames;
          this.Resources = @resources;
          this.Verbs = @verbs;
      }

    }
    /// <summary>
    /// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
    /// RoleBinding. Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 Role, and will no
    /// longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class Role
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Rules holds all the PolicyRules for this Role
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Beta1.PolicyRule> Rules;

      [OutputConstructor]
      private Role(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<Rbac.V1Beta1.PolicyRule> @rules)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Rules = @rules;
      }

    }
    /// <summary>
    /// RoleBinding references a role, but does not contain it.  It can reference a Role in the same
    /// namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
    /// namespace information by which namespace it exists in.  RoleBindings in a given namespace
    /// only have effect in that namespace. Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 RoleBinding, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class RoleBinding
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global
        /// namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
        /// </summary>
      public readonly Rbac.V1Beta1.RoleRef RoleRef;

      /// <summary>
        /// Subjects holds references to the objects the role applies to.
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Beta1.Subject> Subjects;

      [OutputConstructor]
      private RoleBinding(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Rbac.V1Beta1.RoleRef @roleRef,
          ImmutableArray<Rbac.V1Beta1.Subject> @subjects)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.RoleRef = @roleRef;
          this.Subjects = @subjects;
      }

    }
    /// <summary>
    /// RoleBindingList is a collection of RoleBindings Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 RoleBindingList, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class RoleBindingList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of RoleBindings
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Beta1.RoleBinding> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private RoleBindingList(
          string @apiVersion,
          ImmutableArray<Rbac.V1Beta1.RoleBinding> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// RoleList is a collection of Roles Deprecated in v1.17 in favor of
    /// rbac.authorization.k8s.io/v1 RoleList, and will no longer be served in v1.20.
    /// </summary>
    [OutputType]
    public sealed class RoleList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of Roles
        /// </summary>
      public readonly ImmutableArray<Rbac.V1Beta1.Role> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata.
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private RoleList(
          string @apiVersion,
          ImmutableArray<Rbac.V1Beta1.Role> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// RoleRef contains information that points to the role being used
    /// </summary>
    [OutputType]
    public sealed class RoleRef
    {
      /// <summary>
        /// APIGroup is the group for the resource being referenced
        /// </summary>
      public readonly string ApiGroup;

      /// <summary>
        /// Kind is the type of resource being referenced
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
      public readonly string Name;

      [OutputConstructor]
      private RoleRef(
          string @apiGroup,
          string @kind,
          string @name)
      {
          this.ApiGroup = @apiGroup;
          this.Kind = @kind;
          this.Name = @name;
      }

    }
    /// <summary>
    /// Subject contains a reference to the object or user identities a role binding applies to.
    /// This can either hold a direct API object reference, or a value for non-objects such as user
    /// and group names.
    /// </summary>
    [OutputType]
    public sealed class Subject
    {
      /// <summary>
        /// APIGroup holds the API group of the referenced subject. Defaults to "" for
        /// ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group
        /// subjects.
        /// </summary>
      public readonly string ApiGroup;

      /// <summary>
        /// Kind of object being referenced. Values defined by this API group are "User", "Group",
        /// and "ServiceAccount". If the Authorizer does not recognized the kind value, the
        /// Authorizer should report an error.
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Name of the object being referenced.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User"
        /// or "Group", and this value is not empty the Authorizer should report an error.
        /// </summary>
      public readonly string Namespace;

      [OutputConstructor]
      private Subject(
          string @apiGroup,
          string @kind,
          string @name,
          string @namespace)
      {
          this.ApiGroup = @apiGroup;
          this.Kind = @kind;
          this.Name = @name;
          this.Namespace = @namespace;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Scheduling
{
  namespace V1
  {
    /// <summary>
    /// PriorityClass defines mapping from a priority class name to the priority integer value. The
    /// value can be any valid integer.
    /// </summary>
    [OutputType]
    public sealed class PriorityClass
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// description is an arbitrary string that usually provides guidelines on when this
        /// priority class should be used.
        /// </summary>
      public readonly string Description;

      /// <summary>
        /// globalDefault specifies whether this PriorityClass should be considered as the default
        /// priority for pods that do not have any priority class. Only one PriorityClass can be
        /// marked as `globalDefault`. However, if more than one PriorityClasses exists with their
        /// `globalDefault` field set to true, the smallest value of such global default
        /// PriorityClasses will be used as the default priority.
        /// </summary>
      public readonly bool GlobalDefault;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
      public readonly string PreemptionPolicy;

      /// <summary>
        /// The value of this priority class. This is the actual priority that pods receive when
        /// they have the name of this class in their pod spec.
        /// </summary>
      public readonly int Value;

      [OutputConstructor]
      private PriorityClass(
          string @apiVersion,
          string @description,
          bool @globalDefault,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          string @preemptionPolicy,
          int @value)
      {
          this.ApiVersion = @apiVersion;
          this.Description = @description;
          this.GlobalDefault = @globalDefault;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.PreemptionPolicy = @preemptionPolicy;
          this.Value = @value;
      }

    }
    /// <summary>
    /// PriorityClassList is a collection of priority classes.
    /// </summary>
    [OutputType]
    public sealed class PriorityClassList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of PriorityClasses
        /// </summary>
      public readonly ImmutableArray<Scheduling.V1.PriorityClass> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PriorityClassList(
          string @apiVersion,
          ImmutableArray<Scheduling.V1.PriorityClass> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
  }

  namespace V1Alpha1
  {
    /// <summary>
    /// DEPRECATED - This group version of PriorityClass is deprecated by
    /// scheduling.k8s.io/v1/PriorityClass. PriorityClass defines mapping from a priority class name
    /// to the priority integer value. The value can be any valid integer.
    /// </summary>
    [OutputType]
    public sealed class PriorityClass
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// description is an arbitrary string that usually provides guidelines on when this
        /// priority class should be used.
        /// </summary>
      public readonly string Description;

      /// <summary>
        /// globalDefault specifies whether this PriorityClass should be considered as the default
        /// priority for pods that do not have any priority class. Only one PriorityClass can be
        /// marked as `globalDefault`. However, if more than one PriorityClasses exists with their
        /// `globalDefault` field set to true, the smallest value of such global default
        /// PriorityClasses will be used as the default priority.
        /// </summary>
      public readonly bool GlobalDefault;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
      public readonly string PreemptionPolicy;

      /// <summary>
        /// The value of this priority class. This is the actual priority that pods receive when
        /// they have the name of this class in their pod spec.
        /// </summary>
      public readonly int Value;

      [OutputConstructor]
      private PriorityClass(
          string @apiVersion,
          string @description,
          bool @globalDefault,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          string @preemptionPolicy,
          int @value)
      {
          this.ApiVersion = @apiVersion;
          this.Description = @description;
          this.GlobalDefault = @globalDefault;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.PreemptionPolicy = @preemptionPolicy;
          this.Value = @value;
      }

    }
    /// <summary>
    /// PriorityClassList is a collection of priority classes.
    /// </summary>
    [OutputType]
    public sealed class PriorityClassList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of PriorityClasses
        /// </summary>
      public readonly ImmutableArray<Scheduling.V1Alpha1.PriorityClass> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PriorityClassList(
          string @apiVersion,
          ImmutableArray<Scheduling.V1Alpha1.PriorityClass> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// DEPRECATED - This group version of PriorityClass is deprecated by
    /// scheduling.k8s.io/v1/PriorityClass. PriorityClass defines mapping from a priority class name
    /// to the priority integer value. The value can be any valid integer.
    /// </summary>
    [OutputType]
    public sealed class PriorityClass
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// description is an arbitrary string that usually provides guidelines on when this
        /// priority class should be used.
        /// </summary>
      public readonly string Description;

      /// <summary>
        /// globalDefault specifies whether this PriorityClass should be considered as the default
        /// priority for pods that do not have any priority class. Only one PriorityClass can be
        /// marked as `globalDefault`. However, if more than one PriorityClasses exists with their
        /// `globalDefault` field set to true, the smallest value of such global default
        /// PriorityClasses will be used as the default priority.
        /// </summary>
      public readonly bool GlobalDefault;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
        /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is
        /// alpha-level and is only honored by servers that enable the NonPreemptingPriority
        /// feature.
        /// </summary>
      public readonly string PreemptionPolicy;

      /// <summary>
        /// The value of this priority class. This is the actual priority that pods receive when
        /// they have the name of this class in their pod spec.
        /// </summary>
      public readonly int Value;

      [OutputConstructor]
      private PriorityClass(
          string @apiVersion,
          string @description,
          bool @globalDefault,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          string @preemptionPolicy,
          int @value)
      {
          this.ApiVersion = @apiVersion;
          this.Description = @description;
          this.GlobalDefault = @globalDefault;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.PreemptionPolicy = @preemptionPolicy;
          this.Value = @value;
      }

    }
    /// <summary>
    /// PriorityClassList is a collection of priority classes.
    /// </summary>
    [OutputType]
    public sealed class PriorityClassList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of PriorityClasses
        /// </summary>
      public readonly ImmutableArray<Scheduling.V1Beta1.PriorityClass> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PriorityClassList(
          string @apiVersion,
          ImmutableArray<Scheduling.V1Beta1.PriorityClass> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Settings
{
  namespace V1Alpha1
  {
    /// <summary>
    /// PodPreset is a policy resource that defines additional runtime requirements for a Pod.
    /// </summary>
    [OutputType]
    public sealed class PodPreset
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      
      public readonly Meta.V1.ObjectMeta Metadata;

      
      public readonly Settings.V1Alpha1.PodPresetSpec Spec;

      [OutputConstructor]
      private PodPreset(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Settings.V1Alpha1.PodPresetSpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// PodPresetList is a list of PodPreset objects.
    /// </summary>
    [OutputType]
    public sealed class PodPresetList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is a list of schema objects.
        /// </summary>
      public readonly ImmutableArray<Settings.V1Alpha1.PodPreset> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private PodPresetList(
          string @apiVersion,
          ImmutableArray<Settings.V1Alpha1.PodPreset> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// PodPresetSpec is a description of a pod preset.
    /// </summary>
    [OutputType]
    public sealed class PodPresetSpec
    {
      /// <summary>
        /// Env defines the collection of EnvVar to inject into containers.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EnvVar> Env;

      /// <summary>
        /// EnvFrom defines the collection of EnvFromSource to inject into containers.
        /// </summary>
      public readonly ImmutableArray<Core.V1.EnvFromSource> EnvFrom;

      /// <summary>
        /// Selector is a label query over a set of resources, in this case pods. Required.
        /// </summary>
      public readonly Meta.V1.LabelSelector Selector;

      /// <summary>
        /// VolumeMounts defines the collection of VolumeMount to inject into containers.
        /// </summary>
      public readonly ImmutableArray<Core.V1.VolumeMount> VolumeMounts;

      /// <summary>
        /// Volumes defines the collection of Volume to inject into the pod.
        /// </summary>
      public readonly ImmutableArray<Core.V1.Volume> Volumes;

      [OutputConstructor]
      private PodPresetSpec(
          ImmutableArray<Core.V1.EnvVar> @env,
          ImmutableArray<Core.V1.EnvFromSource> @envFrom,
          Meta.V1.LabelSelector @selector,
          ImmutableArray<Core.V1.VolumeMount> @volumeMounts,
          ImmutableArray<Core.V1.Volume> @volumes)
      {
          this.Env = @env;
          this.EnvFrom = @envFrom;
          this.Selector = @selector;
          this.VolumeMounts = @volumeMounts;
          this.Volumes = @volumes;
      }

    }
  }

}

namespace Pulumi.Kubernetes.Types.Outputs.Storage
{
  namespace V1
  {
    /// <summary>
    /// CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need
    /// to create the CSINode object directly. As long as they use the node-driver-registrar sidecar
    /// container, the kubelet will automatically populate the CSINode object for the CSI driver as
    /// part of kubelet plugin registration. CSINode has the same name as a node. If the object is
    /// missing, it means either there are no CSI Drivers available on the node, or the Kubelet
    /// version is low enough that it doesn't create this object. CSINode has an OwnerReference that
    /// points to the corresponding node object.
    /// </summary>
    [OutputType]
    public sealed class CSINode
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// metadata.name must be the Kubernetes node name.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// spec is the specification of CSINode
        /// </summary>
      public readonly Storage.V1.CSINodeSpec Spec;

      [OutputConstructor]
      private CSINode(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Storage.V1.CSINodeSpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// CSINodeDriver holds information about the specification of one CSI driver installed on a
    /// node
    /// </summary>
    [OutputType]
    public sealed class CSINodeDriver
    {
      /// <summary>
        /// allocatable represents the volume resources of a node that are available for scheduling.
        /// This field is beta.
        /// </summary>
      public readonly Storage.V1.VolumeNodeResources Allocatable;

      /// <summary>
        /// This is the name of the CSI driver that this object refers to. This MUST be the same
        /// name returned by the CSI GetPluginName() call for that driver.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// nodeID of the node from the driver point of view. This field enables Kubernetes to
        /// communicate with storage systems that do not share the same nomenclature for nodes. For
        /// example, Kubernetes may refer to a given node as "node1", but the storage system may
        /// refer to the same node as "nodeA". When Kubernetes issues a command to the storage
        /// system to attach a volume to a specific node, it can use this field to refer to the node
        /// name using the ID that the storage system will understand, e.g. "nodeA" instead of
        /// "node1". This field is required.
        /// </summary>
      public readonly string NodeID;

      /// <summary>
        /// topologyKeys is the list of keys supported by the driver. When a driver is initialized
        /// on a cluster, it provides a set of topology keys that it understands (e.g.
        /// "company.com/zone", "company.com/region"). When a driver is initialized on a node, it
        /// provides the same topology keys along with values. Kubelet will expose these topology
        /// keys as labels on its own node object. When Kubernetes does topology aware provisioning,
        /// it can use this list to determine which labels it should retrieve from the node object
        /// and pass back to the driver. It is possible for different nodes to use different
        /// topology keys. This can be empty if driver does not support topology.
        /// </summary>
      public readonly ImmutableArray<string> TopologyKeys;

      [OutputConstructor]
      private CSINodeDriver(
          Storage.V1.VolumeNodeResources @allocatable,
          string @name,
          string @nodeID,
          ImmutableArray<string> @topologyKeys)
      {
          this.Allocatable = @allocatable;
          this.Name = @name;
          this.NodeID = @nodeID;
          this.TopologyKeys = @topologyKeys;
      }

    }
    /// <summary>
    /// CSINodeList is a collection of CSINode objects.
    /// </summary>
    [OutputType]
    public sealed class CSINodeList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of CSINode
        /// </summary>
      public readonly ImmutableArray<Storage.V1.CSINode> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private CSINodeList(
          string @apiVersion,
          ImmutableArray<Storage.V1.CSINode> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// CSINodeSpec holds information about the specification of all CSI drivers installed on a node
    /// </summary>
    [OutputType]
    public sealed class CSINodeSpec
    {
      /// <summary>
        /// drivers is a list of information of all CSI Drivers existing on a node. If all drivers
        /// in the list are uninstalled, this can become empty.
        /// </summary>
      public readonly ImmutableArray<Storage.V1.CSINodeDriver> Drivers;

      [OutputConstructor]
      private CSINodeSpec(
          ImmutableArray<Storage.V1.CSINodeDriver> @drivers)
      {
          this.Drivers = @drivers;
      }

    }
    /// <summary>
    /// StorageClass describes the parameters for a class of storage for which PersistentVolumes can
    /// be dynamically provisioned.
    /// 
    /// StorageClasses are non-namespaced; the name of the storage class according to etcd is in
    /// ObjectMeta.Name.
    /// </summary>
    [OutputType]
    public sealed class StorageClass
    {
      /// <summary>
        /// AllowVolumeExpansion shows whether the storage class allow volume expand
        /// </summary>
      public readonly bool AllowVolumeExpansion;

      /// <summary>
        /// Restrict the node topologies where volumes can be dynamically provisioned. Each volume
        /// plugin defines its own supported topology specifications. An empty TopologySelectorTerm
        /// list means there is no topology restriction. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
      public readonly ImmutableArray<Core.V1.TopologySelectorTerm> AllowedTopologies;

      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with these
        /// mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if
        /// one is invalid.
        /// </summary>
      public readonly ImmutableArray<string> MountOptions;

      /// <summary>
        /// Parameters holds the parameters for the provisioner that should create volumes of this
        /// storage class.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Parameters;

      /// <summary>
        /// Provisioner indicates the type of the provisioner.
        /// </summary>
      public readonly string Provisioner;

      /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with this
        /// reclaimPolicy. Defaults to Delete.
        /// </summary>
      public readonly string ReclaimPolicy;

      /// <summary>
        /// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.
        /// When unset, VolumeBindingImmediate is used. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
      public readonly string VolumeBindingMode;

      [OutputConstructor]
      private StorageClass(
          bool @allowVolumeExpansion,
          ImmutableArray<Core.V1.TopologySelectorTerm> @allowedTopologies,
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<string> @mountOptions,
          ImmutableDictionary<string, string> @parameters,
          string @provisioner,
          string @reclaimPolicy,
          string @volumeBindingMode)
      {
          this.AllowVolumeExpansion = @allowVolumeExpansion;
          this.AllowedTopologies = @allowedTopologies;
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.MountOptions = @mountOptions;
          this.Parameters = @parameters;
          this.Provisioner = @provisioner;
          this.ReclaimPolicy = @reclaimPolicy;
          this.VolumeBindingMode = @volumeBindingMode;
      }

    }
    /// <summary>
    /// StorageClassList is a collection of storage classes.
    /// </summary>
    [OutputType]
    public sealed class StorageClassList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of StorageClasses
        /// </summary>
      public readonly ImmutableArray<Storage.V1.StorageClass> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private StorageClassList(
          string @apiVersion,
          ImmutableArray<Storage.V1.StorageClass> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// VolumeAttachment captures the intent to attach or detach the specified volume to/from the
    /// specified node.
    /// 
    /// VolumeAttachment objects are non-namespaced.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachment
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
        /// system.
        /// </summary>
      public readonly Storage.V1.VolumeAttachmentSpec Spec;

      /// <summary>
        /// Status of the VolumeAttachment request. Populated by the entity completing the attach or
        /// detach operation, i.e. the external-attacher.
        /// </summary>
      public readonly Storage.V1.VolumeAttachmentStatus Status;

      [OutputConstructor]
      private VolumeAttachment(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Storage.V1.VolumeAttachmentSpec @spec,
          Storage.V1.VolumeAttachmentStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// VolumeAttachmentList is a collection of VolumeAttachment objects.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of VolumeAttachments
        /// </summary>
      public readonly ImmutableArray<Storage.V1.VolumeAttachment> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private VolumeAttachmentList(
          string @apiVersion,
          ImmutableArray<Storage.V1.VolumeAttachment> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// VolumeAttachmentSource represents a volume that should be attached. Right now only
    /// PersistenVolumes can be attached via external attacher, in future we may allow also inline
    /// volumes in pods. Exactly one member can be set.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentSource
    {
      /// <summary>
        /// inlineVolumeSpec contains all the information necessary to attach a persistent volume
        /// defined by a pod's inline VolumeSource. This field is populated only for the
        /// CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to
        /// a PersistentVolumeSpec. This field is alpha-level and is only honored by servers that
        /// enabled the CSIMigration feature.
        /// </summary>
      public readonly Core.V1.PersistentVolumeSpec InlineVolumeSpec;

      /// <summary>
        /// Name of the persistent volume to attach.
        /// </summary>
      public readonly string PersistentVolumeName;

      [OutputConstructor]
      private VolumeAttachmentSource(
          Core.V1.PersistentVolumeSpec @inlineVolumeSpec,
          string @persistentVolumeName)
      {
          this.InlineVolumeSpec = @inlineVolumeSpec;
          this.PersistentVolumeName = @persistentVolumeName;
      }

    }
    /// <summary>
    /// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentSpec
    {
      /// <summary>
        /// Attacher indicates the name of the volume driver that MUST handle this request. This is
        /// the name returned by GetPluginName().
        /// </summary>
      public readonly string Attacher;

      /// <summary>
        /// The node that the volume should be attached to.
        /// </summary>
      public readonly string NodeName;

      /// <summary>
        /// Source represents the volume that should be attached.
        /// </summary>
      public readonly Storage.V1.VolumeAttachmentSource Source;

      [OutputConstructor]
      private VolumeAttachmentSpec(
          string @attacher,
          string @nodeName,
          Storage.V1.VolumeAttachmentSource @source)
      {
          this.Attacher = @attacher;
          this.NodeName = @nodeName;
          this.Source = @source;
      }

    }
    /// <summary>
    /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentStatus
    {
      /// <summary>
        /// The last error encountered during attach operation, if any. This field must only be set
        /// by the entity completing the attach operation, i.e. the external-attacher.
        /// </summary>
      public readonly Storage.V1.VolumeError AttachError;

      /// <summary>
        /// Indicates the volume is successfully attached. This field must only be set by the entity
        /// completing the attach operation, i.e. the external-attacher.
        /// </summary>
      public readonly bool Attached;

      /// <summary>
        /// Upon successful attach, this field is populated with any information returned by the
        /// attach operation that must be passed into subsequent WaitForAttach or Mount calls. This
        /// field must only be set by the entity completing the attach operation, i.e. the
        /// external-attacher.
        /// </summary>
      public readonly ImmutableDictionary<string, string> AttachmentMetadata;

      /// <summary>
        /// The last error encountered during detach operation, if any. This field must only be set
        /// by the entity completing the detach operation, i.e. the external-attacher.
        /// </summary>
      public readonly Storage.V1.VolumeError DetachError;

      [OutputConstructor]
      private VolumeAttachmentStatus(
          Storage.V1.VolumeError @attachError,
          bool @attached,
          ImmutableDictionary<string, string> @attachmentMetadata,
          Storage.V1.VolumeError @detachError)
      {
          this.AttachError = @attachError;
          this.Attached = @attached;
          this.AttachmentMetadata = @attachmentMetadata;
          this.DetachError = @detachError;
      }

    }
    /// <summary>
    /// VolumeError captures an error encountered during a volume operation.
    /// </summary>
    [OutputType]
    public sealed class VolumeError
    {
      /// <summary>
        /// String detailing the error encountered during Attach or Detach operation. This string
        /// may be logged, so it should not contain sensitive information.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Time the error was encountered.
        /// </summary>
      public readonly string Time;

      [OutputConstructor]
      private VolumeError(
          string @message,
          string @time)
      {
          this.Message = @message;
          this.Time = @time;
      }

    }
    /// <summary>
    /// VolumeNodeResources is a set of resource limits for scheduling of volumes.
    /// </summary>
    [OutputType]
    public sealed class VolumeNodeResources
    {
      /// <summary>
        /// Maximum number of unique volumes managed by the CSI driver that can be used on a node. A
        /// volume that is both attached and mounted on a node is considered to be used once, not
        /// twice. The same rule applies for a unique volume that is shared among multiple pods on
        /// the same node. If this field is not specified, then the supported number of volumes on
        /// this node is unbounded.
        /// </summary>
      public readonly int Count;

      [OutputConstructor]
      private VolumeNodeResources(
          int @count)
      {
          this.Count = @count;
      }

    }
  }

  namespace V1Alpha1
  {
    /// <summary>
    /// VolumeAttachment captures the intent to attach or detach the specified volume to/from the
    /// specified node.
    /// 
    /// VolumeAttachment objects are non-namespaced.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachment
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
        /// system.
        /// </summary>
      public readonly Storage.V1Alpha1.VolumeAttachmentSpec Spec;

      /// <summary>
        /// Status of the VolumeAttachment request. Populated by the entity completing the attach or
        /// detach operation, i.e. the external-attacher.
        /// </summary>
      public readonly Storage.V1Alpha1.VolumeAttachmentStatus Status;

      [OutputConstructor]
      private VolumeAttachment(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Storage.V1Alpha1.VolumeAttachmentSpec @spec,
          Storage.V1Alpha1.VolumeAttachmentStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// VolumeAttachmentList is a collection of VolumeAttachment objects.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of VolumeAttachments
        /// </summary>
      public readonly ImmutableArray<Storage.V1Alpha1.VolumeAttachment> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private VolumeAttachmentList(
          string @apiVersion,
          ImmutableArray<Storage.V1Alpha1.VolumeAttachment> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// VolumeAttachmentSource represents a volume that should be attached. Right now only
    /// PersistenVolumes can be attached via external attacher, in future we may allow also inline
    /// volumes in pods. Exactly one member can be set.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentSource
    {
      /// <summary>
        /// inlineVolumeSpec contains all the information necessary to attach a persistent volume
        /// defined by a pod's inline VolumeSource. This field is populated only for the
        /// CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to
        /// a PersistentVolumeSpec. This field is alpha-level and is only honored by servers that
        /// enabled the CSIMigration feature.
        /// </summary>
      public readonly Core.V1.PersistentVolumeSpec InlineVolumeSpec;

      /// <summary>
        /// Name of the persistent volume to attach.
        /// </summary>
      public readonly string PersistentVolumeName;

      [OutputConstructor]
      private VolumeAttachmentSource(
          Core.V1.PersistentVolumeSpec @inlineVolumeSpec,
          string @persistentVolumeName)
      {
          this.InlineVolumeSpec = @inlineVolumeSpec;
          this.PersistentVolumeName = @persistentVolumeName;
      }

    }
    /// <summary>
    /// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentSpec
    {
      /// <summary>
        /// Attacher indicates the name of the volume driver that MUST handle this request. This is
        /// the name returned by GetPluginName().
        /// </summary>
      public readonly string Attacher;

      /// <summary>
        /// The node that the volume should be attached to.
        /// </summary>
      public readonly string NodeName;

      /// <summary>
        /// Source represents the volume that should be attached.
        /// </summary>
      public readonly Storage.V1Alpha1.VolumeAttachmentSource Source;

      [OutputConstructor]
      private VolumeAttachmentSpec(
          string @attacher,
          string @nodeName,
          Storage.V1Alpha1.VolumeAttachmentSource @source)
      {
          this.Attacher = @attacher;
          this.NodeName = @nodeName;
          this.Source = @source;
      }

    }
    /// <summary>
    /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentStatus
    {
      /// <summary>
        /// The last error encountered during attach operation, if any. This field must only be set
        /// by the entity completing the attach operation, i.e. the external-attacher.
        /// </summary>
      public readonly Storage.V1Alpha1.VolumeError AttachError;

      /// <summary>
        /// Indicates the volume is successfully attached. This field must only be set by the entity
        /// completing the attach operation, i.e. the external-attacher.
        /// </summary>
      public readonly bool Attached;

      /// <summary>
        /// Upon successful attach, this field is populated with any information returned by the
        /// attach operation that must be passed into subsequent WaitForAttach or Mount calls. This
        /// field must only be set by the entity completing the attach operation, i.e. the
        /// external-attacher.
        /// </summary>
      public readonly ImmutableDictionary<string, string> AttachmentMetadata;

      /// <summary>
        /// The last error encountered during detach operation, if any. This field must only be set
        /// by the entity completing the detach operation, i.e. the external-attacher.
        /// </summary>
      public readonly Storage.V1Alpha1.VolumeError DetachError;

      [OutputConstructor]
      private VolumeAttachmentStatus(
          Storage.V1Alpha1.VolumeError @attachError,
          bool @attached,
          ImmutableDictionary<string, string> @attachmentMetadata,
          Storage.V1Alpha1.VolumeError @detachError)
      {
          this.AttachError = @attachError;
          this.Attached = @attached;
          this.AttachmentMetadata = @attachmentMetadata;
          this.DetachError = @detachError;
      }

    }
    /// <summary>
    /// VolumeError captures an error encountered during a volume operation.
    /// </summary>
    [OutputType]
    public sealed class VolumeError
    {
      /// <summary>
        /// String detailing the error encountered during Attach or Detach operation. This string
        /// maybe logged, so it should not contain sensitive information.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Time the error was encountered.
        /// </summary>
      public readonly string Time;

      [OutputConstructor]
      private VolumeError(
          string @message,
          string @time)
      {
          this.Message = @message;
          this.Time = @time;
      }

    }
  }

  namespace V1Beta1
  {
    /// <summary>
    /// CSIDriver captures information about a Container Storage Interface (CSI) volume driver
    /// deployed on the cluster. CSI drivers do not need to create the CSIDriver object directly.
    /// Instead they may use the cluster-driver-registrar sidecar container. When deployed with a
    /// CSI driver it automatically creates a CSIDriver object representing the driver. Kubernetes
    /// attach detach controller uses this object to determine whether attach is required. Kubelet
    /// uses this object to determine whether pod information needs to be passed on mount. CSIDriver
    /// objects are non-namespaced.
    /// </summary>
    [OutputType]
    public sealed class CSIDriver
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata. metadata.Name indicates the name of the CSI driver that this
        /// object refers to; it MUST be the same name returned by the CSI GetPluginName() call for
        /// that driver. The driver name must be 63 characters or less, beginning and ending with an
        /// alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and alphanumerics
        /// between. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the CSI Driver.
        /// </summary>
      public readonly Storage.V1Beta1.CSIDriverSpec Spec;

      [OutputConstructor]
      private CSIDriver(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Storage.V1Beta1.CSIDriverSpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// CSIDriverList is a collection of CSIDriver objects.
    /// </summary>
    [OutputType]
    public sealed class CSIDriverList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of CSIDriver
        /// </summary>
      public readonly ImmutableArray<Storage.V1Beta1.CSIDriver> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private CSIDriverList(
          string @apiVersion,
          ImmutableArray<Storage.V1Beta1.CSIDriver> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// CSIDriverSpec is the specification of a CSIDriver.
    /// </summary>
    [OutputType]
    public sealed class CSIDriverSpec
    {
      /// <summary>
        /// attachRequired indicates this CSI volume driver requires an attach operation (because it
        /// implements the CSI ControllerPublishVolume() method), and that the Kubernetes attach
        /// detach controller should call the attach volume interface which checks the
        /// volumeattachment status and waits until the volume is attached before proceeding to
        /// mounting. The CSI external-attacher coordinates with CSI volume driver and updates the
        /// volumeattachment status when the attach operation is complete. If the CSIDriverRegistry
        /// feature gate is enabled and the value is specified to false, the attach operation will
        /// be skipped. Otherwise the attach operation will be called.
        /// </summary>
      public readonly bool AttachRequired;

      /// <summary>
        /// If set to true, podInfoOnMount indicates this CSI volume driver requires additional pod
        /// information (like podName, podUID, etc.) during mount operations. If set to false, pod
        /// information will not be passed on mount. Default is false. The CSI driver specifies
        /// podInfoOnMount as part of driver deployment. If true, Kubelet will pass pod information
        /// as VolumeContext in the CSI NodePublishVolume() calls. The CSI driver is responsible for
        /// parsing and validating the information passed in as VolumeContext. The following
        /// VolumeConext will be passed if podInfoOnMount is set to true. This list might grow, but
        /// the prefix will be used. "csi.storage.k8s.io/pod.name": pod.Name
        /// "csi.storage.k8s.io/pod.namespace": pod.Namespace "csi.storage.k8s.io/pod.uid":
        /// string(pod.UID) "csi.storage.k8s.io/ephemeral": "true" iff the volume is an ephemeral
        /// inline volume
        ///                                 defined by a CSIVolumeSource, otherwise "false"
        /// 
        /// "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only required
        /// for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
        /// Other drivers can leave pod info disabled and/or ignore this field. As Kubernetes 1.15
        /// doesn't support this field, drivers can only support one mode when deployed on such a
        /// cluster and the deployment determines which mode that is, for example via a command line
        /// parameter of the driver.
        /// </summary>
      public readonly bool PodInfoOnMount;

      /// <summary>
        /// VolumeLifecycleModes defines what kind of volumes this CSI volume driver supports. The
        /// default if the list is empty is "Persistent", which is the usage defined by the CSI
        /// specification and implemented in Kubernetes via the usual PV/PVC mechanism. The other
        /// mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec with
        /// CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod. A driver has
        /// to be aware of this because it is only going to get a NodePublishVolume call for such a
        /// volume. For more information about implementing this mode, see
        /// https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html A driver can support
        /// one or more of these modes and more modes may be added in the future.
        /// </summary>
      public readonly ImmutableArray<string> VolumeLifecycleModes;

      [OutputConstructor]
      private CSIDriverSpec(
          bool @attachRequired,
          bool @podInfoOnMount,
          ImmutableArray<string> @volumeLifecycleModes)
      {
          this.AttachRequired = @attachRequired;
          this.PodInfoOnMount = @podInfoOnMount;
          this.VolumeLifecycleModes = @volumeLifecycleModes;
      }

    }
    /// <summary>
    /// DEPRECATED - storage/v1beta1/CSINode is not supported by Kubernetes 1.16+ clusters. Use
    /// storage/v1beta1/CSINode instead.
    /// 
    /// CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need
    /// to create the CSINode object directly. As long as they use the node-driver-registrar sidecar
    /// container, the kubelet will automatically populate the CSINode object for the CSI driver as
    /// part of kubelet plugin registration. CSINode has the same name as a node. If the object is
    /// missing, it means either there are no CSI Drivers available on the node, or the Kubelet
    /// version is low enough that it doesn't create this object. CSINode has an OwnerReference that
    /// points to the corresponding node object.
    /// </summary>
    [OutputType]
    public sealed class CSINode
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// metadata.name must be the Kubernetes node name.
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// spec is the specification of CSINode
        /// </summary>
      public readonly Storage.V1Beta1.CSINodeSpec Spec;

      [OutputConstructor]
      private CSINode(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Storage.V1Beta1.CSINodeSpec @spec)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
      }

    }
    /// <summary>
    /// CSINodeDriver holds information about the specification of one CSI driver installed on a
    /// node
    /// </summary>
    [OutputType]
    public sealed class CSINodeDriver
    {
      /// <summary>
        /// allocatable represents the volume resources of a node that are available for scheduling.
        /// </summary>
      public readonly Storage.V1Beta1.VolumeNodeResources Allocatable;

      /// <summary>
        /// This is the name of the CSI driver that this object refers to. This MUST be the same
        /// name returned by the CSI GetPluginName() call for that driver.
        /// </summary>
      public readonly string Name;

      /// <summary>
        /// nodeID of the node from the driver point of view. This field enables Kubernetes to
        /// communicate with storage systems that do not share the same nomenclature for nodes. For
        /// example, Kubernetes may refer to a given node as "node1", but the storage system may
        /// refer to the same node as "nodeA". When Kubernetes issues a command to the storage
        /// system to attach a volume to a specific node, it can use this field to refer to the node
        /// name using the ID that the storage system will understand, e.g. "nodeA" instead of
        /// "node1". This field is required.
        /// </summary>
      public readonly string NodeID;

      /// <summary>
        /// topologyKeys is the list of keys supported by the driver. When a driver is initialized
        /// on a cluster, it provides a set of topology keys that it understands (e.g.
        /// "company.com/zone", "company.com/region"). When a driver is initialized on a node, it
        /// provides the same topology keys along with values. Kubelet will expose these topology
        /// keys as labels on its own node object. When Kubernetes does topology aware provisioning,
        /// it can use this list to determine which labels it should retrieve from the node object
        /// and pass back to the driver. It is possible for different nodes to use different
        /// topology keys. This can be empty if driver does not support topology.
        /// </summary>
      public readonly ImmutableArray<string> TopologyKeys;

      [OutputConstructor]
      private CSINodeDriver(
          Storage.V1Beta1.VolumeNodeResources @allocatable,
          string @name,
          string @nodeID,
          ImmutableArray<string> @topologyKeys)
      {
          this.Allocatable = @allocatable;
          this.Name = @name;
          this.NodeID = @nodeID;
          this.TopologyKeys = @topologyKeys;
      }

    }
    /// <summary>
    /// CSINodeList is a collection of CSINode objects.
    /// </summary>
    [OutputType]
    public sealed class CSINodeList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// items is the list of CSINode
        /// </summary>
      public readonly ImmutableArray<Storage.V1Beta1.CSINode> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private CSINodeList(
          string @apiVersion,
          ImmutableArray<Storage.V1Beta1.CSINode> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// CSINodeSpec holds information about the specification of all CSI drivers installed on a node
    /// </summary>
    [OutputType]
    public sealed class CSINodeSpec
    {
      /// <summary>
        /// drivers is a list of information of all CSI Drivers existing on a node. If all drivers
        /// in the list are uninstalled, this can become empty.
        /// </summary>
      public readonly ImmutableArray<Storage.V1Beta1.CSINodeDriver> Drivers;

      [OutputConstructor]
      private CSINodeSpec(
          ImmutableArray<Storage.V1Beta1.CSINodeDriver> @drivers)
      {
          this.Drivers = @drivers;
      }

    }
    /// <summary>
    /// StorageClass describes the parameters for a class of storage for which PersistentVolumes can
    /// be dynamically provisioned.
    /// 
    /// StorageClasses are non-namespaced; the name of the storage class according to etcd is in
    /// ObjectMeta.Name.
    /// </summary>
    [OutputType]
    public sealed class StorageClass
    {
      /// <summary>
        /// AllowVolumeExpansion shows whether the storage class allow volume expand
        /// </summary>
      public readonly bool AllowVolumeExpansion;

      /// <summary>
        /// Restrict the node topologies where volumes can be dynamically provisioned. Each volume
        /// plugin defines its own supported topology specifications. An empty TopologySelectorTerm
        /// list means there is no topology restriction. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
      public readonly ImmutableArray<Core.V1.TopologySelectorTerm> AllowedTopologies;

      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object's metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with these
        /// mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if
        /// one is invalid.
        /// </summary>
      public readonly ImmutableArray<string> MountOptions;

      /// <summary>
        /// Parameters holds the parameters for the provisioner that should create volumes of this
        /// storage class.
        /// </summary>
      public readonly ImmutableDictionary<string, string> Parameters;

      /// <summary>
        /// Provisioner indicates the type of the provisioner.
        /// </summary>
      public readonly string Provisioner;

      /// <summary>
        /// Dynamically provisioned PersistentVolumes of this storage class are created with this
        /// reclaimPolicy. Defaults to Delete.
        /// </summary>
      public readonly string ReclaimPolicy;

      /// <summary>
        /// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.
        /// When unset, VolumeBindingImmediate is used. This field is only honored by servers that
        /// enable the VolumeScheduling feature.
        /// </summary>
      public readonly string VolumeBindingMode;

      [OutputConstructor]
      private StorageClass(
          bool @allowVolumeExpansion,
          ImmutableArray<Core.V1.TopologySelectorTerm> @allowedTopologies,
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          ImmutableArray<string> @mountOptions,
          ImmutableDictionary<string, string> @parameters,
          string @provisioner,
          string @reclaimPolicy,
          string @volumeBindingMode)
      {
          this.AllowVolumeExpansion = @allowVolumeExpansion;
          this.AllowedTopologies = @allowedTopologies;
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.MountOptions = @mountOptions;
          this.Parameters = @parameters;
          this.Provisioner = @provisioner;
          this.ReclaimPolicy = @reclaimPolicy;
          this.VolumeBindingMode = @volumeBindingMode;
      }

    }
    /// <summary>
    /// StorageClassList is a collection of storage classes.
    /// </summary>
    [OutputType]
    public sealed class StorageClassList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of StorageClasses
        /// </summary>
      public readonly ImmutableArray<Storage.V1Beta1.StorageClass> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private StorageClassList(
          string @apiVersion,
          ImmutableArray<Storage.V1Beta1.StorageClass> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// VolumeAttachment captures the intent to attach or detach the specified volume to/from the
    /// specified node.
    /// 
    /// VolumeAttachment objects are non-namespaced.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachment
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard object metadata. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ObjectMeta Metadata;

      /// <summary>
        /// Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
        /// system.
        /// </summary>
      public readonly Storage.V1Beta1.VolumeAttachmentSpec Spec;

      /// <summary>
        /// Status of the VolumeAttachment request. Populated by the entity completing the attach or
        /// detach operation, i.e. the external-attacher.
        /// </summary>
      public readonly Storage.V1Beta1.VolumeAttachmentStatus Status;

      [OutputConstructor]
      private VolumeAttachment(
          string @apiVersion,
          string @kind,
          Meta.V1.ObjectMeta @metadata,
          Storage.V1Beta1.VolumeAttachmentSpec @spec,
          Storage.V1Beta1.VolumeAttachmentStatus @status)
      {
          this.ApiVersion = @apiVersion;
          this.Kind = @kind;
          this.Metadata = @metadata;
          this.Spec = @spec;
          this.Status = @status;
      }

    }
    /// <summary>
    /// VolumeAttachmentList is a collection of VolumeAttachment objects.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentList
    {
      /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers
        /// should convert recognized schemas to the latest internal value, and may reject
        /// unrecognized values. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
      public readonly string ApiVersion;

      /// <summary>
        /// Items is the list of VolumeAttachments
        /// </summary>
      public readonly ImmutableArray<Storage.V1Beta1.VolumeAttachment> Items;

      /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers
        /// may infer this from the endpoint the client submits requests to. Cannot be updated. In
        /// CamelCase. More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
      public readonly string Kind;

      /// <summary>
        /// Standard list metadata More info:
        /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
      public readonly Meta.V1.ListMeta Metadata;

      [OutputConstructor]
      private VolumeAttachmentList(
          string @apiVersion,
          ImmutableArray<Storage.V1Beta1.VolumeAttachment> @items,
          string @kind,
          Meta.V1.ListMeta @metadata)
      {
          this.ApiVersion = @apiVersion;
          this.Items = @items;
          this.Kind = @kind;
          this.Metadata = @metadata;
      }

    }
    /// <summary>
    /// VolumeAttachmentSource represents a volume that should be attached. Right now only
    /// PersistenVolumes can be attached via external attacher, in future we may allow also inline
    /// volumes in pods. Exactly one member can be set.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentSource
    {
      /// <summary>
        /// inlineVolumeSpec contains all the information necessary to attach a persistent volume
        /// defined by a pod's inline VolumeSource. This field is populated only for the
        /// CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to
        /// a PersistentVolumeSpec. This field is alpha-level and is only honored by servers that
        /// enabled the CSIMigration feature.
        /// </summary>
      public readonly Core.V1.PersistentVolumeSpec InlineVolumeSpec;

      /// <summary>
        /// Name of the persistent volume to attach.
        /// </summary>
      public readonly string PersistentVolumeName;

      [OutputConstructor]
      private VolumeAttachmentSource(
          Core.V1.PersistentVolumeSpec @inlineVolumeSpec,
          string @persistentVolumeName)
      {
          this.InlineVolumeSpec = @inlineVolumeSpec;
          this.PersistentVolumeName = @persistentVolumeName;
      }

    }
    /// <summary>
    /// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentSpec
    {
      /// <summary>
        /// Attacher indicates the name of the volume driver that MUST handle this request. This is
        /// the name returned by GetPluginName().
        /// </summary>
      public readonly string Attacher;

      /// <summary>
        /// The node that the volume should be attached to.
        /// </summary>
      public readonly string NodeName;

      /// <summary>
        /// Source represents the volume that should be attached.
        /// </summary>
      public readonly Storage.V1Beta1.VolumeAttachmentSource Source;

      [OutputConstructor]
      private VolumeAttachmentSpec(
          string @attacher,
          string @nodeName,
          Storage.V1Beta1.VolumeAttachmentSource @source)
      {
          this.Attacher = @attacher;
          this.NodeName = @nodeName;
          this.Source = @source;
      }

    }
    /// <summary>
    /// VolumeAttachmentStatus is the status of a VolumeAttachment request.
    /// </summary>
    [OutputType]
    public sealed class VolumeAttachmentStatus
    {
      /// <summary>
        /// The last error encountered during attach operation, if any. This field must only be set
        /// by the entity completing the attach operation, i.e. the external-attacher.
        /// </summary>
      public readonly Storage.V1Beta1.VolumeError AttachError;

      /// <summary>
        /// Indicates the volume is successfully attached. This field must only be set by the entity
        /// completing the attach operation, i.e. the external-attacher.
        /// </summary>
      public readonly bool Attached;

      /// <summary>
        /// Upon successful attach, this field is populated with any information returned by the
        /// attach operation that must be passed into subsequent WaitForAttach or Mount calls. This
        /// field must only be set by the entity completing the attach operation, i.e. the
        /// external-attacher.
        /// </summary>
      public readonly ImmutableDictionary<string, string> AttachmentMetadata;

      /// <summary>
        /// The last error encountered during detach operation, if any. This field must only be set
        /// by the entity completing the detach operation, i.e. the external-attacher.
        /// </summary>
      public readonly Storage.V1Beta1.VolumeError DetachError;

      [OutputConstructor]
      private VolumeAttachmentStatus(
          Storage.V1Beta1.VolumeError @attachError,
          bool @attached,
          ImmutableDictionary<string, string> @attachmentMetadata,
          Storage.V1Beta1.VolumeError @detachError)
      {
          this.AttachError = @attachError;
          this.Attached = @attached;
          this.AttachmentMetadata = @attachmentMetadata;
          this.DetachError = @detachError;
      }

    }
    /// <summary>
    /// VolumeError captures an error encountered during a volume operation.
    /// </summary>
    [OutputType]
    public sealed class VolumeError
    {
      /// <summary>
        /// String detailing the error encountered during Attach or Detach operation. This string
        /// may be logged, so it should not contain sensitive information.
        /// </summary>
      public readonly string Message;

      /// <summary>
        /// Time the error was encountered.
        /// </summary>
      public readonly string Time;

      [OutputConstructor]
      private VolumeError(
          string @message,
          string @time)
      {
          this.Message = @message;
          this.Time = @time;
      }

    }
    /// <summary>
    /// VolumeNodeResources is a set of resource limits for scheduling of volumes.
    /// </summary>
    [OutputType]
    public sealed class VolumeNodeResources
    {
      /// <summary>
        /// Maximum number of unique volumes managed by the CSI driver that can be used on a node. A
        /// volume that is both attached and mounted on a node is considered to be used once, not
        /// twice. The same rule applies for a unique volume that is shared among multiple pods on
        /// the same node. If this field is nil, then the supported number of volumes on this node
        /// is unbounded.
        /// </summary>
      public readonly int Count;

      [OutputConstructor]
      private VolumeNodeResources(
          int @count)
      {
          this.Count = @count;
      }

    }
  }

}

