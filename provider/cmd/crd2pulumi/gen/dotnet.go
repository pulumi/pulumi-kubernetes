// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gen

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/pkg/v2/codegen"
	"github.com/pulumi/pulumi/pkg/v2/codegen/dotnet"
	pschema "github.com/pulumi/pulumi/pkg/v2/codegen/schema"
)

var unneededDotNetFiles = []string{
	"Provider.cs",
	"Meta/V1/Inputs/ObjectMetaArgs.cs",
	"Meta/V1/Outputs/ObjectMeta.cs",
	"Meta/V1/README.md",
	"Meta/README.md",
}

func (pg *PackageGenerator) genDotNet(types map[string]pschema.ObjectTypeSpec, baseRefs []string) (map[string]*bytes.Buffer, error) {
	// For some reason, the Metadata input type would be generated as
	// `ObjectMeta` instead of `ObjectMetaArgs` if we did not have an actual
	// ObjectMeta type defined. So we'll create a placeholder metadata spec
	// in the Pulumi schema, and then manually remove the generated files for
	// the type later.
	AddPlaceholderMetadataSpec(types)

	pkg, err := getPackage(types, baseRefs)
	if err != nil {
		fmt.Print(errors.Wrap(err, "could not create package"))
	}

	// Set up C# namespaces
	namespaces := map[string]string{}
	for _, groupVersion := range pg.GroupVersions {
		group, version := splitGroupVersion(groupVersion)
		groupPrefix := groupPrefix(group)
		namespaces[groupVersion] = strings.Title(groupPrefix) + "." + versionToUpper(version)
	}
	namespaces["meta/v1"] = "Meta.V1"

	// Configure C# language-specific settings. Notice that we set
	// `compatibility` to `kubernetes20`. This is because the actual ObjectMeta
	// class defined in the .NET SDK is located at
	// `Pulumi.Kubernetes.Types.Outputs.Meta.V1.ObjectMeta`. This path would
	// only get generated properly if `compatibility` was `kubernetes20`.
	pkg.Language["csharp"] = rawMessage(map[string]interface{}{
		"compatibility":          "kubernetes20",
		"dictionaryConstructors": true,
		"namespaces":             namespaces,
	})

	files, err := dotnet.GeneratePackage(tool, pkg, nil)
	if err != nil {
		return nil, errors.Wrap(err, "could not generate .NET package")
	}

	files["KubernetesResource.cs"] = []byte(kubernetesResource)
	files["Utilities.cs"] = []byte(dotNetUtilities)

	// Delete unneeded files
	for _, unneededFile := range unneededDotNetFiles {
		delete(files, unneededFile)
	}

	buffers := map[string]*bytes.Buffer{}
	for name, code := range files {
		buffers[name] = bytes.NewBuffer(code)
	}

	return buffers, nil
}

// Returns a set of the file paths for each CustomResource class for a generated
// C# package.
func (pg *PackageGenerator) dotNetClassPaths() codegen.StringSet {
	paths := codegen.NewStringSet()
	for _, crg := range pg.CustomResourceGenerators {
		for _, groupVersion := range crg.GroupVersions {
			group, version := splitGroupVersion(groupVersion)
			path := filepath.Join(strings.Title(groupPrefix(group)), versionToUpper(version), crg.Kind+".cs")
			paths.Add(path)
		}
	}
	return paths
}

const kubernetesResource = `// Copyright 2016-2020, Pulumi Corporation

namespace Pulumi.Kubernetes
{
    /// <summary>
    /// A base class for all Kubernetes resources.
    /// </summary>
    public abstract class KubernetesResource : CustomResource
    {
        /// <summary>
        /// Standard constructor passing arguments to <see cref="CustomResource"/>.
        /// </summary>
        internal KubernetesResource(string type, string name, ResourceArgs? args, CustomResourceOptions? options = null)
            : base(type, name, args, options)
        {
        }

        /// <summary>
        /// Additional constructor for dynamic arguments received from YAML-based sources.
        /// </summary>
        internal KubernetesResource(string type, string name, DictionaryResourceArgs? args, CustomResourceOptions? options = null)
            : base(type, name, args, options)
        {
        }
    }
}
`

// For some reason, we get a `Missing embedded version.txt file` error if we
// tried running `pulumi up` with the normal `Utilities.cs` file.
// As a temporary fix, this modified `Utilities.cs` file just removes the
// `static Utilities()` method.
const dotNetUtilities = `// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.IO;
using System.Reflection;
using Pulumi;

namespace Pulumi.Kubernetes
{
    static class Utilities
    {
        public static string? GetEnv(params string[] names)
        {
            foreach (var n in names)
            {
                var value = Environment.GetEnvironmentVariable(n);
                if (value != null)
                {
                    return value;
                }
            }
            return null;
        }

        static string[] trueValues = { "1", "t", "T", "true", "TRUE", "True" };
        static string[] falseValues = { "0", "f", "F", "false", "FALSE", "False" };
        public static bool? GetEnvBoolean(params string[] names)
        {
            var s = GetEnv(names);
            if (s != null)
            {
                if (Array.IndexOf(trueValues, s) != -1)
                {
                    return true;
                }
                if (Array.IndexOf(falseValues, s) != -1)
                {
                    return false;
                }
            }
            return null;
        }

        public static int? GetEnvInt32(params string[] names) => int.TryParse(GetEnv(names), out int v) ? (int?)v : null;

        public static double? GetEnvDouble(params string[] names) => double.TryParse(GetEnv(names), out double v) ? (double?)v : null;

        public static InvokeOptions WithVersion(this InvokeOptions? options)
        {
            if (options?.Version != null)
            {
                return options;
            }
            return new InvokeOptions
            {
                Parent = options?.Parent,
                Provider = options?.Provider,
                Version = Version,
            };
        }

        private readonly static string version;
        public static string Version => version;
    }
}
`
