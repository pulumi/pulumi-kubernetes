// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gen

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/pkg/v2/codegen/dotnet"
	pschema "github.com/pulumi/pulumi/pkg/v2/codegen/schema"
)

const dotNetImports = `using Pulumi.Kubernetes.Types.Inputs.Meta.V1;
using Pulumi.Kubernetes.Types.Outputs.Meta.V1;

`

var objectMetaArgs = "Pulumi.Kubernetes.Meta.V1.Inputs.ObjectMeta"
var importedObjectMetaArgs = "ObjectMetaArgs"
var objectMeta = "Pulumi.Kubernetes.Meta.V1.Outputs.ObjectMeta"
var importedObjectMeta = "ObjectMeta"

var unneededDotNetFiles = []string{
	"Provider.cs",
}

func (pg *PackageGenerator) genDotNet(types map[string]pschema.ObjectTypeSpec, baseRefs []string) (map[string]*bytes.Buffer, error) {
	pkg, err := getPackage(types, baseRefs)
	if err != nil {
		fmt.Print(errors.Wrap(err, "could not create package"))
	}

	namespaces := map[string]string{}
	for _, groupVersion := range pg.GroupVersions() {
		group, version := splitGroupVersion(groupVersion)
		groupPrefix := groupPrefix(group)
		namespaces[groupVersion] = strings.Title(groupPrefix) + "." + versionToUpper(version)
	}
	namespaces["meta/v1"] = "Meta.V1"

	pkg.Language["csharp"] = rawMessage(map[string]interface{}{
		"dictionaryConstructors": true,
		"namespaces":             namespaces,
	})

	pkg.Name = "Kubernetes"

	files, err := dotnet.GeneratePackage(tool, pkg, nil)
	if err != nil {
		return nil, errors.Wrap(err, "could not generate .NET package")
	}

	files["Utilities.cs"] = []byte(dotNetUtilities)

	buffers := map[string]*bytes.Buffer{}

	// Manually search and replace ObjectMeta and ObjectMetaArgs imports in
	// the CustomResource classes. Hopefully we'll find a better way to do this
	// soon
	classPaths := pg.dotNetClassPaths()
	for classPath := range classPaths {
		class := files[classPath]
		class = bytes.ReplaceAll(class, []byte(objectMetaArgs), []byte(importedObjectMetaArgs))
		class = bytes.ReplaceAll(class, []byte(objectMeta), []byte(importedObjectMeta))
		newClass := bytes.NewBuffer([]byte(dotNetImports))
		newClass.Write(class)
		buffers[classPath] = newClass
	}

	for name, code := range files {
		if ok := classPaths[name]; !ok {
			buffers[name] = bytes.NewBuffer(code)
		}
	}

	for _, unneededFile := range unneededDotNetFiles {
		delete(buffers, unneededFile)
	}

	return buffers, nil
}

// Returns a set of the file paths for each CustomResource class
func (pg *PackageGenerator) dotNetClassPaths() map[string]bool {
	paths := map[string]bool{}
	for _, crg := range pg.CustomResourceGenerators {
		for _, groupVersion := range crg.GroupVersions() {
			group, version := splitGroupVersion(groupVersion)
			path := filepath.Join(strings.Title(groupPrefix(group)), versionToUpper(version), crg.Kind+".cs")
			paths[path] = true
		}
	}
	return paths
}

const dotNetUtilities = `// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.IO;
using System.Reflection;
using Pulumi;

namespace Pulumi.Kubernetes
{
    static class Utilities
    {
        public static string? GetEnv(params string[] names)
        {
            foreach (var n in names)
            {
                var value = Environment.GetEnvironmentVariable(n);
                if (value != null)
                {
                    return value;
                }
            }
            return null;
        }

        static string[] trueValues = { "1", "t", "T", "true", "TRUE", "True" };
        static string[] falseValues = { "0", "f", "F", "false", "FALSE", "False" };
        public static bool? GetEnvBoolean(params string[] names)
        {
            var s = GetEnv(names);
            if (s != null)
            {
                if (Array.IndexOf(trueValues, s) != -1)
                {
                    return true;
                }
                if (Array.IndexOf(falseValues, s) != -1)
                {
                    return false;
                }
            }
            return null;
        }

        public static int? GetEnvInt32(params string[] names) => int.TryParse(GetEnv(names), out int v) ? (int?)v : null;

        public static double? GetEnvDouble(params string[] names) => double.TryParse(GetEnv(names), out double v) ? (double?)v : null;

        public static InvokeOptions WithVersion(this InvokeOptions? options)
        {
            if (options?.Version != null)
            {
                return options;
            }
            return new InvokeOptions
            {
                Parent = options?.Parent,
                Provider = options?.Provider,
                Version = Version,
            };
        }

        private readonly static string version;
        public static string Version => version;

    }
}
`
