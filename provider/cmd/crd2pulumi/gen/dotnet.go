// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gen

import (
	"bytes"
	"strings"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/pkg/v2/codegen/dotnet"
)

var unneededDotNetFiles = []string{
	"Meta/V1/Inputs/ObjectMetaArgs.cs",
	"Meta/V1/Outputs/ObjectMeta.cs",
	"Meta/V1/README.md",
	"Meta/README.md",
	"Provider.cs",
}

func (pg *PackageGenerator) genDotNet(outputDir string) error {
	if files, err := pg.genDotNetFiles(); err != nil {
		return err
	} else if err := writeFiles(files, outputDir); err != nil {
		return err
	}
	return nil
}

func (pg *PackageGenerator) genDotNetFiles() (map[string]*bytes.Buffer, error) {
	pkg := pg.SchemaPackageWithObjectMetaType()

	// Set up C# namespaces
	namespaces := map[string]string{}
	for _, groupVersion := range pg.GroupVersions {
		group, version := splitGroupVersion(groupVersion)
		groupPrefix := groupPrefix(group)
		namespaces[groupVersion] = strings.Title(groupPrefix) + "." + versionToUpper(version)
	}
	namespaces["meta/v1"] = "Meta.V1"

	// Configure C# language-specific settings. Notice that we set
	// `compatibility` to `kubernetes20`. This is because the actual ObjectMeta
	// class defined in the .NET SDK is located at
	// `Pulumi.Kubernetes.Types.Outputs.Meta.V1.ObjectMeta`. This path would
	// only get generated properly if `compatibility` was `kubernetes20`.
	pkg.Language["csharp"] = rawMessage(map[string]interface{}{
		"packageReferences": map[string]string{
			"Pulumi.Kubernetes": "2.*",
		},
		"compatibility":          "kubernetes20",
		"dictionaryConstructors": true,
		"namespaces":             namespaces,
	})

	files, err := dotnet.GeneratePackage(tool, pkg, nil)
	if err != nil {
		return nil, errors.Wrap(err, "could not generate .NET package")
	}

	delete(pkg.Language, "chsarp")

	files["KubernetesResource.cs"] = []byte(kubernetesResource)
	files["Utilities.cs"] = []byte(dotNetUtilities)

	// Delete unneeded files
	for _, unneededFile := range unneededDotNetFiles {
		delete(files, unneededFile)
	}

	buffers := map[string]*bytes.Buffer{}
	for name, code := range files {
		buffers[name] = bytes.NewBuffer(code)
	}

	return buffers, nil
}

var kubernetesResource = `// Copyright 2016-2020, Pulumi Corporation

namespace Pulumi.` + strings.Title(packageName) + `{
    /// <summary>
    /// A base class for all Kubernetes resources.
    /// </summary>
    public abstract class KubernetesResource : CustomResource
    {
        /// <summary>
        /// Standard constructor passing arguments to <see cref="CustomResource"/>.
        /// </summary>
        internal KubernetesResource(string type, string name, ResourceArgs? args, CustomResourceOptions? options = null)
            : base(type, name, args, options)
        {
        }

        /// <summary>
        /// Additional constructor for dynamic arguments received from YAML-based sources.
        /// </summary>
        internal KubernetesResource(string type, string name, DictionaryResourceArgs? args, CustomResourceOptions? options = null)
            : base(type, name, args, options)
        {
        }
    }
}
`

// For some reason, we get a `Missing embedded version.txt file` error if we
// tried running `pulumi up` with the normal `Utilities.cs` file.
// As a temporary fix, this modified `Utilities.cs` file just removes the
// `static Utilities()` method.
var dotNetUtilities = `// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Reflection;
using Pulumi.Kubernetes;

namespace Pulumi.` + strings.Title(packageName) + `
{
    static class Utilities
    {
        public static string Version { get; } = GetVersion();

        private static string GetVersion()
        {
            const string UtilitiesType = "Pulumi.Kubernetes.Utilities";
            const string VersionProperty = "Version";

            Type? type = Assembly.GetAssembly(typeof(Provider))?.GetType(UtilitiesType);
            if (type is null)
            {
                throw new InvalidOperationException($"{UtilitiesType} type could not be obtained.");
            }

            PropertyInfo? prop = type.GetProperty(VersionProperty, BindingFlags.Static | BindingFlags.Public);
            if (prop is null)
            {
                throw new InvalidOperationException($"{UtilitiesType}.{VersionProperty} property could not be obtained.");
            }

            var result = prop.GetValue(type, null) as string;
            if (result is null)
            {
                throw new InvalidOperationException($"Expected {UtilitiesType}.{VersionProperty} to return a non-null string.");
            }
            return result;
        }
    }
}
`
