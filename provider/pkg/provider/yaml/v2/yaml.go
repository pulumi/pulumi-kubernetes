// Copyright 2016-2024, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v2

import (
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi-kubernetes/provider/v4/pkg/clients"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes"
	yamlv2 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/yaml/v2"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/util/yaml"
)

type ParseArgs struct {
	Files          []string
	YAML           []string
	Objects        []map[string]any
	ResourcePrefix string
	SkipAwait      bool
}

func ParseDecodeYamlFiles(ctx *pulumi.Context, args *ParseArgs, glob bool, clientSet *clients.DynamicClientSet, opts ...pulumi.ResourceOption,
) (pulumi.ArrayOutput, error) {

	// Start with the provided objects and YAML arrays, if any, and we'll append to them.
	objs := args.Objects
	yamls := args.YAML

	// Start by gathering any other YAML from files provided.
	for _, file := range args.Files {
		// Read the raw YAML file(s) specified in the input file parameter. It might be a URL or a file path.
		var yaml []byte
		u, err := url.Parse(file)
		if err == nil && u.IsAbs() {
			// If the string looks like a URL, in that it begins with a scheme, fetch it over the network.
			resp, err := http.Get(file)
			if err != nil {
				return pulumi.ArrayOutput{}, errors.Wrapf(err, "fetching YAML over network")
			}
			defer resp.Body.Close()
			yaml, err = io.ReadAll(resp.Body)
			if err != nil {
				return pulumi.ArrayOutput{}, errors.Wrapf(err, "reading YAML over network")
			}
			yamls = append(yamls, string(yaml))
		} else {
			// Otherwise, assume this is a path to a file on disk. If globbing is enabled, we might have
			// multiple files -- otherwise just read a singular file.
			var files []string
			if glob {
				files, err = filepath.Glob(file)
				if err != nil {
					return pulumi.ArrayOutput{}, errors.Wrapf(err, "expanding glob")
				}
			} else {
				files = []string{file}
			}
			for _, f := range files {
				yaml, err = os.ReadFile(f)
				if err != nil {
					return pulumi.ArrayOutput{}, errors.Wrapf(err, "reading YAML file from disk")
				}
				yamls = append(yamls, string(yaml))
			}
		}
	}

	// Next parse all YAML documents into objects.
	for _, yaml := range yamls {
		// Parse the resulting YAML bytes and turn them into raw Kubernetes objects.
		dec, err := yamlDecode(yaml, clientSet)
		if err != nil {
			return pulumi.ArrayOutput{}, errors.Wrapf(err, "decoding YAML")
		}
		objs = append(objs, dec...)
	}

	// Now process the resulting list of Kubernetes objects.
	return ParseYamlObjects(ctx, objs, args.ResourcePrefix, args.SkipAwait, opts...)
}

// yamlDecode decodes a YAML string into object structures.
func yamlDecode(text string, _ *clients.DynamicClientSet) ([]map[string]any, error) {
	var resources []unstructured.Unstructured

	dec := yaml.NewYAMLOrJSONDecoder(io.NopCloser(strings.NewReader(text)), 128)
	for {
		var value map[string]any
		if err := dec.Decode(&value); err != nil {
			if err == io.EOF {
				break
			}
			return nil, err
		}
		resource := unstructured.Unstructured{Object: value}

		// Sometimes manifests include empty resources, so skip these.
		if len(resource.GetKind()) == 0 || len(resource.GetAPIVersion()) == 0 {
			continue
		}
		resources = append(resources, resource)
	}

	result := make([]map[string]any, 0, len(resources))
	for _, resource := range resources {
		result = append(result, resource.Object)
	}
	return result, nil
}

func ParseYamlObjects(
	ctx *pulumi.Context,
	objs []map[string]any,
	resourcePrefix string,
	skipAwait bool,
	opts ...pulumi.ResourceOption,
) (pulumi.ArrayOutput, error) {
	var intermediates []pulumi.CustomResource
	for _, obj := range objs {
		rs, err := parseYamlObject(ctx, obj, resourcePrefix, skipAwait, opts...)
		if err != nil {
			return pulumi.ArrayOutput{}, err
		}
		intermediates = append(intermediates, rs...)
	}

	resources := pulumi.Array{}
	for _, r := range intermediates {
		resources = append(resources, pulumi.NewResourceOutput(r))
	}
	return resources.ToArrayOutputWithContext(ctx.Context()), nil
}

func parseYamlObject(
	ctx *pulumi.Context,
	obj map[string]any,
	resourcePrefix string,
	skipAwait bool,
	opts ...pulumi.ResourceOption,
) ([]pulumi.CustomResource, error) {

	getProp := func(key string) (string, bool) {
		v, ok := obj[key]
		if !ok {
			return "", false
		}
		return fmt.Sprintf("%s", v), true
	}

	// Ensure there is a kind and API version.
	kind, hasKind := getProp("kind")
	apiVersion, hasAPIVersion := getProp("apiVersion")
	if !hasKind || !hasAPIVersion {
		return nil, errors.Errorf("Kubernetes resources require a kind and apiVersion: %+v", obj)
	}
	fullKind := fmt.Sprintf("%s/%s", apiVersion, kind)

	// Recursively traverse built-in Kubernetes list types into a single set of "naked" resource
	// definitions that we can register with the Pulumi engine.
	//
	// Kubernetes does not instantiate list types like `v1.List`. When the API server receives
	// a list, it will recursively traverse it and perform the necessary operations on
	// each "instantiable" resource it finds. For example, `kubectl apply` on a
	// `v1.ConfigMapList` will cause the API server to traverse the list, and `apply` each
	// `v1.ConfigMap` it finds.
	//
	// Since Kubernetes does not instantiate list types directly, Pulumi also traverses lists
	// for resource definitions that can be managed by Kubernetes, and registers those with the
	// engine instead.
	if yamlv2.IsListKind(apiVersion, kind) {
		var resources []pulumi.CustomResource
		if rawItems, hasItems := obj["items"]; hasItems {
			if items, ok := rawItems.([]any); ok {
				for _, item := range items {
					if obj, ok := item.(map[string]any); ok {
						rs, err := parseYamlObject(ctx, obj, resourcePrefix, skipAwait, opts...)
						if err != nil {
							return nil, err
						}
						resources = append(resources, rs...)
					}
				}
			}
		}
		return resources, nil
	}

	// If we got here, it's not a recursively traversed type, so process it directly.
	// First, validate that it has the requisite metadata and name properties.
	meta, hasMeta := obj["metadata"]
	if !hasMeta {
		return nil, errors.Errorf("YAML object does not have a .metadata field: %s %+v", fullKind, obj)
	}
	metaDict, hasMetaDict := meta.(map[string]any)
	if !hasMetaDict {
		return nil, errors.Errorf("YAML object does not have a .metadata dictionary: %s %+v", fullKind, obj)
	}
	metaName, hasMetaName := metaDict["name"].(string)
	if !hasMetaName || metaName == "" {
		return nil, errors.Errorf("YAML object does not have a .metadata.name: %s %+v", fullKind, obj)
	}

	// Manufacture a name as appropriate, out of the meta name, namespace, and optional prefix.
	if ns, hasNS := metaDict["namespace"]; hasNS {
		metaName = fmt.Sprintf("%s/%s", ns, metaName)
	}
	if resourcePrefix != "" {
		metaName = fmt.Sprintf("%s-%s", resourcePrefix, metaName)
		metaDict["name"] = fmt.Sprintf("%s-%s", resourcePrefix, metaDict["name"])
	}

	if skipAwait {
		if annotations, ok := metaDict["annotations"].(map[string]interface{}); ok {
			annotations["pulumi.com/skipAwait"] = "true"
		} else {
			metaDict["annotations"] = map[string]string{"pulumi.com/skipAwait": "true"}
		}
	}

	if fullKind == "v1/Secret" {
		// Always mark these fields as secret to avoid leaking sensitive values from raw YAML.
		for _, key := range []string{"data", "stringData"} {
			if _, ok := obj[key]; ok {
				obj[key] = pulumi.ToSecret(obj[key])
			}
		}
	}

	// Finally allocate a resource of the correct type.
	res, err := yamlv2.RegisterResource(ctx, apiVersion, kind, metaName, kubernetes.UntypedArgs(obj), opts...)
	if err != nil {
		return nil, err
	}
	return []pulumi.CustomResource{res}, nil
}
