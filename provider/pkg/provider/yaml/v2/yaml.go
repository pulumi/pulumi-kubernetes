// Copyright 2016-2024, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v2

import (
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi-kubernetes/provider/v4/pkg/clients"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes"
	yamlv2 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/yaml/v2"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/yaml"
)

type ParseArgs struct {
	Files          []string
	YAML           string
	Objects        []unstructured.Unstructured
	ResourcePrefix string
	SkipAwait      bool
}

func ParseDecodeYamlFiles(ctx *pulumi.Context, args *ParseArgs, glob bool, clientSet *clients.DynamicClientSet, opts ...pulumi.ResourceOption,
) (pulumi.ArrayOutput, error) {

	// Start with the provided objects.
	var objs []unstructured.Unstructured
	objs = append(objs, args.Objects...)

	// Continue by gathering any other YAML from files provided.
	yamls := []string{args.YAML}
	for _, file := range args.Files {
		// Read the raw YAML file(s) specified in the input file parameter. It might be a URL or a file path.
		var yaml []byte
		u, err := url.Parse(file)
		if err == nil && u.IsAbs() {
			// If the string looks like a URL, in that it begins with a scheme, fetch it over the network.
			resp, err := http.Get(file)
			if err != nil {
				return pulumi.ArrayOutput{}, errors.Wrapf(err, "fetching YAML over network")
			}
			defer resp.Body.Close()
			yaml, err = io.ReadAll(resp.Body)
			if err != nil {
				return pulumi.ArrayOutput{}, errors.Wrapf(err, "reading YAML over network")
			}
			yamls = append(yamls, string(yaml))
		} else {
			// Otherwise, assume this is a path to a file on disk. If globbing is enabled, we might have
			// multiple files -- otherwise just read a singular file.
			var files []string
			if glob {
				files, err = filepath.Glob(file)
				if err != nil {
					return pulumi.ArrayOutput{}, errors.Wrapf(err, "expanding glob")
				}
			} else {
				files = []string{file}
			}
			for _, f := range files {
				yaml, err = os.ReadFile(f)
				if err != nil {
					return pulumi.ArrayOutput{}, errors.Wrapf(err, "reading YAML file from disk")
				}
				yamls = append(yamls, string(yaml))
			}
		}
	}

	// Next parse all YAML documents into objects.
	for _, yaml := range yamls {
		// Parse the resulting YAML bytes and turn them into raw Kubernetes objects.
		dec, err := yamlDecode(yaml, clientSet)
		if err != nil {
			return pulumi.ArrayOutput{}, errors.Wrapf(err, "decoding YAML")
		}
		objs = append(objs, dec...)
	}

	// Now process the resulting list of Kubernetes objects.
	return ParseYamlObjects(ctx, objs, args.ResourcePrefix, args.SkipAwait, opts...)
}

// yamlDecode decodes a YAML string into a slice of Unstructured objects.
func yamlDecode(text string, _ *clients.DynamicClientSet) ([]unstructured.Unstructured, error) {
	var resources []unstructured.Unstructured

	dec := yaml.NewYAMLOrJSONDecoder(io.NopCloser(strings.NewReader(text)), 128)
	for {
		var value map[string]any
		if err := dec.Decode(&value); err != nil {
			if err == io.EOF {
				break
			}
			return nil, err
		}
		resource := unstructured.Unstructured{Object: value}

		// Sometimes manifests include empty blocks, so skip these.
		if len(value) == 0 {
			continue
		}
		resources = append(resources, resource)
	}

	return resources, nil
}

func ParseYamlObjects(
	ctx *pulumi.Context,
	objs []unstructured.Unstructured,
	resourcePrefix string,
	skipAwait bool,
	opts ...pulumi.ResourceOption,
) (pulumi.ArrayOutput, error) {
	resources := pulumi.Array{}
	for _, obj := range objs {
		rs, err := parseUnstructured(ctx, &obj, resourcePrefix, skipAwait, opts...)
		if err != nil {
			return pulumi.ArrayOutput{}, err
		}
		for _, r := range rs {
			resources = append(resources, pulumi.NewResourceOutput(r))
		}
	}
	return resources.ToArrayOutputWithContext(ctx.Context()), nil
}

func parseUnstructured(
	ctx *pulumi.Context,
	obj *unstructured.Unstructured,
	resourcePrefix string,
	skipAwait bool,
	opts ...pulumi.ResourceOption,
) ([]pulumi.CustomResource, error) {

	// Ensure there is a kind and API version.
	kind := obj.GetKind()
	apiVersion := obj.GetAPIVersion()
	if kind == "" || apiVersion == "" {
		return nil, fmt.Errorf("Kubernetes resources require a kind and apiVersion: `%s`", printUnstructured(obj))
	}
	fullKind := fmt.Sprintf("%s/%s", apiVersion, kind)

	// Recursively traverse built-in Kubernetes list types into a single set of "naked" resource
	// definitions that we can register with the Pulumi engine.
	//
	// Kubernetes does not instantiate list types like `v1.List`. When the API server receives
	// a list, it will recursively traverse it and perform the necessary operations on
	// each "instantiable" resource it finds. For example, `kubectl apply` on a
	// `v1.ConfigMapList` will cause the API server to traverse the list, and `apply` each
	// `v1.ConfigMap` it finds.
	//
	// Since Kubernetes does not instantiate list types directly, Pulumi also traverses lists
	// for resource definitions that can be managed by Kubernetes, and registers those with the
	// engine instead.
	if obj.IsList() {
		var resources []pulumi.CustomResource
		err := obj.EachListItem(func(o runtime.Object) error {
			obj := o.(*unstructured.Unstructured)
			rs, err := parseUnstructured(ctx, obj, resourcePrefix, skipAwait, opts...)
			if err != nil {
				return err
			}
			resources = append(resources, rs...)
			return nil
		})
		if err != nil {
			return nil, fmt.Errorf("YAML object is invalid: `%s`: %w", printUnstructured(obj), err)
		}
		return resources, nil
	}

	// If we got here, it's not a recursively traversed type, so process it directly.
	// First, validate that it has the requisite metadata and name properties.
	if obj.GetName() == "" {
		return nil, fmt.Errorf("YAML object does not have a .metadata.name: `%s`", printUnstructured(obj))
	}

	// Manufacture a resource name as appropriate, out of the meta name, namespace, and optional prefix.
	resourceName := obj.GetName()
	if obj.GetNamespace() != "" {
		resourceName = fmt.Sprintf("%s/%s", obj.GetNamespace(), obj.GetName())
	}
	if resourcePrefix != "" {
		resourceName = fmt.Sprintf("%s-%s", resourcePrefix, resourceName)
	}

	// Apply the skipAwait annotation if necessary.
	if skipAwait {
		if err := unstructured.SetNestedField(obj.Object, "true", "metadata", "annotations", "pulumi.com/skipAwait"); err != nil {
			return nil, fmt.Errorf("YAML object is invalid: `%s`: %w", printUnstructured(obj), err)
		}
	}

	if fullKind == "v1/Secret" {
		// Always mark these fields as secret to avoid leaking sensitive values from raw YAML.
		for _, key := range []string{"data", "stringData"} {
			if v, ok := obj.Object[key]; ok {
				obj.Object[key] = pulumi.ToSecret(v)
			}
		}
	}

	// Finally allocate a resource of the correct type.
	res, err := yamlv2.RegisterResource(ctx, apiVersion, kind, resourceName, kubernetes.UntypedArgs(obj.Object), opts...)
	if err != nil {
		return nil, err
	}
	return []pulumi.CustomResource{res}, nil
}

func printUnstructured(obj *unstructured.Unstructured) string {
	truncate := func(s string, maxLen int) string {
		runes := []rune(s)
		if len(runes) <= maxLen {
			return s
		}
		return string(runes[0:maxLen-3]) + "..."
	}

	bytes, _ := obj.MarshalJSON()
	return truncate(strings.TrimSpace(string(bytes)), 100)
}
