// Copyright 2016-2021, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package yaml

import (
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/apiextensions"
{{- range .Imports}}
    {{.}}
{{- end}}
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func GetChildOptions(parent pulumi.Resource, opts []pulumi.ResourceOption) ([]pulumi.ResourceOption, error) {
	snapshot, err := pulumi.NewResourceOptions(opts...)
	if err != nil {
		return nil, err
	}
	childOpts := []pulumi.ResourceOption{pulumi.Parent(parent)}
	if snapshot.Version != "" {
		childOpts = append(childOpts, pulumi.Version(snapshot.Version))
	}
	if snapshot.PluginDownloadURL != "" {
		childOpts = append(childOpts, pulumi.PluginDownloadURL(snapshot.PluginDownloadURL))
	}
	return childOpts, nil
}

func GetInvokeOptions(opts []pulumi.ResourceOption) ([]pulumi.InvokeOption, error) {
	snapshot, err := pulumi.NewResourceOptions(opts...)
	if err != nil {
		return nil, err
	}
	var invokeOpts []pulumi.InvokeOption
	if snapshot.Parent != nil {
		invokeOpts = append(invokeOpts, pulumi.Parent(snapshot.Parent))
	}
	if snapshot.Provider != nil {
		invokeOpts = append(invokeOpts, pulumi.Provider(snapshot.Provider))
	}
	if snapshot.Version != "" {
		invokeOpts = append(invokeOpts, pulumi.Version(snapshot.Version))
	}
	if snapshot.PluginDownloadURL != "" {
		invokeOpts = append(invokeOpts, pulumi.PluginDownloadURL(snapshot.PluginDownloadURL))
	}
	return invokeOpts, nil
}

func parseDecodeYamlFiles(ctx *pulumi.Context, args *ConfigGroupArgs, glob bool, opts ...pulumi.ResourceOption,
) (map[string]pulumi.Resource, error) {

	// Start with the provided objects and YAML arrays, if any, and we'll append to them.
	objs := args.Objs
	yamls := args.YAML

	// Start by gathering up any other YAML from files provided.
	for _, file := range args.Files {
		// Read the raw YAML file(s) specified in the input file parameter. It might be a URL or a file path.
		var yaml []byte
		u, err := url.Parse(file)
		if err == nil && u.IsAbs() {
			// If the string looks like a URL, in that it begins with a scheme, fetch it over the network.
			resp, err := http.Get(file)
			if err != nil {
				return nil, errors.Wrapf(err, "fetching YAML over network")
			}
			defer resp.Body.Close()
			yaml, err = io.ReadAll(resp.Body)
			if err != nil {
				return nil, errors.Wrapf(err, "reading YAML over network")
			}
			yamls = append(yamls, string(yaml))
		} else {
			// Otherwise, assume this is a path to a file on disk. If globbing is enabled, we might have
			// multiple files -- otherwise just read a singular file.
			var files []string
			if glob {
				files, err = filepath.Glob(file)
				if err != nil {
					return nil, errors.Wrapf(err, "expanding glob")
				}
			} else {
				files = []string{file}
			}
			for _, f := range files {
				yaml, err = os.ReadFile(f)
				if err != nil {
					return nil, errors.Wrapf(err, "reading YAML file from disk")
				}
				yamls = append(yamls, string(yaml))
			}
		}
	}

	// Next parse all YAML documents into objects.
	invokeOpts, err := GetInvokeOptions(opts)
	if err != nil {
		return nil, err
	}
	for _, yaml := range yamls {
		// Parse the resulting YAML bytes and turn them into raw Kubernetes objects.
		dec, err := yamlDecode(ctx, yaml, invokeOpts...)
		if err != nil {
			return nil, errors.Wrapf(err, "decoding YAML")
		}
		objs = append(objs, dec...)
	}

	transformations := args.Transformations
	if args.SkipAwait {
		transformations = AddSkipAwaitTransformation(transformations)
	}

	// Now process the resulting list of Kubernetes objects.
	return ParseYamlObjects(ctx, objs, transformations, args.ResourcePrefix, opts...)
}

// AddSkipAwaitTransformation adds a transformation to set the "pulumi.com/skipAwait" annotation
func AddSkipAwaitTransformation(transformations []Transformation) []Transformation {
	transformations = append(transformations, func(obj map[string]interface{}, opts ...pulumi.ResourceOption) {
		metadata := obj["metadata"].(map[string]interface{})
		if annotations, ok := metadata["annotations"].(map[string]interface{}); ok {
			annotations["pulumi.com/skipAwait"] = "true"
		} else {
			metadata["annotations"] = map[string]string{"pulumi.com/skipAwait": "true"}
		}
	})

	return transformations
}

// yamlDecode invokes the function to decode a single YAML file and decompose it into object structures.
func yamlDecode(ctx *pulumi.Context, text string, opts ...pulumi.InvokeOption) ([]map[string]interface{}, error) {
	args := struct {
		Text string `pulumi:"text"`
	}{Text: text}
	var ret struct {
		Result []map[string]interface{} `pulumi:"result"`
	}

	if err := ctx.Invoke("kubernetes:yaml:decode", &args, &ret, opts...); err != nil {
		return nil, err
	}
	return ret.Result, nil
}

func ParseYamlObjects(ctx *pulumi.Context, objs []map[string]interface{}, transformations []Transformation,
	resourcePrefix string, opts ...pulumi.ResourceOption,
) (map[string]pulumi.Resource, error) {
	var intermediates []resourceTuple
	for _, obj := range objs {
		res, err := parseYamlObject(ctx, obj, transformations, resourcePrefix, opts...)
		if err != nil {
			return nil, err
		}
		for _, r := range res {
			intermediates = append(intermediates, r)
		}
	}

	resources := map[string]pulumi.Resource{}
	for _, r := range intermediates {
		resources[r.Name] = r.Resource
	}
	return resources, nil
}

type resourceTuple struct {
	Name     string
	Resource pulumi.Resource
}

func parseYamlObject(ctx *pulumi.Context, obj map[string]interface{}, transformations []Transformation,
	resourcePrefix string, opts ...pulumi.ResourceOption,
) ([]resourceTuple, error) {

	// Allow users to change API objects before any validation.
	for _, t := range transformations {
		t(obj, opts...)
	}

	// Ensure there is a kind and API version.
	kind, hasKind := obj["kind"]
	apiVersion, hasAPIVersion := obj["apiVersion"]
	if !hasKind || !hasAPIVersion {
		return nil, errors.Errorf("Kubernetes resources require a kind and apiVersion: %+v", obj)
	}
	fullKind := fmt.Sprintf("%s/%s", apiVersion, kind)

	// Recursively traverse built-in Kubernetes list types into a single set of "naked" resource
	// definitions that we can register with the Pulumi engine.
	//
	// Kubernetes does not instantiate list types like `v1.List`. When the API server receives
	// a list, it will recursively traverse it and perform the necessary operations on the
	// each "instantiable" resource it finds. For example, `kubectl apply` on a
	// `v1.ConfigMapList` will cause the API server to traverse the list, and `apply` each
	// `v1.ConfigMap` it finds.
	//
	// Since Kubernetes does not instantiate list types directly, Pulumi also traverses lists
	// for resource definitions that can be managed by Kubernetes, and registers those with the
	// engine instead.
	switch fullKind {
	case "v1/List",
	    {{range $idx, $v := .ListKinds -}} {{if $idx}},
	    {{end}}"{{$v.GVK}}" {{- end}}:
		var resources []resourceTuple
		if rawItems, hasItems := obj["items"]; hasItems {
			if items, ok := rawItems.([]interface{}); ok {
				for _, item := range items {
					if obj, ok := item.(map[string]interface{}); ok {
						rs, err := parseYamlObject(ctx, obj, transformations, resourcePrefix, opts...)
						if err != nil {
							return nil, err
						}
						for _, r := range rs {
							resources = append(resources, r)
						}
					}
				}
			}
		}
		return resources, nil
	}

	// If we got here, it's not a recursively traversed type, so process it directly.
	// First, validate that it has the requisite metadata and name properties.
	meta, hasMeta := obj["metadata"]
	if !hasMeta {
		return nil, errors.Errorf("YAML object does not have a .metadata field: %s %+v", fullKind, obj)
	}
	metaDict, hasMetaDict := meta.(map[string]interface{})
	if !hasMetaDict {
		return nil, errors.Errorf("YAML object does not have a .metadata dictionary: %s %+v", fullKind, obj)
	}
	metaName, hasMetaName := metaDict["name"].(string)
	if !hasMetaName || metaName == "" {
		return nil, errors.Errorf("YAML object does not have a .metadata.name: %s %+v", fullKind, obj)
	}

	// Manufacture a name as appropriate, out of the meta name, namespace, and optional prefix.
	if ns, hasNS := metaDict["namespace"]; hasNS {
		metaName = fmt.Sprintf("%s/%s", ns, metaName)
	}
	if resourcePrefix != "" {
		metaName = fmt.Sprintf("%s-%s", resourcePrefix, metaName)
	}

	key := fmt.Sprintf("%s::%s", fullKind, metaName)

	if fullKind == "v1/Secret" {
		// Always mark these fields as secret to avoid leaking sensitive values from raw YAML.
		for _, key := range []string{"data", "stringData"} {
			if _, ok := obj[key]; ok {
				obj[key] = pulumi.ToSecret(obj[key])
			}
		}
	}

	// Finally allocate a resource of the correct type.
	switch fullKind {
{{- range .NonListKinds}}
    case "{{.GVK}}":
        var res {{.Alias}}.{{.Name}}
		err := ctx.RegisterResource("{{.Token}}", metaName, kubernetes.UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		{{`return []resourceTuple{{Name: key, Resource: &res}}, nil`}}
{{- end}}
	default:
		var res apiextensions.CustomResource
		err := ctx.RegisterResource(fmt.Sprintf("kubernetes:%s:%s", apiVersion, kind), metaName, kubernetes.UntypedArgs(obj), &res, opts...)
		if err != nil {
			return nil, err
		}
		{{`return []resourceTuple{{Name: key, Resource: &res}}, nil`}}
	}
}
