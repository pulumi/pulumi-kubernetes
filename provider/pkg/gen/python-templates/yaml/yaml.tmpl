# *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import json
from copy import copy
from inspect import getargspec
from typing import Callable, Dict, List, Optional

import pulumi.runtime
import requests
from pulumi_kubernetes.apiextensions import CustomResource
from . import tables
from .utilities import get_version


class ConfigFile(pulumi.ComponentResource):
    """
    ConfigFile creates a set of Kubernetes resources from a Kubernetes YAML file.
    """

    resources: pulumi.Output[dict]
    """
    Kubernetes resources contained in this ConfigFile.
    """

    def __init__(self, name, file_id, opts=None, transformations=None, resource_prefix=None):
        """
        :param str name: A name for a resource.
        :param str file_id: Path or a URL that uniquely identifies a file.
        :param Optional[pulumi.ResourceOptions] opts: A bag of optional settings that control a resource's behavior.
        :param Optional[List[Tuple[Callable, Optional[pulumi.ResourceOptions]]]] transformations: A set of
               transformations to apply to Kubernetes resource definitions before registering with engine.
        :param Optional[str] resource_prefix: An optional prefix for the auto-generated resource names.
               Example: A resource created with resource_prefix="foo" would produce a resource named "foo-resourceName".
        """
        if not name:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(name, str):
            raise TypeError('Expected resource name to be a string')
        if opts and not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if resource_prefix:
            name = f"{resource_prefix}-{name}"
        super(ConfigFile, self).__init__(
            "kubernetes:yaml:ConfigFile",
            name,
            __props__,
            opts)

        if file_id.startswith('http://') or file_id.startswith('https://'):
            text = _read_url(file_id)
        else:
            text = _read_file(file_id)

        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(parent=self))

        # Rather than using the default provider for the following invoke call, use the version specified
        # in package.json.
        invoke_opts = pulumi.InvokeOptions(version=get_version())

        __ret__ = pulumi.runtime.invoke('kubernetes:yaml:decode', {'text': text}, invoke_opts).value['result']

        # Note: Unlike NodeJS, Python requires that we "pull" on our futures in order to get them scheduled for
        # execution. In order to do this, we leverage the engine's RegisterResourceOutputs to wait for the
        # resolution of all resources that this YAML document created.
        self.resources = _parse_yaml_document(__ret__, opts, transformations, resource_prefix)
        self.register_outputs({"resources": self.resources})

    def translate_output_property(self, prop: str) -> str:
        return tables._CASING_FORWARD_TABLE.get(prop) or prop

    def translate_input_property(self, prop: str) -> str:
        return tables._CASING_BACKWARD_TABLE.get(prop) or prop

    def get_resource(self, group_version_kind, name, namespace=None) -> pulumi.Output[pulumi.CustomResource]:
        """
        get_resource returns a resource defined by a built-in Kubernetes group/version/kind and
        name. For example: `get_resource("apps/v1/Deployment", "nginx")`

        :param str group_version_kind: Group/Version/Kind of the resource, e.g., `apps/v1/Deployment`
        :param str name: Name of the resource to retrieve
        :param str namespace: Optional namespace of the resource to retrieve
        """

        # `id` will either be `${name}` or `${namespace}/${name}`.
        id = pulumi.Output.from_input(name)
        if namespace is not None:
            id = pulumi.Output.concat(namespace, '/', name)

        resource_id = id.apply(lambda x: f'{group_version_kind}:{x}')
        return resource_id.apply(lambda x: self.resources[x])


def _read_url(url: str) -> str:
    response = requests.get(url)
    response.raise_for_status()

    return response.text


def _read_file(path: str) -> str:
    with open(path, 'r') as file:
        data = file.read()

    return data


def _build_resources_dict(objs: List[pulumi.Output]) -> Dict[pulumi.Output, pulumi.Output]:
    return {key: value for key, value in objs}


def _parse_yaml_document(
        objects, opts: Optional[pulumi.ResourceOptions] = None,
        transformations: Optional[List[Callable]] = None,
        resource_prefix: Optional[str] = None
) -> pulumi.Output:
    objs = []
    for obj in objects:
        file_objects = _parse_yaml_object(obj, opts, transformations, resource_prefix)
        for file_object in file_objects:
            objs.append(file_object)

    return pulumi.Output.all(*objs).apply(_build_resources_dict)


def _parse_yaml_object(
        obj, opts: Optional[pulumi.ResourceOptions] = None,
        transformations: Optional[List[Callable]] = None,
        resource_prefix: Optional[str] = None
) -> [pulumi.Output]:
    """
    _parse_yaml_object parses a YAML manifest object, and creates the specified resources.
    """

    if not obj:
        return []

    # Create a copy of opts to pass into potentially mutating transforms that will be applied to this resource.
    if opts is not None:
        opts = copy(opts)
    else:
        opts = {}

    # Allow users to change API objects before any validation.
    if transformations is not None:
        for t in transformations:
            if len(getargspec(t)[0]) == 2:
                t(obj, opts)
            else:
                t(obj)

    if "kind" not in obj or "apiVersion" not in obj:
        raise Exception("Kubernetes resources require a kind and apiVersion: {}".format(json.dumps(obj)))

    api_version = obj["apiVersion"]
    kind = obj["kind"]

    # Don't pass these items as kwargs to the resource classes.
    del obj['apiVersion']
    del obj['kind']

    if kind.endswith("List"):
        objs = []
        if "items" in obj:
            for item in obj["items"]:
                objs += _parse_yaml_object(item, opts, transformations, resource_prefix)
        return objs

    if "metadata" not in obj or "name" not in obj["metadata"]:
        raise Exception("YAML object does not have a .metadata.name: {}/{} {}".format(
            api_version, kind, json.dumps(obj)))

    # Convert obj keys to Python casing
    for key in list(obj.keys()):
        new_key = tables._CASING_FORWARD_TABLE.get(key) or key
        if new_key != key:
            obj[new_key] = obj.pop(key)

    metadata = obj["metadata"]
    spec = obj.get("spec")
    identifier: pulumi.Output = pulumi.Output.from_input(metadata["name"])
    if "namespace" in metadata:
        identifier = pulumi.Output.from_input(metadata).apply(
            lambda metadata: f"{metadata['namespace']}/{metadata['name']}")
    if resource_prefix:
        identifier = pulumi.Output.from_input(identifier).apply(
            lambda identifier: f"{resource_prefix}-{identifier}")

    gvk = f"{api_version}/{kind}"
{{- range .Resources}}
    if gvk == "{{.GVK}}":
        # Import locally to avoid name collisions.
        from pulumi_kubernetes.{{.Package}} import {{.Name}}
        return [identifier.apply(
            lambda x: (f"{{.GVK}}:{x}",
                       {{.Name}}(f"{x}", opts, **obj)))]
{{- end}}
    return [identifier.apply(
        lambda x: (f"{gvk}:{x}",
                   CustomResource(f"{x}", api_version, kind, spec, metadata, opts)))]
