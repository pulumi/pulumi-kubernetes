# *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import json
import warnings
from copy import copy
from glob import glob
from inspect import getfullargspec
from typing import Any, Callable, List, Mapping, Optional, Sequence

import pulumi
import pulumi.runtime
import requests
from pulumi_kubernetes.apiextensions import CustomResource

from . import _utilities, _tables

__all__ = ['ConfigFile', 'ConfigGroup']


class ConfigGroup(pulumi.ComponentResource):
    resources: pulumi.Output[dict]
    """
    Kubernetes resources contained in this ConfigGroup.
    """

    def __init__(self,
                 name: str,
                 files: Optional[Sequence[str]] = None,
                 yaml: Optional[Sequence[str]] = None,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 transformations: Optional[Sequence[Callable[[Any, pulumi.ResourceOptions], None]]] = None,
                 resource_prefix: Optional[str] = None):
        """
        ConfigGroup creates a set of Kubernetes resources from Kubernetes YAML text. The YAML text
        may be supplied using any of the following methods:

        1. Using a filename or a list of filenames:
        2. Using a file pattern or a list of file patterns:
        3. Using a literal string containing YAML, or a list of such strings:
        4. Any combination of files, patterns, or YAML strings:

        ## Example Usage
        ### Local File

        ```python
        from pulumi_kubernetes.yaml import ConfigGroup

        example = ConfigGroup(
            "example",
            files=["foo.yaml"],
        )
        ```
        ### Multiple Local File

        ```python
        from pulumi_kubernetes.yaml import ConfigGroup

        example = ConfigGroup(
            "example",
            files=["foo.yaml", "bar.yaml"],
        )
        ```
        ### Local File Pattern

        ```python
        from pulumi_kubernetes.yaml import ConfigGroup

        example = ConfigGroup(
            "example",
            files=["yaml/*.yaml"],
        )
        ```
        ### Multiple Local File Patterns

        ```python
        from pulumi_kubernetes.yaml import ConfigGroup

        example = ConfigGroup(
            "example",
            files=["foo/*.yaml", "bar/*.yaml"],
        )
        ```
        ### Literal YAML String

        ```python
        from pulumi_kubernetes.yaml import ConfigGroup

        example = ConfigGroup(
            "example",
            yaml=['''
        apiVersion: v1
        kind: Namespace
        metadata:
          name: foo
        ''']
        )
        ```
        ### YAML with Transformations

        ```python
        from pulumi_kubernetes.yaml import ConfigGroup

        # Make every service private to the cluster, i.e., turn all services into ClusterIP instead of LoadBalancer.
        def make_service_private(obj, opts):
            if obj["kind"] == "Service" and obj["apiVersion"] == "v1":
                try:
                    t = obj["spec"]["type"]
                    if t == "LoadBalancer":
                        obj["spec"]["type"] = "ClusterIP"
                except KeyError:
                    pass


        # Set a resource alias for a previous name.
        def alias(obj, opts):
            if obj["kind"] == "Deployment":
                opts.aliases = ["oldName"]


        # Omit a resource from the Chart by transforming the specified resource definition to an empty List.
        def omit_resource(obj, opts):
            if obj["kind"] == "Pod" and obj["metadata"]["name"] == "test":
                obj["apiVersion"] = "v1"
                obj["kind"] = "List"


        example = ConfigGroup(
            "example",
            files=["foo.yaml"],
            transformations=[make_service_private, alias, omit_resource],
        )
        ```

        :param str name: A name for a resource.
        :param Optional[Sequence[str]] files: Set of paths or a URLs that uniquely identify files.
        :param Optional[Sequence[str]] yaml: YAML text containing Kubernetes resource definitions.
        :param Optional[pulumi.ResourceOptions] opts: A bag of optional settings that control a resource's behavior.
        :param Optional[Sequence[Callable[[Any, pulumi.ResourceOptions], None]]] transformations: A set of
               transformations to apply to Kubernetes resource definitions before registering with engine.
        :param Optional[str] resource_prefix: An optional prefix for the auto-generated resource names.
               Example: A resource created with resource_prefix="foo" would produce a resource named "foo-resourceName".
        """
        if not name:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(name, str):
            raise TypeError('Expected resource name to be a string')
        if opts and not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if not files:
            files = []
        if not yaml:
            yaml = []

        __props__ = dict()

        if resource_prefix:
            name = f"{resource_prefix}-{name}"
        super(ConfigGroup, self).__init__(
            "kubernetes:yaml:ConfigGroup",
            name,
            __props__,
            opts)

        self.resources = pulumi.Output.from_input({})

        _files: List[str] = []
        for file in files:
            if _is_url(file):
                _files.append(file)
            else:
                _files += [f for f in glob(file)]

        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(parent=self))

        for file in _files:
            cf = ConfigFile(
                file, file_id=file, transformations=transformations, resource_prefix=resource_prefix, opts=opts)
            # Add any new ConfigFile resources to the ConfigGroup's resources
            self.resources = pulumi.Output.all(cf.resources, self.resources).apply(lambda x: {**x[0], **x[1]})

        for text in yaml:
            # Rather than using the default provider for the following invoke call, use the version specified
            # in package.json.
            invoke_opts = pulumi.InvokeOptions(version=_utilities.get_version())

            __ret__ = pulumi.runtime.invoke('kubernetes:yaml:decode', {'text': text}, invoke_opts).value['result']
            resources = _parse_yaml_document(__ret__, opts, transformations, resource_prefix)
            # Add any new YAML resources to the ConfigGroup's resources
            self.resources = pulumi.Output.all(resources, self.resources).apply(lambda x: {**x[0], **x[1]})

        # Note: Unlike NodeJS, Python requires that we "pull" on our futures in order to get them scheduled for
        # execution. In order to do this, we leverage the engine's RegisterResourceOutputs to wait for the
        # resolution of all resources that this YAML document created.
        self.register_outputs({"resources": self.resources})

    def translate_output_property(self, prop: str) -> str:
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop

    def translate_input_property(self, prop: str) -> str:
        return _tables.SNAKE_TO_CAMEL_CASE_TABLE.get(prop) or prop

    def get_resource(self,
                     group_version_kind: str,
                     name: str,
                     namespace: Optional[str] = None) -> pulumi.Output[pulumi.CustomResource]:
        """
        get_resource returns a resource defined by a built-in Kubernetes group/version/kind and
        name. For example: `get_resource("apps/v1/Deployment", "nginx")`

        :param str group_version_kind: Group/Version/Kind of the resource, e.g., `apps/v1/Deployment`
        :param str name: Name of the resource to retrieve
        :param Optional[str] namespace: Optional namespace of the resource to retrieve
        """

        # `id` will either be `${name}` or `${namespace}/${name}`.
        id = pulumi.Output.from_input(name)
        if namespace is not None:
            id = pulumi.Output.concat(namespace, '/', name)

        resource_id = id.apply(lambda x: f'{group_version_kind}:{x}')
        return resource_id.apply(lambda x: self.resources[x])


class ConfigFile(pulumi.ComponentResource):
    resources: pulumi.Output[dict]
    """
    Kubernetes resources contained in this ConfigFile.
    """

    def __init__(self,
                 name: str,
                 file: Optional[str] = None,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 transformations: Optional[Sequence[Callable[[Any, pulumi.ResourceOptions], None]]] = None,
                 resource_prefix: Optional[str] = None,
                 file_id: Optional[str] = None):
        """
        ConfigFile creates a set of Kubernetes resources from a Kubernetes YAML file.

        ## Example Usage
        ### Local File

        ```python
        from pulumi_kubernetes.yaml import ConfigFile

        example = ConfigFile(
            "example",
            file="foo.yaml",
        )
        ```
        ### YAML with Transformations

        ```python
        from pulumi_kubernetes.yaml import ConfigFile

        # Make every service private to the cluster, i.e., turn all services into ClusterIP instead of LoadBalancer.
        def make_service_private(obj, opts):
            if obj["kind"] == "Service" and obj["apiVersion"] == "v1":
                try:
                    t = obj["spec"]["type"]
                    if t == "LoadBalancer":
                        obj["spec"]["type"] = "ClusterIP"
                except KeyError:
                    pass


        # Set a resource alias for a previous name.
        def alias(obj, opts):
            if obj["kind"] == "Deployment":
                opts.aliases = ["oldName"]


        # Omit a resource from the Chart by transforming the specified resource definition to an empty List.
        def omit_resource(obj, opts):
            if obj["kind"] == "Pod" and obj["metadata"]["name"] == "test":
                obj["apiVersion"] = "v1"
                obj["kind"] = "List"


        example = ConfigFile(
            "example",
            file="foo.yaml",
            transformations=[make_service_private, alias, omit_resource],
        )
        ```

        :param str name: A name for a resource.
        :param Optional[str] file: Path or a URL that uniquely identifies a file.
        :param Optional[pulumi.ResourceOptions] opts: A bag of optional settings that control a resource's behavior.
        :param Optional[Sequence[Callable[[Any, pulumi.ResourceOptions], None]]] transformations: A set of
               transformations to apply to Kubernetes resource definitions before registering with engine.
        :param Optional[str] resource_prefix: An optional prefix for the auto-generated resource names.
               Example: A resource created with resource_prefix="foo" would produce a resource named "foo-resourceName".
        """
        if not name:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(name, str):
            raise TypeError('Expected resource name to be a string')
        if opts and not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if resource_prefix:
            name = f"{resource_prefix}-{name}"
        super(ConfigFile, self).__init__(
            "kubernetes:yaml:ConfigFile",
            name,
            __props__,
            opts)

        if file_id is not None:
            warnings.warn("explicit use of file_id is deprecated, use 'file' instead", DeprecationWarning)
            file = file_id
        if file is None:
            raise TypeError("Missing file argument")

        if _is_url(file):
            text = _read_url(file)
        else:
            text = _read_file(file)

        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(parent=self))

        # Rather than using the default provider for the following invoke call, use the version specified
        # in package.json.
        invoke_opts = pulumi.InvokeOptions(version=_utilities.get_version())

        __ret__ = pulumi.runtime.invoke('kubernetes:yaml:decode', {'text': text}, invoke_opts).value['result']

        # Note: Unlike NodeJS, Python requires that we "pull" on our futures in order to get them scheduled for
        # execution. In order to do this, we leverage the engine's RegisterResourceOutputs to wait for the
        # resolution of all resources that this YAML document created.
        self.resources = _parse_yaml_document(__ret__, opts, transformations, resource_prefix)
        self.register_outputs({"resources": self.resources})

    def translate_output_property(self, prop: str) -> str:
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop

    def translate_input_property(self, prop: str) -> str:
        return _tables.SNAKE_TO_CAMEL_CASE_TABLE.get(prop) or prop

    def get_resource(self,
                     group_version_kind: str,
                     name: str,
                     namespace: Optional[str] = None) -> pulumi.Output[pulumi.CustomResource]:
        """
        get_resource returns a resource defined by a built-in Kubernetes group/version/kind and
        name. For example: `get_resource("apps/v1/Deployment", "nginx")`

        :param str group_version_kind: Group/Version/Kind of the resource, e.g., `apps/v1/Deployment`
        :param str name: Name of the resource to retrieve
        :param Optional[str] namespace: Optional namespace of the resource to retrieve
        """

        # `id` will either be `${name}` or `${namespace}/${name}`.
        id = pulumi.Output.from_input(name)
        if namespace is not None:
            id = pulumi.Output.concat(namespace, '/', name)

        resource_id = id.apply(lambda x: f'{group_version_kind}:{x}')
        return resource_id.apply(lambda x: self.resources[x])


def _is_url(url: str) -> bool:
    return url.startswith('http://') or url.startswith('https://')


def _read_url(url: str) -> str:
    response = requests.get(url)
    response.raise_for_status()

    return response.text


def _read_file(path: str) -> str:
    with open(path, 'r') as file:
        data = file.read()

    return data


def _build_resources_dict(objs: Sequence[pulumi.Output]) -> Mapping[pulumi.Output, pulumi.Output]:
    return {key: value for key, value in objs}


def _parse_yaml_document(
        objects, opts: Optional[pulumi.ResourceOptions] = None,
        transformations: Optional[Sequence[Callable]] = None,
        resource_prefix: Optional[str] = None
) -> pulumi.Output:
    objs = []
    for obj in objects:
        file_objects = _parse_yaml_object(obj, opts, transformations, resource_prefix)
        for file_object in file_objects:
            objs.append(file_object)

    return pulumi.Output.all(*objs).apply(_build_resources_dict)


def _parse_yaml_object(
        obj, opts: Optional[pulumi.ResourceOptions] = None,
        transformations: Optional[Sequence[Callable]] = None,
        resource_prefix: Optional[str] = None
) -> [pulumi.Output]:
    """
    _parse_yaml_object parses a YAML manifest object, and creates the specified resources.
    """

    if not obj:
        return []

    # Create a copy of opts to pass into potentially mutating transforms that will be applied to this resource.
    if opts is not None:
        opts = copy(opts)
    else:
        opts = {}

    # Allow users to change API objects before any validation.
    if transformations is not None:
        for t in transformations:
            if len(getfullargspec(t)[0]) == 2:
                t(obj, opts)
            else:
                t(obj)

    if "kind" not in obj or "apiVersion" not in obj:
        raise Exception("Kubernetes resources require a kind and apiVersion: {}".format(json.dumps(obj)))

    api_version = obj["apiVersion"]
    kind = obj["kind"]

    # Don't pass these items as kwargs to the resource classes.
    del obj['apiVersion']
    del obj['kind']

    if kind.endswith("List"):
        objs = []
        if "items" in obj:
            for item in obj["items"]:
                objs += _parse_yaml_object(item, opts, transformations, resource_prefix)
        return objs

    if "metadata" not in obj or "name" not in obj["metadata"]:
        raise Exception("YAML object does not have a .metadata.name: {}/{} {}".format(
            api_version, kind, json.dumps(obj)))

    # Convert obj keys to Python casing
    for key in list(obj.keys()):
        new_key = _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(key) or key
        if new_key != key:
            obj[new_key] = obj.pop(key)

    metadata = obj["metadata"]
    spec = obj.get("spec")
    identifier: pulumi.Output = pulumi.Output.from_input(metadata["name"])
    if "namespace" in metadata:
        identifier = pulumi.Output.from_input(metadata).apply(
            lambda metadata: f"{metadata['namespace']}/{metadata['name']}")
    if resource_prefix:
        identifier = pulumi.Output.from_input(identifier).apply(
            lambda identifier: f"{resource_prefix}-{identifier}")

    gvk = f"{api_version}/{kind}"
{{- range .Resources}}
    if gvk == "{{.GVK}}":
        # Import locally to avoid name collisions.
        from pulumi_kubernetes.{{.Package}} import {{.Name}}
        return [identifier.apply(
            lambda x: (f"{{.GVK}}:{x}",
                       {{.Name}}(f"{x}", opts, **obj)))]
{{- end}}
    return [identifier.apply(
        lambda x: (f"{gvk}:{x}",
                   CustomResource(f"{x}", api_version, kind, spec, metadata, opts)))]
