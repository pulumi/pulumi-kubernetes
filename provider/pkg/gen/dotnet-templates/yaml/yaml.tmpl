// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.Json;
using GlobExpressions;
using Pu = Pulumi;

#pragma warning disable CS0618

namespace Pulumi.Kubernetes.Yaml
{
    /// <summary>
    /// Base component for containers of Kubernetes resources.
    /// </summary>
    public abstract class CollectionComponentResource : ComponentResource
    {
        internal Output<ImmutableDictionary<string, KubernetesResource>> Resources { get; private set; } = null!;

        protected CollectionComponentResource(string type, string name, ComponentResourceOptions? options = null)
            : base(type, name, options)
        {
        }

        protected void RegisterResources(Output<ImmutableDictionary<string, KubernetesResource>> resources)
        {
            Resources = resources;
            RegisterOutputs(new Dictionary<string, object?> { { "resources", resources } });
        }

        /// <summary>
        /// Returns a resource defined by the given name.
        /// </summary>
        /// <param name="name">Resource name.</param>
        /// <param name="namespaceName">Optional namespace, e.g. "kube-prometheus-exporter-kubernetes".</param>
        /// <typeparam name="T">The type of the resource.</typeparam>
        public Output<T> GetResource<T>(string name, string? namespaceName = null)
            where T : KubernetesResource
        {
            var type = typeof(T);
            string groupVersionKind;
            switch(type)
            {
{{- range .Resources}}
                case var t when t == typeof({{.Package}}.{{.Name}}):
                    groupVersionKind = "{{.GVK}}";
                    break;
{{- end}}
                default:
                    throw new ArgumentException($"Unknown resource type {typeof(T).FullName}");
            }
            var id = namespaceName != null ? $"{namespaceName}/{name}" : name;
            return Resources.Apply(r =>
            {
                if (!r.TryGetValue($"{groupVersionKind}::{id}", out var value))
                {
                    var existingKeys = string.Join(", ", r.Keys);
                    throw new ArgumentException($"Resource {groupVersionKind}::{id} of type {type.FullName} and id {id} is not found, existing resources are {existingKeys}");
                }

                return (T) value;
            });
        }

        /// <summary>
        /// Returns an array of ready resources to be used by DependsOn.
        /// </summary>
        public Output<ImmutableArray<Pu.Resource>> Ready()
        {
            return Resources.Apply(resources => resources.Values.Cast<Pu.Resource>().ToImmutableArray());
        }

        /// <summary>
        /// Returns a custom resource defined by the given group/version/kind and name.
        /// </summary>
        /// <param name="groupVersionKind">Group/version/kind, e.g. "monitoring.coreos.com/v1/ServiceMonitor".
        /// </param>
        /// <param name="name">Resource name.</param>
        /// <param name="namespaceName">Optional namespace, e.g. "kube-prometheus-exporter-kubernetes".</param>
        public Output<CustomResource> GetCustomResource(string groupVersionKind, string name, string? namespaceName = null)
        {
            var id = namespaceName != null ? $"{namespaceName}/{name}" : name;
            return Resources.Apply(r => (CustomResource)r[$"{groupVersionKind}::{id}"]);
        }

        internal static CustomResourceOptions GetChildOptions(Pu.Resource parent, InputList<Pu.Resource>? extraDependsOn, ComponentResourceOptions? options)
        {
            // Create resource options based on component resource options.
            var dependsOn = new InputList<Pu.Resource>();
            if (extraDependsOn is not null)
                dependsOn.AddRange(extraDependsOn);
            return new CustomResourceOptions
            {
                Parent = parent,
                DependsOn = dependsOn,
                Version = options?.Version,
                PluginDownloadURL = options?.PluginDownloadURL,
            };
        }

        internal static ComponentResourceOptions ConvertChildOptions(CustomResourceOptions options)
        {
            var dependsOn = new InputList<Pu.Resource>();
            if (options is not null)
                dependsOn.AddRange(options.DependsOn);
            return new ComponentResourceOptions
            {
                Aliases = options.Aliases.ToList(),
                DependsOn = dependsOn,
                Parent = options.Parent,
                ResourceTransformations = options.ResourceTransformations.ToList(),
                Version = options.Version,
                PluginDownloadURL = options.PluginDownloadURL,
            };
        }

        internal static InvokeOptions GetInvokeOptions(CustomResourceOptions? options)
        {
            return new InvokeOptions { 
                Parent = options?.Parent,
                Provider = options?.Provider,
                Version = options?.Version,
                PluginDownloadURL = options?.PluginDownloadURL,
            }.WithDefaults();
        }

        internal static ResourceTransformation Aliased(Pulumi.Resource parent, Pulumi.Resource? oldParent = null) {
            return new ResourceTransformation((args) => {
                if (!Object.ReferenceEquals(args.Options?.Parent, parent)) {
                    return null;
                }

                var alias = new Alias { 
                    Parent = oldParent,
                    Name = args.Resource.GetResourceName(),
                    Type = args.Resource.GetResourceType(),
                };
                if (args.Options is ComponentResourceOptions options1)
                {
                    var options = ComponentResourceOptions.Merge(
                        options1,
                        new ComponentResourceOptions { Aliases = {alias} });
                    return new ResourceTransformationResult(args.Args, options);
                }
                if (args.Options is CustomResourceOptions options2)
                {
                    var options = CustomResourceOptions.Merge(
                        options2,
                        new CustomResourceOptions { Aliases = {alias} });
                    return new ResourceTransformationResult(args.Args, options);
                }
                return null;
            });
        }
    }

    internal static class Parser
    {
        public static Output<ImmutableDictionary<string, KubernetesResource>> Parse(ConfigGroupArgs config, CustomResourceOptions options,
            Pulumi.Resource? aliasParent = null)
        {
            var resources = Output.Create(ImmutableDictionary.Create<string, KubernetesResource>());

            var transformations = config.Transformations;
            if (config?.SkipAwait == true)
            {
                transformations.Add(SkipAwait);
            }

            if (config.Files != null)
            {
                var files = new List<string>();
                foreach (var file in config.Files)
                {
                    if (IsUrl(file))
                        files.Add(file);
                    else
                        files.AddRange(Glob.Files(Directory.GetCurrentDirectory(), file));
                }

                foreach (var file in files)
                {
                    var cfOptions = CollectionComponentResource.ConvertChildOptions(options);
                    var cfArgs = new ConfigFileArgs
                    {
                        File = file,
                        Transformations = transformations,
                        ResourcePrefix = config.ResourcePrefix
                    };

                    var cf = new ConfigFile(file, cfArgs, cfOptions, aliasParent);
                    resources = Output.Tuple(resources, cf.Resources).Apply(vs => vs.Item1.AddRange(vs.Item2));
                }
            }

            if (config.Yaml != null)
            {
                var invokeOpts = CollectionComponentResource.GetInvokeOptions(options);
                var yamlResources = config.Yaml.ToOutput().Apply(texts =>
                {
                    var yamls = texts
                        .Select(text =>
                            ParseYamlDocument(new ParseArgs
                            {
                                Objs = Invokes.YamlDecode(new YamlDecodeArgs { Text = text }, invokeOpts),
                                Transformations = transformations,
                                ResourcePrefix = config.ResourcePrefix
                            }, options))
                        .Select(output => (Input<ImmutableDictionary<string, KubernetesResource>>)output)
                        .ToImmutableArray();
                    return Output.All(yamls);
                });

                resources = Output.Tuple(resources, yamlResources).Apply(vs =>
                {
                    var builder = ImmutableDictionary.CreateBuilder<string, KubernetesResource>();
                    builder.AddRange(vs.Item1);
                    foreach (var bs in vs.Item2)
                        builder.AddRange(bs);
                    return builder.ToImmutable();
                });
            }

            if (config.Objs != null)
            {
                var docResources = ParseYamlDocument(new ParseArgs
                {
                    Objs = config.Objs,
                    Transformations = transformations,
                    ResourcePrefix = config.ResourcePrefix
                }, options);
                resources = Output.Tuple(resources, docResources).Apply(vs => vs.Item1.AddRange(vs.Item2));
            }

            return resources;

        }

        // Define a transformation to set the skipAwait annotation on resources.
        internal static ImmutableDictionary<string, object> SkipAwait(ImmutableDictionary<string, object> obj, CustomResourceOptions opts)
        {
            var metadata = (ImmutableDictionary<string, object>)obj["metadata"];
            if (metadata.ContainsKey("annotations"))
            {
                var annotations = (ImmutableDictionary<string, object>)metadata["annotations"];
                annotations = annotations.SetItem("pulumi.com/skipAwait", "true");
                metadata = metadata.SetItem("annotations", annotations);
                obj = obj.SetItem("metadata", metadata);
            }
            else
            {
                var annotations = new Dictionary<string, string> { { "pulumi.com/skipAwait", "true" } }.ToImmutableDictionary();
                metadata = metadata.SetItem("annotations", annotations);
                obj = obj.SetItem("metadata", metadata);
            }

            return obj;
        }

        internal static bool IsUrl(string s)
            => s.StartsWith("http://", StringComparison.Ordinal) || s.StartsWith("https://", StringComparison.Ordinal);

        internal static Output<ImmutableDictionary<string, KubernetesResource>> ParseYamlDocument(ParseArgs config,
            CustomResourceOptions? options = null)
        {
            return config.Objs.ToOutput().Apply(objs =>
            {

                var inputs = objs
                    .SelectMany(obj => ParseYamlObject(obj, config.Transformations, config.ResourcePrefix, options))
                    .Select(output => (Input<(string, KubernetesResource)>) output)
                    .ToImmutableArray();

                return Output.All(inputs)
                    .Apply(items =>
                        items.Select(obj => new KeyValuePair<string, KubernetesResource>(obj.Item1, obj.Item2))
                             .ToImmutableDictionary());
            });
        }

        private static Output<(string, KubernetesResource)>[] ParseYamlObject(ImmutableDictionary<string, object> obj,
            List<TransformationAction>? transformations, string? resourcePrefix, CustomResourceOptions? options = null)
        {
            if (obj == null || obj.Count == 0)
                return new Output<(string, KubernetesResource)>[0];

            // Create a copy of options to pass into potentially mutating transforms that will be applied to this resource.
            var opts = CustomResourceOptions.Merge(null, options);

            // Allow users to change API objects before any validation.
            if (transformations != null)
            {
                foreach (var transform in transformations)
                    obj = transform(obj, opts);
            }

            if (!(obj.ContainsKey("kind") && obj.ContainsKey("apiVersion")))
            {
                var serialized = JsonSerializer.Serialize(obj);
                throw new FormatException($"Kubernetes resources require a kind and apiVersion: {serialized}");
            }

            var kind = (string)obj["kind"];
            var apiVersion = (string)obj["apiVersion"];
            var gvk = $"{apiVersion}/{kind}";

            // Recursively traverse built-in Kubernetes list types into a single set of "naked" resource
            // definitions that we can register with the Pulumi engine.
            //
            // Kubernetes does not instantiate list types like `v1.List`. When the API server receives
            // a list, it will recursively traverse it and perform the necessary operations on the
            // each "instantiable" resource it finds. For example, `kubectl apply` on a
            // `v1.ConfigMapList` will cause the API server to traverse the list, and `apply` each
            // `v1.ConfigMap` it finds.
            //
            // Since Kubernetes does not instantiate list types directly, Pulumi also traverses lists
            // for resource definitions that can be managed by Kubernetes, and registers those with the
            // engine instead.
            if (
                gvk == "v1/List"
{{- range .ListKinds}}
                || gvk == "{{.GVK}}"
{{- end}}
               )
            {
                var objs = new List<Output<(string, KubernetesResource)>>();
                if (obj["items"] is IEnumerable<ImmutableDictionary<string, object>> items)
                {
                    foreach (var item in items)
                        objs.AddRange(Parser.ParseYamlObject(item, transformations, resourcePrefix, opts));
                }
                return objs.ToArray();
            }

            if (!obj.ContainsKey("metadata") || !(obj["metadata"] is ImmutableDictionary<string, object> metadata)
                || !metadata.ContainsKey("name"))
            {
                var serialized = obj.TryGetValue("metadata", out var m) ? JsonSerializer.Serialize(m) : "<null>";
                throw new FormatException($"YAML object does not have a .metadata.name: {apiVersion}/{kind} {serialized}");
            }

            var meta = (ImmutableDictionary<string, object>)obj["metadata"];
            var id = Output.Create((string)meta["name"]);
            if (meta.TryGetValue("namespace", out object ns))
                id = Output.Format($"{ns}/{id}");
            if (resourcePrefix != null)
                id = Output.Format($"{resourcePrefix}-{id}");

            if (gvk == "v1/Secret")
            {
                // Always mark these fields as secret to avoid leaking sensitive values from raw YAML.
                foreach (string key in new string[]{"data", "stringData"})
                {
                    if (obj.ContainsKey(key))
                    {
                        obj = obj.SetItem(key, Output.CreateSecret(obj[key]));
                    }
                }
            }

            switch (gvk)
            {
{{- range .NonListKinds}}
                    case "{{.GVK}}":
                        return new[]
                        {
                            id.Apply(id => ($"{{.GVK}}::{id}",
                                new {{.Package}}.{{.Name}}(id, obj!, opts) as KubernetesResource))
                        };
{{- end}}
                default:
                    return new[]
                    {
                        id.Apply(id => ($"{apiVersion}/{kind}::{id}",
                            new ApiExtensions.CustomResource(id, obj!, opts) as KubernetesResource))
                    };
            }
        }
    }

    internal class ParseArgs
    {
        /// <summary>
        /// Objects representing Kubernetes resources.
        /// </summary>
        public InputList<ImmutableDictionary<string, object>> Objs { get; set; } = null!;

        private List<TransformationAction>? _transformations;

        /// <summary>
        /// An optional list of transformations to apply to Kubernetes resource definitions before registering
        /// with engine.
        /// </summary>
        public List<TransformationAction> Transformations
        {
            get => _transformations ??= new List<TransformationAction>();
            set => _transformations = value;
        }

        /// <summary>
        /// An optional prefix for the auto-generated resource names.
        /// Example: A resource created with resourcePrefix="foo" would produce a resource named "foo-resourceName".
        /// </summary>
        public string? ResourcePrefix { get; set; }
    }
}
