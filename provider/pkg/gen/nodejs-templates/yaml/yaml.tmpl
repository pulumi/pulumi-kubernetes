// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as fs from "fs";
import * as glob from "glob";
import fetch from "node-fetch";
{{- range .Packages}}
import * as {{.}} from "../{{.}}";
{{- end}}
import * as provider from "../provider";
import * as outputs from "../types/output";
import { getVersion } from "../utilities";

export abstract class CollectionComponentResource extends pulumi.ComponentResource {
    resources!: pulumi.Output<{ [key: string]: pulumi.CustomResource }>;
    ready!: pulumi.Output<pulumi.CustomResource[]>;

    protected constructor(
        resourceType: string, name: string, config: any, opts?: pulumi.ComponentResourceOptions,
    ) {
        super(resourceType, name, config, opts);
    }

    /**
     * getResource returns a resource defined by a built-in Kubernetes group/version/kind and name.
     *
     * For example:
     *     getResource("apps/v1/Deployment", "nginx")
     */
{{- range .Resources}}
    public getResource(groupVersionKind: "{{.GVK}}", name: string): pulumi.Output<{{.Package}}.{{.Name}}>;
    public getResource(groupVersionKind: "{{.GVK}}", namespace: string, name: string): pulumi.Output<{{.Package}}.{{.Name}}>;
{{- end}}
    public getResource(groupVersionKind: string, namespaceOrName: string, name?: string): pulumi.Output<pulumi.CustomResource> {
        return this.getResourceImpl(groupVersionKind, namespaceOrName, name);
    }

    /**
     * getResourceProperty returns a single property of a resource defined by a built-in Kubernetes group/version/kind and name.
     *
     * For example:
     *     getResourceProperty("v1/Service", "nginx", "spec")
     */
{{- range .Resources}}
{{- $token := .GVK}}
{{- range .Properties}}
    public getResourceProperty(groupVersionKind: "{{$token}}", name: string, property: "{{.Name}}"): pulumi.Output<{{.Type}}>;
    public getResourceProperty(groupVersionKind: "{{$token}}", namespace: string, name: string, property: "{{.Name}}"): pulumi.Output<{{.Type}}>;
{{- end}}
{{- end}}
    public getResourceProperty(groupVersionKind: string, namespaceOrName: string, nameOrProperty: string, property?: string): pulumi.Output<any> {
        const name = property !== undefined ? nameOrProperty : undefined;
        return this.getResourceImpl(groupVersionKind, namespaceOrName, name)
            .apply(r => (<any>r)[property || nameOrProperty]);
    }

    /**
     * getCustomResource returns a resource defined by a CRD with the given group/version/kind and name.
     *
     * For example:
     *     getCustomResource("monitoring.coreos.com/v1/ServiceMonitor", "kube-prometheus-exporter-kubernetes")
     */
    public getCustomResource<T extends pulumi.CustomResource>(groupVersionKind: string, namespace: string): pulumi.Output<T>;
    public getCustomResource<T extends pulumi.CustomResource>(groupVersionKind: string, namespace: string, name: string): pulumi.Output<T>;
    public getCustomResource(groupVersionKind: string, namespaceOrName: string, name?: string): pulumi.Output<pulumi.CustomResource> {
        return this.getResourceImpl(groupVersionKind, namespaceOrName, name);
    }

    private getResourceImpl(groupVersionKind: string, namespaceOrName: string, name?: string): pulumi.Output<pulumi.CustomResource> {
        // `id` will either be `${name}` or `${namespace}/${name}`.
        let id = namespaceOrName;
        if (name !== undefined) {
            id = `${namespaceOrName}/${name}`;
        }

        return this.resources.apply(r => r[`${groupVersionKind}::${id}`]);
    }
}

/**
 * ConfigGroup creates a set of Kubernetes resources from Kubernetes YAML text. The YAML text
 * may be supplied using any of the following `ConfigGroupOpts`:
 *
 *   1. Using a filename or a list of filenames:
 *        a. `{files: "foo.yaml"}`
 *        b. `{files: ["foo.yaml", "bar.yaml"]}`
 *   2. Using a file pattern or a list of file patterns:
 *        a. `{files: "*.yaml"}`
 *        b. `{files: ["foo/*.yaml", "bar/*.yaml"]}`
 *   3. Using a literal string containing YAML, or a list of such strings:
 *        a. `{yaml: "(LITERAL YAML HERE)"}`
 *        b. `{yaml: ["(LITERAL YAML HERE)", "(MORE YAML)"]}`
 *   4. Any combination of files, patterns, or YAML strings:
 *        a. `{files: "foo.yaml", yaml: "(LITERAL YAML HERE)"}`
 *
 * ## Example Usage
 * ### Local File
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const example = new k8s.yaml.ConfigGroup("example", {
 *   files: "foo.yaml",
 * });
 * ```
 * ### Multiple Local Files
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const example = new k8s.yaml.ConfigGroup("example", {
 *   files: ["foo.yaml", "bar.yaml"],
 * });
 * ```
 * ### Local File Pattern
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const example = new k8s.yaml.ConfigGroup("example", {
 *   files: "yaml/*.yaml",
 * });
 * ```
 * ### Multiple Local File Patterns
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const example = new k8s.yaml.ConfigGroup("example", {
 *   files: ["foo/*.yaml", "bar/*.yaml"],
 * });
 * ```
 * ### Literal YAML String
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const example = new k8s.yaml.ConfigGroup("example", {
 *   yaml: `
 * apiVersion: v1
 * kind: Namespace
 * metadata:
 *   name: foo
 * `,
 * })
 * ```
 * ### YAML with Transformations
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const example = new k8s.yaml.ConfigGroup("example", {
 *   files: "foo.yaml",
 *   transformations: [
 *     // Make every service private to the cluster, i.e., turn all services into ClusterIP instead of LoadBalancer.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *       if (obj.kind === "Service" && obj.apiVersion === "v1") {
 *         if (obj.spec && obj.spec.type && obj.spec.type === "LoadBalancer") {
 *           obj.spec.type = "ClusterIP";
 *         }
 *       }
 *     },
 *
 *     // Set a resource alias for a previous name.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *     if (obj.kind === "Deployment") {
 *       opts.aliases = [{ name: "oldName" }]
 *     },
 *
 *     // Omit a resource from the Chart by transforming the specified resource definition to an empty List.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *     if (obj.kind === "Pod" && obj.metadata.name === "test") {
 *       obj.apiVersion = "v1"
 *       obj.kind = "List"
 *     },
 *   ],
 * });
 * ```
 */
export class ConfigGroup extends CollectionComponentResource {
    /**
     * Create a ConfigGroup resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param config The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, config: ConfigGroupOpts, opts?: pulumi.ComponentResourceOptions) {
        super("kubernetes:yaml:ConfigGroup", name, config, opts);
        const childOpts = getChildOpts(this, opts);
        this.resources = parse(config, childOpts);
    }
}

/**
 * ConfigFile creates a set of Kubernetes resources from Kubernetes YAML file. If `config.name`
 * is not specified, `ConfigFile` assumes the argument `name` is the filename.
 *
 * ## Example Usage
 * ### Local File
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const example = new k8s.yaml.ConfigFile("example", {
 *   file: "foo.yaml",
 * });
 * ```
 * ### YAML with Transformations
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const example = new k8s.yaml.ConfigFile("example", {
 *   file: "foo.yaml",
 *   transformations: [
 *     // Make every service private to the cluster, i.e., turn all services into ClusterIP instead of LoadBalancer.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *       if (obj.kind === "Service" && obj.apiVersion === "v1") {
 *         if (obj.spec && obj.spec.type && obj.spec.type === "LoadBalancer") {
 *           obj.spec.type = "ClusterIP";
 *         }
 *       }
 *     },
 *
 *     // Set a resource alias for a previous name.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *       if (obj.kind === "Deployment") {
 *         opts.aliases = [{name: "oldName"}]
 *       }
 *     },
 *
 *     // Omit a resource from the Chart by transforming the specified resource definition to an empty List.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *       if (obj.kind === "Pod" && obj.metadata.name === "test") {
 *         obj.apiVersion = "v1"
 *         obj.kind = "List"
 *       }
 *     },
 *   ],
 * });
 * ```
 */
export class ConfigFile extends CollectionComponentResource {
    /**
     * Create a ConfigFile resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param config The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(
        name: string,
        config?: ConfigFileOpts,
        opts?: pulumi.ComponentResourceOptions
    ) {
        if (config && config.resourcePrefix !== undefined) {
            name = `${config.resourcePrefix}-${name}`
        }
        super("kubernetes:yaml:ConfigFile", name, config, opts);
        const fileId = config && config.file || name;
        let text: Promise<string>;
        if (isUrl(fileId)) {
            text = fetch(fileId).then(r => {
                if (r.ok) {
                    return r.text()
                } else {
                    throw Error(`Error fetching YAML file '${fileId}': ${r.status} ${r.statusText}`);
                }
            });
        } else {
            text = Promise.resolve(fs.readFileSync(fileId).toString());
        }

        const transformations = config?.transformations ?? [];
        if (config?.skipAwait) {
            transformations.push(skipAwait);
        }

        const childOpts = getChildOpts(this, opts);
        this.resources = pulumi.output(text.then(t => {
            try {
                const parsed = parseYamlDocument({
                    objs: yamlLoadAll(t, childOpts),
                    transformations,
                    resourcePrefix: config && config.resourcePrefix || undefined
                }, childOpts);
                // If the provider is not fully initialized, the engine skips invoking on the provider and returns an
                // empty result. This may change based on how https://github.com/pulumi/pulumi/issues/10209 is addressed.
                parsed.apply(p => {
                    if (opts?.provider !== undefined && (Object.entries(p).length == 0)) {
                        pulumi.log.info("Can't decode yaml config when provider is not fully initialized. " +
                         "This can result in empty previews but should resolve correctly during apply.", this);
                    }
                });
                return parsed;
            } catch (e) {
                throw Error(`Error fetching YAML file '${fileId}': ${e}`);
            }
        }));
    }
}

/**
 * The set of arguments for constructing a ConfigGroup resource.
 */
export interface ConfigGroupOpts {
    /** Set of paths or a URLs that uniquely identify files. */
    files?: string[] | string;

    /** YAML text containing Kubernetes resource definitions. */
    yaml?: string[] | string;

    /** JavaScript objects representing Kubernetes resources. */
    objs?: any[] | any;

    /** A set of transformations to apply to Kubernetes resource definitions before registering with engine. */
    transformations?: ((o: any, opts: pulumi.CustomResourceOptions) => void)[];

    /**
     * An optional prefix for the auto-generated resource names.
     * Example: A resource created with resourcePrefix="foo" would produce a resource named "foo-resourceName".
     */
    resourcePrefix?: string;

    /**
     * Skip await logic for all resources in this YAML. Resources will be marked ready as soon as they are created.
     * Warning: This option should not be used if you have resources depending on Outputs from the YAML.
     */
    skipAwait?: boolean;
}

/**
 * The set of arguments for constructing a ConfigFile resource.
 */
export interface ConfigFileOpts {
    /** Path or a URL that uniquely identifies a file. */
    file?: string;

    /** A set of transformations to apply to Kubernetes resource definitions before registering with engine. */
    transformations?: ((o: any, opts: pulumi.CustomResourceOptions) => void)[];

    /**
     * An optional prefix for the auto-generated resource names.
     * Example: A resource created with resourcePrefix="foo" would produce a resource named "foo-resourceName".
     */
    resourcePrefix?: string;

    /**
     * Skip await logic for all resources in this YAML. Resources will be marked ready as soon as they are created.
     * Warning: This option should not be used if you have resources depending on Outputs from the YAML.
     */
    skipAwait?: boolean;
}

/**
 * The set of arguments common to the ConfigFile and ConfigGroup resources.
 */
export interface ConfigOpts {
    /** JavaScript objects representing Kubernetes resources. */
    objs: Promise<any[]>;

    /** A set of transformations to apply to Kubernetes resource definitions before registering with engine. */
    transformations?: ((o: any, opts: pulumi.CustomResourceOptions) => void)[];

    /**
     * An optional prefix for the auto-generated resource names.
     * Example: A resource created with resourcePrefix="foo" would produce a resource named "foo-resourceName".
     */
    resourcePrefix?: string;
}

/** @ignore */ export function getChildOpts(parent: pulumi.Resource, opts?: pulumi.ComponentResourceOptions): pulumi.CustomResourceOptions {
    return {
        parent: parent,
        ...opts?.version && {version: opts.version},
        ...opts?.pluginDownloadURL && {pluginDownloadURL: opts.pluginDownloadURL}
    };
}

/** @ignore */ export function getInvokeOpts(opts?: pulumi.CustomResourceOptions): pulumi.InvokeOptions {
    return {
        parent: opts?.parent,
        provider: opts?.provider,
        version: opts?.version ?? getVersion(),
        pluginDownloadURL: opts?.pluginDownloadURL,
        async: true
    };
}

/** @ignore */ function yamlLoadAll(text: string, opts?: pulumi.CustomResourceOptions): Promise<any[]> {
    const invokeOpts = getInvokeOpts(opts);
    return pulumi.runtime.invoke("kubernetes:yaml:decode", {text}, invokeOpts)
        .then(p => p.result);
}

/** @ignore */ export function skipAwait(o: any, opts: pulumi.ComponentResourceOptions) {
    if (o.metadata.annotations === undefined) {
        o.metadata.annotations = {"pulumi.com/skipAwait": "true"};
    } else {
        o.metadata.annotations["pulumi.com/skipAwait"] = "true";
    }
}

/** @ignore */ export function parse(
    config: ConfigGroupOpts, opts?: pulumi.CustomResourceOptions
): pulumi.Output<{[key: string]: pulumi.CustomResource}> {
    let resources = pulumi.output<{[key: string]: pulumi.CustomResource}>({});

    const transformations = config.transformations ?? [];
    if (config.skipAwait) {
        transformations.push(skipAwait);
    }

    if (config.files !== undefined) {
        let files: string[] = [];
        if (typeof config.files === 'string') {
            if (isUrl(config.files)) {
                files = [config.files];
            } else {
                files = glob.sync(config.files, {dotRelative: true});
            }
        } else {
            for (const file of config.files) {
                if (isUrl(file)) {
                    files.push(file);
                } else {
                    files.push(...glob.sync(file, {dotRelative: true}));
                }
            }
        }

        for (const file of files) {
            const cf = new ConfigFile(
                file,
                {
                    file: file,
                    transformations,
                    resourcePrefix: config.resourcePrefix
                },
                opts
            );
            resources = pulumi.all([resources, cf.resources]).apply(([rs, cfrs]) => ({...rs, ...cfrs}));
        }
    }

    if (config.yaml !== undefined) {
        let yamlTexts: string[] = [];
        if (typeof config.yaml === 'string') {
            yamlTexts.push(config.yaml);
        } else {
            yamlTexts.push(...config.yaml);
        }

        for (const text of yamlTexts) {
            const docResources = parseYamlDocument({
                    objs: yamlLoadAll(text, opts),
                    transformations,
                    resourcePrefix: config.resourcePrefix
                },
                opts);
            resources = pulumi.all([resources, docResources]).apply(([rs, drs]) => ({...rs, ...drs}));
        }
    }

    if (config.objs !== undefined) {
        const objs: Promise<any[]> = Array.isArray(config.objs) ? Promise.resolve(config.objs) : Promise.resolve([config.objs]);
        const docResources = parseYamlDocument({
            objs,
            transformations,
            resourcePrefix: config.resourcePrefix
        }, opts);
        resources = pulumi.all([resources, docResources]).apply(([rs, drs]) => ({...rs, ...drs}));
    }

    return resources;
}

/** @ignore */ function isUrl(s: string): boolean {
    return s.startsWith("http://") || s.startsWith("https://")
}

/** @ignore */ function parseYamlDocument(
    config: ConfigOpts,
    opts?: pulumi.CustomResourceOptions,
):  pulumi.Output<{[key: string]: pulumi.CustomResource}> {
    const objs = config.objs.then(configObjs => {
        return Array.isArray(configObjs) ? configObjs
            .map(obj => parseYamlObject(obj, config.transformations, config.resourcePrefix, opts))
            .reduce((array, objs) => (array.concat(...objs)), []) : [];
    });
    return pulumi.output(objs).apply(objs => objs
            .reduce((map: {[key: string]: pulumi.CustomResource}, val) => (map[val.name] = val.resource, map), {}));
}

/** @ignore */ function parseYamlObject(
    obj: any,
    transformations?: ((o: any, opts: pulumi.CustomResourceOptions) => void)[],
    resourcePrefix?: string,
    opts?: pulumi.CustomResourceOptions,
): pulumi.Output<{name: string, resource: pulumi.CustomResource}>[] {
    if (obj == null || Object.keys(obj).length == 0) {
        return [];
    }

    // Create a copy of opts to pass into potentially mutating transforms that will be applied to this resource.
    opts = Object.assign({}, opts);

    // Allow users to change API objects before any validation.
    for (const t of transformations || []) {
        t(obj, opts);
    }

    if (!("kind" in obj && "apiVersion" in obj)) {
        throw new Error(`Kubernetes resources require a kind and apiVersion: ${JSON.stringify(obj)}`)
    }

    const kind = obj["kind"];
    const apiVersion = obj["apiVersion"];
    const gvk = `${apiVersion}/${kind}`

    // Recursively traverse built-in Kubernetes list types into a single set of "naked" resource
    // definitions that we can register with the Pulumi engine.
    //
    // Kubernetes does not instantiate list types like `v1.List`. When the API server receives
    // a list, it will recursively traverse it and perform the necessary operations on the
    // each "instantiable" resource it finds. For example, `kubectl apply` on a
    // `v1.ConfigMapList` will cause the API server to traverse the list, and `apply` each
    // `v1.ConfigMap` it finds.
    //
    // Since Kubernetes does not instantiate list types directly, Pulumi also traverses lists
    // for resource definitions that can be managed by Kubernetes, and registers those with the
    // engine instead.
    if (
           (gvk === "v1/List")
{{- range .ListKinds}}
        || (gvk === "{{.GVK}}")
{{- end}}
    ) {
        const objs = [];
        const items = obj["items"] || [];
        for (const item of items) {
            objs.push(...parseYamlObject(item, transformations, resourcePrefix, opts));
        }
        return objs;
    }

    if (!("metadata" in obj) || !("name" in obj["metadata"])) {
        throw new Error(`YAML object does not have a .metadata.name: ${obj.apiVersion}/${obj.kind} ${JSON.stringify(obj.metadata)}`)
    }

    const metadata = obj["metadata"];
    let id: pulumi.Output<any> = pulumi.output(metadata["name"]);
    const namespace = metadata["namespace"] || undefined;
    if (namespace !== undefined) {
        id = pulumi.concat(namespace, "/", id);
    }
    if (resourcePrefix !== undefined) {
        id = pulumi.concat(resourcePrefix, "-", id);
    }
    switch (gvk) {
{{- range .NonListKinds}}
        case "{{.GVK}}":
            return [id.apply(id => ({
                name: `{{.GVK}}::${id}`,
                resource: new {{.Package}}.{{.Name}}(id, obj, opts),
            }))];
{{- end}}
        default:
            return [id.apply(id => ({
                name: `${apiVersion}/${kind}::${id}`,
                resource: new apiextensions.CustomResource(id, obj, opts),
            }))];
    }
}
